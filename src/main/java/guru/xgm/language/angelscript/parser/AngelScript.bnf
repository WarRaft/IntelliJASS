{
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="AngelScript"
    psiImplClassSuffix="Impl"

    parserClass=              "guru.xgm.language.angelscript.parser.AngelScriptParser"
    psiPackage=               "guru.xgm.language.angelscript.psi"
    psiImplPackage=           "guru.xgm.language.angelscript.psi.impl"
    elementTypeHolderClass=   "guru.xgm.language.angelscript.psi.AngelScriptTypes"
    elementTypeClass=         "guru.xgm.language.angelscript.psi.tree.AngelScriptIElement"
    tokenTypeClass=           "guru.xgm.language.angelscript.psi.tree.AngelScriptIToken"

    extends(".*Expr")=Expr

    tokens=[
        WHITE_SPACE='regexp:\s+'
        SINGLE_LINE_COMMENT="regexp://[^\n]*"
        MULTI_LINE_COMMENT="regexp:/\*([^\n])*\*/"
        ABSTRACT='abstract'
        ARRAY='array'
        AND='and'
        AUTO='auto'
        BOOL='bool'
        BREAK='break'
        CASE='case'
        CODE='code'
        CONST='const'
        CLASS='class'
        DOUBLE='double'
        DEFAULT='default'
        DO='do'
        ELSE='else'
        EXTERNAL='external'
        EXPLICIT='explicit'
        FALSE='false'
        FINAL='final'
        FLOAT='float'
        FOR='for'
        FUNCDEF='funcdef'
        FUNCTION='function'
        GET='get'
        HANDLE='handle'
        IF='if'
        INCLUDE='include'
        IN = 'in'
        INOUT='inout'
        INT = 'int'
        INT8 = 'int8'
        INT16 = 'int16'
        INT32 = 'int32'
        INT64 = 'int64'
        NAMESPACE='namespace'
        NOT='not'
        NULL='null'
        NIL='nil'
        OR='or'
        OVERRIDE='override'
        OUT='out'
        PRIVATE='private'
        PROPERTY='property'
        PROTECTED='protected'
        RETURN='return'
        SET='set'
        SHARED='shared'
        STATIC='static'
        STRING='string'
        SWITCH='switch'
        TRUE='true'
        UINT = 'uint'
        UINT8 = 'uint8'
        UINT16 = 'uint16'
        UINT32 = 'uint32'
        UINT64 = 'uint64'
        VOID = 'void'
        WHILE='while'

        AT='@'
        HASH='#'
        TILDE='~'
        DOT='.'
        COMMA=','
        EQ_EQ='=='
        EQ='='
        NEQ='!='
        COLON_COLON='::'
        COLON=':'
        SEMI = ';'
        MINUS_GT = '->'
        AMP_AMP = '&&'
        AMP='&'
        VBAR_VBAR = '||'
        VBAR='|'
        EXCL='!'
        PLUS_PLUS='++'
        PLUS='+'
        PLUS_EQ='+='
        MINUS_MINUS='--'
        MINUS='-'
        MINUS_EQ='-='
        MUL='*'
        MUL_EQ='*='
        DIV='/'
        DIV_EQ='/='
        LT_EQ='<='
        LT='<'
        GT_EQ='>='
        GT='>'
        QUEST='?'
        LBRACE = '{'
        RBRACE = '}'
        LPAREN = '('
        RPAREN = ')'
        LBRACK = '['
        RBRACK = ']'

        REALVAL='regexp:(\d+\.\d*|\.\d+)([fd])?'
        HEXVAL='regexp:(0x|\$)[0-9a-fA-F]+'
        INTVAL='regexp:\d+'

        // STRVAL="regexp:(\"{3}(^(\"{3}))*\"{3})|(\"([^\"\\]|\\.)*\")|('([^'\\]|\\.)*')"
        // https://stackoverflow.com/questions/46133654/antlr-grammar-for-triple-quoted-string
        // https://github.com/JetBrains/intellij-community/blob/master/python/python-parser/src/com/jetbrains/python/lexer/Python.flex

        STRING_SINGLE="regexp:'([^'\\]|\\.)*'"
        STRING_DOUBLE='regexp:"([^"\\]|\\.)*"'
        STRING_BLOCK='regexp:\"\"\"(.*?)\"\"\"'
        // https://github.com/hmatt1/angelscript-intellij/blob/main/src/main/java/org/intellij/sdk/language/angelscript.bnf

        ID='regexp:[A-Za-z_][_0-9A-Za-z]*'
    ]

}
// https://www.angelcode.com/angelscript/sdk/docs/manual/doc_script_bnf.html

Root ::= RootItem*
private RootItem ::= IncludeStmt|Var|Fun|FunDef|Clazz|Nspace|SEMI

//NAMESPACE     ::= 'namespace' IDENTIFIER {'::' IDENTIFIER} '{' SCRIPT '}'
Nspace ::= NAMESPACE ID (COLON_COLON ID)* LBRACE RootItem* RBRACE
IncludeStmt ::= HASH INCLUDE STRVAL
// FUNCDEF       ::= {'external' | 'shared'} 'funcdef' TYPE ['&'] IDENTIFIER PARAMLIST ';'
// CLASS         ::= {'shared' | 'abstract' | 'final' | 'external'} 'class' IDENTIFIER  (
//                                                                                          ';'
//                                                                                          |
//                                                                                          (
//                                                                                              [':' IDENTIFIER {',' IDENTIFIER}]
//                                                                                              '{'
//                                                                                              {VIRTPROP | FUNC | VAR | FUNCDEF}
//                                                                                              '}'
//                                                                                          )
//                                                                                      )
Clazz ::= (SHARED|ABSTRACT|FINAL|EXTERNAL)* CLASS ID (SEMI | ((COLON ID (COMMA ID)*)? LBRACE (VirtProp|Fun|Var|FunDef)* RBRACE))
// VIRTPROP      ::= ['private' | 'protected'] TYPE ['&'] IDENTIFIER    '{'
//                                                                      {
//                                                                          ('get' | 'set') ['const'] FUNCATTR (STATBLOCK | ';')
//                                                                      }
//                                                                      '}'
VirtProp ::= (PRIVATE|PROTECTED)? Type AND? ID LBRACE ((GET|SET) CONST? FuncAttr (StatBlock | SEMI))*
FunDef ::= (EXTERNAL|SHARED)* FUNCDEF Type AND? ID ParamList SEMI
// VAR ::=  ['private'|'protected']
//          TYPE
//          IDENTIFIER
//          [
//              ('=' (INITLIST | EXPR)) | ARGLIST
//          ]
//          {
//              ','
//              IDENTIFIER
//              [
//                  ('=' (INITLIST | EXPR)) | ARGLIST
//              ]
//          }
//          ';'
Var ::= (PRIVATE|PROTECTED)?
        Type
        ID
        (
            (EQ (InitList | Expr)) | ArgList
        )?
        (
            COMMA
            ID
            (
                (EQ (InitList|Expr)) | ArgList
            )?
        )*
        SEMI
// TYPE ::=
//          ['const']
//          SCOPE
//          DATATYPE
//          [
//              '<' TYPE {',' TYPE} '>'
//          ]
//          {
//              ('[' ']') | ('@' ['const'])
//          }
Type ::=    CONST?
            Scope
            DataType
            GenericType?
            (
                (LBRACK RBRACK)|(AT CONST?)
            )*
GenericType ::= LT Type (COMMA Type)* GT
// SCOPE         ::= ['::'] {IDENTIFIER '::'}   [
//                                                  IDENTIFIER
//                                                  [
//                                                      '<' TYPE {',' TYPE} '>'
//                                                  ]
//                                                  '::'
//                                              ]
Scope ::= COLON_COLON? (ID COLON_COLON)* (ID GenericType? COLON_COLON)?
// DATATYPE      ::= (IDENTIFIER | PRIMTYPE | '?' | 'auto')
DataType ::= ID|PrimType|QUEST|AUTO
// PRIMTYPE      ::= 'void' | 'int' | 'int8' | 'int16' | 'int32' | 'int64' | 'uint' | 'uint8' | 'uint16' | 'uint32' | 'uint64' | 'float' | 'double' | 'bool'
PrimType ::= ARRAY|BOOL|CODE|DOUBLE|FLOAT|HANDLE|INT|INT8|INT16|INT32|INT64|STRING|UINT|UINT16|UINT32|UINT64|VOID|ID
// INITLIST      ::=    '{'
//                      [ASSIGN | INITLIST]
//                      {
//                          ','
//                          [ASSIGN | INITLIST]
//                      }
//                      '}'
InitList ::=    LBRACE
                (Assign|InitList)?
                (
                    COMMA
                    (Assign|InitList)?
                )*
                RBRACE
// ASSIGN        ::= CONDITION [ ASSIGNOP ASSIGN ]
Assign ::= Condition (AssignOp Assign)?
// CONDITION     ::= EXPR ['?' ASSIGN ':' ASSIGN]
Condition ::= Expr (QUEST Assign COLON Assign)?
// ASSIGNOP      ::= '=' | '+=' | '-=' | '*=' | '/=' | '|=' | '&=' | '^=' | '%=' | '**=' | '<<=' | '>>=' | '>>>='
AssignOp ::= EQ|PLUS_EQ|MINUS_EQ|MUL_EQ|DIV_EQ
// ARGLIST       ::=    '('
//                      [IDENTIFIER ':']
//                      ASSIGN
//                      {
//                          ',' [IDENTIFIER ':'] ASSIGN
//                      }
//                      ')'
ArgList ::= LPAREN (ID COLON)? Assign (COMMA (ID COLON)? Assign)* RPAREN
// FUNCCALL      ::= SCOPE IDENTIFIER ARGLIST
FuncCall ::= Scope ID (ArgList | (LPAREN RPAREN))
// FUNC          ::= {'shared' | 'external'} ['private' | 'protected']  [
//                                                                          ( (TYPE ['&']) | '~' )
//                                                                      ]
//                                                                      IDENTIFIER PARAMLIST ['const'] FUNCATTR (';' | STATBLOCK)
Fun ::= (SHARED|EXTERNAL)* (PRIVATE|PROTECTED)?  (((Type AND?)|TILDE))? ID ParamList CONST? FuncAttr (SEMI | StatBlock) {pin=StatBlock}
// PARAMLIST     ::=    '('
//                      [
//                          'void'
//                          |
//                          (
//                              TYPE TYPEMOD [IDENTIFIER] ['=' EXPR]    {
//                                                                          ',' TYPE TYPEMOD [IDENTIFIER] ['=' EXPR]
//                                                                      }
//                          )
//                      ]
//                      ')'
ParamList ::= LPAREN (VOID | (Param (COMMA Param)*) )? RPAREN
Param ::= Type TypeMod ID? (EQ Expr)?
// TYPEMOD       ::= ['&' ['in' | 'out' | 'inout']]
TypeMod ::= (AND (IN|OUT|INOUT)?)?
// FUNCATTR      ::= {'override' | 'final' | 'explicit' | 'property'}
FuncAttr ::= (OVERRIDE|FINAL|EXPLICIT|PROPERTY)*
// STATBLOCK     ::= '{' {VAR | STATEMENT} '}'
StatBlock ::= LBRACE (Var | Stmt)* RBRACE
// STATEMENT     ::= (IF | FOR | WHILE | RETURN | STATBLOCK | BREAK | CONTINUE | DOWHILE | SWITCH | EXPRSTAT | TRY)
private Stmt ::= (StatBlock|ExprStat|IfStmt|ForStmt|WhileStmt|DoWhileStmt|SwitchStmt|BreakStmt|ReturnStmt)
// EXPRSTAT      ::= [ASSIGN] ';'
ExprStat ::= Assign? SEMI
// IF            ::= 'if' '(' ASSIGN ')' STATEMENT ['else' STATEMENT]
IfStmt ::= IF LPAREN Assign RPAREN Stmt ElseStmt? {pin=1}
ElseStmt ::= ELSE Stmt {pin=1}
// FOR           ::= 'for' '(' (VAR | EXPRSTAT) EXPRSTAT    [
//                                                              ASSIGN {',' ASSIGN}
//                                                          ]
//                                                          ')'
//                                                          STATEMENT
ForStmt ::=  FOR LPAREN (Var | ExprStat) ExprStat (Assign (COMMA Assign)*)? RPAREN Stmt
// WHILE         ::= 'while' '(' ASSIGN ')' STATEMENT
WhileStmt ::= WHILE LPAREN Assign RPAREN Stmt
// DOWHILE       ::= 'do' STATEMENT 'while' '(' ASSIGN ')' ';'
DoWhileStmt ::= DO Stmt WHILE LPAREN Assign RPAREN SEMI
// RETURN        ::= 'return' [ASSIGN] ';'
ReturnStmt ::= RETURN Assign? SEMI
// SWITCH        ::= 'switch' '(' ASSIGN ')' '{' {CASE} '}'
SwitchStmt ::= SWITCH LPAREN Assign RPAREN LBRACE (CaseStmt)* RBRACE
// CASE          ::= (('case' EXPR) | 'default') ':' {STATEMENT}
CaseStmt ::= ((CASE Expr) | DEFAULT) COLON (Stmt)*
// BREAK         ::= 'break' ';'
BreakStmt ::= BREAK SEMI
// LAMBDA ::=   'function'
//              '('
//              [
//                  [TYPE TYPEMOD]
//                  [IDENTIFIER]
//                  {
//                      ','
//                      [TYPE TYPEMOD]
//                      [IDENTIFIER]
//                  }
//              ]
//              ')'
//              STATBLOCK
Lambda ::= FUNCTION LPAREN ((Type TypeMod)? ID? (COMMA (Type TypeMod)? ID?)*)? RPAREN StatBlock

// === EXPRESSION
// https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
// https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000094104-Expression-handling-in-grammar-kit-issue-with-deep-trees
// https://gist.github.com/FatalCatharsis/aad0b72c3ffed144c3d61ee73dcb283f

Expr ::=
    AssignExpr |
    RefExpr |
    PlusExpr|MinusExpr|
    MulExpr | DivExpr |
    MulUnExpr|DivUnExpr|PlusUnExpr|MinusUnExpr|NotExpr|PreIncExpr|PostIncExpr|PreDecExpr|PostDecExpr|
    EqExpr|NEqExpr|LTExpr|LTEqExpr|GTExpr|GTEqExpr|
    OrExpr|AndExpr|
    PrimaryExpr

RefExpr ::= Expr DOT Expr
AssignExpr ::= Expr (EQ|PLUS_EQ|MINUS_EQ|MUL_EQ|DIV_EQ) Expr

PlusExpr ::= Expr PLUS Expr
MinusExpr ::= Expr MINUS Expr

MulExpr ::= Expr MUL Expr
DivExpr ::= Expr DIV Expr

MulUnExpr ::= MUL Expr
DivUnExpr ::= DIV Expr
PlusUnExpr ::= PLUS Expr
MinusUnExpr ::= MINUS Expr
NotExpr ::= (NOT|EXCL) Expr
PreIncExpr ::= PLUS_PLUS Expr
PostIncExpr ::= Expr PLUS_PLUS
PreDecExpr ::= MINUS_MINUS Expr
PostDecExpr ::= Expr MINUS_MINUS

EqExpr ::= Expr EQ_EQ Expr
NEqExpr ::= Expr NEQ Expr
LTExpr ::= Expr LT Expr
LTEqExpr ::= Expr LT_EQ Expr
GTExpr ::= Expr GT Expr
GTEqExpr ::= Expr GT_EQ Expr

OrExpr ::= Expr (OR|VBAR_VBAR) Expr
AndExpr ::= Expr (AND|AMP_AMP) Expr
ParenExpr ::= LPAREN Expr RPAREN

PrimaryExpr ::=
    TRUE |
    FALSE |
    NULL |
    NIL |
    ParenExpr |
    ArrayAccess |
    FuncCall |
    Lambda |
    REALVAL |
    HEXVAL |
    INTVAL |
    Str |
    (AT? ID)


Str ::= (STRING_BLOCK|STRING_SINGLE|STRING_DOUBLE)+
ArrayAccess ::= ID ArrayAccessItem ArrayAccessItem*
ArrayAccessItem ::= LBRACK Expr? RBRACK {pin=1}
