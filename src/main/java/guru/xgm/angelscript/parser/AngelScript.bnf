{
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="AngelScript"
    psiImplClassSuffix="Impl"

    parserClass=              "guru.xgm.angelscript.parser.AngelScriptParser"
    psiPackage=               "guru.xgm.angelscript.psi"
    psiImplPackage=           "guru.xgm.angelscript.psi.impl"
    elementTypeHolderClass=   "guru.xgm.angelscript.psi.AngelScriptTypes"
    elementTypeClass=         "guru.xgm.angelscript.psi.tree.AngelScriptIElement"
    tokenTypeClass=           "guru.xgm.angelscript.psi.tree.AngelScriptIToken"

    extends(".*Expr")=Expr

    tokens=[
        WHITE_SPACE='regexp:\s+'
        SINGLE_LINE_COMMENT="regexp://[^\n]*"
        MULTI_LINE_COMMENT="regexp:/\*([^\n])*\*/"
        ARRAY='array'
        AUTO='auto'
        BOOL='bool'
        BREAK='break'
        CASE='case'
        CODE='code'
        CONST='const'
        DOUBLE='double'
        DEBUG='debug'
        DEFAULT='default'
        DO='do'
        ELSE='else'
        EXTERNAL='external'
        EXPLICIT='explicit'
        FALSE='false'
        FINAL='final'
        FLOAT='float'
        FOR='for'
        FUNCTION='function'
        HANDLE='handle'
        IF='if'
        IN = 'in'
        INOUT='inout'
        INT = 'int'
        INT8 = 'int8'
        INT16 = 'int16'
        INT32 = 'int32'
        INT64 = 'int64'
        INTEGER='integer'
        LIBRARY='library'
        METHOD='method'
        NOTHING='nothing'
        NULL='null'
        OPTIONAL='optional'
        OVERRIDE='override'
        OUT='out'
        PRIVATE='private'
        PROPERTY='property'
        PROTECTED='protected'
        REAL='real'
        REQUIRES='requires'
        RETURN='return'
        SHARED='shared'
        STATIC='static'
        STRING='string'
        STRUCT='struct'
        SWITCH='switch'
        TRUE='true'
        THISTYPE='thistype'
        UINT = 'uint'
        UINT8 = 'uint8'
        UINT16 = 'uint16'
        UINT32 = 'uint32'
        UINT64 = 'uint64'
        VOID = 'void'
        WHILE='while'

        AT='@'
        TILDE='~'
        DOT='.'
        COMMA=','
        EQ_EQ='=='
        EQ='='
        NEQ='!='
        COLON_COLON='::'
        COLON=':'
        SEMI = ';'
        MINUS_GT = '->'
        AND_AND = '&&'
        OR_OR = '||'
        NOT='!'
        PLUS_PLUS='++'
        PLUS='+'
        PLUS_EQ='+='
        MINUS='-'
        MINUS_MINUS='--'
        MINUS_EQ='-='
        MUL='*'
        MUL_EQ='*='
        DIV='/'
        DIV_EQ='/='
        LT_EQ='<='
        LT='<'
        GT_EQ='>='
        GT='>'
        QUEST='?'
        LBRACE = '{'
        RBRACE = '}'
        LPAREN = '('
        RPAREN = ')'
        LBRACK = '['
        RBRACK = ']'

        REALVAl='regexp:(\d+\.\d*|\.\d+)([fd])?'
        HEXVAL='regexp:(0x|\$)[0-9a-fA-F]+'
        INTVAL='regexp:\d+'

        STRVAL="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\'|\\)*\")"

        ID='regexp:[A-Za-z_][_0-9A-Za-z]*'
    ]

}
// https://www.angelcode.com/angelscript/sdk/docs/manual/doc_script_bnf.html

Root ::= (Var|Func)* {recoverWhile=RootRecover}
private RootRecover ::= !(SEMI)

// VAR ::= ['private'|'protected'] TYPE IDENTIFIER  [
//                                                      ( '=' (INITLIST | EXPR)) | ARGLIST
//                                                  ]
//                                                  {
//                                                      ',' IDENTIFIER  [
//                                                                          ( '=' (INITLIST | EXPR)) | ARGLIST
//                                                                      ]
//                                                  }
//                                                  ';'
Var ::= (PRIVATE|PROTECTED)? Type ID ( (EQ (InitList | Expr)) | ArgList )? ( COMMA ID ( EQ (InitList | Expr)|ArgList )? )* SEMI SEMI*
// TYPE          ::= ['const'] SCOPE DATATYPE   [
//                                                  '<' TYPE {',' TYPE} '>'
//                                              ]
//                                              {
//                                                  ('[' ']') | ('@' ['const'])
//                                              }
Type ::= CONST? Scope DataType GenericType? ((LBRACK RBRACK)|(AT CONST?))*
GenericType ::= LT Type (COMMA Type)* GT
// SCOPE         ::= ['::'] {IDENTIFIER '::'}   [
//                                                  IDENTIFIER
//                                                  [
//                                                      '<' TYPE {',' TYPE} '>'
//                                                  ]
//                                                  '::'
//                                              ]
Scope ::= COLON_COLON? (ID COLON_COLON)* (ID GenericType? COLON_COLON)?
// DATATYPE      ::= (IDENTIFIER | PRIMTYPE | '?' | 'auto')
DataType ::= ID|PrimType|QUEST|AUTO
// PRIMTYPE      ::= 'void' | 'int' | 'int8' | 'int16' | 'int32' | 'int64' | 'uint' | 'uint8' | 'uint16' | 'uint32' | 'uint64' | 'float' | 'double' | 'bool'
PrimType ::= ARRAY|BOOL|CODE|DOUBLE|FLOAT|HANDLE|INT|INT8|INT16|INT32|INT64|REAL|STRING|UINT|UINT16|UINT32|UINT64|VOID|ID
// INITLIST      ::=    '{'
//                      [ASSIGN | INITLIST]
//                      {
//                          ','
//                          [ASSIGN | INITLIST]
//                      }
//                      '}'
InitList ::= LBRACE (Assign|InitList)? ( COMMA (Assign|InitList)? )* RBRACE
// ASSIGN        ::= CONDITION [ ASSIGNOP ASSIGN ]
Assign ::= Condition  (AssignOp Assign)?
// CONDITION     ::= EXPR ['?' ASSIGN ':' ASSIGN]
Condition ::= Expr (QUEST Assign COLON Assign)?
// ASSIGNOP      ::= '=' | '+=' | '-=' | '*=' | '/=' | '|=' | '&=' | '^=' | '%=' | '**=' | '<<=' | '>>=' | '>>>='
AssignOp ::= EQ|PLUS_EQ|MINUS_EQ|MUL_EQ|DIV_EQ
// ARGLIST       ::=    '('
//                      [IDENTIFIER ':']
//                      ASSIGN
//                      {
//                          ',' [IDENTIFIER ':'] ASSIGN
//                      }
//                      ')'
ArgList ::= LPAREN (ID COLON)? Assign (COMMA (ID COLON)? Assign)* RPAREN
// FUNCCALL      ::= SCOPE IDENTIFIER ARGLIST
FuncCall ::= Scope ID (ArgList | (LPAREN RPAREN))
// FUNC          ::= {'shared' | 'external'} ['private' | 'protected']  [
//                                                                          ( (TYPE ['&']) | '~' )
//                                                                      ]
//                                                                      IDENTIFIER PARAMLIST ['const'] FUNCATTR (';' | STATBLOCK)
Func ::= (SHARED|EXTERNAL)* (PRIVATE|PROTECTED)?  (((Type AND?)|TILDE))? ID ParamList CONST? FuncAttr ((SEMI SEMI*) | StatBlock) {pin=StatBlock}
// PARAMLIST     ::=    '('
//                      [
//                          'void'
//                          |
//                          (
//                              TYPE TYPEMOD [IDENTIFIER] ['=' EXPR]    {
//                                                                          ',' TYPE TYPEMOD [IDENTIFIER] ['=' EXPR]
//                                                                      }
//                          )
//                      ]
//                      ')'
ParamList ::= LPAREN (VOID | (Param (COMMA Param)*) )? RPAREN
Param ::= Type TypeMod ID? (EQ Expr)?
// TYPEMOD       ::= ['&' ['in' | 'out' | 'inout']]
TypeMod ::= (AND (IN|OUT|INOUT)?)?
// FUNCATTR      ::= {'override' | 'final' | 'explicit' | 'property'}
FuncAttr ::= (OVERRIDE|FINAL|EXPLICIT|PROPERTY)*
// STATBLOCK     ::= '{' {VAR | STATEMENT} '}'
StatBlock ::= LBRACE (Var | Stmt)* RBRACE
// STATEMENT     ::= (IF | FOR | WHILE | RETURN | STATBLOCK | BREAK | CONTINUE | DOWHILE | SWITCH | EXPRSTAT | TRY)
Stmt ::= (StatBlock|ExprStat|IfStmt|ForStmt|WhileStnt|DoWhileStmt|SwitchStmt|BreakStmt|ReturnStmt)
// EXPRSTAT      ::= [ASSIGN] ';'
ExprStat ::= Assign? SEMI
// IF            ::= 'if' '(' ASSIGN ')' STATEMENT ['else' STATEMENT]
IfStmt ::= IF LPAREN Assign RPAREN Stmt (ELSE Stmt)?
// FOR           ::= 'for' '(' (VAR | EXPRSTAT) EXPRSTAT    [
//                                                              ASSIGN {',' ASSIGN}
//                                                          ]
//                                                          ')'
//                                                          STATEMENT
ForStmt ::=  FOR LPAREN (Var | ExprStat) ExprStat (Assign (COMMA Assign)*)? RPAREN Stmt
// WHILE         ::= 'while' '(' ASSIGN ')' STATEMENT
WhileStnt ::= WHILE LPAREN Assign RPAREN Stmt
// DOWHILE       ::= 'do' STATEMENT 'while' '(' ASSIGN ')' ';'
DoWhileStmt ::= DO Stmt WHILE LPAREN Assign RPAREN SEMI
// RETURN        ::= 'return' [ASSIGN] ';'
ReturnStmt ::= RETURN Assign? SEMI*
// SWITCH        ::= 'switch' '(' ASSIGN ')' '{' {CASE} '}'
SwitchStmt ::= SWITCH LPAREN Assign RPAREN LBRACE (CaseStmt)* RBRACE
// CASE          ::= (('case' EXPR) | 'default') ':' {STATEMENT}
CaseStmt ::= ((CASE Expr) | DEFAULT) COLON (Stmt)*
// BREAK         ::= 'break' ';'
BreakStmt ::= BREAK SEMI

// === EXPRESSION
// https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
// https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000094104-Expression-handling-in-grammar-kit-issue-with-deep-trees
// https://gist.github.com/FatalCatharsis/aad0b72c3ffed144c3d61ee73dcb283f

Expr ::=
    AssignExpr |
    RefExpr |
    AddGroup |
    MulGroup |
    UnaryGroup |
    CmpGroup |
    OrExpr |
    AndExpr |
    PrimaryExpr

RefExpr ::= Expr DOT Expr
AssignExpr ::= Expr (EQ|PLUS_EQ|MINUS_EQ|MUL_EQ|DIV_EQ) Expr

private AddGroup ::= PlusExpr | MinusExpr
PlusExpr ::= Expr PLUS Expr
MinusExpr ::= Expr MINUS Expr

private MulGroup ::= MulExpr | DivExpr
MulExpr ::= Expr MUL Expr
DivExpr ::= Expr DIV Expr

private UnaryGroup ::=
    MulUnaryExpr |
    DivUnaryExpr |
    PlusUnaryExpr |
    MinusUnaryExpr |
    NotExpr |
    PreIncExpr |
    PostIncExpr |
    PreDecExpr |
    PostDecExpr

MulUnaryExpr ::= MUL Expr
DivUnaryExpr ::= DIV Expr
PlusUnaryExpr ::= PLUS Expr
MinusUnaryExpr ::= MINUS Expr
NotExpr ::= NOT Expr
PreIncExpr ::= PLUS_PLUS Expr
PostIncExpr ::= Expr PLUS_PLUS
PreDecExpr ::= MINUS_MINUS Expr
PostDecExpr ::= Expr MINUS_MINUS

private CmpGroup ::=
    EqExpr |
    NEqExpr |
    LTExpr |
    LTEqExpr |
    GTExpr |
    GTEqExpr

EqExpr ::= Expr EQ_EQ Expr
NEqExpr ::= Expr NEQ Expr
LTExpr ::= Expr LT Expr
LTEqExpr ::= Expr LT_EQ Expr
GTExpr ::= Expr GT Expr
GTEqExpr ::= Expr GT_EQ Expr

OrExpr ::= Expr OR_OR Expr
AndExpr ::= Expr AND_AND Expr
ParenExpr ::= LPAREN Expr RPAREN

PrimaryExpr ::=
    FALSE |
    NULL |
    TRUE |
    ParenExpr |
    ArrayAccess |
    FuncCall |
    REALVAL |
    HEXVAL |
    INTVAL |
    STRVAL |
    (AT? ID)

ArrayAccess ::= ID ArrayAccessItem ArrayAccessItem*
ArrayAccessItem ::= LBRACK Expr? RBRACK {pin=1}
