{
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="JASS"
    psiImplClassSuffix="Impl"

    parserClass=              "guru.xgm.jass.parser.JASSParser"

    psiPackage=               "guru.xgm.jass.psi"
    psiImplPackage=           "guru.xgm.jass.psi.impl"
    elementTypeHolderClass=   "guru.xgm.jass.psi.TypesJASS"
    elementTypeClass=         "guru.xgm.jass.psi.tree.IElementTypeJASS_Element"
    tokenTypeClass=           "guru.xgm.jass.psi.tree.IElementTypeJASS_Token"

    extends(".*Expr")=Expression

    tokens = [
        WHITE_SPACE='regexp:\s+'
        SINGLE_LINE_COMMENT="regexp://[^\n]*"

        AND='and'
        ARRAY='array'
        CALL='call'
        CONSTANT='constant'
        DEBUG='debug'
        ELSE='else'
        ELSEIF='elseif'
        ENDFUNCTION='endfunction'
        ENDIF='endif'
        ENDLOOP='endloop'
        ENDGLOBALS='endglobals'
        EXTENDS='extends'
        EXITWHEN='exitwhen'
        FALSE='false'
        FUNCTION='function'
        GLOBALS='globals'
        IF='if'
        LOCAL='local'
        LOOP='loop'
        NATIVE='native'
        NOT='not'
        NOTHING='nothing'
        NULL='null'
        OR='or'
        RETURNS='returns'
        RETURN='return'
        SET='set'
        TAKES='takes'
        THEN='then'
        TRUE='true'
        TYPE='type'

        COMMA=','
        EQEQ='=='
        EQ='='
        NEQ='!='
        LTEQ='<='
        LT='<'
        GTEQ='>='
        GT='>'
        PLUS='+'
        MINUS='-'
        MUL='*'
        DIV='/'
        LP='('
        RP=')'
        LB='['
        RB=']'
        LT='<'
        GT='>'

        REAL='regexp:\d+\.\d*|\.\d+'
        HEX='regexp:(0x|\$)[0-9a-fA-F]+'
        INTEGER='regexp:\d+'
        RAWCODE="regexp:'[^']*'"
        STRING="regexp:\"([^\"\\]|\\.)*\""

        ID='regexp:[A-Za-z_][_0-9A-Za-z]*'
    ]
}

Root ::= (
    TypeDeclaration |
    NativeDeclaration |
    GlobalsDeclaration |
    FunctionDeclaration
    )* {recoverWhile=rootRecover}
private rootRecover ::= !(TYPE|CONSTANT|GLOBALS|NATIVE|FUNCTION)

// === DECLARATION
TypeDeclaration ::= TYPE ID EXTENDS ID {pin=1}

TypedVariable ::= ID ID
ParamList ::= TypedVariable  (COMMA TypedVariable)*
FunctionHead ::= ID TAKES (NOTHING|ParamList) RETURNS (NOTHING|ID) {pin=2}
NativeDeclaration ::= CONSTANT? NATIVE FunctionHead {pin=2}

GlobalsDeclaration ::= GLOBALS GlobalVarDeclaration* ENDGLOBALS {pin=1}

GlobalVarDeclaration ::= CONSTANT? ID ARRAY? ID (EQ Expression)? {pin=2 recoverWhile=GlobalVarDeclarationRecover}
private GlobalVarDeclarationRecover ::= !(CONSTANT|ENDGLOBALS|ID ID|ID ARRAY|ID EQ)

FunctionDeclaration ::= FUNCTION FunctionHead Statement* ENDFUNCTION {pin=1}

Statement ::=
    SetStatement |
    CallStatement |
    LocalVarStatement |
    ReturnStatement |
    IfStatement |
    LoopStatement |
    ExitWhenStatement
    {recoverWhile=StatementRecover}

private StatementRecover ::= !(CALL|DEBUG|ELSE|ELSEIF|ENDFUNCTION|ENDLOOP|ENDIF|EXITWHEN|IF|LOCAL|LOOP|RETURN|SET|ID EQ|ID LP|ID LB|ID ID|ID ARRAY)

LocalVarStatement ::= LOCAL? ID ARRAY? ID (EQ Expression)? {pin=2}

SetStatement ::= SET? (ArrayLiteral|ID) EQ Expression {pin=3}

CallStatement ::= DEBUG? CALL? FunctionCallLiteral

ReturnStatement ::= RETURN Expression?

IfStatement ::= IF Expression THEN? (Statement|ElseIfStatement|ElseStatement)* ENDIF {pin=1}
ElseIfStatement ::= ELSEIF Expression THEN? Statement* {pin=1}
ElseStatement ::= ELSE Statement* {pin=1}

LoopStatement ::= LOOP Statement* ENDLOOP {pin=1}
ExitWhenStatement ::=EXITWHEN Expression {pin=1}

// === EXPRESSION
// https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
// https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000094104-Expression-handling-in-grammar-kit-issue-with-deep-trees
// https://gist.github.com/FatalCatharsis/aad0b72c3ffed144c3d61ee73dcb283f

Expression ::=
    AddGroup |
    MulGroup |
    UnaryGroup |
    ComparsionGroup |
    OrExpr |
    AndExpr |
    PrimaryExpr

private AddGroup ::= PlusExpr | MinusExpr
PlusExpr ::= Expression PLUS Expression
MinusExpr ::= Expression MINUS Expression

private MulGroup ::= MulExpr | DivExpr
MulExpr ::= Expression MUL Expression
DivExpr ::= Expression DIV Expression

private UnaryGroup ::=
    MulUnaryExpr |
    DivUnaryExpr |
    PlusUnaryExpr |
    MinusUnaryExpr |
    NotExpr

MulUnaryExpr ::= MUL Expression
DivUnaryExpr ::= DIV Expression
PlusUnaryExpr ::= PLUS Expression
MinusUnaryExpr ::= MINUS Expression
NotExpr ::= NOT Expression

private ComparsionGroup ::=
    EqualExpr |
    NotEqualsExpr |
    LessThanExpr |
    LessThanEqualsExpr |
    GreaterThanExpr |
    GreaterThanEqualsExpr

EqualExpr ::= Expression EQEQ Expression
NotEqualsExpr ::= Expression NEQ Expression
LessThanExpr ::= Expression LT Expression
LessThanEqualsExpr ::= Expression LTEQ Expression
GreaterThanExpr ::= Expression GT Expression
GreaterThanEqualsExpr ::= Expression GTEQ Expression

OrExpr ::= Expression OR Expression
AndExpr ::= Expression AND Expression
ParenExpr ::= LP Expression RP

PrimaryExpr ::=
    FALSE |
    NULL |
    TRUE |
    ParenExpr |
    ArrayLiteral |
    FunctionCallLiteral |
    REAL |
    HEX |
    INTEGER |
    RAWCODE |
    STRING |
    ID

ArrayLiteral ::= ID LB Expression? RB

FunctionSendLiteral ::= FUNCTION ID {pin=1}
Argument ::= Expression|FunctionSendLiteral
FunctionCallLiteral ::= ID LP (Argument (COMMA Argument)*)? RP

