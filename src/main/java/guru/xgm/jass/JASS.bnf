{
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="JASS"
    psiImplClassSuffix="Impl"

    parserClass=              "guru.xgm.jass.lang.PsiParserJASS"
    psiPackage=               "guru.xgm.jass.psi"
    psiImplPackage=           "guru.xgm.jass.psi.impl"
    elementTypeHolderClass=   "guru.xgm.jass.psi.TypesJASS"
    //psiImplUtilClass=         "guru.xgm.jass.psi.PsiImplUtilJASS"
    elementTypeClass=         "guru.xgm.jass.psi.tree.IElementTypeJASS_Element"
    tokenTypeClass=           "guru.xgm.jass.psi.tree.IElementTypeJASS_Token"

    extends(".*Expression")=expression

    tokens = [
        SINGLE_LINE_COMMENT="regexp://[^\n]*"
    ]
}

script ::= (
typeDeclaration
|nativeDeclaration
|globalsDeclaration)* {recoverWhile="scriptRecover"}
private scriptRecover ::= !(
KEYWORD_TYPE
|KEYWORD_CONSTANT
|KEYWORD_NATIVE
|KEYWORD_GLOBALS
)

// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
expression ::= assignExpression
  | conditionalExpression
  | additionGroup
  | booleanGroup
  | multiplyGroup
  | unaryGroup
  | callExpression
  | qualificationExpression
  | primaryGroup
  {extraRoot=true}
private booleanGroup ::= andExpression | orExpression
private unaryGroup ::= plusUnaryExpression | minusUnaryExpression | notUnaryExpression
private multiplyGroup ::= mulExpression | divExpression
private additionGroup ::= plusExpression | minusExpression
private primaryGroup ::=  refSimpleExpression | literalExpression | parenExpression

//noinspection BnfUnusedRule
fake refExpression ::= expression? DOT IDENTIFIER
refSimpleExpression ::= IDENTIFIER {extends=refExpression elementType=refExpression}
qualificationExpression ::= expression DOT IDENTIFIER {extends=refExpression elementType=refExpression}
callExpression ::= refExpression argumentList
argumentList ::= LPAREN [ !RPAREN expression  (COMMA expression)* ] RPAREN {pin(".*")=1}
literalExpression ::= INTEGER | REAL | RAWCODE | HEX | STRING
assignExpression ::= expression ASSIGN expression { rightAssociative=true }
conditionalExpression ::= expression (LT | RT | LT_EQ | RT_EQ | EQ_EQ | NEQ) expression
divExpression ::= expression DIV expression
mulExpression ::= expression MUL expression
minusExpression ::= expression MINUS expression
minusUnaryExpression ::= MINUS expression
plusExpression ::= expression PLUS expression
plusUnaryExpression ::= PLUS expression
notUnaryExpression ::= NOT expression
andExpression ::= expression AND expression
orExpression ::= expression OR expression
parenExpression ::= LPAREN expression RPAREN

// DECLARATION
typeDeclaration ::= KEYWORD_TYPE type KEYWORD_EXTENDS type {pin=1}
nativeDeclaration ::= KEYWORD_CONSTANT? KEYWORD_NATIVE functionName KEYWORD_TAKES (KEYWORD_NOTHING|argument (COMMA argument)*) KEYWORD_RETURNS (KEYWORD_NOTHING|type) {pin=2}
globalsDeclaration ::= KEYWORD_GLOBALS (variableDeclaration)* KEYWORD_ENDGLOBALS {pin=1}
variableDeclaration ::= KEYWORD_CONSTANT? type ARRAY? variable (ASSIGN expression)? {pin=3}

type ::= IDENTIFIER
variable ::= IDENTIFIER
functionName ::= IDENTIFIER
argument ::= type variable

