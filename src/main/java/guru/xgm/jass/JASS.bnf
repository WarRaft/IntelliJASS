{
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="JASS"
    psiImplClassSuffix="Impl"

    parserClass=              "guru.xgm.jass.lang.PsiParserJASS"
    psiPackage=               "guru.xgm.jass.psi"
    psiImplPackage=           "guru.xgm.jass.psi.impl"
    elementTypeHolderClass=   "guru.xgm.jass.psi.TypesJASS"
    elementTypeClass=         "guru.xgm.jass.psi.tree.IElementTypeJASS_Element"
    tokenTypeClass=           "guru.xgm.jass.psi.tree.IElementTypeJASS_Token"

    extends(".*Expression")=expression

    tokens = [
        SINGLE_LINE_COMMENT="regexp://[^\n]*"
    ]
}

script ::= (
typeDeclaration
|nativeDeclaration
|globalsDeclaration
|functionDeclaration
)* {recoverWhile=scriptRecover}
private scriptRecover ::= !(
KEYWORD_TYPE
|KEYWORD_CONSTANT
|KEYWORD_NATIVE
|KEYWORD_GLOBALS
|KEYWORD_FUNCTION
)

// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf

expression ::= assignExpression
  | conditionalExpression
  | additionGroup
  | booleanGroup
  | multiplyGroup
  | unaryGroup
  | callExpression
  | qualificationExpression
  | primaryGroup
  {extraRoot=true}
private booleanGroup ::= andExpression | orExpression
private unaryGroup ::= plusUnaryExpression | minusUnaryExpression | notUnaryExpression
private multiplyGroup ::= mulExpression | divExpression
private additionGroup ::= plusExpression | minusExpression
private primaryGroup ::=  refSimpleExpression | literalExpression | parenExpression

//noinspection BnfUnusedRule
fake refExpression ::= expression? DOT IDENTIFIER
refSimpleExpression ::= IDENTIFIER {extends=refExpression elementType=refExpression}
qualificationExpression ::= expression DOT IDENTIFIER {extends=refExpression elementType=refExpression}
callExpression ::= refExpression callParamenters
callParamenters ::= LPAREN [ !RPAREN expression  (COMMA expression)* ] RPAREN {pin(".*")=1}
literalExpression ::= INTEGER | REAL | RAWCODE | HEX | STRING | TRUE | FALSE
assignExpression ::= expression ASSIGN expression { rightAssociative=true }
conditionalExpression ::= expression (LT | RT | LT_EQ | RT_EQ | EQ_EQ | NEQ) expression
divExpression ::= expression DIV expression
mulExpression ::= expression MUL expression
minusExpression ::= expression MINUS expression
minusUnaryExpression ::= MINUS expression
plusExpression ::= expression PLUS expression
plusUnaryExpression ::= PLUS expression
notUnaryExpression ::= NOT expression
andExpression ::= expression AND expression
orExpression ::= expression OR expression
parenExpression ::= LPAREN expression RPAREN


typeDeclaration ::= KEYWORD_TYPE type KEYWORD_EXTENDS type {pin=1}
globalsDeclaration ::= KEYWORD_GLOBALS (variableDeclaration)* KEYWORD_ENDGLOBALS {pin=3}
variableDeclaration ::= KEYWORD_CONSTANT? type ARRAY? variable (ASSIGN expression)? {pin=4}

// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#22-using-recoverwhile-attribute
// https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md

nativeDeclaration ::= KEYWORD_CONSTANT? KEYWORD_NATIVE functionHead
functionHead ::= functionName KEYWORD_TAKES (NOTHING|argumentList) KEYWORD_RETURNS (NOTHING|type) {pin=1}
functionDeclaration ::= KEYWORD_FUNCTION functionHead statementList KEYWORD_ENDFUNCTION {pin=1 recoverWhile=functionDeclarationRecover}
private functionDeclarationRecover ::= !(KEYWORD_FUNCTION | IDENTIFIER ASSIGN | KEYWORD_ENDFUNCTION)

statementList ::= (assignStatement)*
assignStatement ::= SET? variable ASSIGN expression {pin=3 recoverWhile=assignStatementRecover}
private assignStatementRecover ::= !(SET)

type ::= IDENTIFIER
variable ::= IDENTIFIER
functionName ::= IDENTIFIER
argumentList ::= argument  (COMMA argument)*
argument ::= type variable

