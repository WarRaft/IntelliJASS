{
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="JASS"
  psiImplClassSuffix="Impl"

  parserClass=              "guru.xgm.jass.lang.PsiParserJASS"
  psiPackage=               "guru.xgm.jass.psi"
  psiImplPackage=           "guru.xgm.jass.psi.impl"
  elementTypeHolderClass=   "guru.xgm.jass.psi.TypesJASS"
  //psiImplUtilClass=         "guru.xgm.jass.psi.PsiImplUtilJASS"
  elementTypeClass=         "guru.xgm.jass.psi.tree.IElementTypeJASS_Element"
  tokenTypeClass=           "guru.xgm.jass.psi.tree.IElementTypeJASS_Token"
}

script ::= (
typeDeclaration
|nativeDeclaration
|globalsDeclaration
|SINGLE_LINE_COMMENT)* {recoverWhile="scriptRecover"}
private scriptRecover ::= !(
KEYWORD_TYPE
|KEYWORD_CONSTANT
|KEYWORD_NATIVE
|KEYWORD_GLOBALS
)
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities



typeDeclaration ::= KEYWORD_TYPE type KEYWORD_EXTENDS type {pin=1}
nativeDeclaration ::= KEYWORD_CONSTANT? KEYWORD_NATIVE functionName KEYWORD_TAKES (KEYWORD_NOTHING|argumentDelaration (COMMA argumentDelaration)*) KEYWORD_RETURNS (KEYWORD_NOTHING|type) {pin=2}
globalsDeclaration ::= KEYWORD_GLOBALS (variableDeclaration)* KEYWORD_ENDGLOBALS {pin=1}
variableDeclaration ::= KEYWORD_CONSTANT? type variable (ASSIGN expression)? {pin=3}

type ::= IDENTIFIER
variable ::= IDENTIFIER
functionName ::= IDENTIFIER
argumentDelaration ::= type variable

functionCall ::= IDENTIFIER LPAREN (expression (COMMA expression)*)? RPAREN {pin=1}



// expression
expression ::= addition ((AND|OR) addition)*
addition ::= multiplication ((PLUS|MINUS) multiplication)*
multiplication ::= primary ((MUL|DIV) primary)*
primary ::= primaryTerm | not primary
primaryTerm ::= MINUS? INTEGER|functionCall|IDENTIFIER

/*
file ::= expr*

expr ::=  plus_expr | expr_
expr_ ::= array_ref_expr | const_expr

plus_expr ::= expr_ '+' expr
const_expr ::= number
array_ref_expr ::= id '[' expr ']'
 */
