{
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="JASS"
  psiImplClassSuffix="Impl"

  parserClass=              "guru.xgm.jass.lang.PsiParserJASS"
  psiPackage=               "guru.xgm.jass.psi"
  psiImplPackage=           "guru.xgm.jass.psi.impl"
  elementTypeHolderClass=   "guru.xgm.jass.psi.TypesJASS"
  //psiImplUtilClass=         "guru.xgm.jass.psi.PsiImplUtilJASS"
  elementTypeClass=         "guru.xgm.jass.psi.tree.IElementTypeJASS_Element"
  tokenTypeClass=           "guru.xgm.jass.psi.tree.IElementTypeJASS_Token"

  extends(".*Expression")="expression"
}

script ::= (
typeDeclaration
|nativeDeclaration
|globalsDeclaration
|SINGLE_LINE_COMMENT)* {recoverWhile="scriptRecover"}
private scriptRecover ::= !(
KEYWORD_TYPE
|KEYWORD_CONSTANT
|KEYWORD_NATIVE
|KEYWORD_GLOBALS
)


typeDeclaration ::= KEYWORD_TYPE type KEYWORD_EXTENDS type {pin=1}
nativeDeclaration ::= KEYWORD_CONSTANT? KEYWORD_NATIVE functionName KEYWORD_TAKES (KEYWORD_NOTHING|argumentDelaration (COMMA argumentDelaration)*) KEYWORD_RETURNS (KEYWORD_NOTHING|type) {pin=2}
globalsDeclaration ::= KEYWORD_GLOBALS (variableDeclaration)* KEYWORD_ENDGLOBALS {pin=1}
variableDeclaration ::= KEYWORD_CONSTANT? type variable (ASSIGN expression)? {pin=3}

type ::= IDENTIFIER
variable ::= IDENTIFIER
functionName ::= IDENTIFIER
argumentDelaration ::= type variable

functionCall ::= IDENTIFIER LPAREN (expression (COMMA expression)*)? RPAREN {pin=1}

// expression
expression ::= additionExpression ((AND|OR) additionExpression)*
additionExpression ::= multiplicationExpression ((PLUS|MINUS) multiplicationExpression)*
multiplicationExpression ::= primary ((MUL|DIV) primary)*
primary ::= primaryTermExpression | not primary
primaryTermExpression ::= MINUS? INTEGER|functionCall|IDENTIFIER

/*
<expression> ::= <conditional-expression>

<conditional-expression> ::= <logical-or-expression>

<logical-or-expression> ::= <logical-and-expression> | <logical-or-expression> "or" <logical-and-expression>

<logical-and-expression> ::= <equality-expression> | <logical-and-expression> "and" <equality-expression>

<equality-expression> ::= <relational-expression> | <equality-expression> "==" <relational-expression> | <equality-expression> "!=" <relational-expression>

<relational-expression> ::= <additive-expression> | <relational-expression> "<" <additive-expression> | <relational-expression> "<=" <additive-expression> | <relational-expression> ">" <additive-expression> | <relational-expression> ">=" <additive-expression>

<additive-expression> ::= <multiplicative-expression> | <additive-expression> "+" <multiplicative-expression> | <additive-expression> "-" <multiplicative-expression>

<multiplicative-expression> ::= <unary-expression> | <multiplicative-expression> "*" <unary-expression> | <multiplicative-expression> "/" <unary-expression>

<unary-expression> ::= <primary> | "-" <primary> | "not" <primary>

<primary> ::= <literal> | <identifier> | "(" <expression> ")" | <function-call>

<literal> ::= <integer> | <real>

<function-call> ::= <function-name> "(" <argument-list> ")"

<argument-list> ::= <expression> | <expression> "," <argument-list>

<identifier> ::= <identifier-name>

<identifier-name> ::= ...  // Здесь следует определить правила для имени переменной или функции

<function-name> ::= ...  // Здесь следует определить правила для имени функции

<integer> ::= ...  // Здесь следует определить правила для целых чисел

<real> ::= ...  // Здесь следует определить правила для чисел с плавающей запятой


 */
