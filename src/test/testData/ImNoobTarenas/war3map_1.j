globals
constant boolean LIBRARY_APIAllTypecast=true
code Code
code l__Code
integer Int
integer l__Int
string Str
string l__Str
boolean Bool
boolean l__Bool
handle Handle
handle l__Handle
unit Unit
unit l__Unit
ability Abil
ability l__Abil
trigger Trig
trigger l__Trig
integer Array
integer array l__Array
integer ArrayA
integer array l__ArrayA
integer ArrayB
integer array l__ArrayB
integer ArrayC
integer array l__ArrayC
integer ArrayD
integer array l__ArrayD
integer ArrayE
integer array l__ArrayE
integer bytecode
integer array l__bytecode
integer pbytecode
constant boolean LIBRARY_APIBasicUtils=true
boolean IsPrint=false
constant string sLetters="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
constant boolean LIBRARY_APIMemory=true
constant integer NULL=0
constant boolean LIBRARY_libHero=true
constant boolean LIBRARY_libBuy=true
hashtable MemHackTable=InitHashtable()
integer iGameVersion=0
integer pGameDLL=0
string PatchVersion=""
integer pMemory=0
integer array RJassNativesBuffer
integer Memory
integer array libBuy___CRAFTS
integer libBuy___CRAFT_COUNTER= 0
integer array libBuy___ITEMS
trigger gg_trg_libBuy= null
trigger gg_trg_libHero= null
integer array l__Memory
integer iBytecodeData
integer pPointers=0
integer pWriteMemory=0
integer pJassEnvAddress=0
integer RJassNativesBufferSize=0
integer JassVM=0
integer JassTable=0
integer pUnlockCall1=0
integer pUnlockCall2=0
integer pUnlockJmp1=0
constant boolean LIBRARY_APIMemoryAllCalls=true
constant boolean LIBRARY_APIMemoryBitwise=true
constant boolean LIBRARY_APIMemoryForString=true
constant boolean LIBRARY_APIMemoryFrameData=true
constant boolean LIBRARY_APIMemoryGameData=true
hashtable htObjectDataPointers=InitHashtable()
constant boolean LIBRARY_APIMemoryHStormDLL=true
integer pStormDLL=0
constant boolean LIBRARY_APIMemoryKernel=true
constant boolean LIBRARY_APIMemoryMPQ=true
constant boolean LIBRARY_APIMemoryRestorer=true
constant boolean LIBRARY_APIMemoryUtilityLibraryAPI=true
constant boolean LIBRARY_APIMemoryWC3GameUI=true
integer pGameUI=0
integer pWorldFrameWar3=0
constant boolean LIBRARY_APIMemoryWC3GameUIButton=true
constant boolean LIBRARY_APIMemoryWC3GameWindow=true
constant boolean LIBRARY_AchievLib=true
constant boolean LIBRARY_DictatorshipOfProletariatLib=true
constant boolean LIBRARY_DummyLib=true
constant boolean LIBRARY_GameLib=true
constant boolean LIBRARY_Group=true
group bj_group
constant boolean LIBRARY_HashLib=true
constant boolean LIBRARY_InitLib=true
string Version="v2.1.7b"
integer stand_tree=10
integer MaxHeroRes=3
integer Rat_Limit=125
real CastleUnlockUltimate_time=480.00
integer SOLO_HERO_FOOD=15
integer array Units
integer array bj_unitLimit
group LimitGroup=CreateGroup()
boolexpr LimitFilter
integer array HeroRes
boolean array tooltip
real array damage
unit bj_caster
real bj_real
integer bj_int
integer bj_num
real array bj_TELEPORT_MIN
real array bj_TELEPORT_MAX
unit array bj_TELEPORT_UNIT
integer array GradeScore
integer array TotalKills
boolean array XpLoad
integer array Rats
boolexpr RatsFilter
boolean array hasDefense
constant boolean LIBRARY_InvokerLib=true
constant boolean LIBRARY_ItemLib=true
constant boolean LIBRARY_MathLib=true
constant boolean LIBRARY_MemoryHackAbilityAddressAPI=true
constant boolean LIBRARY_MemoryHackAbilityBaseAPI=true
constant boolean LIBRARY_MemoryHackAbilityNormalAPI=true
constant boolean LIBRARY_MemoryHackAbilityUnitAPI=true
constant boolean LIBRARY_MemoryHackCASpriteBaseAPI=true
constant boolean LIBRARY_MemoryHackCASpriteMiniAPI=true
constant boolean LIBRARY_MemoryHackCASpriteUberAPI=true
constant boolean LIBRARY_MemoryHackCFrameAPI=true
constant boolean LIBRARY_MemoryHackCFrameBackDropAPI=true
constant boolean LIBRARY_MemoryHackCFrameEditBoxAPI=true
constant boolean LIBRARY_MemoryHackCLayerAPI=true
constant boolean LIBRARY_MemoryHackCLayoutFrameAPI=true
constant boolean LIBRARY_MemoryHackCModelFrameAPI=true
constant boolean LIBRARY_MemoryHackCObjectAPI=true
constant boolean LIBRARY_MemoryHackCSimpleButtonAPI=true
constant boolean LIBRARY_MemoryHackCSimpleConsoleAPI=true
constant boolean LIBRARY_MemoryHackCSimpleFontAPI=true
constant boolean LIBRARY_MemoryHackCSimpleFrameAPI=true
constant boolean LIBRARY_MemoryHackCSimpleGlueAPI=true
constant boolean LIBRARY_MemoryHackCSimpleMessageFrameAPI=true
constant boolean LIBRARY_MemoryHackCSimpleRegionAPI=true
constant boolean LIBRARY_MemoryHackCSimpleStatusBarAPI=true
constant boolean LIBRARY_MemoryHackCSimpleTextureAPI=true
constant boolean LIBRARY_MemoryHackCSliderAPI=true
constant boolean LIBRARY_MemoryHackCSpriteFrameAPI=true
constant boolean LIBRARY_MemoryHackCStatusBarAPI=true
constant boolean LIBRARY_MemoryHackCTextAreaAPI=true
constant boolean LIBRARY_MemoryHackCTextFrameAPI=true
constant boolean LIBRARY_MemoryHackCWidgetAPI=true
constant boolean LIBRARY_MemoryHackCWidgetBaseAPI=true
constant boolean LIBRARY_MemoryHackCastAbility=true
constant boolean LIBRARY_MemoryHackConstantsAPI=true
constant boolean LIBRARY_MemoryHackDamageEventHook=true
integer pDamageStack=0
integer pDamageHook=0
integer pUnitVtable=0
constant boolean LIBRARY_MemoryHackEffectAPI=true
constant boolean LIBRARY_MemoryHackFrameAPI=true
constant boolean LIBRARY_MemoryHackGroupAPI=true
constant boolean LIBRARY_MemoryHackItemBaseAPI=true
constant boolean LIBRARY_MemoryHackItemNormalAPI=true
constant boolean LIBRARY_MemoryHackMouseAPI=true
constant boolean LIBRARY_MemoryHackPlayerAPI=true
constant boolean LIBRARY_MemoryHackTrackableAPI=true
constant boolean LIBRARY_MemoryHackUIAPI=true
constant integer ANCHOR_TOPLEFT=0
constant integer ANCHOR_TOP=1
constant integer ANCHOR_TOPRIGHT=2
constant integer ANCHOR_LEFT=3
constant integer ANCHOR_CENTER=4
constant integer ANCHOR_RIGHT=5
constant integer ANCHOR_BOTTOMLEFT=6
constant integer ANCHOR_BOTTOM=7
constant integer ANCHOR_BOTTOMRIGHT=8
boolean IsGameUIEnabled=true
constant boolean LIBRARY_MemoryHackUnitBaseAPI=true
constant boolean LIBRARY_MemoryHackUnitNormalAPI=true
constant boolean LIBRARY_PeriodicDamage=true
string array pd_DamageType
constant boolean LIBRARY_StatsLib=true
constant boolean LIBRARY_TextLib=true
constant boolean LIBRARY_AbilityLib=true
constant boolean LIBRARY_ControlUnitLib=true
constant boolean LIBRARY_EffectsLib=true
real el_PENTA_LINES=5
real el_PENTA_ANGLE=360/ el_PENTA_LINES
constant boolean LIBRARY_KydesnikLib=true
constant boolean LIBRARY_UnitLib=true
constant boolean LIBRARY_VipLib=true
string array PLAYER_NAMES
boolean array VIP_ACCESS
string array VIP_NAMES
constant boolean LIBRARY_EndLib=true
constant boolean LIBRARY_HeroRespawnLib=true
constant boolean LIBRARY_MagicWand=true
real MagicWand__PERIODIC=1.25
real MagicWand__DMG_RANGE=0.00
real MagicWand__DAMAGE=20.00
real MagicWand__RANGE=700.00
integer MagicWand__GREAT_WAND_ID='I02I'
boolean MagicWand__IS_NECRO=false
integer MagicWand__COUNT=1
string MagicWand__FIRE_SPHERE_EFFECT_PATH="Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl"
constant boolean LIBRARY_MercenaryLib=true
constant boolean LIBRARY_PentagramLib=true
constant real PENTA_DAMAGE=20.00
constant real PENTA_RANGE=750.00
constant real PENTA_TIME=999999999.00
constant real PENTA_DMG_PERIODIC=1.00
constant integer PENTA_DMG_COUNT=R2I(PENTA_TIME/ PENTA_DMG_PERIODIC)
constant boolean LIBRARY_RecipesLib=true
integer array RecipesLib__RECIPES_LIST
constant boolean LIBRARY_SpellsLib=true
constant boolean LIBRARY_Stun=true
constant boolean LIBRARY_UnitTypeLib=true
constant boolean LIBRARY_WillOfNature=true
constant boolean LIBRARY_DispelLib=true
real DISPEL_RANGE=300.00
real WIZARD_RING_RANGE=250.00
integer WIZARD_RING_ID='A0JN'
real DETONATE_RANGE=300.00
integer DETONATE_ID='A01Z'
constant boolean LIBRARY_Frostmorne=true
constant real Frostmorne___DAMAGE_PER_LVL=15.00
constant real Frostmorne___FROST_TIME_PER_LVL=0.50
constant real Frostmorne___RELOAD_TIME=12.00
constant boolean LIBRARY_Move=true
constant boolean LIBRARY_TalantsLib=true
integer array TALANTS_LIST
integer TALANTS_LIST_MIN=1
integer TALANTS_LIST_MAX=0
constant boolean LIBRARY_BadWave=true
string BadWave__DAMAGE_FX="Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl"
string BadWave__WAVE_FX="AFOD"
real BadWave__WAVE_DESTROY_TIME=0.25
constant boolean LIBRARY_Clap=true
constant boolean LIBRARY_CursedPrince=true
constant boolean LIBRARY_DarkRevenge=true
constant boolean LIBRARY_FireRain=true
constant boolean LIBRARY_HealWave=true
string HealWave__HEAL_EFFECT_PATH="Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
constant boolean LIBRARY_HolyLight=true
constant boolean LIBRARY_Illusions=true
constant boolean LIBRARY_IncomeLib=true
constant boolean LIBRARY_PowerWave=true
constant boolean LIBRARY_PrisonOnWheels=true
constant boolean LIBRARY_RewardLib=true
integer RewardLib___LVL_GOLD=2
real RewardLib___GOLD_DIGGER=0.20
real RewardLib___SOLO_HERO_GOLD=1.25
real RewardLib___SOLO_HERO_DIE_GOLD=1.50
real RewardLib___JUST_HERO_GOLD=4.00
real RewardLib___STRUCTURE_GOLD=10.00
real RewardLib___STRUCTURE_KILLER_GOLD=1.10
real RewardLib___KILL_BONUS=0.001
real RewardLib___SWARM_QUEEN_GOLD=0.50
real RewardLib___RAT_KING_GOLD=0.50
real RewardLib___ATTACK_ON_TITAN_GOLD=0.50
real RewardLib___ZOMBIE_GOLD=0.35
integer RewardLib___SUMMON_GOLD=2
real RewardLib___GREEDY_GOLD=0.50
real RewardLib___SHARING_GOLD=0.30
integer RewardLib___LVL_XP=6
real RewardLib___BOOK_WORM_XP=1.55
real RewardLib___SOLO_HERO_XP=2.00
real RewardLib___SOLO_HERO_DIE_XP=1.50
real RewardLib___JUST_HERO_XP=4.00
real RewardLib___STRUCTURE_XP=10.00
real RewardLib___STRUCTURE_KILLER_XP=0.90
real RewardLib___ATTACK_ON_TITAN_XP=0.50
integer RewardLib___SUMMON_XP=6
real RewardLib___GREEDY_XP=0.50
real RewardLib___SHARING_XP=0.30
constant boolean LIBRARY_RuneShield=true
real array udg_MS_power
unit array udg_MS_units
effect array udg_MS_effects
integer udg_MS_num=0
trigger array udg_MS_trigs
constant boolean LIBRARY_SpawnLib=true
integer array bj_unitDamageType
integer array bj_unitArmourType
constant boolean LIBRARY_StompLib=true
constant boolean LIBRARY_SupremeShaman=true
constant boolean LIBRARY_TranquilityLib=true
real TranquilityLib__PERIODIC=1.00
real TranquilityLib__MAX_TIME=10.00
real TranquilityLib__POWER=0.0175
string TranquilityLib__EFFECT_STRING="Tranquility | Effect"
string TranquilityLib__TIME_STRING="Tranquility | Time"
trigger TranquilityLib__DAMAGE_EVENT_TRIGGER=CreateTrigger()
constant boolean LIBRARY_WonderfulFlow=true
real WonderfulFlow__PERIODIC=5.00
real WonderfulFlow__WAIT_TIME=2.00
real WonderfulFlow__RANGE=250.00
real WonderfulFlow__LVL_DAMAGE=16.00
real WonderfulFlow__SUMMON_DAMAGE=1.50
integer WonderfulFlow__BUFF_USE_COUNT=4
constant boolean LIBRARY_cursedAI=true
constant real cursedAI___PERIODIC_TIME=1.00
constant integer cursedAI___MIN_ATTACK_GROUP_SIZE=15
constant boolean cursedAI___IS_LOGGER_ENABLED=false
constant real cursedAI___RUN_AWAY_HP_PERCENT=0.35
constant real cursedAI___WAIT_FOR_HP_PERCENT=0.50
constant real cursedAI___WAIT_FOR_HP_PERIODIC=2.00
constant real cursedAI___DEFEND_TIME=30.00
constant integer cursedAI___DEFEND_GROUP_SIZE=12
constant real cursedAI___ULTIMATE_HP_PERCENT=0.50
player cursedAI___bj_player
integer array cursedAI___BOTS
group cursedAI___attackGroup=CreateGroup()
group cursedAI___unitsCountGroup=CreateGroup()
trigger cursedAI___takeDamage=CreateTrigger()
constant boolean LIBRARY_RaceLib=true
integer array RACE_LIST
integer RACE_LIST_MIN=1
integer RACE_LIST_MAX=0
integer array bj_playerRace
constant boolean LIBRARY_StartGameLib=true
real INCOME_PERIODIC=2.00
integer INIT_GOLD_COUNT=0
integer INIT_INCOME=1
integer BANNED_RACES=0
integer BANNED_TALANTS=0
string REJIME="teams"
string CHOICE_REJIME="std"
boolean UNIT_TYPES_CHANGE=false
boolean RACE_LIMIT=true
player bj_PlayerChoice
string bj_ChoicePlayer
trigger sgl_settingsTrigger=CreateTrigger()
trigger sgl_setSettingsTrigger=CreateTrigger()
trigger sgl_startGameTrigger=CreateTrigger()
unit array udg_Hero
real array udg_SpawnTime
integer array udg_Unit
unit array udg_Castle
trigger array udg_UnitSpawnTrigg
real array udg_HeroResTime
integer array udg_Boss
unit udg_Bossss=null
unit udg_DarkLight=null
real array udg_KillBonus
button array udg_BTN
dialog udg_DIALOG=null
force array udg_PlayerGroup
integer udg_PlayerNum=0
real array udg_BossDamage
leaderboard udg_HandleBoard=null
integer array udg_PvE_Unit
integer udg_Round=0
timer udg_Timer=null
unit udg_PvE_Castle=null
timer udg_PvE_Timer=null
hashtable udg_Hash=null
quest array udg_Achievement
integer array udg_BuilderPower
quest array udg_Fake_Achievement
integer udg_TimeSecond=0
integer udg_TimeMinute=0
integer udg_TimeHours=0
integer array udg_Bandos
integer array udg_Necronomicon
integer array udg_Dalbaeb
multiboard udg_MultiBoard=null
real udg_VlastDyxov=0
unit udg_DarkExp=null
unit udg_u_VlastDyxov=null
unit udg_caster=null
integer udg_TimeMiniSecond=0
integer udg_HeroCount=0
unit array udg_Visualisator
unit array udg_TalantPicker
rect gg_rct_Blue=null
rect gg_rct_Orange=null
rect gg_rct_LightGreen=null
rect gg_rct_Yellow=null
rect gg_rct_MID=null
rect gg_rct_Red=null
rect gg_rct_Purple=null
rect gg_rct_PvE=null
rect gg_rct________________010=null
rect gg_rct________________011=null
rect gg_rct_CreepsUp=null
rect gg_rct_CreepsDown=null
rect gg_rct_UpMiniTower1=null
rect gg_rct_UpMiniTower4=null
rect gg_rct_UpMiniTower3=null
rect gg_rct_UpMiniTower2=null
rect gg_rct_DownMiniTower1=null
rect gg_rct_DownMiniTower2=null
rect gg_rct_DownMiniTower3=null
rect gg_rct_DownMiniTower4=null
sound gg_snd_HumanCallToArmsWhat1=null
trigger gg_trg_APIBasicUtils=null
trigger gg_trg_APITypecast=null
trigger gg_trg_APIMemory=null
trigger gg_trg_APIMemoryCalls=null
trigger gg_trg_APIMemoryBitwise=null
trigger gg_trg_APIMemoryString=null
trigger gg_trg_APIMemoryKernel=null
trigger gg_trg_APIMemoryRestorer=null
trigger gg_trg_APIMemoryStormDLL=null
trigger gg_trg_APIMemoryMPQ=null
trigger gg_trg_APIMemoryFrameData=null
trigger gg_trg_APIMemoryGameData=null
trigger gg_trg_APIMemoryGameUI=null
trigger gg_trg_APIMemoryGameUIButton=null
trigger gg_trg_APIMemoryGameWindow=null
trigger gg_trg_APIMemoryUtilityLibraryAPI=null
trigger gg_trg_MemHackConstantsAPI=null
trigger gg_trg_MemHackCFrameAPI=null
trigger gg_trg_MemHackCLayerAPI=null
trigger gg_trg_MemHackCLayoutFrameAPI=null
trigger gg_trg_MemHackCBackDropFrameAPI=null
trigger gg_trg_MemHackCEditBoxAPI=null
trigger gg_trg_MemHackCModelFrameAPI=null
trigger gg_trg_MemHackCSimpleButtonAPI=null
trigger gg_trg_MemHackCSimpleFontAPI=null
trigger gg_trg_MemHackCSimpleGlueAPI=null
trigger gg_trg_MemHackCSimpleFrameAPI=null
trigger gg_trg_MemHackCSimpleConsoleAPI=null
trigger gg_trg_MemHackCSpriteFrameAPI=null
trigger gg_trg_MemHackCSimpleMessageFrameAPI=null
trigger gg_trg_MemHackCSliderAPI=null
trigger gg_trg_MemHackCTextAreaAPI=null
trigger gg_trg_MemHackCTextFrameAPI=null
trigger gg_trg_MemHackCSimpleStatusBarAPI=null
trigger gg_trg_MemHackCStatusBarAPI=null
trigger gg_trg_MemHackCSimpleTextureAPI=null
trigger gg_trg_MemHackCSimpleRegionAPI=null
trigger gg_trg_MemHackFrameAPI=null
trigger gg_trg_MemHackUIAPI=null
trigger gg_trg_MemHackCSpriteBaseAPI=null
trigger gg_trg_MemHackCSpriteMiniAPI=null
trigger gg_trg_MemHackCSpriteUberAPI=null
trigger gg_trg_MemHackCObjectAPI=null
trigger gg_trg_MemHackPlayerAPI=null
trigger gg_trg_MemHackAbilityAddressAPI=null
trigger gg_trg_MemHackAbilityBaseAPI=null
trigger gg_trg_MemHackAbilityNormalAPI=null
trigger gg_trg_MemHackAbilityUnitAPI=null
trigger gg_trg_MemHackCastAbility=null
trigger gg_trg_MemHackWidgetBaseAPI=null
trigger gg_trg_MemHackWidgetNormalAPI=null
trigger gg_trg_MemHackEffectAPI=null
trigger gg_trg_MemHackTrackableAPI=null
trigger gg_trg_MemHackItemBaseAPI=null
trigger gg_trg_MemHackItemNormalAPI=null
trigger gg_trg_MemHackUnitBaseAPI=null
trigger gg_trg_MemHackUnitNormalAPI=null
trigger gg_trg_MemHackGroupAPI=null
trigger gg_trg_MemHackMouseAPI=null
trigger gg_trg_InitMemoryHack=null
trigger gg_trg_InitMainHook=null
trigger gg_trg_asdf=null
trigger gg_trg_MemHackDrawCooldown=null
trigger gg_trg_MemHackDamageHook=null
trigger gg_trg_MemHackBerserkHook=null
trigger gg_trg_MemHackCustomAbilityChargesHook=null
trigger gg_trg_InitLib=null
trigger gg_trg_AchievLib=null
trigger gg_trg_HeroRespawnLib=null
trigger gg_trg_ItemLib=null
trigger gg_trg_UnitTypeLib=null
trigger gg_trg_cursedAI=null
trigger gg_trg_SpawnLib=null
trigger gg_trg_SpellsLib=null
trigger gg_trg_RecipesLib=null
trigger gg_trg_MoveLib=null
trigger gg_trg_RaceLib=null
trigger gg_trg_StunLib=null
trigger gg_trg_MercenaryLib=null
trigger gg_trg_TalantsLib=null
trigger gg_trg_VipLib=null
trigger gg_trg_EndLib=null
trigger gg_trg_IncomeLib=null
trigger gg_trg_StartGameLib=null
trigger gg_trg_TextLib=null
trigger gg_trg_GameLib=null
trigger gg_trg_RewardLib=null
trigger gg_trg_DispelLib=null
trigger gg_trg_UnitLib=null
trigger gg_trg_AbilityLib=null
trigger gg_trg_DummyLib=null
trigger gg_trg_HashLib=null
trigger gg_trg_ControlUnitLib=null
trigger gg_trg_PeriodicDamageLib=null
trigger gg_trg_StatsLib=null
trigger gg_trg_MathLib=null
trigger gg_trg_GroupLib=null
trigger gg_trg_EffectsLib=null
trigger gg_trg_BandaDodikov=null
trigger gg_trg_SetupAchiv=null
trigger gg_trg_BuilderPower=null
trigger gg_trg_Bandos=null
trigger gg_trg_runSeachHandle=null
trigger gg_trg_xp=null
trigger gg_trg_Kick=null
trigger gg_trg_GGold=null
trigger gg_trg_Control=null
trigger gg_trg_CursedCross=null
trigger gg_trg_MagicWand=null
trigger gg_trg_ItemUpByLvl=null
trigger gg_trg_FenixEgg=null
trigger gg_trg_GhostKey=null
trigger gg_trg_BloodKey=null
trigger gg_trg_LightKey=null
trigger gg_trg_Illusori=null
trigger gg_trg_StormHummer=null
trigger gg_trg_Inferno=null
trigger gg_trg_LegJump=null
trigger gg_trg_DrevniPosox=null
trigger gg_trg_AmuletElyni=null
trigger gg_trg_Old_Sphere=null
trigger gg_trg_PosoxNeveria=null
trigger gg_trg_ZnaxarAmylet=null
trigger gg_trg_ZnakNeprist=null
trigger gg_trg_Teleport=null
trigger gg_trg_Kokon=null
trigger gg_trg_ShlemGospodstva=null
trigger gg_trg_Necronomicon=null
trigger gg_trg_MeshokDruida=null
trigger gg_trg_MeshokDruidaHash=null
trigger gg_trg_NightAmul=null
trigger gg_trg_RogKena=null
trigger gg_trg_FrostMorn=null
trigger gg_trg_DayviHeart=null
trigger gg_trg_PosoxAkari=null
trigger gg_trg_MolotSveta2=null
trigger gg_trg_MolotSveta1=null
trigger gg_trg_Blink=null
trigger gg_trg_BattleBrigade=null
trigger gg_trg_Tentakli=null
trigger gg_trg_Revive=null
trigger gg_trg_RazrSnaryadi=null
trigger gg_trg_DarkExp=null
trigger gg_trg_VlastDyxov=null
trigger gg_trg_Otmshenie=null
trigger gg_trg_Magic=null
trigger gg_trg_Opyst=null
trigger gg_trg_JajdaNajivi=null
trigger gg_trg_KornSystem=null
trigger gg_trg_PlamyaFenixa=null
trigger gg_trg_Ispepel=null
trigger gg_trg_Vendetta=null
trigger gg_trg_VolsSnar=null
trigger gg_trg_BombBrigade=null
trigger gg_trg_EngineeringMiracle=null
trigger gg_trg_RuneArmor=null
trigger gg_trg_RuneShieldUnit=null
trigger gg_trg_CuttingBlow=null
trigger gg_trg_Zombification=null
trigger gg_trg_LifeAura=null
trigger gg_trg_Old_Magic=null
trigger gg_trg_Berserks=null
trigger gg_trg_Bezymie=null
trigger gg_trg_BoeboyDyx=null
trigger gg_trg_DyxiPredkov=null
trigger gg_trg_BloodAura=null
trigger gg_trg_BloodOrcs=null
trigger gg_trg_BerserkFrenzy=null
trigger gg_trg_Grabej=null
trigger gg_trg_ZahvatKontrolya=null
trigger gg_trg_AuraAntimagic=null
trigger gg_trg_AuraPredkov=null
trigger gg_trg_Storojili=null
trigger gg_trg_YarostByri=null
trigger gg_trg_GromAndMolnia=null
trigger gg_trg_OLD_AURA=null
trigger gg_trg_KRIT_AURA=null
trigger gg_trg_DEATH_AURA=null
trigger gg_trg_NIGHT_AURA=null
trigger gg_trg_HEAVEN_AURA=null
trigger gg_trg_Detonation=null
trigger gg_trg_Tarakanshina=null
trigger gg_trg_Jychara=null
trigger gg_trg_Pancir=null
trigger gg_trg_AuraPleti=null
trigger gg_trg_Gylefication=null
trigger gg_trg_YarostVyrd=null
trigger gg_trg_Nekromantia=null
trigger gg_trg_FuryOfDamned=null
trigger gg_trg_YarostProklyatixx=null
trigger gg_trg_YarosttRemove=null
trigger gg_trg_Yarostt=null
trigger gg_trg_Yveche=null
trigger gg_trg_Zaxvatt=null
trigger gg_trg_Mest=null
trigger gg_trg_Podchinenie=null
trigger gg_trg_AuraProklyat=null
trigger gg_trg_Reznya=null
trigger gg_trg_NevidimkaGrade=null
trigger gg_trg_Nevidimka=null
trigger gg_trg_WoodDecay=null
trigger gg_trg_Vhod=null
trigger gg_trg_DrevesAura=null
trigger gg_trg_KorniMirDreva=null
trigger gg_trg_IskystvaWar=null
trigger gg_trg_GnevPrirodi=null
trigger gg_trg_OjereleGrade=null
trigger gg_trg_OjereleDriadi=null
trigger gg_trg_Flag=null
trigger gg_trg_Patrol=null
trigger gg_trg_Move=null
trigger gg_trg_Stay=null
trigger gg_trg_Stop=null
trigger gg_trg_Attack=null
trigger gg_trg_ProklyatieKnight=null
trigger gg_trg_Proklyatie=null
trigger gg_trg_Oderjimost=null
trigger gg_trg_Pistolet=null
trigger gg_trg_PirateNature=null
trigger gg_trg_CepMolni=null
trigger gg_trg_Shtorm=null
trigger gg_trg_Razmnojenie=null
trigger gg_trg_PortalInDalaran=null
trigger gg_trg_MagicGnev=null
trigger gg_trg_GodDefense2=null
trigger gg_trg_GodDefense1=null
trigger gg_trg_KydesnikLib=null
trigger gg_trg_Astral=null
trigger gg_trg_Transfer=null
trigger gg_trg_Gust=null
trigger gg_trg_FrostyInspiration=null
trigger gg_trg_ThreeElements=null
trigger gg_trg_Arson=null
trigger gg_trg_Monsoon=null
trigger gg_trg_Flash=null
trigger gg_trg_IceFront=null
trigger gg_trg_Sunstrike=null
trigger gg_trg_InvokerLib=null
trigger gg_trg_ElectroStrike=null
trigger gg_trg_Clap=null
trigger gg_trg_MountainPower=null
trigger gg_trg_RuneShield=null
trigger gg_trg_StormBolt=null
trigger gg_trg_RocksInMe=null
trigger gg_trg_WarStomp=null
trigger gg_trg_RatUp=null
trigger gg_trg_CursedSeno=null
trigger gg_trg_GuardSouls=null
trigger gg_trg_HealCircle=null
trigger gg_trg_Portals=null
trigger gg_trg_KokonSpawn=null
trigger gg_trg_Ultralish=null
trigger gg_trg_Kor_Kokon=null
trigger gg_trg_Evolution=null
trigger gg_trg_Zabitoe=null
trigger gg_trg_OldMosh=null
trigger gg_trg_LifeObmen=null
trigger gg_trg_Kartech=null
trigger gg_trg_Pricel=null
trigger gg_trg_PricelSet=null
trigger gg_trg_Myshketi=null
trigger gg_trg_MagicFire=null
trigger gg_trg_MagicShield=null
trigger gg_trg_ShieldDoblesti=null
trigger gg_trg_GreenKrest=null
trigger gg_trg_GiveAbility=null
trigger gg_trg_BadWave=null
trigger gg_trg_Boomerang=null
trigger gg_trg_RagePotion=null
trigger gg_trg_KoldAura=null
trigger gg_trg_HealWave=null
trigger gg_trg_Stomp=null
trigger gg_trg_Mylgor=null
trigger gg_trg_Vozmezdie=null
trigger gg_trg_PowerWave=null
trigger gg_trg_Potomstvo2=null
trigger gg_trg_Potomstvo=null
trigger gg_trg_XarchaSet=null
trigger gg_trg_Xarcha=null
trigger gg_trg_Eat=null
trigger gg_trg_HeroKiller=null
trigger gg_trg_Illusions=null
trigger gg_trg_SHTORM=null
trigger gg_trg_TotemCommander=null
trigger gg_trg_Zap=null
trigger gg_trg_SupremeShaman=null
trigger gg_trg_Hex=null
trigger gg_trg_Heroizm=null
trigger gg_trg_Parasites=null
trigger gg_trg_Mogilnik=null
trigger gg_trg_PancirWithSpikes=null
trigger gg_trg_Impale=null
trigger gg_trg_Frostmorne=null
trigger gg_trg_DarkArm=null
trigger gg_trg_FrostMorne=null
trigger gg_trg_YarostPleti=null
trigger gg_trg_DarkMagic=null
trigger gg_trg_DarkStrike=null
trigger gg_trg_Morozilko=null
trigger gg_trg_HellWrath=null
trigger gg_trg_DarkFire=null
trigger gg_trg_TombleStone=null
trigger gg_trg_BlackArrows=null
trigger gg_trg_Charm=null
trigger gg_trg_DarkRevenge=null
trigger gg_trg_PowerOtreks=null
trigger gg_trg_PrisonOnWheels=null
trigger gg_trg_Starfall=null
trigger gg_trg_SharpBlade=null
trigger gg_trg_PoisonSwords=null
trigger gg_trg_AstralArmor=null
trigger gg_trg_NaturePower=null
trigger gg_trg_MagicSnaryads=null
trigger gg_trg_Vozmezide=null
trigger gg_trg_SpiritFire=null
trigger gg_trg_DyxPower=null
trigger gg_trg_WrathOfNature=null
trigger gg_trg_WillOfNature=null
trigger gg_trg_PowerOfNature=null
trigger gg_trg_TreeSilence=null
trigger gg_trg_KornSystema=null
trigger gg_trg_SeaHope=null
trigger gg_trg_GromKleshnya=null
trigger gg_trg_Fenix=null
trigger gg_trg_FireRain=null
trigger gg_trg_FenixFly=null
trigger gg_trg_KladbisheCreate=null
trigger gg_trg_Kladbishe=null
trigger gg_trg_LedyanayaScorb=null
trigger gg_trg_KyltProklyatix=null
trigger gg_trg_DeathCoil=null
trigger gg_trg_CursedPrince=null
trigger gg_trg_DarkLight=null
trigger gg_trg_SaberOfSeas=null
trigger gg_trg_PirateNatureHero=null
trigger gg_trg_SheepKaptain=null
trigger gg_trg_SheepKaptainDmg=null
trigger gg_trg_SheepKaptainDye=null
trigger gg_trg_GnevMorey=null
trigger gg_trg_Korsars=null
trigger gg_trg_WonderfulFlow=null
trigger gg_trg_DalaranPortal=null
trigger gg_trg_MagicDospex=null
trigger gg_trg_GreatSummon=null
trigger gg_trg_Altar=null
trigger gg_trg_HolyArmor=null
trigger gg_trg_HolyLight=null
trigger gg_trg_CastEvent=null
trigger gg_trg_Holodomor=null
trigger gg_trg_Tranquility=null
trigger gg_trg_DictatorshipOfProletariat=null
trigger gg_trg_BurdenOfDarkness=null
trigger gg_trg_Pentagram=null
trigger gg_trg_AttackOnTitan=null
trigger gg_trg_Opolchenie=null
trigger gg_trg_Marshal=null
trigger gg_trg_ITEM_BUG=null
trigger gg_trg_ClondikeItemovv=null
trigger gg_trg_GoldHordeIncome=null
trigger gg_trg_PussyLick=null
trigger gg_trg_Illusia_Eblana=null
trigger gg_trg_Kapital=null
trigger gg_trg_BlockTalants=null
trigger gg_trg_Talants=null
trigger gg_trg_ChangePages=null
trigger gg_trg_PAGES=null
trigger gg_trg_Race=null
trigger gg_trg_Limit=null
trigger gg_trg_DalaranTowers=null
trigger gg_trg_MineInvul=null
trigger gg_trg_Mine=null
trigger gg_trg_GoldMine=null
trigger gg_trg_GradesScore=null
trigger gg_trg_PowerCounter=null
trigger gg_trg_Time=null
trigger gg_trg_TableCreate=null
trigger gg_trg_BlockAbilities=null
trigger gg_trg_CastleUltimateUnlock=null
trigger gg_trg_UnitPreload=null
trigger gg_trg_ITEM_CD=null
trigger gg_trg_TACTIC_SPAWN=null
trigger gg_trg_DamageTaken=null
trigger gg_trg_DamageTaken_____________________u=null
trigger gg_trg_UNITS_ON_MAP=null
trigger gg_trg_UNITS_ENTER_MAP=null
trigger gg_trg_Discord=null
trigger gg_trg_SS=null
trigger gg_trg_HeroGrade=null
trigger gg_trg_TimeGrade=null
trigger gg_trg_Xp=null
trigger gg_trg_Gold=null
trigger gg_trg_UnitDye=null
trigger gg_trg_HeroRes=null
trigger gg_trg_Cam=null
trigger gg_trg_Tooltip=null
trigger gg_trg_ItemCollect=null
trigger gg_trg___________________________u=null
trigger gg_trg_Hat=null
unit gg_unit_h001_0020=null
unit gg_unit_h001_0017=null
unit gg_unit_h001_0018=null
unit gg_unit_h001_0019=null
unit gg_unit_h001_0056=null
unit gg_unit_h001_0041=null
unit gg_unit_n01K_0012=null
unit gg_unit_n01K_0013=null
unit gg_unit_h02V_0072=null
unit gg_unit_h02V_0075=null
unit gg_unit_h02V_0074=null
unit gg_unit_h02V_0073=null
unit gg_unit_h02V_0065=null
unit gg_unit_h02V_0066=null
integer array PlayerPower
trigger l__library_init
constant integer si__InvokerSpells_st=1
integer si__InvokerSpells_st_F=0
integer si__InvokerSpells_st_I=0
integer array si__InvokerSpells_st_V
unit array s__InvokerSpells_st_caster
integer array s__InvokerSpells_st_index
integer array s___InvokerSpells_st_Abil
constant integer s___InvokerSpells_st_Abil_size=2
integer array s__InvokerSpells_st_Abil
constant integer si__InvokerSpheres_st=3
integer si__InvokerSpheres_st_F=0
integer si__InvokerSpheres_st_I=0
integer array si__InvokerSpheres_st_V
unit array s__InvokerSpheres_st_caster
integer array s__InvokerSpheres_st_index
string array s___InvokerSpheres_st_Sphere
constant integer s___InvokerSpheres_st_Sphere_size=3
integer array s__InvokerSpheres_st_Sphere
effect array s___InvokerSpheres_st_Effect
constant integer s___InvokerSpheres_st_Effect_size=3
integer array s__InvokerSpheres_st_Effect
integer array s___InvokerSpheres_st_Buff
constant integer s___InvokerSpheres_st_Buff_size=3
integer array s__InvokerSpheres_st_Buff
string array s___InvokerSpheres_st_buffEffect
constant integer s___InvokerSpheres_st_buffEffect_size=3
integer array s__InvokerSpheres_st_buffEffect
constant integer si__PeriodicDamage__Damager=8
integer si__PeriodicDamage__Damager_F=0
integer si__PeriodicDamage__Damager_I=0
integer array si__PeriodicDamage__Damager_V
string array s__PeriodicDamage__Damager_Type
integer array s__PeriodicDamage__Damager_movementAbil
unit array s__PeriodicDamage__Damager_caster
unit array s__PeriodicDamage__Damager_target
effect array s__PeriodicDamage__Damager_eff
real array s__PeriodicDamage__Damager_periodic
real array s__PeriodicDamage__Damager_damage
real array s__PeriodicDamage__Damager_time
constant integer si__AbilityLib___TimedAbility_st=9
integer si__AbilityLib___TimedAbility_st_F=0
integer si__AbilityLib___TimedAbility_st_I=0
integer array si__AbilityLib___TimedAbility_st_V
unit array s__AbilityLib___TimedAbility_st_target
real array s__AbilityLib___TimedAbility_st_time
integer array s__AbilityLib___TimedAbility_st_id
constant integer si__AbilityLib___AbilityCooldown_st=10
integer si__AbilityLib___AbilityCooldown_st_F=0
integer si__AbilityLib___AbilityCooldown_st_I=0
integer array si__AbilityLib___AbilityCooldown_st_V
unit array s__AbilityLib___AbilityCooldown_st_target
integer array s__AbilityLib___AbilityCooldown_st_id
constant integer si__Controler=11
integer si__Controler_F=0
integer si__Controler_I=0
integer array si__Controler_V
integer array s__Controler_ownerID
unit array s__Controler_caster
unit array s__Controler_target
effect array s__Controler_eff
constant integer si__EffectsLib__TimedRoundedEffectTarget_st=12
integer si__EffectsLib__TimedRoundedEffectTarget_st_F=0
integer si__EffectsLib__TimedRoundedEffectTarget_st_I=0
integer array si__EffectsLib__TimedRoundedEffectTarget_st_V
unit array s__EffectsLib__TimedRoundedEffectTarget_st_target
effect array s__EffectsLib__TimedRoundedEffectTarget_st_eff
real array s__EffectsLib__TimedRoundedEffectTarget_st_periodic
real array s__EffectsLib__TimedRoundedEffectTarget_st_height
real array s__EffectsLib__TimedRoundedEffectTarget_st_speed
real array s__EffectsLib__TimedRoundedEffectTarget_st_range
real array s__EffectsLib__TimedRoundedEffectTarget_st_angle
real array s__EffectsLib__TimedRoundedEffectTarget_st_time
constant integer si__EffectsLib__TimedEffectTarget_st=13
integer si__EffectsLib__TimedEffectTarget_st_F=0
integer si__EffectsLib__TimedEffectTarget_st_I=0
integer array si__EffectsLib__TimedEffectTarget_st_V
unit array s__EffectsLib__TimedEffectTarget_st_target
effect array s__EffectsLib__TimedEffectTarget_st_eff
real array s__EffectsLib__TimedEffectTarget_st_time
real array s__EffectsLib__TimedEffectTarget_st_periodic
constant integer si__EffectsLib__TimedEffect_st=14
integer si__EffectsLib__TimedEffect_st_F=0
integer si__EffectsLib__TimedEffect_st_I=0
integer array si__EffectsLib__TimedEffect_st_V
effect array s__EffectsLib__TimedEffect_st_eff
constant integer si__EffectsLib__DestroyLightningN_st=15
integer si__EffectsLib__DestroyLightningN_st_F=0
integer si__EffectsLib__DestroyLightningN_st_I=0
integer array si__EffectsLib__DestroyLightningN_st_V
lightning array s__EffectsLib__DestroyLightningN_st_light
integer array s__EffectsLib__DestroyLightningN_st_percent
real array s__EffectsLib__DestroyLightningN_st_periodic
constant integer si__EffectsLib__TimedRageEffectDestroy_st=16
integer si__EffectsLib__TimedRageEffectDestroy_st_F=0
integer si__EffectsLib__TimedRageEffectDestroy_st_I=0
integer array si__EffectsLib__TimedRageEffectDestroy_st_V
unit array s__EffectsLib__TimedRageEffectDestroy_st_target
real array s__EffectsLib__TimedRageEffectDestroy_st_changeTime
real array s__EffectsLib__TimedRageEffectDestroy_st_time
constant integer si__EffectsLib__TimedRageEffect_st=17
integer si__EffectsLib__TimedRageEffect_st_F=0
integer si__EffectsLib__TimedRageEffect_st_I=0
integer array si__EffectsLib__TimedRageEffect_st_V
unit array s__EffectsLib__TimedRageEffect_st_target
integer array s__EffectsLib__TimedRageEffect_st_percent
real array s__EffectsLib__TimedRageEffect_st_periodic
constant integer si__KydesnikLib__Portals_st=18
integer si__KydesnikLib__Portals_st_F=0
integer si__KydesnikLib__Portals_st_I=0
integer array si__KydesnikLib__Portals_st_V
integer array s___KydesnikLib__Portals_st_unitID
constant integer s___KydesnikLib__Portals_st_unitID_size=12
integer array s__KydesnikLib__Portals_st_unitID
unit array s___KydesnikLib__Portals_st_portal
constant integer s___KydesnikLib__Portals_st_portal_size=2
integer array s__KydesnikLib__Portals_st_portal
unit array s__KydesnikLib__Portals_st_caster
integer array s__KydesnikLib__Portals_st_index
integer array s__KydesnikLib__Portals_st_limit
unit array s__KydesnikLib__Portals_st_target
real array s__KydesnikLib__Portals_st_targetX
real array s__KydesnikLib__Portals_st_targetY
real array s__KydesnikLib__Portals_st_periodic
constant integer si__KydesnikLib__Summons_st=21
integer si__KydesnikLib__Summons_st_F=0
integer si__KydesnikLib__Summons_st_I=0
integer array si__KydesnikLib__Summons_st_V
integer array s___KydesnikLib__Summons_st_unitID
constant integer s___KydesnikLib__Summons_st_unitID_size=12
integer array s__KydesnikLib__Summons_st_unitID
integer array s__KydesnikLib__Summons_st_limit
integer array s__KydesnikLib__Summons_st_index
constant integer si__UnitSpawner_st=23
integer si__UnitSpawner_st_F=0
integer si__UnitSpawner_st_I=0
integer array si__UnitSpawner_st_V
unit array s__UnitSpawner_st_caster
integer array s__UnitSpawner_st_unitID
constant integer si__UnitLib__TimedInvul_st=24
integer si__UnitLib__TimedInvul_st_F=0
integer si__UnitLib__TimedInvul_st_I=0
integer array si__UnitLib__TimedInvul_st_V
unit array s__UnitLib__TimedInvul_st_target
constant integer si__UnitLib__TimedMpRegen_st=25
integer si__UnitLib__TimedMpRegen_st_F=0
integer si__UnitLib__TimedMpRegen_st_I=0
integer array si__UnitLib__TimedMpRegen_st_V
unit array s__UnitLib__TimedMpRegen_st_target
real array s__UnitLib__TimedMpRegen_st_regen
constant integer si__UnitLib__TimedHpRegen_st=26
integer si__UnitLib__TimedHpRegen_st_F=0
integer si__UnitLib__TimedHpRegen_st_I=0
integer array si__UnitLib__TimedHpRegen_st_V
unit array s__UnitLib__TimedHpRegen_st_target
real array s__UnitLib__TimedHpRegen_st_regen
constant integer si__UnitLib__TimedArmor_st=27
integer si__UnitLib__TimedArmor_st_F=0
integer si__UnitLib__TimedArmor_st_I=0
integer array si__UnitLib__TimedArmor_st_V
unit array s__UnitLib__TimedArmor_st_target
real array s__UnitLib__TimedArmor_st_armor
constant integer si__UnitLib__TimedDamage_st=28
integer si__UnitLib__TimedDamage_st_F=0
integer si__UnitLib__TimedDamage_st_I=0
integer array si__UnitLib__TimedDamage_st_V
unit array s__UnitLib__TimedDamage_st_target
integer array s__UnitLib__TimedDamage_st_damage
constant integer si__UnitLib__TimedPause_st=29
integer si__UnitLib__TimedPause_st_F=0
integer si__UnitLib__TimedPause_st_I=0
integer array si__UnitLib__TimedPause_st_V
unit array s__UnitLib__TimedPause_st_target
constant integer si__UnitLib__ReplaceAfterTime_st=30
integer si__UnitLib__ReplaceAfterTime_st_F=0
integer si__UnitLib__ReplaceAfterTime_st_I=0
integer array si__UnitLib__ReplaceAfterTime_st_V
unit array s__UnitLib__ReplaceAfterTime_st_target
integer array s__UnitLib__ReplaceAfterTime_st_id
constant integer si__UnitLib__OwnerAfterTime_st=31
integer si__UnitLib__OwnerAfterTime_st_F=0
integer si__UnitLib__OwnerAfterTime_st_I=0
integer array si__UnitLib__OwnerAfterTime_st_V
player array s__UnitLib__OwnerAfterTime_st_casterPlayer
unit array s__UnitLib__OwnerAfterTime_st_target
integer array s__UnitLib__OwnerAfterTime_st_id
constant integer si__HeroRespawnLib___HeroRespawn_st=32
integer si__HeroRespawnLib___HeroRespawn_st_F=0
integer si__HeroRespawnLib___HeroRespawn_st_I=0
integer array si__HeroRespawnLib___HeroRespawn_st_V
timer array s__HeroRespawnLib___HeroRespawn_st_t
timerdialog array s__HeroRespawnLib___HeroRespawn_st_td
unit array s__HeroRespawnLib___HeroRespawn_st_caster
unit array s__HeroRespawnLib___HeroRespawn_st_killer
real array s__HeroRespawnLib___HeroRespawn_st_time
real array s__HeroRespawnLib___HeroRespawn_st_x
real array s__HeroRespawnLib___HeroRespawn_st_y
constant integer si__MagicWand__MagicWandProjectile_st=33
integer si__MagicWand__MagicWandProjectile_st_F=0
integer si__MagicWand__MagicWandProjectile_st_I=0
integer array si__MagicWand__MagicWandProjectile_st_V
boolean array s__MagicWand__MagicWandProjectile_st_isNecro
effect array s__MagicWand__MagicWandProjectile_st_projectile
timer array s__MagicWand__MagicWandProjectile_st_Timer
unit array s__MagicWand__MagicWandProjectile_st_caster
real array s__MagicWand__MagicWandProjectile_st_checkRange
real array s__MagicWand__MagicWandProjectile_st_dmgRange
real array s__MagicWand__MagicWandProjectile_st_damage
real array s__MagicWand__MagicWandProjectile_st_distance
real array s__MagicWand__MagicWandProjectile_st_speed
real array s__MagicWand__MagicWandProjectile_st_angle
real array s__MagicWand__MagicWandProjectile_st_targetX
real array s__MagicWand__MagicWandProjectile_st_targetY
constant integer si__MagicWand__MagicWand_st=34
integer si__MagicWand__MagicWand_st_F=0
integer si__MagicWand__MagicWand_st_I=0
integer array si__MagicWand__MagicWand_st_V
boolean array s__MagicWand__MagicWand_st_isCollected
boolean array s__MagicWand__MagicWand_st_isNecro
timer array s__MagicWand__MagicWand_st_Timer
unit array s__MagicWand__MagicWand_st_caster
item array s__MagicWand__MagicWand_st_wand
integer array s__MagicWand__MagicWand_st_count
real array s__MagicWand__MagicWand_st_periodic
real array s__MagicWand__MagicWand_st_dmgRange
real array s__MagicWand__MagicWand_st_damage
real array s__MagicWand__MagicWand_st_range
constant integer si__RecipesLib__Recipe_st=35
integer si__RecipesLib__Recipe_st_F=0
integer si__RecipesLib__Recipe_st_I=0
integer array si__RecipesLib__Recipe_st_V
integer array s__RecipesLib__Recipe_st_collectedItem
integer array s___RecipesLib__Recipe_st_items
constant integer s___RecipesLib__Recipe_st_items_size=7
integer array s__RecipesLib__Recipe_st_items
constant integer si__SpellsLib__DamageWave_st=37
integer si__SpellsLib__DamageWave_st_F=0
integer si__SpellsLib__DamageWave_st_I=0
integer array si__SpellsLib__DamageWave_st_V
group array s__SpellsLib__DamageWave_st_damagedGroup
effect array s__SpellsLib__DamageWave_st_wave
timer array s__SpellsLib__DamageWave_st_t
unit array s__SpellsLib__DamageWave_st_caster
real array s__SpellsLib__DamageWave_st_distance
real array s__SpellsLib__DamageWave_st_damage
real array s__SpellsLib__DamageWave_st_range
real array s__SpellsLib__DamageWave_st_speed
real array s__SpellsLib__DamageWave_st_angle
constant integer si__Stun___Stun_st=38
integer si__Stun___Stun_st_F=0
integer si__Stun___Stun_st_I=0
integer array si__Stun___Stun_st_V
unit array s__Stun___Stun_st_caster
unit array s__Stun___Stun_st_target
effect array s__Stun___Stun_st_eff
real array s__Stun___Stun_st_time
constant integer si__Stun___Frost_st=39
integer si__Stun___Frost_st_F=0
integer si__Stun___Frost_st_I=0
integer array si__Stun___Frost_st_V
unit array s__Stun___Frost_st_target
effect array s__Stun___Frost_st_eff
constant integer si__Stun___Roots_st=40
integer si__Stun___Roots_st_F=0
integer si__Stun___Roots_st_I=0
integer array si__Stun___Roots_st_V
unit array s__Stun___Roots_st_caster
unit array s__Stun___Roots_st_target
effect array s__Stun___Roots_st_eff
real array s__Stun___Roots_st_periodic
real array s__Stun___Roots_st_damage
real array s__Stun___Roots_st_time
constant integer si__Stun___Parasites_st=41
integer si__Stun___Parasites_st_F=0
integer si__Stun___Parasites_st_I=0
integer array si__Stun___Parasites_st_V
unit array s__Stun___Parasites_st_caster
unit array s__Stun___Parasites_st_target
effect array s__Stun___Parasites_st_eff
real array s__Stun___Parasites_st_periodic
real array s__Stun___Parasites_st_damage
real array s__Stun___Parasites_st_time
constant integer si__WillOfNature_st=42
integer si__WillOfNature_st_F=0
integer si__WillOfNature_st_I=0
integer array si__WillOfNature_st_V
unit array s__WillOfNature_st_caster
integer array s__WillOfNature_st_count
real array s__WillOfNature_st_periodic
real array s__WillOfNature_st_x
real array s__WillOfNature_st_y
constant integer si__WillOfNatureProjectile_st=43
integer si__WillOfNatureProjectile_st_F=0
integer si__WillOfNatureProjectile_st_I=0
integer array si__WillOfNatureProjectile_st_V
group array s__WillOfNatureProjectile_st_picker
real array s__WillOfNatureProjectile_st_healCheckRange
real array s__WillOfNatureProjectile_st_spiritChance
integer array s__WillOfNatureProjectile_st_spiritID
real array s__WillOfNatureProjectile_st_healRange
real array s__WillOfNatureProjectile_st_maxDistance
unit array s__WillOfNatureProjectile_st_caster
unit array s__WillOfNatureProjectile_st_dummy
real array s__WillOfNatureProjectile_st_flySpeed
real array s__WillOfNatureProjectile_st_distance
real array s__WillOfNatureProjectile_st_heal
real array s__WillOfNatureProjectile_st_speed
real array s__WillOfNatureProjectile_st_range
real array s__WillOfNatureProjectile_st_stAngle
real array s__WillOfNatureProjectile_st_angle
constant integer si__Frostmorne_stpj=44
integer si__Frostmorne_stpj_F=0
integer si__Frostmorne_stpj_I=0
integer array si__Frostmorne_stpj_V
effect array s__Frostmorne_stpj_eff
timer array s__Frostmorne_stpj_t
boolean array s__Frostmorne_stpj_isLaunched
real array s__Frostmorne_stpj_periodic
unit array s__Frostmorne_stpj_caster
unit array s__Frostmorne_stpj_target
integer array s__Frostmorne_stpj_lvl
real array s__Frostmorne_stpj_speed
real array s__Frostmorne_stpj_angle
real array s__Frostmorne_stpj_damage
real array s__Frostmorne_stpj_frostTime
constant integer si__Frostmorne_st=45
integer si__Frostmorne_st_F=0
integer si__Frostmorne_st_I=0
integer array si__Frostmorne_st_V
integer array s___Frostmorne_st_projectiles
constant integer s___Frostmorne_st_projectiles_size=8
integer array s__Frostmorne_st_projectiles
group array s__Frostmorne_st_g
timer array s__Frostmorne_st_t
real array s__Frostmorne_st_periodic
real array s__Frostmorne_st_offset
real array s__Frostmorne_st_range
unit array s__Frostmorne_st_caster
integer array s__Frostmorne_st_count
integer array s__Frostmorne_st_lvl
real array s__Frostmorne_st_speed
constant integer si__Frostmorne_strl=47
integer si__Frostmorne_strl_F=0
integer si__Frostmorne_strl_I=0
integer array si__Frostmorne_strl_V
integer array s__Frostmorne_strl_fm
timer array s__Frostmorne_strl_t
real array s__Frostmorne_strl_time
integer array s__Frostmorne_strl_index
constant integer si__Move___Jump=48
integer si__Move___Jump_F=0
integer si__Move___Jump_I=0
integer array si__Move___Jump_V
boolean array s__Move___Jump_isPaused
timer array s__Move___Jump_Timer
unit array s__Move___Jump_target
real array s__Move___Jump_totalCount
real array s__Move___Jump_stunTime
real array s__Move___Jump_periodic
real array s__Move___Jump_height
real array s__Move___Jump_speed
constant integer si__BadWave__BadWave_st=49
integer si__BadWave__BadWave_st_F=0
integer si__BadWave__BadWave_st_I=0
integer array si__BadWave__BadWave_st_V
group array s__BadWave__BadWave_st_damagedGroup
boolean array s__BadWave__BadWave_st_isFirst
lightning array s__BadWave__BadWave_st_wave
real array s__BadWave__BadWave_st_damageDebuff
timer array s__BadWave__BadWave_st_Timer
unit array s__BadWave__BadWave_st_caster
unit array s__BadWave__BadWave_st_target
integer array s__BadWave__BadWave_st_count
real array s__BadWave__BadWave_st_damage
real array s__BadWave__BadWave_st_range
constant integer si__DarkRevenge_st=50
integer si__DarkRevenge_st_F=0
integer si__DarkRevenge_st_I=0
integer array si__DarkRevenge_st_V
unit array s__DarkRevenge_st_caster
integer array s__DarkRevenge_st_count
real array s__DarkRevenge_st_periodic
real array s__DarkRevenge_st_x
real array s__DarkRevenge_st_y
constant integer si__DarkRevengeProjectile_st=51
integer si__DarkRevengeProjectile_st_F=0
integer si__DarkRevengeProjectile_st_I=0
integer array si__DarkRevengeProjectile_st_V
group array s__DarkRevengeProjectile_st_picker
real array s__DarkRevengeProjectile_st_dmgCheckRange
real array s__DarkRevengeProjectile_st_maxDistance
unit array s__DarkRevengeProjectile_st_caster
unit array s__DarkRevengeProjectile_st_dummy
real array s__DarkRevengeProjectile_st_flySpeed
real array s__DarkRevengeProjectile_st_distance
real array s__DarkRevengeProjectile_st_damage
real array s__DarkRevengeProjectile_st_speed
real array s__DarkRevengeProjectile_st_range
real array s__DarkRevengeProjectile_st_stAngle
real array s__DarkRevengeProjectile_st_angle
constant integer si__FireRain_st=52
integer si__FireRain_st_F=0
integer si__FireRain_st_I=0
integer array si__FireRain_st_V
unit array s__FireRain_st_caster
integer array s__FireRain_st_count
real array s__FireRain_st_periodic
real array s__FireRain_st_x
real array s__FireRain_st_y
constant integer si__FireRainProjectile_st=53
integer si__FireRainProjectile_st_F=0
integer si__FireRainProjectile_st_I=0
integer array si__FireRainProjectile_st_V
group array s__FireRainProjectile_st_picker
real array s__FireRainProjectile_st_dmgCheckRange
real array s__FireRainProjectile_st_dmgRange
real array s__FireRainProjectile_st_maxDistance
unit array s__FireRainProjectile_st_caster
unit array s__FireRainProjectile_st_dummy
real array s__FireRainProjectile_st_flySpeed
real array s__FireRainProjectile_st_distance
real array s__FireRainProjectile_st_damage
real array s__FireRainProjectile_st_speed
real array s__FireRainProjectile_st_range
real array s__FireRainProjectile_st_stAngle
real array s__FireRainProjectile_st_angle
constant integer si__HealWave__HealWave_st=54
integer si__HealWave__HealWave_st_F=0
integer si__HealWave__HealWave_st_I=0
integer array si__HealWave__HealWave_st_V
group array s__HealWave__HealWave_st_healedGroup
boolean array s__HealWave__HealWave_st_isFirst
lightning array s__HealWave__HealWave_st_wave
real array s__HealWave__HealWave_st_healDebuff
timer array s__HealWave__HealWave_st_Timer
unit array s__HealWave__HealWave_st_caster
unit array s__HealWave__HealWave_st_target
integer array s__HealWave__HealWave_st_count
real array s__HealWave__HealWave_st_range
real array s__HealWave__HealWave_st_heal
constant integer si__Illusions___Illusions_st=55
integer si__Illusions___Illusions_st_F=0
integer si__Illusions___Illusions_st_I=0
integer array si__Illusions___Illusions_st_V
group array s__Illusions___Illusions_st_illusions
unit array s__Illusions___Illusions_st_caster
constant integer si__PowerWave__PowerWave_st=56
integer si__PowerWave__PowerWave_st_F=0
integer si__PowerWave__PowerWave_st_I=0
integer array si__PowerWave__PowerWave_st_V
group array s__PowerWave__PowerWave_st_damagedGroup
effect array s__PowerWave__PowerWave_st_wave
timer array s__PowerWave__PowerWave_st_t
unit array s__PowerWave__PowerWave_st_caster
real array s__PowerWave__PowerWave_st_distance
real array s__PowerWave__PowerWave_st_damage
real array s__PowerWave__PowerWave_st_range
real array s__PowerWave__PowerWave_st_speed
real array s__PowerWave__PowerWave_st_angle
constant integer si__SpawnLib__Spawn_st=57
integer si__SpawnLib__Spawn_st_F=0
integer si__SpawnLib__Spawn_st_I=0
integer array si__SpawnLib__Spawn_st_V
texttag array s__SpawnLib__Spawn_st_tt
timer array s__SpawnLib__Spawn_st_t
real array s__SpawnLib__Spawn_st_periodic
real array s__SpawnLib__Spawn_st_time
integer array s__SpawnLib__Spawn_st_index
unit array s__SpawnLib__Spawn_st_castle
real array s__SpawnLib__Spawn_st_x
real array s__SpawnLib__Spawn_st_y
constant integer si__StompLib__StompFly_st=58
integer si__StompLib__StompFly_st_F=0
integer si__StompLib__StompFly_st_I=0
integer array si__StompLib__StompFly_st_V
boolean array s__StompLib__StompFly_st_isPaused
timer array s__StompLib__StompFly_st_Timer
unit array s__StompLib__StompFly_st_caster
unit array s__StompLib__StompFly_st_target
real array s__StompLib__StompFly_st_maxDistance
real array s__StompLib__StompFly_st_stunTime
real array s__StompLib__StompFly_st_periodic
real array s__StompLib__StompFly_st_distance
real array s__StompLib__StompFly_st_damage
real array s__StompLib__StompFly_st_speed
real array s__StompLib__StompFly_st_angle
constant integer si__WonderfulFlow__WonderfulFlow_st=59
integer si__WonderfulFlow__WonderfulFlow_st_F=0
integer si__WonderfulFlow__WonderfulFlow_st_I=0
hashtable Hash = InitHashtable()
integer array si__WonderfulFlow__WonderfulFlow_st_V
effect array s__WonderfulFlow__WonderfulFlow_st_eff
unit array s__WonderfulFlow__WonderfulFlow_st_caster
real array s__WonderfulFlow__WonderfulFlow_st_range
real array s__WonderfulFlow__WonderfulFlow_st_damage
real array s__WonderfulFlow__WonderfulFlow_st_scale
real array s__WonderfulFlow__WonderfulFlow_st_x
real array s__WonderfulFlow__WonderfulFlow_st_y
constant integer si__cursedAI___UnitAI=60
integer si__cursedAI___UnitAI_F=0
integer si__cursedAI___UnitAI_I=0
integer array si__cursedAI___UnitAI_V
boolean array s__cursedAI___UnitAI_isWaitForHp
boolean array s__cursedAI___UnitAI_isDefended
boolean array s__cursedAI___UnitAI_isDefend
unit array s__cursedAI___UnitAI_target
constant integer si__StormHummer_st=61
integer si__StormHummer_st_F=0
integer si__StormHummer_st_I=0
integer array si__StormHummer_st_V
effect array s__StormHummer_st_aroundEff
group array s__StormHummer_st_g
unit array s__StormHummer_st_caster
real array s__StormHummer_st_periodic
real array s__StormHummer_st_damage
real array s__StormHummer_st_range
real array s__StormHummer_st_stun
real array s__StormHummer_st_count
real array s__StormHummer_st_x
real array s__StormHummer_st_y
constant integer si__Transfer_st=62
integer si__Transfer_st_F=0
integer si__Transfer_st_I=0
integer array si__Transfer_st_V
lightning array s__Transfer_st_link
unit array s__Transfer_st_caster
unit array s__Transfer_st_target
real array s__Transfer_st_mPeriodic
real array s__Transfer_st_cPeriodic
real array s__Transfer_st_periodic
real array s__Transfer_st_time
real array s__Transfer_st_hp
real array s__Transfer_st_mp
constant integer si__Gust_st=63
integer si__Gust_st_F=0
integer si__Gust_st_I=0
integer array si__Gust_st_V
unit array s__Gust_st_target
real array s__Gust_st_totalDist
real array s__Gust_st_periodic
real array s__Gust_st_distance
real array s__Gust_st_speed
real array s__Gust_st_angle
constant integer si__Monsoon_st=64
integer si__Monsoon_st_F=0
integer si__Monsoon_st_I=0
integer array si__Monsoon_st_V
effect array s__Monsoon_st_aroundEff
unit array s__Monsoon_st_caster
real array s__Monsoon_st_periodic
real array s__Monsoon_st_damage
real array s__Monsoon_st_range
real array s__Monsoon_st_time
real array s__Monsoon_st_x
real array s__Monsoon_st_y
constant integer si__ElectroStrike_st=65
integer si__ElectroStrike_st_F=0
integer si__ElectroStrike_st_I=0
integer array si__ElectroStrike_st_V
unit array s__ElectroStrike_st_caster
unit array s__ElectroStrike_st_dummy
real array s__ElectroStrike_st_dmgRange
real array s__ElectroStrike_st_distance
real array s__ElectroStrike_st_damage
real array s__ElectroStrike_st_speed
constant integer si__ElectroStrikeLaunch_st=66
integer si__ElectroStrikeLaunch_st_F=0
integer si__ElectroStrikeLaunch_st_I=0
integer array si__ElectroStrikeLaunch_st_V
real array s__ElectroStrikeLaunch_st_offsetAngle
unit array s__ElectroStrikeLaunch_st_caster
real array s__ElectroStrikeLaunch_st_offset
real array s__ElectroStrikeLaunch_st_angle
real array s__ElectroStrikeLaunch_st_damage
constant integer si__StormBolt_st=67
integer si__StormBolt_st_F=0
integer si__StormBolt_st_I=0
integer array si__StormBolt_st_V
unit array s__StormBolt_st_caster
unit array s__StormBolt_st_target
unit array s__StormBolt_st_dummy
real array s__StormBolt_st_range
real array s__StormBolt_st_damage
real array s__StormBolt_st_stun
integer array s__StormBolt_st_lvl
constant integer si__RocksInMe_st=68
integer si__RocksInMe_st_F=0
integer si__RocksInMe_st_I=0
integer array si__RocksInMe_st_V
unit array s__RocksInMe_st_caster
effect array s__RocksInMe_st_dummy
real array s__RocksInMe_st_dmgRange
real array s__RocksInMe_st_distance
real array s__RocksInMe_st_maxDistance
real array s__RocksInMe_st_damage
real array s__RocksInMe_st_speed
constant integer si__RocksInMeLaunch_st=69
integer si__RocksInMeLaunch_st_F=0
integer si__RocksInMeLaunch_st_I=0
integer array si__RocksInMeLaunch_st_V
unit array s__RocksInMeLaunch_st_caster
real array s__RocksInMeLaunch_st_damage
integer array s__RocksInMeLaunch_st_count
constant integer si__LifeObmen_st=70
integer si__LifeObmen_st_F=0
integer si__LifeObmen_st_I=0
integer array si__LifeObmen_st_V
timer array s__LifeObmen_st_Timer
texttag array s__LifeObmen_st_ttCaster
texttag array s__LifeObmen_st_ttTarget
lightning array s__LifeObmen_st_light
string array s__LifeObmen_st_linkType
unit array s__LifeObmen_st_caster
unit array s__LifeObmen_st_target
real array s__LifeObmen_st_maxDistance
real array s__LifeObmen_st_periodic
real array s__LifeObmen_st_time
constant integer si__Parasites_projectile_st=71
integer si__Parasites_projectile_st_F=0
integer si__Parasites_projectile_st_I=0
integer array si__Parasites_projectile_st_V
unit array s__Parasites_projectile_st_caster
unit array s__Parasites_projectile_st_target
timer array s__Parasites_projectile_st_Timer
effect array s__Parasites_projectile_st_eff
integer array s__Parasites_projectile_st_lvl
real array s__Parasites_projectile_st_speed
constant integer si__Impale=72
integer si__Impale_F=0
integer si__Impale_I=0
integer array si__Impale_V
unit array s__Impale_caster
timer array s__Impale_Timer
real array s__Impale_stunTime
real array s__Impale_periodic
group array s__Impale_targetGroup
real array s__Impale_damageRange
integer array s__Impale_count
real array s__Impale_damage
real array s__Impale_angle
real array s__Impale_range
real array s__Impale_step
real array s__Impale_x
real array s__Impale_y
constant integer si__DarkArmy_st=73
integer si__DarkArmy_st_F=0
integer si__DarkArmy_st_I=0
integer array si__DarkArmy_st_V
real array s__DarkArmy_st_zombieChance
real array s__DarkArmy_st_pudgeChance
unit array s__DarkArmy_st_caster
effect array s__DarkArmy_st_eff
real array s__DarkArmy_st_periodic
real array s__DarkArmy_st_range
real array s__DarkArmy_st_time
constant integer si__Exgumation_st=74
integer si__Exgumation_st_F=0
integer si__Exgumation_st_I=0
integer array si__Exgumation_st_V
unit array s__Exgumation_st_caster
integer array s__Exgumation_st_count
real array s__Exgumation_st_periodic
real array s__Exgumation_st_range
constant integer si__HellWrathCast_st=75
integer si__HellWrathCast_st_F=0
integer si__HellWrathCast_st_I=0
integer array si__HellWrathCast_st_V
unit array s__HellWrathCast_st_caster
integer array s__HellWrathCast_st_count
real array s__HellWrathCast_st_range
real array s__HellWrathCast_st_x
real array s__HellWrathCast_st_y
constant integer si__HellWrath_st=76
integer si__HellWrath_st_F=0
integer si__HellWrath_st_I=0
integer array si__HellWrath_st_V
real array s__HellWrath_st_summonDamage
real array s__HellWrath_st_structDamage
unit array s__HellWrath_st_dummy
unit array s__HellWrath_st_caster
real array s__HellWrath_st_periodic
real array s__HellWrath_st_damage
real array s__HellWrath_st_range
real array s__HellWrath_st_time
real array s__HellWrath_st_x
real array s__HellWrath_st_y
constant integer si__DarkFire_st=77
integer si__DarkFire_st_F=0
integer si__DarkFire_st_I=0
integer array si__DarkFire_st_V
real array s__DarkFire_st_targetDamage
real array s__DarkFire_st_structDamage
real array s__DarkFire_st_summonDamage
unit array s__DarkFire_st_dummy
unit array s__DarkFire_st_caster
unit array s__DarkFire_st_target
real array s__DarkFire_st_periodic
real array s__DarkFire_st_damage
real array s__DarkFire_st_range
real array s__DarkFire_st_time
real array s__DarkFire_st_x
real array s__DarkFire_st_y
constant integer si__SpiritFire_st=78
integer si__SpiritFire_st_F=0
integer si__SpiritFire_st_I=0
integer array si__SpiritFire_st_V
real array s__SpiritFire_st_structDamage
unit array s__SpiritFire_st_caster
unit array s__SpiritFire_st_dummy
integer array s__SpiritFire_st_spiritID
real array s__SpiritFire_st_periodic
real array s__SpiritFire_st_damage
real array s__SpiritFire_st_range
real array s__SpiritFire_st_time
real array s__SpiritFire_st_x
real array s__SpiritFire_st_y
constant integer si__SeaHope_st=79
integer si__SeaHope_st_F=0
integer si__SeaHope_st_I=0
integer array si__SeaHope_st_V
unit array s__SeaHope_st_caster
effect array s__SeaHope_st_eff
integer array s__SeaHope_st_abil
constant integer si__FenixFly_st=80
integer si__FenixFly_st_F=0
integer si__FenixFly_st_I=0
integer array si__FenixFly_st_V
real array s__FenixFly_st_maxDistance
unit array s__FenixFly_st_caster
unit array s__FenixFly_st_dummy
real array s__FenixFly_st_distance
real array s__FenixFly_st_periodic
real array s__FenixFly_st_speed
endglobals
native MergeUnits takes integer qty,integer a,integer b,integer make returns boolean
native ConvertUnits takes integer qty,integer id returns boolean
native IgnoredUnits takes integer unitid returns integer
native GetUnitGoldCost takes integer unitid returns integer
native GetUnitWoodCost takes integer unitid returns integer
function s__InvokerSpells_st__allocate takes nothing returns integer
local integer this=si__InvokerSpells_st_F
if(this!=0)then
set si__InvokerSpells_st_F=si__InvokerSpells_st_V[this]
else
set si__InvokerSpells_st_I=si__InvokerSpells_st_I+1
set this=si__InvokerSpells_st_I
endif
if(this>4094)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: InvokerSpells_st")
return 0
endif
set s__InvokerSpells_st_Abil[this]=(this-1)*2
set s__InvokerSpells_st_caster[this]=null
set s__InvokerSpells_st_index[this]=1
set si__InvokerSpells_st_V[this]=-1
return this
endfunction
function s__InvokerSpells_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: InvokerSpells_st")
return
elseif(si__InvokerSpells_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: InvokerSpells_st")
return
endif
set si__InvokerSpells_st_V[this]=si__InvokerSpells_st_F
set si__InvokerSpells_st_F=this
endfunction
function s__FenixFly_st__allocate takes nothing returns integer
local integer this=si__FenixFly_st_F
if(this!=0)then
set si__FenixFly_st_F=si__FenixFly_st_V[this]
else
set si__FenixFly_st_I=si__FenixFly_st_I+1
set this=si__FenixFly_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: FenixFly_st")
return 0
endif
set s__FenixFly_st_maxDistance[this]=0.
set s__FenixFly_st_caster[this]=null
set s__FenixFly_st_dummy[this]=null
set s__FenixFly_st_distance[this]=0.
set s__FenixFly_st_periodic[this]=0.
set s__FenixFly_st_speed[this]=0.
set si__FenixFly_st_V[this]=-1
return this
endfunction
function s__FenixFly_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: FenixFly_st")
return
elseif(si__FenixFly_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: FenixFly_st")
return
endif
set si__FenixFly_st_V[this]=si__FenixFly_st_F
set si__FenixFly_st_F=this
endfunction
function s__SeaHope_st__allocate takes nothing returns integer
local integer this=si__SeaHope_st_F
if(this!=0)then
set si__SeaHope_st_F=si__SeaHope_st_V[this]
else
set si__SeaHope_st_I=si__SeaHope_st_I+1
set this=si__SeaHope_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: SeaHope_st")
return 0
endif
set s__SeaHope_st_caster[this]=null
set s__SeaHope_st_eff[this]=null
set s__SeaHope_st_abil[this]=0
set si__SeaHope_st_V[this]=-1
return this
endfunction
function s__SeaHope_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: SeaHope_st")
return
elseif(si__SeaHope_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: SeaHope_st")
return
endif
set si__SeaHope_st_V[this]=si__SeaHope_st_F
set si__SeaHope_st_F=this
endfunction
function s__SpiritFire_st__allocate takes nothing returns integer
local integer this=si__SpiritFire_st_F
if(this!=0)then
set si__SpiritFire_st_F=si__SpiritFire_st_V[this]
else
set si__SpiritFire_st_I=si__SpiritFire_st_I+1
set this=si__SpiritFire_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: SpiritFire_st")
return 0
endif
set s__SpiritFire_st_structDamage[this]=0.
set s__SpiritFire_st_caster[this]=null
set s__SpiritFire_st_dummy[this]=null
set s__SpiritFire_st_spiritID[this]=0
set s__SpiritFire_st_periodic[this]=0.
set s__SpiritFire_st_damage[this]=0.
set s__SpiritFire_st_range[this]=0.
set s__SpiritFire_st_time[this]=0.
set s__SpiritFire_st_x[this]=0.
set s__SpiritFire_st_y[this]=0.
set si__SpiritFire_st_V[this]=-1
return this
endfunction
function s__SpiritFire_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: SpiritFire_st")
return
elseif(si__SpiritFire_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: SpiritFire_st")
return
endif
set si__SpiritFire_st_V[this]=si__SpiritFire_st_F
set si__SpiritFire_st_F=this
endfunction
function s__DarkFire_st__allocate takes nothing returns integer
local integer this=si__DarkFire_st_F
if(this!=0)then
set si__DarkFire_st_F=si__DarkFire_st_V[this]
else
set si__DarkFire_st_I=si__DarkFire_st_I+1
set this=si__DarkFire_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: DarkFire_st")
return 0
endif
set s__DarkFire_st_targetDamage[this]=0.
set s__DarkFire_st_structDamage[this]=0.
set s__DarkFire_st_summonDamage[this]=0.
set s__DarkFire_st_dummy[this]=null
set s__DarkFire_st_caster[this]=null
set s__DarkFire_st_target[this]=null
set s__DarkFire_st_periodic[this]=0.
set s__DarkFire_st_damage[this]=0.
set s__DarkFire_st_range[this]=0.
set s__DarkFire_st_time[this]=0.
set s__DarkFire_st_x[this]=0.
set s__DarkFire_st_y[this]=0.
set si__DarkFire_st_V[this]=-1
return this
endfunction
function s__DarkFire_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: DarkFire_st")
return
elseif(si__DarkFire_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: DarkFire_st")
return
endif
set si__DarkFire_st_V[this]=si__DarkFire_st_F
set si__DarkFire_st_F=this
endfunction
function s__HellWrath_st__allocate takes nothing returns integer
local integer this=si__HellWrath_st_F
if(this!=0)then
set si__HellWrath_st_F=si__HellWrath_st_V[this]
else
set si__HellWrath_st_I=si__HellWrath_st_I+1
set this=si__HellWrath_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: HellWrath_st")
return 0
endif
set s__HellWrath_st_summonDamage[this]=0.
set s__HellWrath_st_structDamage[this]=0.
set s__HellWrath_st_dummy[this]=null
set s__HellWrath_st_caster[this]=null
set s__HellWrath_st_periodic[this]=0.
set s__HellWrath_st_damage[this]=0.
set s__HellWrath_st_range[this]=0.
set s__HellWrath_st_time[this]=0.
set s__HellWrath_st_x[this]=0.
set s__HellWrath_st_y[this]=0.
set si__HellWrath_st_V[this]=-1
return this
endfunction
function s__HellWrath_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: HellWrath_st")
return
elseif(si__HellWrath_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: HellWrath_st")
return
endif
set si__HellWrath_st_V[this]=si__HellWrath_st_F
set si__HellWrath_st_F=this
endfunction
function s__HellWrathCast_st__allocate takes nothing returns integer
local integer this=si__HellWrathCast_st_F
if(this!=0)then
set si__HellWrathCast_st_F=si__HellWrathCast_st_V[this]
else
set si__HellWrathCast_st_I=si__HellWrathCast_st_I+1
set this=si__HellWrathCast_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: HellWrathCast_st")
return 0
endif
set s__HellWrathCast_st_caster[this]=null
set s__HellWrathCast_st_count[this]=0
set s__HellWrathCast_st_range[this]=0.
set s__HellWrathCast_st_x[this]=0.
set s__HellWrathCast_st_y[this]=0.
set si__HellWrathCast_st_V[this]=-1
return this
endfunction
function s__HellWrathCast_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: HellWrathCast_st")
return
elseif(si__HellWrathCast_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: HellWrathCast_st")
return
endif
set si__HellWrathCast_st_V[this]=si__HellWrathCast_st_F
set si__HellWrathCast_st_F=this
endfunction
function s__Exgumation_st__allocate takes nothing returns integer
local integer this=si__Exgumation_st_F
if(this!=0)then
set si__Exgumation_st_F=si__Exgumation_st_V[this]
else
set si__Exgumation_st_I=si__Exgumation_st_I+1
set this=si__Exgumation_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Exgumation_st")
return 0
endif
set s__Exgumation_st_caster[this]=null
set s__Exgumation_st_count[this]=0
set s__Exgumation_st_periodic[this]=0.
set s__Exgumation_st_range[this]=0.
set si__Exgumation_st_V[this]=-1
return this
endfunction
function s__Exgumation_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Exgumation_st")
return
elseif(si__Exgumation_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Exgumation_st")
return
endif
set si__Exgumation_st_V[this]=si__Exgumation_st_F
set si__Exgumation_st_F=this
endfunction
function s__DarkArmy_st__allocate takes nothing returns integer
local integer this=si__DarkArmy_st_F
if(this!=0)then
set si__DarkArmy_st_F=si__DarkArmy_st_V[this]
else
set si__DarkArmy_st_I=si__DarkArmy_st_I+1
set this=si__DarkArmy_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: DarkArmy_st")
return 0
endif
set s__DarkArmy_st_zombieChance[this]=0.
set s__DarkArmy_st_pudgeChance[this]=0.
set s__DarkArmy_st_caster[this]=null
set s__DarkArmy_st_eff[this]=null
set s__DarkArmy_st_periodic[this]=0.
set s__DarkArmy_st_range[this]=0.
set s__DarkArmy_st_time[this]=0.
set si__DarkArmy_st_V[this]=-1
return this
endfunction
function s__DarkArmy_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: DarkArmy_st")
return
elseif(si__DarkArmy_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: DarkArmy_st")
return
endif
set si__DarkArmy_st_V[this]=si__DarkArmy_st_F
set si__DarkArmy_st_F=this
endfunction
function s__Impale__allocate takes nothing returns integer
local integer this=si__Impale_F
if(this!=0)then
set si__Impale_F=si__Impale_V[this]
else
set si__Impale_I=si__Impale_I+1
set this=si__Impale_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Impale")
return 0
endif
set s__Impale_caster[this]=null
set s__Impale_Timer[this]=null
set s__Impale_stunTime[this]=0.
set s__Impale_periodic[this]=0.
set s__Impale_targetGroup[this]=null
set s__Impale_damageRange[this]=0.
set s__Impale_count[this]=0
set s__Impale_damage[this]=0.
set s__Impale_angle[this]=0.
set s__Impale_range[this]=0.
set s__Impale_step[this]=0.
set s__Impale_x[this]=0.
set s__Impale_y[this]=0.
set si__Impale_V[this]=-1
return this
endfunction
function s__Impale_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Impale")
return
elseif(si__Impale_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Impale")
return
endif
set si__Impale_V[this]=si__Impale_F
set si__Impale_F=this
endfunction
function s__Parasites_projectile_st__allocate takes nothing returns integer
local integer this=si__Parasites_projectile_st_F
if(this!=0)then
set si__Parasites_projectile_st_F=si__Parasites_projectile_st_V[this]
else
set si__Parasites_projectile_st_I=si__Parasites_projectile_st_I+1
set this=si__Parasites_projectile_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Parasites_projectile_st")
return 0
endif
set s__Parasites_projectile_st_caster[this]=null
set s__Parasites_projectile_st_target[this]=null
set s__Parasites_projectile_st_Timer[this]=null
set s__Parasites_projectile_st_eff[this]=null
set s__Parasites_projectile_st_lvl[this]=0
set s__Parasites_projectile_st_speed[this]=0.
set si__Parasites_projectile_st_V[this]=-1
return this
endfunction
function s__Parasites_projectile_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Parasites_projectile_st")
return
elseif(si__Parasites_projectile_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Parasites_projectile_st")
return
endif
set si__Parasites_projectile_st_V[this]=si__Parasites_projectile_st_F
set si__Parasites_projectile_st_F=this
endfunction
function s__LifeObmen_st__allocate takes nothing returns integer
local integer this=si__LifeObmen_st_F
if(this!=0)then
set si__LifeObmen_st_F=si__LifeObmen_st_V[this]
else
set si__LifeObmen_st_I=si__LifeObmen_st_I+1
set this=si__LifeObmen_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: LifeObmen_st")
return 0
endif
set s__LifeObmen_st_Timer[this]=CreateTimer()
set s__LifeObmen_st_ttCaster[this]=null
set s__LifeObmen_st_ttTarget[this]=null
set s__LifeObmen_st_light[this]=null
set s__LifeObmen_st_linkType[this]=""
set s__LifeObmen_st_caster[this]=null
set s__LifeObmen_st_target[this]=null
set s__LifeObmen_st_maxDistance[this]=0.
set s__LifeObmen_st_periodic[this]=0.
set s__LifeObmen_st_time[this]=0.
set si__LifeObmen_st_V[this]=-1
return this
endfunction
function s__LifeObmen_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: LifeObmen_st")
return
elseif(si__LifeObmen_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: LifeObmen_st")
return
endif
set si__LifeObmen_st_V[this]=si__LifeObmen_st_F
set si__LifeObmen_st_F=this
endfunction
function s__RocksInMeLaunch_st__allocate takes nothing returns integer
local integer this=si__RocksInMeLaunch_st_F
if(this!=0)then
set si__RocksInMeLaunch_st_F=si__RocksInMeLaunch_st_V[this]
else
set si__RocksInMeLaunch_st_I=si__RocksInMeLaunch_st_I+1
set this=si__RocksInMeLaunch_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: RocksInMeLaunch_st")
return 0
endif
set s__RocksInMeLaunch_st_caster[this]=null
set s__RocksInMeLaunch_st_damage[this]=0.
set s__RocksInMeLaunch_st_count[this]=0
set si__RocksInMeLaunch_st_V[this]=-1
return this
endfunction
function s__RocksInMeLaunch_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: RocksInMeLaunch_st")
return
elseif(si__RocksInMeLaunch_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: RocksInMeLaunch_st")
return
endif
set si__RocksInMeLaunch_st_V[this]=si__RocksInMeLaunch_st_F
set si__RocksInMeLaunch_st_F=this
endfunction
function s__RocksInMe_st__allocate takes nothing returns integer
local integer this=si__RocksInMe_st_F
if(this!=0)then
set si__RocksInMe_st_F=si__RocksInMe_st_V[this]
else
set si__RocksInMe_st_I=si__RocksInMe_st_I+1
set this=si__RocksInMe_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: RocksInMe_st")
return 0
endif
set s__RocksInMe_st_caster[this]=null
set s__RocksInMe_st_dummy[this]=null
set s__RocksInMe_st_dmgRange[this]=0.
set s__RocksInMe_st_distance[this]=0.
set s__RocksInMe_st_maxDistance[this]=0.
set s__RocksInMe_st_damage[this]=0.
set s__RocksInMe_st_speed[this]=0.
set si__RocksInMe_st_V[this]=-1
return this
endfunction
function s__RocksInMe_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: RocksInMe_st")
return
elseif(si__RocksInMe_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: RocksInMe_st")
return
endif
set si__RocksInMe_st_V[this]=si__RocksInMe_st_F
set si__RocksInMe_st_F=this
endfunction
function s__StormBolt_st__allocate takes nothing returns integer
local integer this=si__StormBolt_st_F
if(this!=0)then
set si__StormBolt_st_F=si__StormBolt_st_V[this]
else
set si__StormBolt_st_I=si__StormBolt_st_I+1
set this=si__StormBolt_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: StormBolt_st")
return 0
endif
set s__StormBolt_st_caster[this]=null
set s__StormBolt_st_target[this]=null
set s__StormBolt_st_dummy[this]=null
set s__StormBolt_st_range[this]=0.
set s__StormBolt_st_damage[this]=0.
set s__StormBolt_st_stun[this]=0.
set s__StormBolt_st_lvl[this]=0
set si__StormBolt_st_V[this]=-1
return this
endfunction
function s__StormBolt_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: StormBolt_st")
return
elseif(si__StormBolt_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: StormBolt_st")
return
endif
set si__StormBolt_st_V[this]=si__StormBolt_st_F
set si__StormBolt_st_F=this
endfunction
function s__ElectroStrikeLaunch_st__allocate takes nothing returns integer
local integer this=si__ElectroStrikeLaunch_st_F
if(this!=0)then
set si__ElectroStrikeLaunch_st_F=si__ElectroStrikeLaunch_st_V[this]
else
set si__ElectroStrikeLaunch_st_I=si__ElectroStrikeLaunch_st_I+1
set this=si__ElectroStrikeLaunch_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ElectroStrikeLaunch_st")
return 0
endif
set s__ElectroStrikeLaunch_st_offsetAngle[this]=0.
set s__ElectroStrikeLaunch_st_caster[this]=null
set s__ElectroStrikeLaunch_st_offset[this]=0.
set s__ElectroStrikeLaunch_st_angle[this]=0.
set s__ElectroStrikeLaunch_st_damage[this]=0.
set si__ElectroStrikeLaunch_st_V[this]=-1
return this
endfunction
function s__ElectroStrikeLaunch_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ElectroStrikeLaunch_st")
return
elseif(si__ElectroStrikeLaunch_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ElectroStrikeLaunch_st")
return
endif
set si__ElectroStrikeLaunch_st_V[this]=si__ElectroStrikeLaunch_st_F
set si__ElectroStrikeLaunch_st_F=this
endfunction
function s__ElectroStrike_st__allocate takes nothing returns integer
local integer this=si__ElectroStrike_st_F
if(this!=0)then
set si__ElectroStrike_st_F=si__ElectroStrike_st_V[this]
else
set si__ElectroStrike_st_I=si__ElectroStrike_st_I+1
set this=si__ElectroStrike_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: ElectroStrike_st")
return 0
endif
set s__ElectroStrike_st_caster[this]=null
set s__ElectroStrike_st_dummy[this]=null
set s__ElectroStrike_st_dmgRange[this]=0.
set s__ElectroStrike_st_distance[this]=0.
set s__ElectroStrike_st_damage[this]=0.
set s__ElectroStrike_st_speed[this]=0.
set si__ElectroStrike_st_V[this]=-1
return this
endfunction
function s__ElectroStrike_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: ElectroStrike_st")
return
elseif(si__ElectroStrike_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: ElectroStrike_st")
return
endif
set si__ElectroStrike_st_V[this]=si__ElectroStrike_st_F
set si__ElectroStrike_st_F=this
endfunction
function s__Monsoon_st__allocate takes nothing returns integer
local integer this=si__Monsoon_st_F
if(this!=0)then
set si__Monsoon_st_F=si__Monsoon_st_V[this]
else
set si__Monsoon_st_I=si__Monsoon_st_I+1
set this=si__Monsoon_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Monsoon_st")
return 0
endif
set s__Monsoon_st_aroundEff[this]=null
set s__Monsoon_st_caster[this]=null
set s__Monsoon_st_periodic[this]=0.
set s__Monsoon_st_damage[this]=0.
set s__Monsoon_st_range[this]=0.
set s__Monsoon_st_time[this]=0.
set s__Monsoon_st_x[this]=0.
set s__Monsoon_st_y[this]=0.
set si__Monsoon_st_V[this]=-1
return this
endfunction
function s__Monsoon_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Monsoon_st")
return
elseif(si__Monsoon_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Monsoon_st")
return
endif
set si__Monsoon_st_V[this]=si__Monsoon_st_F
set si__Monsoon_st_F=this
endfunction
function s__Gust_st__allocate takes nothing returns integer
local integer this=si__Gust_st_F
if(this!=0)then
set si__Gust_st_F=si__Gust_st_V[this]
else
set si__Gust_st_I=si__Gust_st_I+1
set this=si__Gust_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Gust_st")
return 0
endif
set s__Gust_st_target[this]=null
set s__Gust_st_totalDist[this]=0.
set s__Gust_st_periodic[this]=0.
set s__Gust_st_distance[this]=0.
set s__Gust_st_speed[this]=0.
set s__Gust_st_angle[this]=0.
set si__Gust_st_V[this]=-1
return this
endfunction
function s__Gust_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Gust_st")
return
elseif(si__Gust_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Gust_st")
return
endif
set si__Gust_st_V[this]=si__Gust_st_F
set si__Gust_st_F=this
endfunction
function s__Transfer_st__allocate takes nothing returns integer
local integer this=si__Transfer_st_F
if(this!=0)then
set si__Transfer_st_F=si__Transfer_st_V[this]
else
set si__Transfer_st_I=si__Transfer_st_I+1
set this=si__Transfer_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Transfer_st")
return 0
endif
set s__Transfer_st_link[this]=null
set s__Transfer_st_caster[this]=null
set s__Transfer_st_target[this]=null
set s__Transfer_st_mPeriodic[this]=0.
set s__Transfer_st_cPeriodic[this]=0.
set s__Transfer_st_periodic[this]=0.
set s__Transfer_st_time[this]=0.
set s__Transfer_st_hp[this]=0.
set s__Transfer_st_mp[this]=0.
set si__Transfer_st_V[this]=-1
return this
endfunction
function s__Transfer_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Transfer_st")
return
elseif(si__Transfer_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Transfer_st")
return
endif
set si__Transfer_st_V[this]=si__Transfer_st_F
set si__Transfer_st_F=this
endfunction
function s__StormHummer_st__allocate takes nothing returns integer
local integer this=si__StormHummer_st_F
if(this!=0)then
set si__StormHummer_st_F=si__StormHummer_st_V[this]
else
set si__StormHummer_st_I=si__StormHummer_st_I+1
set this=si__StormHummer_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: StormHummer_st")
return 0
endif
set s__StormHummer_st_aroundEff[this]=null
set s__StormHummer_st_g[this]=CreateGroup()
set s__StormHummer_st_caster[this]=null
set s__StormHummer_st_periodic[this]=0.
set s__StormHummer_st_damage[this]=0.
set s__StormHummer_st_range[this]=0.
set s__StormHummer_st_stun[this]=0.
set s__StormHummer_st_count[this]=0
set s__StormHummer_st_x[this]=0.
set s__StormHummer_st_y[this]=0.
set si__StormHummer_st_V[this]=-1
return this
endfunction
function s__StormHummer_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: StormHummer_st")
return
elseif(si__StormHummer_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: StormHummer_st")
return
endif
set si__StormHummer_st_V[this]=si__StormHummer_st_F
set si__StormHummer_st_F=this
endfunction
function s__cursedAI___UnitAI__allocate takes nothing returns integer
local integer this=si__cursedAI___UnitAI_F
if(this!=0)then
set si__cursedAI___UnitAI_F=si__cursedAI___UnitAI_V[this]
else
set si__cursedAI___UnitAI_I=si__cursedAI___UnitAI_I+1
set this=si__cursedAI___UnitAI_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: cursedAI___UnitAI")
return 0
endif
set s__cursedAI___UnitAI_isWaitForHp[this]=false
set s__cursedAI___UnitAI_isDefended[this]=false
set s__cursedAI___UnitAI_isDefend[this]=false
set s__cursedAI___UnitAI_target[this]=null
set si__cursedAI___UnitAI_V[this]=-1
return this
endfunction
function s__cursedAI___UnitAI_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: cursedAI___UnitAI")
return
elseif(si__cursedAI___UnitAI_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: cursedAI___UnitAI")
return
endif
set si__cursedAI___UnitAI_V[this]=si__cursedAI___UnitAI_F
set si__cursedAI___UnitAI_F=this
endfunction
function s__WonderfulFlow__WonderfulFlow_st__allocate takes nothing returns integer
local integer this=si__WonderfulFlow__WonderfulFlow_st_F
if(this!=0)then
set si__WonderfulFlow__WonderfulFlow_st_F=si__WonderfulFlow__WonderfulFlow_st_V[this]
else
set si__WonderfulFlow__WonderfulFlow_st_I=si__WonderfulFlow__WonderfulFlow_st_I+1
set this=si__WonderfulFlow__WonderfulFlow_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: WonderfulFlow__WonderfulFlow_st")
return 0
endif
set s__WonderfulFlow__WonderfulFlow_st_eff[this]=null
set s__WonderfulFlow__WonderfulFlow_st_caster[this]=null
set s__WonderfulFlow__WonderfulFlow_st_range[this]=0.
set s__WonderfulFlow__WonderfulFlow_st_damage[this]=0.
set s__WonderfulFlow__WonderfulFlow_st_scale[this]=0.
set s__WonderfulFlow__WonderfulFlow_st_x[this]=0.
set s__WonderfulFlow__WonderfulFlow_st_y[this]=0.
set si__WonderfulFlow__WonderfulFlow_st_V[this]=-1
return this
endfunction
function s__WonderfulFlow__WonderfulFlow_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: WonderfulFlow__WonderfulFlow_st")
return
elseif(si__WonderfulFlow__WonderfulFlow_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: WonderfulFlow__WonderfulFlow_st")
return
endif
set si__WonderfulFlow__WonderfulFlow_st_V[this]=si__WonderfulFlow__WonderfulFlow_st_F
set si__WonderfulFlow__WonderfulFlow_st_F=this
endfunction
function s__StompLib__StompFly_st__allocate takes nothing returns integer
local integer this=si__StompLib__StompFly_st_F
if(this!=0)then
set si__StompLib__StompFly_st_F=si__StompLib__StompFly_st_V[this]
else
set si__StompLib__StompFly_st_I=si__StompLib__StompFly_st_I+1
set this=si__StompLib__StompFly_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: StompLib__StompFly_st")
return 0
endif
set s__StompLib__StompFly_st_isPaused[this]=false
set s__StompLib__StompFly_st_Timer[this]=null
set s__StompLib__StompFly_st_caster[this]=null
set s__StompLib__StompFly_st_target[this]=null
set s__StompLib__StompFly_st_maxDistance[this]=0.
set s__StompLib__StompFly_st_stunTime[this]=0.
set s__StompLib__StompFly_st_periodic[this]=0.
set s__StompLib__StompFly_st_distance[this]=0.
set s__StompLib__StompFly_st_damage[this]=0.
set s__StompLib__StompFly_st_speed[this]=0.
set s__StompLib__StompFly_st_angle[this]=0.
set si__StompLib__StompFly_st_V[this]=-1
return this
endfunction
function s__StompLib__StompFly_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: StompLib__StompFly_st")
return
elseif(si__StompLib__StompFly_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: StompLib__StompFly_st")
return
endif
set si__StompLib__StompFly_st_V[this]=si__StompLib__StompFly_st_F
set si__StompLib__StompFly_st_F=this
endfunction
function s__SpawnLib__Spawn_st__allocate takes nothing returns integer
local integer this=si__SpawnLib__Spawn_st_F
if(this!=0)then
set si__SpawnLib__Spawn_st_F=si__SpawnLib__Spawn_st_V[this]
else
set si__SpawnLib__Spawn_st_I=si__SpawnLib__Spawn_st_I+1
set this=si__SpawnLib__Spawn_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: SpawnLib__Spawn_st")
return 0
endif
set s__SpawnLib__Spawn_st_tt[this]=CreateTextTag()
set s__SpawnLib__Spawn_st_t[this]=CreateTimer()
set s__SpawnLib__Spawn_st_periodic[this]=0.10
set s__SpawnLib__Spawn_st_time[this]=0.00
set s__SpawnLib__Spawn_st_index[this]=-1
set s__SpawnLib__Spawn_st_castle[this]=null
set s__SpawnLib__Spawn_st_x[this]=0.
set s__SpawnLib__Spawn_st_y[this]=0.
set si__SpawnLib__Spawn_st_V[this]=-1
return this
endfunction
function s__SpawnLib__Spawn_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: SpawnLib__Spawn_st")
return
elseif(si__SpawnLib__Spawn_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: SpawnLib__Spawn_st")
return
endif
set si__SpawnLib__Spawn_st_V[this]=si__SpawnLib__Spawn_st_F
set si__SpawnLib__Spawn_st_F=this
endfunction
function s__PowerWave__PowerWave_st__allocate takes nothing returns integer
local integer this=si__PowerWave__PowerWave_st_F
if(this!=0)then
set si__PowerWave__PowerWave_st_F=si__PowerWave__PowerWave_st_V[this]
else
set si__PowerWave__PowerWave_st_I=si__PowerWave__PowerWave_st_I+1
set this=si__PowerWave__PowerWave_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: PowerWave__PowerWave_st")
return 0
endif
set s__PowerWave__PowerWave_st_damagedGroup[this]=CreateGroup()
set s__PowerWave__PowerWave_st_wave[this]=null
set s__PowerWave__PowerWave_st_t[this]=null
set s__PowerWave__PowerWave_st_caster[this]=null
set s__PowerWave__PowerWave_st_distance[this]=0.
set s__PowerWave__PowerWave_st_damage[this]=0.
set s__PowerWave__PowerWave_st_range[this]=0.
set s__PowerWave__PowerWave_st_speed[this]=0.
set s__PowerWave__PowerWave_st_angle[this]=0.
set si__PowerWave__PowerWave_st_V[this]=-1
return this
endfunction
function s__PowerWave__PowerWave_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: PowerWave__PowerWave_st")
return
elseif(si__PowerWave__PowerWave_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: PowerWave__PowerWave_st")
return
endif
set si__PowerWave__PowerWave_st_V[this]=si__PowerWave__PowerWave_st_F
set si__PowerWave__PowerWave_st_F=this
endfunction
function s__Illusions___Illusions_st__allocate takes nothing returns integer
local integer this=si__Illusions___Illusions_st_F
if(this!=0)then
set si__Illusions___Illusions_st_F=si__Illusions___Illusions_st_V[this]
else
set si__Illusions___Illusions_st_I=si__Illusions___Illusions_st_I+1
set this=si__Illusions___Illusions_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Illusions___Illusions_st")
return 0
endif
set s__Illusions___Illusions_st_illusions[this]=CreateGroup()
set s__Illusions___Illusions_st_caster[this]=null
set si__Illusions___Illusions_st_V[this]=-1
return this
endfunction
function s__Illusions___Illusions_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Illusions___Illusions_st")
return
elseif(si__Illusions___Illusions_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Illusions___Illusions_st")
return
endif
set si__Illusions___Illusions_st_V[this]=si__Illusions___Illusions_st_F
set si__Illusions___Illusions_st_F=this
endfunction
function s__HealWave__HealWave_st__allocate takes nothing returns integer
local integer this=si__HealWave__HealWave_st_F
if(this!=0)then
set si__HealWave__HealWave_st_F=si__HealWave__HealWave_st_V[this]
else
set si__HealWave__HealWave_st_I=si__HealWave__HealWave_st_I+1
set this=si__HealWave__HealWave_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: HealWave__HealWave_st")
return 0
endif
set s__HealWave__HealWave_st_healedGroup[this]=CreateGroup()
set s__HealWave__HealWave_st_isFirst[this]=false
set s__HealWave__HealWave_st_wave[this]=null
set s__HealWave__HealWave_st_healDebuff[this]=0.
set s__HealWave__HealWave_st_Timer[this]=null
set s__HealWave__HealWave_st_caster[this]=null
set s__HealWave__HealWave_st_target[this]=null
set s__HealWave__HealWave_st_count[this]=0
set s__HealWave__HealWave_st_range[this]=0.
set s__HealWave__HealWave_st_heal[this]=0.
set si__HealWave__HealWave_st_V[this]=-1
return this
endfunction
function s__HealWave__HealWave_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: HealWave__HealWave_st")
return
elseif(si__HealWave__HealWave_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: HealWave__HealWave_st")
return
endif
set si__HealWave__HealWave_st_V[this]=si__HealWave__HealWave_st_F
set si__HealWave__HealWave_st_F=this
endfunction
function s__FireRainProjectile_st__allocate takes nothing returns integer
local integer this=si__FireRainProjectile_st_F
if(this!=0)then
set si__FireRainProjectile_st_F=si__FireRainProjectile_st_V[this]
else
set si__FireRainProjectile_st_I=si__FireRainProjectile_st_I+1
set this=si__FireRainProjectile_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: FireRainProjectile_st")
return 0
endif
set s__FireRainProjectile_st_picker[this]=CreateGroup()
set s__FireRainProjectile_st_dmgCheckRange[this]=0.
set s__FireRainProjectile_st_dmgRange[this]=0.
set s__FireRainProjectile_st_maxDistance[this]=0.
set s__FireRainProjectile_st_caster[this]=null
set s__FireRainProjectile_st_dummy[this]=null
set s__FireRainProjectile_st_flySpeed[this]=0.
set s__FireRainProjectile_st_distance[this]=0.
set s__FireRainProjectile_st_damage[this]=0.
set s__FireRainProjectile_st_speed[this]=0.
set s__FireRainProjectile_st_range[this]=0.
set s__FireRainProjectile_st_stAngle[this]=0.
set s__FireRainProjectile_st_angle[this]=0.
set si__FireRainProjectile_st_V[this]=-1
return this
endfunction
function s__FireRainProjectile_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: FireRainProjectile_st")
return
elseif(si__FireRainProjectile_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: FireRainProjectile_st")
return
endif
set si__FireRainProjectile_st_V[this]=si__FireRainProjectile_st_F
set si__FireRainProjectile_st_F=this
endfunction
function s__FireRain_st__allocate takes nothing returns integer
local integer this=si__FireRain_st_F
if(this!=0)then
set si__FireRain_st_F=si__FireRain_st_V[this]
else
set si__FireRain_st_I=si__FireRain_st_I+1
set this=si__FireRain_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: FireRain_st")
return 0
endif
set s__FireRain_st_caster[this]=null
set s__FireRain_st_count[this]=0
set s__FireRain_st_periodic[this]=0.
set s__FireRain_st_x[this]=0.
set s__FireRain_st_y[this]=0.
set si__FireRain_st_V[this]=-1
return this
endfunction
function s__FireRain_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: FireRain_st")
return
elseif(si__FireRain_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: FireRain_st")
return
endif
set si__FireRain_st_V[this]=si__FireRain_st_F
set si__FireRain_st_F=this
endfunction
function s__DarkRevengeProjectile_st__allocate takes nothing returns integer
local integer this=si__DarkRevengeProjectile_st_F
if(this!=0)then
set si__DarkRevengeProjectile_st_F=si__DarkRevengeProjectile_st_V[this]
else
set si__DarkRevengeProjectile_st_I=si__DarkRevengeProjectile_st_I+1
set this=si__DarkRevengeProjectile_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: DarkRevengeProjectile_st")
return 0
endif
set s__DarkRevengeProjectile_st_picker[this]=CreateGroup()
set s__DarkRevengeProjectile_st_dmgCheckRange[this]=0.
set s__DarkRevengeProjectile_st_maxDistance[this]=0.
set s__DarkRevengeProjectile_st_caster[this]=null
set s__DarkRevengeProjectile_st_dummy[this]=null
set s__DarkRevengeProjectile_st_flySpeed[this]=0.
set s__DarkRevengeProjectile_st_distance[this]=0.
set s__DarkRevengeProjectile_st_damage[this]=0.
set s__DarkRevengeProjectile_st_speed[this]=0.
set s__DarkRevengeProjectile_st_range[this]=0.
set s__DarkRevengeProjectile_st_stAngle[this]=0.
set s__DarkRevengeProjectile_st_angle[this]=0.
set si__DarkRevengeProjectile_st_V[this]=-1
return this
endfunction
function s__DarkRevengeProjectile_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: DarkRevengeProjectile_st")
return
elseif(si__DarkRevengeProjectile_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: DarkRevengeProjectile_st")
return
endif
set si__DarkRevengeProjectile_st_V[this]=si__DarkRevengeProjectile_st_F
set si__DarkRevengeProjectile_st_F=this
endfunction
function s__DarkRevenge_st__allocate takes nothing returns integer
local integer this=si__DarkRevenge_st_F
if(this!=0)then
set si__DarkRevenge_st_F=si__DarkRevenge_st_V[this]
else
set si__DarkRevenge_st_I=si__DarkRevenge_st_I+1
set this=si__DarkRevenge_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: DarkRevenge_st")
return 0
endif
set s__DarkRevenge_st_caster[this]=null
set s__DarkRevenge_st_count[this]=0
set s__DarkRevenge_st_periodic[this]=0.
set s__DarkRevenge_st_x[this]=0.
set s__DarkRevenge_st_y[this]=0.
set si__DarkRevenge_st_V[this]=-1
return this
endfunction
function s__DarkRevenge_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: DarkRevenge_st")
return
elseif(si__DarkRevenge_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: DarkRevenge_st")
return
endif
set si__DarkRevenge_st_V[this]=si__DarkRevenge_st_F
set si__DarkRevenge_st_F=this
endfunction
function s__BadWave__BadWave_st__allocate takes nothing returns integer
local integer this=si__BadWave__BadWave_st_F
if(this!=0)then
set si__BadWave__BadWave_st_F=si__BadWave__BadWave_st_V[this]
else
set si__BadWave__BadWave_st_I=si__BadWave__BadWave_st_I+1
set this=si__BadWave__BadWave_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: BadWave__BadWave_st")
return 0
endif
set s__BadWave__BadWave_st_damagedGroup[this]=CreateGroup()
set s__BadWave__BadWave_st_isFirst[this]=false
set s__BadWave__BadWave_st_wave[this]=null
set s__BadWave__BadWave_st_damageDebuff[this]=0.
set s__BadWave__BadWave_st_Timer[this]=null
set s__BadWave__BadWave_st_caster[this]=null
set s__BadWave__BadWave_st_target[this]=null
set s__BadWave__BadWave_st_count[this]=0
set s__BadWave__BadWave_st_damage[this]=0.
set s__BadWave__BadWave_st_range[this]=0.
set si__BadWave__BadWave_st_V[this]=-1
return this
endfunction
function s__BadWave__BadWave_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: BadWave__BadWave_st")
return
elseif(si__BadWave__BadWave_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: BadWave__BadWave_st")
return
endif
set si__BadWave__BadWave_st_V[this]=si__BadWave__BadWave_st_F
set si__BadWave__BadWave_st_F=this
endfunction
function s__Move___Jump__allocate takes nothing returns integer
local integer this=si__Move___Jump_F
if(this!=0)then
set si__Move___Jump_F=si__Move___Jump_V[this]
else
set si__Move___Jump_I=si__Move___Jump_I+1
set this=si__Move___Jump_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Move___Jump")
return 0
endif
set s__Move___Jump_isPaused[this]=false
set s__Move___Jump_Timer[this]=null
set s__Move___Jump_target[this]=null
set s__Move___Jump_totalCount[this]=0.
set s__Move___Jump_stunTime[this]=0.
set s__Move___Jump_periodic[this]=0.
set s__Move___Jump_height[this]=0.
set s__Move___Jump_speed[this]=0.
set si__Move___Jump_V[this]=-1
return this
endfunction
function s__Move___Jump_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Move___Jump")
return
elseif(si__Move___Jump_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Move___Jump")
return
endif
set si__Move___Jump_V[this]=si__Move___Jump_F
set si__Move___Jump_F=this
endfunction
function s__Frostmorne_strl__allocate takes nothing returns integer
local integer this=si__Frostmorne_strl_F
if(this!=0)then
set si__Frostmorne_strl_F=si__Frostmorne_strl_V[this]
else
set si__Frostmorne_strl_I=si__Frostmorne_strl_I+1
set this=si__Frostmorne_strl_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Frostmorne_strl")
return 0
endif
set s__Frostmorne_strl_fm[this]=0
set s__Frostmorne_strl_t[this]=CreateTimer()
set s__Frostmorne_strl_time[this]=Frostmorne___RELOAD_TIME
set s__Frostmorne_strl_index[this]=0
set si__Frostmorne_strl_V[this]=-1
return this
endfunction
function s__Frostmorne_strl_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Frostmorne_strl")
return
elseif(si__Frostmorne_strl_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Frostmorne_strl")
return
endif
set si__Frostmorne_strl_V[this]=si__Frostmorne_strl_F
set si__Frostmorne_strl_F=this
endfunction
function s__Frostmorne_st__allocate takes nothing returns integer
local integer this=si__Frostmorne_st_F
if(this!=0)then
set si__Frostmorne_st_F=si__Frostmorne_st_V[this]
else
set si__Frostmorne_st_I=si__Frostmorne_st_I+1
set this=si__Frostmorne_st_I
endif
if(this>1022)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Frostmorne_st")
return 0
endif
set s__Frostmorne_st_projectiles[this]=(this-1)*8
set s__Frostmorne_st_g[this]=CreateGroup()
set s__Frostmorne_st_t[this]=CreateTimer()
set s__Frostmorne_st_periodic[this]=0.03
set s__Frostmorne_st_offset[this]=125.00
set s__Frostmorne_st_range[this]=700.00
set s__Frostmorne_st_caster[this]=null
set s__Frostmorne_st_count[this]=0
set s__Frostmorne_st_lvl[this]=0
set s__Frostmorne_st_speed[this]=3.00
set si__Frostmorne_st_V[this]=-1
return this
endfunction
function s__Frostmorne_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Frostmorne_st")
return
elseif(si__Frostmorne_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Frostmorne_st")
return
endif
set si__Frostmorne_st_V[this]=si__Frostmorne_st_F
set si__Frostmorne_st_F=this
endfunction
function s__Frostmorne_stpj__allocate takes nothing returns integer
local integer this=si__Frostmorne_stpj_F
if(this!=0)then
set si__Frostmorne_stpj_F=si__Frostmorne_stpj_V[this]
else
set si__Frostmorne_stpj_I=si__Frostmorne_stpj_I+1
set this=si__Frostmorne_stpj_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Frostmorne_stpj")
return 0
endif
set s__Frostmorne_stpj_eff[this]=AddSpecialEffect("Abilities\\Spells\\Other\\FrostBolt\\FrostBoltMissile.mdl",0,0)
set s__Frostmorne_stpj_t[this]=CreateTimer()
set s__Frostmorne_stpj_isLaunched[this]=false
set s__Frostmorne_stpj_periodic[this]=0.03
set s__Frostmorne_stpj_caster[this]=null
set s__Frostmorne_stpj_target[this]=null
set s__Frostmorne_stpj_lvl[this]=0
set s__Frostmorne_stpj_speed[this]=20.00
set s__Frostmorne_stpj_angle[this]=0.00
set s__Frostmorne_stpj_damage[this]=0.00
set s__Frostmorne_stpj_frostTime[this]=0.00
set si__Frostmorne_stpj_V[this]=-1
return this
endfunction
function s__Frostmorne_stpj_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Frostmorne_stpj")
return
elseif(si__Frostmorne_stpj_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Frostmorne_stpj")
return
endif
set si__Frostmorne_stpj_V[this]=si__Frostmorne_stpj_F
set si__Frostmorne_stpj_F=this
endfunction
function s__WillOfNatureProjectile_st__allocate takes nothing returns integer
local integer this=si__WillOfNatureProjectile_st_F
if(this!=0)then
set si__WillOfNatureProjectile_st_F=si__WillOfNatureProjectile_st_V[this]
else
set si__WillOfNatureProjectile_st_I=si__WillOfNatureProjectile_st_I+1
set this=si__WillOfNatureProjectile_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: WillOfNatureProjectile_st")
return 0
endif
set s__WillOfNatureProjectile_st_picker[this]=CreateGroup()
set s__WillOfNatureProjectile_st_healCheckRange[this]=0.
set s__WillOfNatureProjectile_st_spiritChance[this]=0.
set s__WillOfNatureProjectile_st_spiritID[this]=0
set s__WillOfNatureProjectile_st_healRange[this]=0.
set s__WillOfNatureProjectile_st_maxDistance[this]=0.
set s__WillOfNatureProjectile_st_caster[this]=null
set s__WillOfNatureProjectile_st_dummy[this]=null
set s__WillOfNatureProjectile_st_flySpeed[this]=0.
set s__WillOfNatureProjectile_st_distance[this]=0.
set s__WillOfNatureProjectile_st_heal[this]=0.
set s__WillOfNatureProjectile_st_speed[this]=0.
set s__WillOfNatureProjectile_st_range[this]=0.
set s__WillOfNatureProjectile_st_stAngle[this]=0.
set s__WillOfNatureProjectile_st_angle[this]=0.
set si__WillOfNatureProjectile_st_V[this]=-1
return this
endfunction
function s__WillOfNatureProjectile_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: WillOfNatureProjectile_st")
return
elseif(si__WillOfNatureProjectile_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: WillOfNatureProjectile_st")
return
endif
set si__WillOfNatureProjectile_st_V[this]=si__WillOfNatureProjectile_st_F
set si__WillOfNatureProjectile_st_F=this
endfunction
function s__WillOfNature_st__allocate takes nothing returns integer
local integer this=si__WillOfNature_st_F
if(this!=0)then
set si__WillOfNature_st_F=si__WillOfNature_st_V[this]
else
set si__WillOfNature_st_I=si__WillOfNature_st_I+1
set this=si__WillOfNature_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: WillOfNature_st")
return 0
endif
set s__WillOfNature_st_caster[this]=null
set s__WillOfNature_st_count[this]=0
set s__WillOfNature_st_periodic[this]=0.
set s__WillOfNature_st_x[this]=0.
set s__WillOfNature_st_y[this]=0.
set si__WillOfNature_st_V[this]=-1
return this
endfunction
function s__WillOfNature_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: WillOfNature_st")
return
elseif(si__WillOfNature_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: WillOfNature_st")
return
endif
set si__WillOfNature_st_V[this]=si__WillOfNature_st_F
set si__WillOfNature_st_F=this
endfunction
function s__Stun___Parasites_st__allocate takes nothing returns integer
local integer this=si__Stun___Parasites_st_F
if(this!=0)then
set si__Stun___Parasites_st_F=si__Stun___Parasites_st_V[this]
else
set si__Stun___Parasites_st_I=si__Stun___Parasites_st_I+1
set this=si__Stun___Parasites_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Stun___Parasites_st")
return 0
endif
set s__Stun___Parasites_st_caster[this]=null
set s__Stun___Parasites_st_target[this]=null
set s__Stun___Parasites_st_eff[this]=null
set s__Stun___Parasites_st_periodic[this]=0.
set s__Stun___Parasites_st_damage[this]=0.
set s__Stun___Parasites_st_time[this]=0.
set si__Stun___Parasites_st_V[this]=-1
return this
endfunction
function s__Stun___Parasites_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Stun___Parasites_st")
return
elseif(si__Stun___Parasites_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Stun___Parasites_st")
return
endif
set si__Stun___Parasites_st_V[this]=si__Stun___Parasites_st_F
set si__Stun___Parasites_st_F=this
endfunction
function s__Stun___Roots_st__allocate takes nothing returns integer
local integer this=si__Stun___Roots_st_F
if(this!=0)then
set si__Stun___Roots_st_F=si__Stun___Roots_st_V[this]
else
set si__Stun___Roots_st_I=si__Stun___Roots_st_I+1
set this=si__Stun___Roots_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Stun___Roots_st")
return 0
endif
set s__Stun___Roots_st_caster[this]=null
set s__Stun___Roots_st_target[this]=null
set s__Stun___Roots_st_eff[this]=null
set s__Stun___Roots_st_periodic[this]=0.
set s__Stun___Roots_st_damage[this]=0.
set s__Stun___Roots_st_time[this]=0.
set si__Stun___Roots_st_V[this]=-1
return this
endfunction
function s__Stun___Roots_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Stun___Roots_st")
return
elseif(si__Stun___Roots_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Stun___Roots_st")
return
endif
set si__Stun___Roots_st_V[this]=si__Stun___Roots_st_F
set si__Stun___Roots_st_F=this
endfunction
function s__Stun___Frost_st__allocate takes nothing returns integer
local integer this=si__Stun___Frost_st_F
if(this!=0)then
set si__Stun___Frost_st_F=si__Stun___Frost_st_V[this]
else
set si__Stun___Frost_st_I=si__Stun___Frost_st_I+1
set this=si__Stun___Frost_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Stun___Frost_st")
return 0
endif
set s__Stun___Frost_st_target[this]=null
set s__Stun___Frost_st_eff[this]=null
set si__Stun___Frost_st_V[this]=-1
return this
endfunction
function s__Stun___Frost_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Stun___Frost_st")
return
elseif(si__Stun___Frost_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Stun___Frost_st")
return
endif
set si__Stun___Frost_st_V[this]=si__Stun___Frost_st_F
set si__Stun___Frost_st_F=this
endfunction
function s__Stun___Stun_st__allocate takes nothing returns integer
local integer this=si__Stun___Stun_st_F
if(this!=0)then
set si__Stun___Stun_st_F=si__Stun___Stun_st_V[this]
else
set si__Stun___Stun_st_I=si__Stun___Stun_st_I+1
set this=si__Stun___Stun_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Stun___Stun_st")
return 0
endif
set s__Stun___Stun_st_caster[this]=null
set s__Stun___Stun_st_target[this]=null
set s__Stun___Stun_st_eff[this]=null
set s__Stun___Stun_st_time[this]=0.
set si__Stun___Stun_st_V[this]=-1
return this
endfunction
function s__Stun___Stun_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Stun___Stun_st")
return
elseif(si__Stun___Stun_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Stun___Stun_st")
return
endif
set si__Stun___Stun_st_V[this]=si__Stun___Stun_st_F
set si__Stun___Stun_st_F=this
endfunction
function s__SpellsLib__DamageWave_st__allocate takes nothing returns integer
local integer this=si__SpellsLib__DamageWave_st_F
if(this!=0)then
set si__SpellsLib__DamageWave_st_F=si__SpellsLib__DamageWave_st_V[this]
else
set si__SpellsLib__DamageWave_st_I=si__SpellsLib__DamageWave_st_I+1
set this=si__SpellsLib__DamageWave_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: SpellsLib__DamageWave_st")
return 0
endif
set s__SpellsLib__DamageWave_st_damagedGroup[this]=CreateGroup()
set s__SpellsLib__DamageWave_st_wave[this]=null
set s__SpellsLib__DamageWave_st_t[this]=null
set s__SpellsLib__DamageWave_st_caster[this]=null
set s__SpellsLib__DamageWave_st_distance[this]=0.
set s__SpellsLib__DamageWave_st_damage[this]=0.
set s__SpellsLib__DamageWave_st_range[this]=0.
set s__SpellsLib__DamageWave_st_speed[this]=0.
set s__SpellsLib__DamageWave_st_angle[this]=0.
set si__SpellsLib__DamageWave_st_V[this]=-1
return this
endfunction
function s__SpellsLib__DamageWave_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: SpellsLib__DamageWave_st")
return
elseif(si__SpellsLib__DamageWave_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: SpellsLib__DamageWave_st")
return
endif
set si__SpellsLib__DamageWave_st_V[this]=si__SpellsLib__DamageWave_st_F
set si__SpellsLib__DamageWave_st_F=this
endfunction
function s__RecipesLib__Recipe_st__allocate takes nothing returns integer
local integer this=si__RecipesLib__Recipe_st_F
if(this!=0)then
set si__RecipesLib__Recipe_st_F=si__RecipesLib__Recipe_st_V[this]
else
set si__RecipesLib__Recipe_st_I=si__RecipesLib__Recipe_st_I+1
set this=si__RecipesLib__Recipe_st_I
endif
if(this>1169)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: RecipesLib__Recipe_st")
return 0
endif
set s__RecipesLib__Recipe_st_items[this]=(this-1)*7
set s__RecipesLib__Recipe_st_collectedItem[this]=0
set si__RecipesLib__Recipe_st_V[this]=-1
return this
endfunction
function s__RecipesLib__Recipe_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: RecipesLib__Recipe_st")
return
elseif(si__RecipesLib__Recipe_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: RecipesLib__Recipe_st")
return
endif
set si__RecipesLib__Recipe_st_V[this]=si__RecipesLib__Recipe_st_F
set si__RecipesLib__Recipe_st_F=this
endfunction
function s__MagicWand__MagicWand_st__allocate takes nothing returns integer
local integer this=si__MagicWand__MagicWand_st_F
if(this!=0)then
set si__MagicWand__MagicWand_st_F=si__MagicWand__MagicWand_st_V[this]
else
set si__MagicWand__MagicWand_st_I=si__MagicWand__MagicWand_st_I+1
set this=si__MagicWand__MagicWand_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: MagicWand__MagicWand_st")
return 0
endif
set s__MagicWand__MagicWand_st_isCollected[this]=false
set s__MagicWand__MagicWand_st_isNecro[this]=false
set s__MagicWand__MagicWand_st_Timer[this]=null
set s__MagicWand__MagicWand_st_caster[this]=null
set s__MagicWand__MagicWand_st_wand[this]=null
set s__MagicWand__MagicWand_st_count[this]=0
set s__MagicWand__MagicWand_st_periodic[this]=0.
set s__MagicWand__MagicWand_st_dmgRange[this]=0.
set s__MagicWand__MagicWand_st_damage[this]=0.
set s__MagicWand__MagicWand_st_range[this]=0.
set si__MagicWand__MagicWand_st_V[this]=-1
return this
endfunction
function s__MagicWand__MagicWand_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: MagicWand__MagicWand_st")
return
elseif(si__MagicWand__MagicWand_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: MagicWand__MagicWand_st")
return
endif
set si__MagicWand__MagicWand_st_V[this]=si__MagicWand__MagicWand_st_F
set si__MagicWand__MagicWand_st_F=this
endfunction
function s__MagicWand__MagicWandProjectile_st__allocate takes nothing returns integer
local integer this=si__MagicWand__MagicWandProjectile_st_F
if(this!=0)then
set si__MagicWand__MagicWandProjectile_st_F=si__MagicWand__MagicWandProjectile_st_V[this]
else
set si__MagicWand__MagicWandProjectile_st_I=si__MagicWand__MagicWandProjectile_st_I+1
set this=si__MagicWand__MagicWandProjectile_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: MagicWand__MagicWandProjectile_st")
return 0
endif
set s__MagicWand__MagicWandProjectile_st_isNecro[this]=false
set s__MagicWand__MagicWandProjectile_st_projectile[this]=null
set s__MagicWand__MagicWandProjectile_st_Timer[this]=null
set s__MagicWand__MagicWandProjectile_st_caster[this]=null
set s__MagicWand__MagicWandProjectile_st_checkRange[this]=0.
set s__MagicWand__MagicWandProjectile_st_dmgRange[this]=0.
set s__MagicWand__MagicWandProjectile_st_damage[this]=0.
set s__MagicWand__MagicWandProjectile_st_distance[this]=0.
set s__MagicWand__MagicWandProjectile_st_speed[this]=0.
set s__MagicWand__MagicWandProjectile_st_angle[this]=0.
set s__MagicWand__MagicWandProjectile_st_targetX[this]=0.
set s__MagicWand__MagicWandProjectile_st_targetY[this]=0.
set si__MagicWand__MagicWandProjectile_st_V[this]=-1
return this
endfunction
function s__MagicWand__MagicWandProjectile_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: MagicWand__MagicWandProjectile_st")
return
elseif(si__MagicWand__MagicWandProjectile_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: MagicWand__MagicWandProjectile_st")
return
endif
set si__MagicWand__MagicWandProjectile_st_V[this]=si__MagicWand__MagicWandProjectile_st_F
set si__MagicWand__MagicWandProjectile_st_F=this
endfunction
function s__HeroRespawnLib___HeroRespawn_st__allocate takes nothing returns integer
local integer this=si__HeroRespawnLib___HeroRespawn_st_F
if(this!=0)then
set si__HeroRespawnLib___HeroRespawn_st_F=si__HeroRespawnLib___HeroRespawn_st_V[this]
else
set si__HeroRespawnLib___HeroRespawn_st_I=si__HeroRespawnLib___HeroRespawn_st_I+1
set this=si__HeroRespawnLib___HeroRespawn_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: HeroRespawnLib___HeroRespawn_st")
return 0
endif
set s__HeroRespawnLib___HeroRespawn_st_t[this]=CreateTimer()
set s__HeroRespawnLib___HeroRespawn_st_td[this]=CreateTimerDialog(s__HeroRespawnLib___HeroRespawn_st_t[this])
set s__HeroRespawnLib___HeroRespawn_st_caster[this]=null
set s__HeroRespawnLib___HeroRespawn_st_killer[this]=null
set s__HeroRespawnLib___HeroRespawn_st_time[this]=0.00
set s__HeroRespawnLib___HeroRespawn_st_x[this]=0.00
set s__HeroRespawnLib___HeroRespawn_st_y[this]=0.00
set si__HeroRespawnLib___HeroRespawn_st_V[this]=-1
return this
endfunction
function s__HeroRespawnLib___HeroRespawn_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: HeroRespawnLib___HeroRespawn_st")
return
elseif(si__HeroRespawnLib___HeroRespawn_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: HeroRespawnLib___HeroRespawn_st")
return
endif
set si__HeroRespawnLib___HeroRespawn_st_V[this]=si__HeroRespawnLib___HeroRespawn_st_F
set si__HeroRespawnLib___HeroRespawn_st_F=this
endfunction
function s__UnitLib__OwnerAfterTime_st__allocate takes nothing returns integer
local integer this=si__UnitLib__OwnerAfterTime_st_F
if(this!=0)then
set si__UnitLib__OwnerAfterTime_st_F=si__UnitLib__OwnerAfterTime_st_V[this]
else
set si__UnitLib__OwnerAfterTime_st_I=si__UnitLib__OwnerAfterTime_st_I+1
set this=si__UnitLib__OwnerAfterTime_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitLib__OwnerAfterTime_st")
return 0
endif
set s__UnitLib__OwnerAfterTime_st_casterPlayer[this]=null
set s__UnitLib__OwnerAfterTime_st_target[this]=null
set s__UnitLib__OwnerAfterTime_st_id[this]=0
set si__UnitLib__OwnerAfterTime_st_V[this]=-1
return this
endfunction
function s__UnitLib__OwnerAfterTime_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitLib__OwnerAfterTime_st")
return
elseif(si__UnitLib__OwnerAfterTime_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitLib__OwnerAfterTime_st")
return
endif
set si__UnitLib__OwnerAfterTime_st_V[this]=si__UnitLib__OwnerAfterTime_st_F
set si__UnitLib__OwnerAfterTime_st_F=this
endfunction
function s__UnitLib__ReplaceAfterTime_st__allocate takes nothing returns integer
local integer this=si__UnitLib__ReplaceAfterTime_st_F
if(this!=0)then
set si__UnitLib__ReplaceAfterTime_st_F=si__UnitLib__ReplaceAfterTime_st_V[this]
else
set si__UnitLib__ReplaceAfterTime_st_I=si__UnitLib__ReplaceAfterTime_st_I+1
set this=si__UnitLib__ReplaceAfterTime_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitLib__ReplaceAfterTime_st")
return 0
endif
set s__UnitLib__ReplaceAfterTime_st_target[this]=null
set s__UnitLib__ReplaceAfterTime_st_id[this]=0
set si__UnitLib__ReplaceAfterTime_st_V[this]=-1
return this
endfunction
function s__UnitLib__ReplaceAfterTime_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitLib__ReplaceAfterTime_st")
return
elseif(si__UnitLib__ReplaceAfterTime_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitLib__ReplaceAfterTime_st")
return
endif
set si__UnitLib__ReplaceAfterTime_st_V[this]=si__UnitLib__ReplaceAfterTime_st_F
set si__UnitLib__ReplaceAfterTime_st_F=this
endfunction
function s__UnitLib__TimedPause_st__allocate takes nothing returns integer
local integer this=si__UnitLib__TimedPause_st_F
if(this!=0)then
set si__UnitLib__TimedPause_st_F=si__UnitLib__TimedPause_st_V[this]
else
set si__UnitLib__TimedPause_st_I=si__UnitLib__TimedPause_st_I+1
set this=si__UnitLib__TimedPause_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitLib__TimedPause_st")
return 0
endif
set s__UnitLib__TimedPause_st_target[this]=null
set si__UnitLib__TimedPause_st_V[this]=-1
return this
endfunction
function s__UnitLib__TimedPause_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitLib__TimedPause_st")
return
elseif(si__UnitLib__TimedPause_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitLib__TimedPause_st")
return
endif
set si__UnitLib__TimedPause_st_V[this]=si__UnitLib__TimedPause_st_F
set si__UnitLib__TimedPause_st_F=this
endfunction
function s__UnitLib__TimedDamage_st__allocate takes nothing returns integer
local integer this=si__UnitLib__TimedDamage_st_F
if(this!=0)then
set si__UnitLib__TimedDamage_st_F=si__UnitLib__TimedDamage_st_V[this]
else
set si__UnitLib__TimedDamage_st_I=si__UnitLib__TimedDamage_st_I+1
set this=si__UnitLib__TimedDamage_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitLib__TimedDamage_st")
return 0
endif
set s__UnitLib__TimedDamage_st_target[this]=null
set s__UnitLib__TimedDamage_st_damage[this]=0
set si__UnitLib__TimedDamage_st_V[this]=-1
return this
endfunction
function s__UnitLib__TimedDamage_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitLib__TimedDamage_st")
return
elseif(si__UnitLib__TimedDamage_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitLib__TimedDamage_st")
return
endif
set si__UnitLib__TimedDamage_st_V[this]=si__UnitLib__TimedDamage_st_F
set si__UnitLib__TimedDamage_st_F=this
endfunction
function s__UnitLib__TimedArmor_st__allocate takes nothing returns integer
local integer this=si__UnitLib__TimedArmor_st_F
if(this!=0)then
set si__UnitLib__TimedArmor_st_F=si__UnitLib__TimedArmor_st_V[this]
else
set si__UnitLib__TimedArmor_st_I=si__UnitLib__TimedArmor_st_I+1
set this=si__UnitLib__TimedArmor_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitLib__TimedArmor_st")
return 0
endif
set s__UnitLib__TimedArmor_st_target[this]=null
set s__UnitLib__TimedArmor_st_armor[this]=0.
set si__UnitLib__TimedArmor_st_V[this]=-1
return this
endfunction
function s__UnitLib__TimedArmor_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitLib__TimedArmor_st")
return
elseif(si__UnitLib__TimedArmor_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitLib__TimedArmor_st")
return
endif
set si__UnitLib__TimedArmor_st_V[this]=si__UnitLib__TimedArmor_st_F
set si__UnitLib__TimedArmor_st_F=this
endfunction
function s__UnitLib__TimedHpRegen_st__allocate takes nothing returns integer
local integer this=si__UnitLib__TimedHpRegen_st_F
if(this!=0)then
set si__UnitLib__TimedHpRegen_st_F=si__UnitLib__TimedHpRegen_st_V[this]
else
set si__UnitLib__TimedHpRegen_st_I=si__UnitLib__TimedHpRegen_st_I+1
set this=si__UnitLib__TimedHpRegen_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitLib__TimedHpRegen_st")
return 0
endif
set s__UnitLib__TimedHpRegen_st_target[this]=null
set s__UnitLib__TimedHpRegen_st_regen[this]=0.
set si__UnitLib__TimedHpRegen_st_V[this]=-1
return this
endfunction
function s__UnitLib__TimedHpRegen_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitLib__TimedHpRegen_st")
return
elseif(si__UnitLib__TimedHpRegen_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitLib__TimedHpRegen_st")
return
endif
set si__UnitLib__TimedHpRegen_st_V[this]=si__UnitLib__TimedHpRegen_st_F
set si__UnitLib__TimedHpRegen_st_F=this
endfunction
function s__UnitLib__TimedMpRegen_st__allocate takes nothing returns integer
local integer this=si__UnitLib__TimedMpRegen_st_F
if(this!=0)then
set si__UnitLib__TimedMpRegen_st_F=si__UnitLib__TimedMpRegen_st_V[this]
else
set si__UnitLib__TimedMpRegen_st_I=si__UnitLib__TimedMpRegen_st_I+1
set this=si__UnitLib__TimedMpRegen_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitLib__TimedMpRegen_st")
return 0
endif
set s__UnitLib__TimedMpRegen_st_target[this]=null
set s__UnitLib__TimedMpRegen_st_regen[this]=0.
set si__UnitLib__TimedMpRegen_st_V[this]=-1
return this
endfunction
function s__UnitLib__TimedMpRegen_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitLib__TimedMpRegen_st")
return
elseif(si__UnitLib__TimedMpRegen_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitLib__TimedMpRegen_st")
return
endif
set si__UnitLib__TimedMpRegen_st_V[this]=si__UnitLib__TimedMpRegen_st_F
set si__UnitLib__TimedMpRegen_st_F=this
endfunction
function s__UnitLib__TimedInvul_st__allocate takes nothing returns integer
local integer this=si__UnitLib__TimedInvul_st_F
if(this!=0)then
set si__UnitLib__TimedInvul_st_F=si__UnitLib__TimedInvul_st_V[this]
else
set si__UnitLib__TimedInvul_st_I=si__UnitLib__TimedInvul_st_I+1
set this=si__UnitLib__TimedInvul_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitLib__TimedInvul_st")
return 0
endif
set s__UnitLib__TimedInvul_st_target[this]=null
set si__UnitLib__TimedInvul_st_V[this]=-1
return this
endfunction
function s__UnitLib__TimedInvul_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitLib__TimedInvul_st")
return
elseif(si__UnitLib__TimedInvul_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitLib__TimedInvul_st")
return
endif
set si__UnitLib__TimedInvul_st_V[this]=si__UnitLib__TimedInvul_st_F
set si__UnitLib__TimedInvul_st_F=this
endfunction
function s__UnitSpawner_st__allocate takes nothing returns integer
local integer this=si__UnitSpawner_st_F
if(this!=0)then
set si__UnitSpawner_st_F=si__UnitSpawner_st_V[this]
else
set si__UnitSpawner_st_I=si__UnitSpawner_st_I+1
set this=si__UnitSpawner_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: UnitSpawner_st")
return 0
endif
set s__UnitSpawner_st_caster[this]=null
set s__UnitSpawner_st_unitID[this]=0
set si__UnitSpawner_st_V[this]=-1
return this
endfunction
function s__UnitSpawner_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: UnitSpawner_st")
return
elseif(si__UnitSpawner_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: UnitSpawner_st")
return
endif
set si__UnitSpawner_st_V[this]=si__UnitSpawner_st_F
set si__UnitSpawner_st_F=this
endfunction
function s__KydesnikLib__Summons_st__allocate takes nothing returns integer
local integer this=si__KydesnikLib__Summons_st_F
if(this!=0)then
set si__KydesnikLib__Summons_st_F=si__KydesnikLib__Summons_st_V[this]
else
set si__KydesnikLib__Summons_st_I=si__KydesnikLib__Summons_st_I+1
set this=si__KydesnikLib__Summons_st_I
endif
if(this>681)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: KydesnikLib__Summons_st")
return 0
endif
set s__KydesnikLib__Summons_st_unitID[this]=(this-1)*12
set s__KydesnikLib__Summons_st_limit[this]=0
set s__KydesnikLib__Summons_st_index[this]=0
set si__KydesnikLib__Summons_st_V[this]=-1
return this
endfunction
function s__KydesnikLib__Summons_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: KydesnikLib__Summons_st")
return
elseif(si__KydesnikLib__Summons_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: KydesnikLib__Summons_st")
return
endif
set si__KydesnikLib__Summons_st_V[this]=si__KydesnikLib__Summons_st_F
set si__KydesnikLib__Summons_st_F=this
endfunction
function s__KydesnikLib__Portals_st__allocate takes nothing returns integer
local integer this=si__KydesnikLib__Portals_st_F
if(this!=0)then
set si__KydesnikLib__Portals_st_F=si__KydesnikLib__Portals_st_V[this]
else
set si__KydesnikLib__Portals_st_I=si__KydesnikLib__Portals_st_I+1
set this=si__KydesnikLib__Portals_st_I
endif
if(this>681)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: KydesnikLib__Portals_st")
return 0
endif
set s__KydesnikLib__Portals_st_unitID[this]=(this-1)*12
set s__KydesnikLib__Portals_st_portal[this]=(this-1)*2
set s__KydesnikLib__Portals_st_caster[this]=null
set s__KydesnikLib__Portals_st_index[this]=0
set s__KydesnikLib__Portals_st_limit[this]=0
set s__KydesnikLib__Portals_st_target[this]=null
set s__KydesnikLib__Portals_st_targetX[this]=0.
set s__KydesnikLib__Portals_st_targetY[this]=0.
set s__KydesnikLib__Portals_st_periodic[this]=0.
set si__KydesnikLib__Portals_st_V[this]=-1
return this
endfunction
function s__KydesnikLib__Portals_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: KydesnikLib__Portals_st")
return
elseif(si__KydesnikLib__Portals_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: KydesnikLib__Portals_st")
return
endif
set si__KydesnikLib__Portals_st_V[this]=si__KydesnikLib__Portals_st_F
set si__KydesnikLib__Portals_st_F=this
endfunction
function s__EffectsLib__TimedRageEffect_st__allocate takes nothing returns integer
local integer this=si__EffectsLib__TimedRageEffect_st_F
if(this!=0)then
set si__EffectsLib__TimedRageEffect_st_F=si__EffectsLib__TimedRageEffect_st_V[this]
else
set si__EffectsLib__TimedRageEffect_st_I=si__EffectsLib__TimedRageEffect_st_I+1
set this=si__EffectsLib__TimedRageEffect_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: EffectsLib__TimedRageEffect_st")
return 0
endif
set s__EffectsLib__TimedRageEffect_st_target[this]=null
set s__EffectsLib__TimedRageEffect_st_percent[this]=0
set s__EffectsLib__TimedRageEffect_st_periodic[this]=0.
set si__EffectsLib__TimedRageEffect_st_V[this]=-1
return this
endfunction
function s__EffectsLib__TimedRageEffect_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: EffectsLib__TimedRageEffect_st")
return
elseif(si__EffectsLib__TimedRageEffect_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: EffectsLib__TimedRageEffect_st")
return
endif
set si__EffectsLib__TimedRageEffect_st_V[this]=si__EffectsLib__TimedRageEffect_st_F
set si__EffectsLib__TimedRageEffect_st_F=this
endfunction
function s__EffectsLib__TimedRageEffectDestroy_st__allocate takes nothing returns integer
local integer this=si__EffectsLib__TimedRageEffectDestroy_st_F
if(this!=0)then
set si__EffectsLib__TimedRageEffectDestroy_st_F=si__EffectsLib__TimedRageEffectDestroy_st_V[this]
else
set si__EffectsLib__TimedRageEffectDestroy_st_I=si__EffectsLib__TimedRageEffectDestroy_st_I+1
set this=si__EffectsLib__TimedRageEffectDestroy_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: EffectsLib__TimedRageEffectDestroy_st")
return 0
endif
set s__EffectsLib__TimedRageEffectDestroy_st_target[this]=null
set s__EffectsLib__TimedRageEffectDestroy_st_changeTime[this]=0.
set s__EffectsLib__TimedRageEffectDestroy_st_time[this]=0.
set si__EffectsLib__TimedRageEffectDestroy_st_V[this]=-1
return this
endfunction
function s__EffectsLib__TimedRageEffectDestroy_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: EffectsLib__TimedRageEffectDestroy_st")
return
elseif(si__EffectsLib__TimedRageEffectDestroy_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: EffectsLib__TimedRageEffectDestroy_st")
return
endif
set si__EffectsLib__TimedRageEffectDestroy_st_V[this]=si__EffectsLib__TimedRageEffectDestroy_st_F
set si__EffectsLib__TimedRageEffectDestroy_st_F=this
endfunction
function s__EffectsLib__DestroyLightningN_st__allocate takes nothing returns integer
local integer this=si__EffectsLib__DestroyLightningN_st_F
if(this!=0)then
set si__EffectsLib__DestroyLightningN_st_F=si__EffectsLib__DestroyLightningN_st_V[this]
else
set si__EffectsLib__DestroyLightningN_st_I=si__EffectsLib__DestroyLightningN_st_I+1
set this=si__EffectsLib__DestroyLightningN_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: EffectsLib__DestroyLightningN_st")
return 0
endif
set s__EffectsLib__DestroyLightningN_st_light[this]=null
set s__EffectsLib__DestroyLightningN_st_percent[this]=0
set s__EffectsLib__DestroyLightningN_st_periodic[this]=0.
set si__EffectsLib__DestroyLightningN_st_V[this]=-1
return this
endfunction
function s__EffectsLib__DestroyLightningN_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: EffectsLib__DestroyLightningN_st")
return
elseif(si__EffectsLib__DestroyLightningN_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: EffectsLib__DestroyLightningN_st")
return
endif
set si__EffectsLib__DestroyLightningN_st_V[this]=si__EffectsLib__DestroyLightningN_st_F
set si__EffectsLib__DestroyLightningN_st_F=this
endfunction
function s__EffectsLib__TimedEffect_st__allocate takes nothing returns integer
local integer this=si__EffectsLib__TimedEffect_st_F
if(this!=0)then
set si__EffectsLib__TimedEffect_st_F=si__EffectsLib__TimedEffect_st_V[this]
else
set si__EffectsLib__TimedEffect_st_I=si__EffectsLib__TimedEffect_st_I+1
set this=si__EffectsLib__TimedEffect_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: EffectsLib__TimedEffect_st")
return 0
endif
set s__EffectsLib__TimedEffect_st_eff[this]=null
set si__EffectsLib__TimedEffect_st_V[this]=-1
return this
endfunction
function s__EffectsLib__TimedEffect_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: EffectsLib__TimedEffect_st")
return
elseif(si__EffectsLib__TimedEffect_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: EffectsLib__TimedEffect_st")
return
endif
set si__EffectsLib__TimedEffect_st_V[this]=si__EffectsLib__TimedEffect_st_F
set si__EffectsLib__TimedEffect_st_F=this
endfunction
function s__EffectsLib__TimedEffectTarget_st__allocate takes nothing returns integer
local integer this=si__EffectsLib__TimedEffectTarget_st_F
if(this!=0)then
set si__EffectsLib__TimedEffectTarget_st_F=si__EffectsLib__TimedEffectTarget_st_V[this]
else
set si__EffectsLib__TimedEffectTarget_st_I=si__EffectsLib__TimedEffectTarget_st_I+1
set this=si__EffectsLib__TimedEffectTarget_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: EffectsLib__TimedEffectTarget_st")
return 0
endif
set s__EffectsLib__TimedEffectTarget_st_target[this]=null
set s__EffectsLib__TimedEffectTarget_st_eff[this]=null
set s__EffectsLib__TimedEffectTarget_st_time[this]=0.
set s__EffectsLib__TimedEffectTarget_st_periodic[this]=0.
set si__EffectsLib__TimedEffectTarget_st_V[this]=-1
return this
endfunction
function s__EffectsLib__TimedEffectTarget_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: EffectsLib__TimedEffectTarget_st")
return
elseif(si__EffectsLib__TimedEffectTarget_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: EffectsLib__TimedEffectTarget_st")
return
endif
set si__EffectsLib__TimedEffectTarget_st_V[this]=si__EffectsLib__TimedEffectTarget_st_F
set si__EffectsLib__TimedEffectTarget_st_F=this
endfunction
function s__EffectsLib__TimedRoundedEffectTarget_st__allocate takes nothing returns integer
local integer this=si__EffectsLib__TimedRoundedEffectTarget_st_F
if(this!=0)then
set si__EffectsLib__TimedRoundedEffectTarget_st_F=si__EffectsLib__TimedRoundedEffectTarget_st_V[this]
else
set si__EffectsLib__TimedRoundedEffectTarget_st_I=si__EffectsLib__TimedRoundedEffectTarget_st_I+1
set this=si__EffectsLib__TimedRoundedEffectTarget_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: EffectsLib__TimedRoundedEffectTarget_st")
return 0
endif
set s__EffectsLib__TimedRoundedEffectTarget_st_target[this]=null
set s__EffectsLib__TimedRoundedEffectTarget_st_eff[this]=null
set s__EffectsLib__TimedRoundedEffectTarget_st_periodic[this]=0.
set s__EffectsLib__TimedRoundedEffectTarget_st_height[this]=0.
set s__EffectsLib__TimedRoundedEffectTarget_st_speed[this]=0.
set s__EffectsLib__TimedRoundedEffectTarget_st_range[this]=0.
set s__EffectsLib__TimedRoundedEffectTarget_st_angle[this]=0.
set s__EffectsLib__TimedRoundedEffectTarget_st_time[this]=0.
set si__EffectsLib__TimedRoundedEffectTarget_st_V[this]=-1
return this
endfunction
function s__EffectsLib__TimedRoundedEffectTarget_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: EffectsLib__TimedRoundedEffectTarget_st")
return
elseif(si__EffectsLib__TimedRoundedEffectTarget_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: EffectsLib__TimedRoundedEffectTarget_st")
return
endif
set si__EffectsLib__TimedRoundedEffectTarget_st_V[this]=si__EffectsLib__TimedRoundedEffectTarget_st_F
set si__EffectsLib__TimedRoundedEffectTarget_st_F=this
endfunction
function s__Controler__allocate takes nothing returns integer
local integer this=si__Controler_F
if(this!=0)then
set si__Controler_F=si__Controler_V[this]
else
set si__Controler_I=si__Controler_I+1
set this=si__Controler_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: Controler")
return 0
endif
set s__Controler_ownerID[this]=0
set s__Controler_caster[this]=null
set s__Controler_target[this]=null
set s__Controler_eff[this]=null
set si__Controler_V[this]=-1
return this
endfunction
function s__Controler_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: Controler")
return
elseif(si__Controler_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: Controler")
return
endif
set si__Controler_V[this]=si__Controler_F
set si__Controler_F=this
endfunction
function s__AbilityLib___AbilityCooldown_st__allocate takes nothing returns integer
local integer this=si__AbilityLib___AbilityCooldown_st_F
if(this!=0)then
set si__AbilityLib___AbilityCooldown_st_F=si__AbilityLib___AbilityCooldown_st_V[this]
else
set si__AbilityLib___AbilityCooldown_st_I=si__AbilityLib___AbilityCooldown_st_I+1
set this=si__AbilityLib___AbilityCooldown_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AbilityLib___AbilityCooldown_st")
return 0
endif
set s__AbilityLib___AbilityCooldown_st_target[this]=null
set s__AbilityLib___AbilityCooldown_st_id[this]=0
set si__AbilityLib___AbilityCooldown_st_V[this]=-1
return this
endfunction
function s__AbilityLib___AbilityCooldown_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AbilityLib___AbilityCooldown_st")
return
elseif(si__AbilityLib___AbilityCooldown_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AbilityLib___AbilityCooldown_st")
return
endif
set si__AbilityLib___AbilityCooldown_st_V[this]=si__AbilityLib___AbilityCooldown_st_F
set si__AbilityLib___AbilityCooldown_st_F=this
endfunction
function s__AbilityLib___TimedAbility_st__allocate takes nothing returns integer
local integer this=si__AbilityLib___TimedAbility_st_F
if(this!=0)then
set si__AbilityLib___TimedAbility_st_F=si__AbilityLib___TimedAbility_st_V[this]
else
set si__AbilityLib___TimedAbility_st_I=si__AbilityLib___TimedAbility_st_I+1
set this=si__AbilityLib___TimedAbility_st_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: AbilityLib___TimedAbility_st")
return 0
endif
set s__AbilityLib___TimedAbility_st_target[this]=null
set s__AbilityLib___TimedAbility_st_time[this]=0.
set s__AbilityLib___TimedAbility_st_id[this]=0
set si__AbilityLib___TimedAbility_st_V[this]=-1
return this
endfunction
function s__AbilityLib___TimedAbility_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: AbilityLib___TimedAbility_st")
return
elseif(si__AbilityLib___TimedAbility_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: AbilityLib___TimedAbility_st")
return
endif
set si__AbilityLib___TimedAbility_st_V[this]=si__AbilityLib___TimedAbility_st_F
set si__AbilityLib___TimedAbility_st_F=this
endfunction
function s__PeriodicDamage__Damager__allocate takes nothing returns integer
local integer this=si__PeriodicDamage__Damager_F
if(this!=0)then
set si__PeriodicDamage__Damager_F=si__PeriodicDamage__Damager_V[this]
else
set si__PeriodicDamage__Damager_I=si__PeriodicDamage__Damager_I+1
set this=si__PeriodicDamage__Damager_I
endif
if(this>8190)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: PeriodicDamage__Damager")
return 0
endif
set s__PeriodicDamage__Damager_Type[this]="none"
set s__PeriodicDamage__Damager_movementAbil[this]=0
set s__PeriodicDamage__Damager_caster[this]=null
set s__PeriodicDamage__Damager_target[this]=null
set s__PeriodicDamage__Damager_eff[this]=null
set s__PeriodicDamage__Damager_periodic[this]=0.
set s__PeriodicDamage__Damager_damage[this]=0.
set s__PeriodicDamage__Damager_time[this]=0.
set si__PeriodicDamage__Damager_V[this]=-1
return this
endfunction
function s__PeriodicDamage__Damager_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: PeriodicDamage__Damager")
return
elseif(si__PeriodicDamage__Damager_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: PeriodicDamage__Damager")
return
endif
set si__PeriodicDamage__Damager_V[this]=si__PeriodicDamage__Damager_F
set si__PeriodicDamage__Damager_F=this
endfunction
function s__InvokerSpheres_st__allocate takes nothing returns integer
local integer this=si__InvokerSpheres_st_F
if(this!=0)then
set si__InvokerSpheres_st_F=si__InvokerSpheres_st_V[this]
else
set si__InvokerSpheres_st_I=si__InvokerSpheres_st_I+1
set this=si__InvokerSpheres_st_I
endif
if(this>2729)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Unable to allocate id for an object of type: InvokerSpheres_st")
return 0
endif
set s__InvokerSpheres_st_Sphere[this]=(this-1)*3
set s__InvokerSpheres_st_Effect[this]=(this-1)*3
set s__InvokerSpheres_st_Buff[this]=(this-1)*3
set s__InvokerSpheres_st_buffEffect[this]=(this-1)*3
set s__InvokerSpheres_st_caster[this]=null
set s__InvokerSpheres_st_index[this]=1
set si__InvokerSpheres_st_V[this]=-1
return this
endfunction
function s__InvokerSpheres_st_deallocate takes integer this returns nothing
if this==null then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Attempt to destroy a null struct of type: InvokerSpheres_st")
return
elseif(si__InvokerSpheres_st_V[this]!=-1)then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,1000.,"Double free of type: InvokerSpheres_st")
return
endif
set si__InvokerSpheres_st_V[this]=si__InvokerSpheres_st_F
set si__InvokerSpheres_st_F=this
endfunction
function InitBytecode takes integer id,integer k returns nothing
set l__bytecode[0]=0x0C010900
set l__bytecode[1]=k
set l__bytecode[2]=0x11010000
set l__bytecode[3]=id
set l__bytecode[4]=0x0C010400
set l__bytecode[6]=0x27000000
set l__bytecode[8]=0x07090000
set l__bytecode[9]=0x005E
set l__bytecode[10]=0x0E010400
set l__bytecode[11]=id+0x1
set l__bytecode[12]=0x12010100
set l__bytecode[13]=0x005E
set l__bytecode[14]=0x0E010400
set l__bytecode[15]=0x005E
set l__bytecode[16]=0x11010000
set l__bytecode[17]=id+0x1
set l__bytecode[18]=0x27000000
endfunction
function Typecast takes nothing returns nothing
local integer l__bytecode
endfunction
function GetBytecodeAddress takes nothing returns integer
loop
return l__bytecode
endloop
return 0
endfunction
function InitArray takes integer vtable returns nothing
set l__Array[4]=0
set l__Array[1]=vtable
set l__Array[2]=-1
set l__Array[3]=-1
endfunction
function InitArrayA takes integer index,integer valueA returns nothing
set l__ArrayA[1000]=0
set l__ArrayA[index+3]=valueA
set l__ArrayA[index+2]=valueA
set l__ArrayA[index+1]=valueA
set l__ArrayA[index]=valueA
set l__ArrayA[index-1]=valueA
set l__ArrayA[index-2]=valueA
set l__ArrayA[index-3]=valueA
endfunction
function InitArrayB takes integer index,integer valueB returns nothing
set l__ArrayB[1000]=0
set l__ArrayB[index]=valueB
endfunction
function WriteArrayBMemory takes integer addr,integer value returns nothing
local integer ii=addr
set l__ArrayB[ii]=value
endfunction
function InitArrayC takes integer valueC returns nothing
set l__ArrayC[4]=0
set l__ArrayC[3]=valueC
set l__ArrayC[2]=valueC
set l__ArrayC[1]=valueC
set l__ArrayC[0]=valueC
endfunction
function InitArrayD takes integer index,integer valueD returns nothing
set l__ArrayD[1001]=0
set l__ArrayD[index]=valueD
endfunction
function InitArrayE takes integer valueE returns nothing
set l__ArrayE[4]=0
set l__ArrayE[3]=valueE
set l__ArrayE[2]=valueE
set l__ArrayE[1]=valueE
set l__ArrayE[0]=valueE
endfunction
function TypecastArray takes nothing returns nothing
local integer l__Array
endfunction
function GetArrayAddress takes nothing returns integer
loop
return l__Array
endloop
return 0
endfunction
function TypecastArrayA takes nothing returns nothing
local integer l__ArrayA
endfunction
function GetArrayAAddress takes nothing returns integer
loop
return l__ArrayA
endloop
return 0
endfunction
function TypecastArrayB takes nothing returns nothing
local integer l__ArrayB
endfunction
function GetArrayBAddress takes nothing returns integer
loop
return l__ArrayB
endloop
return 0
endfunction
function TypecastArrayC takes nothing returns nothing
local integer l__ArrayC
endfunction
function GetArrayCAddress takes nothing returns integer
loop
return l__ArrayC
endloop
return 0
endfunction
function TypecastArrayD takes nothing returns nothing
local integer l__ArrayD
endfunction
function GetArrayDAddress takes nothing returns integer
loop
return l__ArrayD
endloop
return 0
endfunction
function TypecastArrayE takes nothing returns nothing
local integer l__ArrayE
endfunction
function GetArrayEAddress takes nothing returns integer
loop
return l__ArrayE
endloop
return 0
endfunction
function setCode takes code c returns nothing
set l__Code=c
return
endfunction
function setInt takes integer i returns nothing
set l__Int=i
return
endfunction
function setStr takes string s returns nothing
set l__Str=s
return
endfunction
function setBool takes boolean b returns nothing
set l__Bool=b
return
endfunction
function setHandle takes handle h returns nothing
set l__Handle=h
return
endfunction
function setUnit takes unit u returns nothing
set l__Unit=u
return
endfunction
function setAbility takes ability a returns nothing
set l__Abil=a
return
endfunction
function setTrig takes trigger t returns nothing
set l__Trig=t
return
endfunction
function Typecast1 takes nothing returns nothing
local integer l__Code
local code l__Int
endfunction
function C2I takes code c returns integer
call setCode(c)
loop
return l__Code
endloop
return 0
endfunction
function I2C takes integer i returns code
call setInt(i)
loop
return l__Int
endloop
return null
endfunction
function Typecast2 takes nothing returns nothing
local integer l__Str
local string l__Int
endfunction
function SH2I takes string s returns integer
call setStr(s)
loop
return l__Str
endloop
return 0
endfunction
function I2SH takes integer i returns string
call setInt(i)
loop
return l__Int
endloop
return null
endfunction
function Typecast3 takes nothing returns nothing
local integer l__Bool
local boolean l__Int
endfunction
function B2I takes boolean b returns integer
call setBool(b)
loop
return l__Bool
endloop
return 0
endfunction
function I2B takes integer i returns boolean
call setInt(i)
loop
return l__Int
endloop
return false
endfunction
function Typecast4 takes nothing returns nothing
local integer l__Handle
local handle l__Int
endfunction
function H2I takes handle h returns integer
call setHandle(h)
loop
return l__Handle
endloop
return 0
endfunction
function I2H takes integer i returns handle
call setInt(i)
loop
return l__Int
endloop
return null
endfunction
function Typecast5 takes nothing returns nothing
local integer l__Unit
local unit l__Int
endfunction
function U2I takes unit u returns integer
call setUnit(u)
loop
return l__Unit
endloop
return 0
endfunction
function I2U takes integer i returns unit
call setInt(i)
loop
return l__Int
endloop
return null
endfunction
function Typecast6 takes nothing returns nothing
local integer l__Abil
local ability l__Int
endfunction
function A2I takes ability a returns integer
call setAbility(a)
loop
return l__Abil
endloop
return 0
endfunction
function I2A takes integer i returns ability
call setInt(i)
loop
return l__Int
endloop
return null
endfunction
function Typecast7 takes nothing returns nothing
local integer l__Trig
local trigger l__Int
endfunction
function T2I takes trigger t returns integer
call setTrig(t)
loop
return l__Trig
endloop
return 0
endfunction
function I2T takes integer i returns trigger
call setInt(i)
return l__Int
endfunction
function RealToIndex takes real r returns integer
loop
return r
endloop
return 0
endfunction
function CleanInt takes integer i returns integer
return i
endfunction
function IndexToReal takes integer i returns real
loop
return i
endloop
return 0.
endfunction
function CleanReal takes real r returns real
return r
endfunction
function GetRealFromMemory takes integer i returns real
return CleanReal(IndexToReal(i))
endfunction
function SetRealIntoMemory takes real r returns integer
return CleanInt(RealToIndex(r))
endfunction
function BitwiseNot takes integer i returns integer
return 0xFFFFFFFF-i
endfunction
function Init_APITypecast takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
elseif PatchVersion=="1.26a" then
elseif PatchVersion=="1.27a" then
elseif PatchVersion=="1.27b" then
elseif PatchVersion=="1.28f" then
endif
endif
endfunction
function absI takes integer number returns integer
if number<0 then
return-number
endif
return number
endfunction
function absF takes real r returns real
if r<0. then
return-r
endif
return r
endfunction
function floorF takes real r returns real
if r<0. then
return-I2R(R2I(-r))
endif
return I2R(R2I(r))
endfunction
function floorI takes integer i returns integer
return R2I(floorF(I2R(i)))
endfunction
function ceilF takes real r returns real
if floorF(r)==r then
return r
elseif r<0. then
return-(I2R(R2I(-r))+1.)
endif
return I2R(R2I(r))+1.
endfunction
function ceilI takes integer i returns integer
return R2I(ceilF(I2R(i)))
endfunction
function roundF takes real r returns real
if r>0. then
return I2R(R2I(r+.5))
endif
return I2R(R2I(r-.5))
endfunction
function roundI takes integer i returns integer
return R2I(roundF(I2R(i)))
endfunction
function log takes integer number,integer base returns integer
local integer id=1
if number>0 then
loop
exitwhen number/ base<=1
set id=id+1
set number=number/ base
endloop
return id
endif
return 0
endfunction
function PowI takes integer x,integer power returns integer
local integer y=x
if power==0 then
set x=1
elseif power>1 then
loop
set power=power-1
exitwhen power==0
set x=x*y
endloop
endif
return x
endfunction
function B2S takes boolean flag returns string
if flag then
return"yes"
endif
return"no"
endfunction
function CharToId takes string input returns integer
local integer pos=0
local string char
loop
set char=SubString(sLetters,pos,pos+1)
exitwhen char==null or char==input
set pos=pos+1
endloop
if pos<10 then
return pos+48
elseif pos<36 then
return pos+65-10
endif
return pos+97-36
endfunction
function StringToId takes string input returns integer
return((CharToId(SubString(input,0,1))*256+CharToId(SubString(input,1,2)))*256+CharToId(SubString(input,2,3)))*256+CharToId(SubString(input,3,4))
endfunction
function IdToChar takes integer input returns string
local integer pos=input-48
if input>=97 then
set pos=input-97+36
elseif input>=65 then
set pos=input-65+10
endif
return SubString(sLetters,pos,pos+1)
endfunction
function IdToString takes integer input returns string
local integer result=input/ 256
local string char=IdToChar(input-256*result)
set input=result/ 256
set char=IdToChar(result-256*input)+char
set result=input/ 256
return IdToChar(result)+IdToChar(input-256*result)+char
endfunction
function GetIntHex takes integer i returns string
local string result=""
local integer numb=absI(i)
if numb>=0 and numb<=15 then
if numb<=9 then
set result=I2S(numb)
elseif numb==10 then
set result="A"
elseif numb==11 then
set result="B"
elseif numb==12 then
set result="C"
elseif numb==13 then
set result="D"
elseif numb==14 then
set result="E"
elseif numb==15 then
set result="F"
endif
endif
return result
endfunction
function IntToHex takes integer i returns string
local string result=""
local boolean ispos=i>=0
local integer numb=absI(i)
local integer j=0
loop
exitwhen numb==0
set j=numb-(numb/ 16)*16
set result=GetIntHex(j)+result
set numb=(numb-j)/ 16
endloop
set result="0x"+result
if not ispos then
set result="-"+result
endif
return result
endfunction
function PrintData takes string path,string s,boolean flag returns nothing
if not IsPrint then
call PreloadGenClear()
call PreloadGenStart()
set IsPrint=true
endif
if IsPrint then
call Preload(s)
if flag then
call PreloadGenEnd(path)
set IsPrint=false
endif
endif
endfunction
function GetByteFromInteger takes integer i,integer byteid returns integer
local integer tmpval=i
local integer retval=0
local integer byte1=0
local integer byte2=0
local integer byte3=0
local integer byte4=0
if tmpval<0 then
set tmpval=BitwiseNot(tmpval)
set byte4=255-ModuloInteger(tmpval,256)
set tmpval=tmpval/ 256
set byte3=255-ModuloInteger(tmpval,256)
set tmpval=tmpval/ 256
set byte2=255-ModuloInteger(tmpval,256)
set tmpval=tmpval/ 256
set byte1=255-tmpval
else
set byte4=ModuloInteger(tmpval,256)
set tmpval=tmpval/ 256
set byte3=ModuloInteger(tmpval,256)
set tmpval=tmpval/ 256
set byte2=ModuloInteger(tmpval,256)
set tmpval=tmpval/ 256
set byte1=tmpval
endif
if byteid==1 then
return byte1
elseif byteid==2 then
return byte2
elseif byteid==3 then
return byte3
elseif byteid==4 then
return byte4
endif
return retval
endfunction
function CreateInteger1 takes integer byte1,integer byte2,integer byte3,integer byte4 returns integer
local integer retval=byte1
set retval=(retval*256)+byte2
set retval=(retval*256)+byte3
set retval=(retval*256)+byte4
return retval
endfunction
function CreateIntegerFromTwoByOffset takes integer LocalInteger1,integer LocalInteger2,integer offset returns integer
local integer array pBytes
set pBytes[0]=GetByteFromInteger(LocalInteger1,4)
set pBytes[1]=GetByteFromInteger(LocalInteger1,3)
set pBytes[2]=GetByteFromInteger(LocalInteger1,2)
set pBytes[3]=GetByteFromInteger(LocalInteger1,1)
set pBytes[4]=GetByteFromInteger(LocalInteger2,4)
set pBytes[5]=GetByteFromInteger(LocalInteger2,3)
set pBytes[6]=GetByteFromInteger(LocalInteger2,2)
set pBytes[7]=GetByteFromInteger(LocalInteger2,1)
return CreateInteger1(pBytes[offset+3],pBytes[offset+2],pBytes[offset+1],pBytes[offset+0])
endfunction
function CreateDoubleIntegerAndGetOne takes integer LocalInteger1,integer LocalInteger2,integer value,integer offset,boolean first returns integer
local integer array pBytes
set pBytes[0]=GetByteFromInteger(LocalInteger1,4)
set pBytes[1]=GetByteFromInteger(LocalInteger1,3)
set pBytes[2]=GetByteFromInteger(LocalInteger1,2)
set pBytes[3]=GetByteFromInteger(LocalInteger1,1)
set pBytes[4]=GetByteFromInteger(LocalInteger2,4)
set pBytes[5]=GetByteFromInteger(LocalInteger2,3)
set pBytes[6]=GetByteFromInteger(LocalInteger2,2)
set pBytes[7]=GetByteFromInteger(LocalInteger2,1)
set pBytes[offset+0]=GetByteFromInteger(value,4)
set pBytes[offset+1]=GetByteFromInteger(value,3)
set pBytes[offset+2]=GetByteFromInteger(value,2)
set pBytes[offset+3]=GetByteFromInteger(value,1)
if first then
return CreateInteger1(pBytes[3],pBytes[2],pBytes[1],pBytes[0])
else
return CreateInteger1(pBytes[7],pBytes[6],pBytes[5],pBytes[4])
endif
endfunction
function ReadMemory takes integer address returns integer
return l__Memory[address/ 4]
endfunction
function ReadRealMemorySafe takes integer addr returns integer
local integer ByteOffset=addr-(addr/ 4*4)
local integer FirstAddr=addr-ByteOffset
return CreateIntegerFromTwoByOffset(l__Memory[FirstAddr/ 4],l__Memory[FirstAddr/ 4+1],ByteOffset)
endfunction
function ReadUnrealMemory takes integer address returns integer
if address*4<0x7Fffffff and address>0x500 then
return l__Memory[address]
endif
return 0
endfunction
function ReadRealMemory takes integer address returns integer
if address<0x500 or address>0x7FFFFFFF then
return 0
endif
if address/ 4*4!=address then
return ReadRealMemorySafe(address)
else
return ReadMemory(address)
endif
endfunction
function RMem takes integer address returns integer
return ReadRealMemory(address)
endfunction
function ReadOffset takes integer pOff returns integer
return ReadRealMemory(pGameDLL+pOff)
endfunction
function ReadOffsetUnsafe takes integer pOff returns integer
return ReadUnrealMemory((pGameDLL+pOff)/ 4)
endfunction
function ReadByte takes integer byte returns integer
return GetByteFromInteger(ReadRealMemory(byte),4)
endfunction
function ReadRealFloat takes integer address returns real
return GetRealFromMemory(ReadRealMemory(address))
endfunction
function WriteMemory takes integer address,integer value returns nothing
set l__Memory[address/ 4]=value
endfunction
function WriteRealMemorySafe takes integer addr,integer val returns nothing
local integer Int_1
local integer Int_2
local integer ByteOffset=addr-(addr/ 4*4)
local integer FirstAddr=addr-ByteOffset
set Int_1=ReadRealMemory(FirstAddr)
set Int_2=ReadRealMemory(FirstAddr+0x4)
set l__Memory[FirstAddr/ 4]=CreateDoubleIntegerAndGetOne(Int_1,Int_2,val,ByteOffset,true)
set l__Memory[FirstAddr/ 4+1]=CreateDoubleIntegerAndGetOne(Int_1,Int_2,val,ByteOffset,false)
endfunction
function WriteUnrealMemory takes integer address,integer value returns nothing
if address>0x500 and address*4<0x7FFFFFFF then
set l__Memory[address]=value
return
endif
endfunction
function WriteRealMemory takes integer address,integer value returns nothing
if address<0x500 or address>0x7FFFFFFF then
return
endif
if address==pWriteMemory then
return
endif
if address/ 4*4!=address then
call WriteRealMemorySafe(address,value)
else
call WriteMemory(address,value)
endif
endfunction
function WMem takes integer address,integer value returns nothing
call WriteRealMemory(address,value)
endfunction
function WriteOffset takes integer pOff,integer value returns nothing
call WriteRealMemory(pGameDLL+pOff,value)
endfunction
function WriteOffsetUnsafe takes integer pOff,integer value returns nothing
call WriteUnrealMemory(pGameDLL+pOff,value)
endfunction
function WriteRealFloat takes integer address,real value returns nothing
call WriteRealMemory(address,SetRealIntoMemory(value))
endfunction
function NewGlobal takes nothing returns integer
return-0x005E0704
return 0x2700
endfunction
function SetGlobal takes nothing returns nothing
local integer i=0x2114D008
endfunction
function Malloc takes integer bytes returns integer
set iBytecodeData=bytes/ 4+0x4
call ForForce(bj_FORCE_PLAYER[0],I2C(l__Memory[GetBytecodeAddress()/ 4+0x3]+0x20))
return(ReadUnrealMemory(iBytecodeData/ 4+0x3)+0x4)/ 4*4
endfunction
function ConvertPointer takes integer ptr returns integer
local integer i=ReadRealMemory(ptr)
if i<0 then
return ReadRealMemory(ReadRealMemory(pPointers+0x2C)-i*8+0x4)
endif
return ReadRealMemory(ReadRealMemory(pPointers+0xC)+i*8+0x4)
endfunction
function ReadRealPointer1LVL takes integer addr,integer offset1 returns integer
local integer retval=0
if addr>0 then
set retval=ReadRealMemory(addr)
if addr>0 then
set retval=ReadRealMemory(retval+offset1)
else
set retval=0
endif
endif
return retval
endfunction
function WriteRealPointer1LVL takes integer addr,integer offset1,integer val returns nothing
local integer retval=0
if addr>0 then
set retval=ReadRealMemory(addr)
if addr>0 then
call WriteRealMemory(retval+offset1,val)
endif
endif
endfunction
function ReadRealPointer2LVL takes integer addr,integer offset1,integer offset2 returns integer
local integer retval=ReadRealPointer1LVL(addr,offset1)
if retval>0 then
set retval=ReadRealMemory(retval+offset2)
else
set retval=0
endif
return retval
endfunction
function WriteRealPointer2LVL takes integer addr,integer offset1,integer offset2,integer val returns nothing
local integer retval=0
if addr>0 then
set retval=ReadRealPointer1LVL(addr,offset1)
if addr>0 then
call WriteRealMemory(retval+offset2,val)
endif
endif
endfunction
function ReadRealPointer3LVL takes integer addr,integer offset1,integer offset2,integer offset3 returns integer
local integer retval=ReadRealPointer2LVL(addr,offset1,offset2)
if retval>0 then
set retval=ReadRealMemory(retval+offset3)
else
set retval=0
endif
return retval
endfunction
function WriteRealPointer3LVL takes integer addr,integer offset1,integer offset2,integer offset3,integer val returns nothing
local integer retval=0
if addr>0 then
set retval=ReadRealPointer2LVL(addr,offset1,offset2)
if addr>0 then
call WriteRealMemory(retval+offset3,val)
endif
endif
endfunction
function ReadRealPointer4LVL takes integer addr,integer offset1,integer offset2,integer offset3,integer offset4 returns integer
local integer retval=ReadRealPointer3LVL(addr,offset1,offset2,offset3)
if retval>0 then
set retval=ReadRealMemory(retval+offset4)
else
set retval=0
endif
return retval
endfunction
function WriteRealPointer4LVL takes integer addr,integer offset1,integer offset2,integer offset3,integer offset4,integer val returns nothing
local integer retval=0
if addr>0 then
set retval=ReadRealPointer3LVL(addr,offset1,offset2,offset3)
if addr>0 then
call WriteRealMemory(retval+offset4,val)
endif
endif
endfunction
function ReadRealPointer5LVL takes integer addr,integer offset1,integer offset2,integer offset3,integer offset4,integer offset5 returns integer
local integer retval=ReadRealPointer4LVL(addr,offset1,offset2,offset3,offset4)
if retval>0 then
set retval=ReadRealMemory(retval+offset5)
else
set retval=0
endif
return retval
endfunction
function WriteRealPointer5LVL takes integer addr,integer offset1,integer offset2,integer offset3,integer offset4,integer offset5,integer val returns nothing
local integer retval=0
if addr>0 then
set retval=ReadRealPointer4LVL(addr,offset1,offset2,offset3,offset4)
if addr>0 then
call WriteRealMemory(retval+offset5,val)
endif
endif
endfunction
function IsJassNativeExists takes integer nativeaddress returns boolean
local integer FirstAddress=ReadRealPointer2LVL(pJassEnvAddress,0x14,0x20)
local integer NextAddress=FirstAddress
local integer i=0
loop
if ReadRealMemory(NextAddress+0xC)==nativeaddress then
return NextAddress>0
endif
set NextAddress=ReadRealMemory(NextAddress)
if NextAddress==FirstAddress or NextAddress==0 then
return false
endif
endloop
return false
endfunction
function CreateJassNativeHook takes integer oldaddress,integer newaddress returns integer
local integer FirstAddress=ReadRealPointer2LVL(pJassEnvAddress,0x14,0x20)
local integer NextAddress=FirstAddress
local integer i=0
if RJassNativesBufferSize>0 then
loop
set i=i+1
if RJassNativesBuffer[i*3-0x3]==oldaddress or RJassNativesBuffer[i*3-0x2]==oldaddress or RJassNativesBuffer[i*3-0x3]==newaddress or RJassNativesBuffer[i*3-0x2]==newaddress then
call WriteRealMemory(RJassNativesBuffer[i*3-0x1],newaddress)
return RJassNativesBuffer[i*3-0x1]
endif
exitwhen i==RJassNativesBufferSize
endloop
endif
loop
if ReadRealMemory(NextAddress+0xC)<0x3000 then
return 0
endif
if ReadRealMemory(NextAddress+0xC)==oldaddress then
call WriteRealMemory(NextAddress+0xC,newaddress)
if RJassNativesBufferSize<100 then
set RJassNativesBufferSize=RJassNativesBufferSize+1
set RJassNativesBuffer[RJassNativesBufferSize*3-0x1]=NextAddress+0xC
set RJassNativesBuffer[RJassNativesBufferSize*3-0x2]=oldaddress
set RJassNativesBuffer[RJassNativesBufferSize*3-0x3]=newaddress
endif
return NextAddress+0xC
endif
set NextAddress=ReadRealMemory(NextAddress)
if NextAddress==FirstAddress or NextAddress==0 then
return 0
endif
endloop
return 0
endfunction
function GetJassVM takes integer id returns integer
local integer result=0
if pJassEnvAddress>0 then
set result=ReadRealMemory(ReadRealMemory(ReadRealMemory(ReadRealMemory(pJassEnvAddress)+0x14)+0x90)+0x4*id)
if id==1 then
if JassVM<=0 then
set JassVM=result
endif
endif
endif
return result
endfunction
function GetJassTable takes nothing returns integer
local integer jvm=GetJassVM(1)
if jvm>0 then
return ReadRealMemory(ReadRealMemory(ReadRealMemory(jvm+0x28A4))+0x19C)
endif
return 0
endfunction
function GetStringAddress takes string s returns integer
local integer jvm=GetJassVM(1)
if jvm>0 then
return ReadRealMemory(ReadRealMemory(ReadRealMemory(ReadRealMemory(jvm+0x2874)+0x8)+SH2I(s)*0x10+0x8)+0x1C)
endif
return 0
endfunction
function BitwiseOperation takes integer memaddr,integer arg1,integer arg2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("JassNative"),StringHash("ConvertUnits"))
local integer func=LoadInteger(MemHackTable,StringHash("MemCall"),StringHash("ConvertUnits"))
local integer retval=0
if addr!=0 and memaddr!=0 then
if func==0 then
set func=CreateJassNativeHook(addr,memaddr)
call SaveInteger(MemHackTable,StringHash("MemCall"),StringHash("ConvertUnits"),func)
endif
if func!=0 then
call WriteRealMemory(func,memaddr)
set retval=B2I(ConvertUnits(arg1,arg2))
call WriteRealMemory(func,addr)
endif
endif
return retval
endfunction
function ExecuteBytecode takes integer memaddr returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("JassNative"),StringHash("IgnoredUnits"))
local integer func=LoadInteger(MemHackTable,StringHash("MemCall"),StringHash("IgnoredUnits"))
local integer pOffset1=0
if addr!=0 and memaddr!=0 then
if func==0 then
set func=CreateJassNativeHook(addr,memaddr)
call SaveInteger(MemHackTable,StringHash("MemCall"),StringHash("IgnoredUnits"),func)
endif
if func!=0 then
call WriteRealMemory(func,memaddr)
set pOffset1=IgnoredUnits(0)
call WriteRealMemory(func,addr)
endif
endif
return pOffset1
endfunction
function AllocateExecutableMemory takes integer size returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("JassNative"),StringHash("MergeUnits"))
local integer func=LoadInteger(MemHackTable,StringHash("MemCall"),StringHash("MergeUnits"))
local integer valloc=LoadInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("VirtualAlloc"))
local integer retval=0
if valloc!=0 and addr!=0 then
if func==0 then
set func=CreateJassNativeHook(addr,valloc)
call SaveInteger(MemHackTable,StringHash("MemCall"),StringHash("MergeUnits"),func)
endif
if func!=0 then
call WriteRealMemory(func,valloc)
set retval=B2I(MergeUnits(0,size+4,0x3000,0x40))
call WriteRealMemory(func,addr)
endif
if retval!=0 then
return(retval+0x4)/ 4*4
endif
endif
return 0
endfunction
function AllocatePointerArray takes string name,integer id,integer size returns nothing
if not HaveSavedInteger(MemHackTable,StringHash(name),id)then
call SaveInteger(MemHackTable,StringHash(name),id,Malloc(size))
call SaveInteger(MemHackTable,StringHash(name+"Size"),id,size)
endif
endfunction
function InitMemoryArray takes integer id,integer val returns nothing
set l__Memory[id]=val
endfunction
function TypecastMemoryArray takes nothing returns nothing
local integer l__Memory
endfunction
function GetMemoryArrayAddress takes nothing returns integer
loop
return l__Memory
endloop
return 0
endfunction
function UnlockMemEx takes nothing returns nothing
local integer array i
local integer a
local integer b
local integer offset
call InitArrayA(0,0)
call InitArrayA(0,i[GetArrayAAddress()/ 4])
call InitArrayB(0,0)
call InitArrayB(0,i[GetArrayBAddress()/ 4])
call InitArrayC(0)
call InitArrayC(i[GetArrayCAddress()/ 4])
call InitArrayD(0,0)
call InitArrayD(0,i[GetArrayDAddress()/ 4])
call InitArrayE(0)
call InitArrayE(i[GetArrayEAddress()/ 4])
set JassVM=i[i[i[i[pJassEnvAddress/ 4]/ 4+5]/ 4+36]/ 4+1]
if JassVM>0 then
set JassTable=i[i[i[JassVM/ 4+0x28A4/ 4]/ 4]/ 4+0x19C/ 4]
if JassTable>0 then
set offset=(i[GetArrayDAddress()/ 4+3]+4)-(i[GetArrayBAddress()/ 4+3])
call InitArrayD(1+0x1C/ 4,pUnlockCall1)
call InitArrayD(1+0xA4/ 4,pUnlockCall2)
call InitArrayD(1+0x5C/ 4,pUnlockJmp1)
call InitArrayD(1+0x04/ 4,GetArrayBAddress()-offset+0x8)
call InitArrayD(1,GetArrayBAddress()+0x8)
call InitArrayB(1,i[GetArrayDAddress()/ 4+3]+1*4)
call InitArrayB(2,pMemory)
call InitArrayA(4,i[GetArrayBAddress()/ 4+3]+4)
set b=JassTable-ModuloInteger(i[GetArrayAAddress()/ 4+3]/ 4+4,3)
set a=(i[GetArrayAAddress()/ 4+3]/ 4+4-b/ 4+0x2FFFFF)/ 3
call SetUnitUserData(I2U(a),23)
call WriteArrayBMemory(0+offset/ 4,0xFFFFFFFF)
call WriteArrayBMemory(1+offset/ 4,0)
call WriteArrayBMemory(1+GetArrayBAddress()/ 4,0xFFFFFFFF)
call WriteArrayBMemory(pMemory/ 4+1,0xFFFFFFFF)
call WriteArrayBMemory(pMemory/ 4+2,0xFFFFFFFF)
call WriteArrayBMemory(pMemory/ 4+3,0)
endif
endif
endfunction
function UnlockMemory takes nothing returns nothing
local integer array i
local boolean IsExtra=false
call ForForce(bj_FORCE_PLAYER[0],I2C(C2I(function NewGlobal)+0x2))
call ForForce(bj_FORCE_PLAYER[0],I2C(C2I(function SetGlobal)+0x8))
call InitArray(0)
set pGameDLL=i[GetArrayAddress()/ 4]
call InitArray(pGameDLL)
call InitMemoryArray(10,0)
set pMemory=GetMemoryArrayAddress()
set iGameVersion=pGameDLL-i[pGameDLL/ 4]
if iGameVersion==0x5084A8 then
set PatchVersion="1.24e"
set pGameDLL=pGameDLL-0x9631B8
set pJassEnvAddress=pGameDLL+0xAF16A8
set pWriteMemory=pGameDLL+0x9B26C0
set pPointers=ReadRealMemory(pGameDLL+0xACE5E0)
elseif iGameVersion==0x4F6E60 then
set PatchVersion="1.26a"
set pGameDLL=pGameDLL-0x951060
set pJassEnvAddress=pGameDLL+0xADA848
set pWriteMemory=pGameDLL+0xBE6188
set pPointers=ReadRealMemory(pGameDLL+0xAB7788)
elseif iGameVersion==0x277890 then
set PatchVersion="1.27a"
set pGameDLL=pGameDLL-0xA63B30
set pJassEnvAddress=pGameDLL+0xBE3740
set pWriteMemory=pGameDLL+0xAB5948
set pPointers=ReadRealMemory(pGameDLL+0xBE40A8)
elseif iGameVersion==0x2C1554 then
set PatchVersion="1.27b"
set pGameDLL=pGameDLL-0xBD7214
set pJassEnvAddress=pGameDLL+0xD46118
set pWriteMemory=pGameDLL+0xC2E428
set pPointers=ReadRealMemory(pGameDLL+0xD68610)
set pUnlockCall1=pGameDLL+0x3F4C50
set pUnlockCall2=pGameDLL+0x124142
set pUnlockJmp1=pGameDLL+0x684BA0
set IsExtra=true
elseif iGameVersion==0x2BF828 then
set PatchVersion="1.28f"
set pGameDLL=pGameDLL-0xB8A438
set pJassEnvAddress=pGameDLL+0xD0DEF8
set pWriteMemory=pGameDLL+0xBEAF90
set pPointers=ReadRealMemory(pGameDLL+0xD30448)
set pUnlockCall1=pGameDLL+0x428D30
set pUnlockCall2=pGameDLL+0x152802
set pUnlockJmp1=pGameDLL+0x6B8D30
set IsExtra=true
else
set iGameVersion=0
endif
if IsExtra then
call ForForce(bj_FORCE_PLAYER[0],I2C(C2I(function UnlockMemEx)+0x8))
endif
call InitBytecode(i[(C2I(function ReadMemory)+0x34)/ 4],i[(GetArrayAddress()+0xC)/ 4]+0x4)
call ForForce(bj_FORCE_PLAYER[0],I2C(i[(GetBytecodeAddress()+0xC)/ 4]))
endfunction
function Init_APIMemory takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("MergeUnits"),pGameDLL+0x2DDE40)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("IgnoredUnits"),pGameDLL+0x2DD9A0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("ConvertUnits"),pGameDLL+0x2DDE00)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("GetUnitCount"),pGameDLL+0x2DDB70)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("AttackMoveXY"),pGameDLL+0x2DE730)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadInteger"),pGameDLL+0x3CB5D0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadBoolean"),pGameDLL+0x3CB650)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("MergeUnits"),pGameDLL+0x2DD320)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("IgnoredUnits"),pGameDLL+0x2DCE80)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("ConvertUnits"),pGameDLL+0x2DD2E0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("GetUnitCount"),pGameDLL+0x2DD050)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("AttackMoveXY"),pGameDLL+0x2DDC10)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadInteger"),pGameDLL+0x3CAA90)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadBoolean"),pGameDLL+0x3CAB10)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("MergeUnits"),pGameDLL+0x891F20)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("IgnoredUnits"),pGameDLL+0x890FB0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("ConvertUnits"),pGameDLL+0x88E350)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("GetUnitCount"),pGameDLL+0x890750)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("AttackMoveXY"),pGameDLL+0x88CFE0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadInteger"),pGameDLL+0x1F0710)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadBoolean"),pGameDLL+0x1F04D0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("MergeUnits"),pGameDLL+0x9BD020)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("IgnoredUnits"),pGameDLL+0x9BC0B0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("ConvertUnits"),pGameDLL+0x9B9450)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("GetUnitCount"),pGameDLL+0x9BB850)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("AttackMoveXY"),pGameDLL+0x9B80E0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadInteger"),pGameDLL+0x20E150)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadBoolean"),pGameDLL+0x20DF10)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("MergeUnits"),pGameDLL+0x971FB0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("IgnoredUnits"),pGameDLL+0x971040)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("ConvertUnits"),pGameDLL+0x96E3E0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("GetUnitCount"),pGameDLL+0x9707E0)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("AttackMoveXY"),pGameDLL+0x96D070)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadInteger"),pGameDLL+0x240940)
call SaveInteger(MemHackTable,StringHash("JassNative"),StringHash("LoadBoolean"),pGameDLL+0x240700)
endif
call AllocatePointerArray("StringArray",0,3000)
call AllocatePointerArray("PointerArray",0,0x10)
endif
endfunction
function fast_call_0 takes integer funcaddr returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_0"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x0,0xBEF68B56)
call WriteRealMemory(addr+0x8,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x4,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_1 takes integer funcaddr,integer arg1 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_1"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x0,0xB9F68B56)
call WriteRealMemory(addr+0x8,0xBEF68B90)
call WriteRealMemory(addr+0x10,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x4,arg1)
call WriteRealMemory(addr+0xC,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_2 takes integer funcaddr,integer arg1,integer arg2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_2"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0xBAF68B56)
call WriteRealMemory(addr+0x08,0xB9F68B90)
call WriteRealMemory(addr+0x10,0xBEF68B90)
call WriteRealMemory(addr+0x18,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg2)
call WriteRealMemory(addr+0x0C,arg1)
call WriteRealMemory(addr+0x14,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_3 takes integer funcaddr,integer arg1,integer arg2,integer arg3 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_3"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0xBAF68B90)
call WriteRealMemory(addr+0x10,0xB9F68B90)
call WriteRealMemory(addr+0x18,0xBEF68B90)
call WriteRealMemory(addr+0x20,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg3)
call WriteRealMemory(addr+0x0C,arg2)
call WriteRealMemory(addr+0x14,arg1)
call WriteRealMemory(addr+0x1C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_4 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_4"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0xBAF68B90)
call WriteRealMemory(addr+0x18,0xB9F68B90)
call WriteRealMemory(addr+0x20,0xBEF68B90)
call WriteRealMemory(addr+0x28,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg4)
call WriteRealMemory(addr+0x0C,arg3)
call WriteRealMemory(addr+0x14,arg2)
call WriteRealMemory(addr+0x1C,arg1)
call WriteRealMemory(addr+0x24,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_5 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_5"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0xBAF68B90)
call WriteRealMemory(addr+0x20,0xB9F68B90)
call WriteRealMemory(addr+0x28,0xBEF68B90)
call WriteRealMemory(addr+0x30,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg5)
call WriteRealMemory(addr+0x0C,arg4)
call WriteRealMemory(addr+0x14,arg3)
call WriteRealMemory(addr+0x1C,arg2)
call WriteRealMemory(addr+0x24,arg1)
call WriteRealMemory(addr+0x2C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_6 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_6"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0x68F68B90)
call WriteRealMemory(addr+0x20,0xBAF68B90)
call WriteRealMemory(addr+0x28,0xB9F68B90)
call WriteRealMemory(addr+0x30,0xBEF68B90)
call WriteRealMemory(addr+0x38,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg6)
call WriteRealMemory(addr+0x0C,arg5)
call WriteRealMemory(addr+0x14,arg4)
call WriteRealMemory(addr+0x1C,arg3)
call WriteRealMemory(addr+0x24,arg2)
call WriteRealMemory(addr+0x2C,arg1)
call WriteRealMemory(addr+0x34,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_7 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_7"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0x68F68B90)
call WriteRealMemory(addr+0x20,0x68F68B90)
call WriteRealMemory(addr+0x28,0xBAF68B90)
call WriteRealMemory(addr+0x30,0xB9F68B90)
call WriteRealMemory(addr+0x38,0xBEF68B90)
call WriteRealMemory(addr+0x40,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg7)
call WriteRealMemory(addr+0x0C,arg6)
call WriteRealMemory(addr+0x14,arg5)
call WriteRealMemory(addr+0x1C,arg4)
call WriteRealMemory(addr+0x24,arg3)
call WriteRealMemory(addr+0x2C,arg2)
call WriteRealMemory(addr+0x34,arg1)
call WriteRealMemory(addr+0x3C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_8 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_8"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0x68F68B90)
call WriteRealMemory(addr+0x20,0x68F68B90)
call WriteRealMemory(addr+0x28,0x68F68B90)
call WriteRealMemory(addr+0x30,0xBAF68B90)
call WriteRealMemory(addr+0x38,0xB9F68B90)
call WriteRealMemory(addr+0x40,0xBEF68B90)
call WriteRealMemory(addr+0x48,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg8)
call WriteRealMemory(addr+0x0C,arg7)
call WriteRealMemory(addr+0x14,arg6)
call WriteRealMemory(addr+0x1C,arg5)
call WriteRealMemory(addr+0x24,arg4)
call WriteRealMemory(addr+0x2C,arg3)
call WriteRealMemory(addr+0x34,arg2)
call WriteRealMemory(addr+0x3C,arg1)
call WriteRealMemory(addr+0x44,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_9 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_9"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0x68F68B90)
call WriteRealMemory(addr+0x20,0x68F68B90)
call WriteRealMemory(addr+0x28,0x68F68B90)
call WriteRealMemory(addr+0x30,0x68F68B90)
call WriteRealMemory(addr+0x38,0xBAF68B90)
call WriteRealMemory(addr+0x40,0xB9F68B90)
call WriteRealMemory(addr+0x48,0xBEF68B90)
call WriteRealMemory(addr+0x50,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg9)
call WriteRealMemory(addr+0x0C,arg8)
call WriteRealMemory(addr+0x14,arg7)
call WriteRealMemory(addr+0x1C,arg6)
call WriteRealMemory(addr+0x24,arg5)
call WriteRealMemory(addr+0x2C,arg4)
call WriteRealMemory(addr+0x34,arg3)
call WriteRealMemory(addr+0x3C,arg2)
call WriteRealMemory(addr+0x44,arg1)
call WriteRealMemory(addr+0x4C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_10 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9,integer arg10 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_10"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0x68F68B90)
call WriteRealMemory(addr+0x20,0x68F68B90)
call WriteRealMemory(addr+0x28,0x68F68B90)
call WriteRealMemory(addr+0x30,0x68F68B90)
call WriteRealMemory(addr+0x38,0x68F68B90)
call WriteRealMemory(addr+0x40,0xBAF68B90)
call WriteRealMemory(addr+0x48,0xB9F68B90)
call WriteRealMemory(addr+0x50,0xBEF68B90)
call WriteRealMemory(addr+0x58,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg10)
call WriteRealMemory(addr+0x0C,arg9)
call WriteRealMemory(addr+0x14,arg8)
call WriteRealMemory(addr+0x1C,arg7)
call WriteRealMemory(addr+0x24,arg6)
call WriteRealMemory(addr+0x2C,arg5)
call WriteRealMemory(addr+0x34,arg4)
call WriteRealMemory(addr+0x3C,arg3)
call WriteRealMemory(addr+0x44,arg2)
call WriteRealMemory(addr+0x4C,arg1)
call WriteRealMemory(addr+0x54,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_11 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9,integer arg10,integer arg11 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_11"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0x68F68B90)
call WriteRealMemory(addr+0x20,0x68F68B90)
call WriteRealMemory(addr+0x28,0x68F68B90)
call WriteRealMemory(addr+0x30,0x68F68B90)
call WriteRealMemory(addr+0x38,0x68F68B90)
call WriteRealMemory(addr+0x40,0x68F68B90)
call WriteRealMemory(addr+0x48,0xBAF68B90)
call WriteRealMemory(addr+0x50,0xB9F68B90)
call WriteRealMemory(addr+0x58,0xBEF68B90)
call WriteRealMemory(addr+0x60,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg11)
call WriteRealMemory(addr+0x0C,arg10)
call WriteRealMemory(addr+0x14,arg9)
call WriteRealMemory(addr+0x1C,arg8)
call WriteRealMemory(addr+0x24,arg7)
call WriteRealMemory(addr+0x2C,arg6)
call WriteRealMemory(addr+0x34,arg5)
call WriteRealMemory(addr+0x3C,arg4)
call WriteRealMemory(addr+0x44,arg3)
call WriteRealMemory(addr+0x4C,arg2)
call WriteRealMemory(addr+0x54,arg1)
call WriteRealMemory(addr+0x5C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_12 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9,integer arg10,integer arg11,integer arg12 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_12"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0x68F68B90)
call WriteRealMemory(addr+0x20,0x68F68B90)
call WriteRealMemory(addr+0x28,0x68F68B90)
call WriteRealMemory(addr+0x30,0x68F68B90)
call WriteRealMemory(addr+0x38,0x68F68B90)
call WriteRealMemory(addr+0x40,0x68F68B90)
call WriteRealMemory(addr+0x48,0x68F68B90)
call WriteRealMemory(addr+0x50,0xBAF68B90)
call WriteRealMemory(addr+0x58,0xB9F68B90)
call WriteRealMemory(addr+0x60,0xBEF68B90)
call WriteRealMemory(addr+0x68,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg12)
call WriteRealMemory(addr+0x0C,arg11)
call WriteRealMemory(addr+0x14,arg10)
call WriteRealMemory(addr+0x1C,arg9)
call WriteRealMemory(addr+0x24,arg8)
call WriteRealMemory(addr+0x2C,arg7)
call WriteRealMemory(addr+0x34,arg6)
call WriteRealMemory(addr+0x3C,arg5)
call WriteRealMemory(addr+0x44,arg4)
call WriteRealMemory(addr+0x4C,arg3)
call WriteRealMemory(addr+0x54,arg2)
call WriteRealMemory(addr+0x5C,arg1)
call WriteRealMemory(addr+0x64,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function fast_call_13 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9,integer arg10,integer arg11,integer arg12,integer arg13 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("fast_call_13"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68F68B56)
call WriteRealMemory(addr+0x08,0x68F68B90)
call WriteRealMemory(addr+0x10,0x68F68B90)
call WriteRealMemory(addr+0x18,0x68F68B90)
call WriteRealMemory(addr+0x20,0x68F68B90)
call WriteRealMemory(addr+0x28,0x68F68B90)
call WriteRealMemory(addr+0x30,0x68F68B90)
call WriteRealMemory(addr+0x38,0x68F68B90)
call WriteRealMemory(addr+0x40,0x68F68B90)
call WriteRealMemory(addr+0x48,0x68F68B90)
call WriteRealMemory(addr+0x50,0x68F68B90)
call WriteRealMemory(addr+0x58,0xBAF68B90)
call WriteRealMemory(addr+0x60,0xB9F68B90)
call WriteRealMemory(addr+0x68,0xBEF68B90)
call WriteRealMemory(addr+0x70,0xC35ED6FF)
endif
call WriteRealMemory(addr+0x04,arg13)
call WriteRealMemory(addr+0x0C,arg12)
call WriteRealMemory(addr+0x14,arg11)
call WriteRealMemory(addr+0x1C,arg10)
call WriteRealMemory(addr+0x24,arg9)
call WriteRealMemory(addr+0x2C,arg8)
call WriteRealMemory(addr+0x34,arg7)
call WriteRealMemory(addr+0x3C,arg6)
call WriteRealMemory(addr+0x44,arg5)
call WriteRealMemory(addr+0x4C,arg4)
call WriteRealMemory(addr+0x54,arg3)
call WriteRealMemory(addr+0x5C,arg2)
call WriteRealMemory(addr+0x64,arg1)
call WriteRealMemory(addr+0x6C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function this_call_0 takes integer pfuncaddr,integer arg1 returns integer
return fast_call_1(pfuncaddr,0)
endfunction
function this_call_1 takes integer pfuncaddr,integer arg1 returns integer
return fast_call_2(pfuncaddr,arg1,0)
endfunction
function this_call_2 takes integer pfuncaddr,integer arg1,integer arg2 returns integer
return fast_call_3(pfuncaddr,arg1,0,arg2)
endfunction
function this_call_3 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3 returns integer
return fast_call_4(pfuncaddr,arg1,0,arg2,arg3)
endfunction
function this_call_4 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4 returns integer
return fast_call_5(pfuncaddr,arg1,0,arg2,arg3,arg4)
endfunction
function this_call_5 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5 returns integer
return fast_call_6(pfuncaddr,arg1,0,arg2,arg3,arg4,arg5)
endfunction
function this_call_6 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6 returns integer
return fast_call_7(pfuncaddr,arg1,0,arg2,arg3,arg4,arg5,arg6)
endfunction
function this_call_7 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7 returns integer
return fast_call_8(pfuncaddr,arg1,0,arg2,arg3,arg4,arg5,arg6,arg7)
endfunction
function this_call_8 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8 returns integer
return fast_call_9(pfuncaddr,arg1,0,arg2,arg3,arg4,arg5,arg6,arg7,arg8)
endfunction
function this_call_9 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9 returns integer
return fast_call_10(pfuncaddr,arg1,0,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)
endfunction
function this_call_10 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9,integer arg10 returns integer
return fast_call_11(pfuncaddr,arg1,0,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)
endfunction
function this_call_11 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9,integer arg10,integer arg11 returns integer
return fast_call_12(pfuncaddr,arg1,0,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11)
endfunction
function this_call_12 takes integer pfuncaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7,integer arg8,integer arg9,integer arg10,integer arg11,integer arg12 returns integer
return fast_call_13(pfuncaddr,arg1,0,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12)
endfunction
function std_call_0 takes integer funcaddr returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("std_call_0"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x0,0xB9519090)
call WriteRealMemory(addr+0x8,0xC359D1FF)
endif
call WriteRealMemory(addr+0x4,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function std_call_1 takes integer funcaddr,integer arg1 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("std_call_1"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0xB990C98B)
call WriteRealMemory(addr+0x10,0xC359D1FF)
endif
call WriteRealMemory(addr+0x04,arg1)
call WriteRealMemory(addr+0x0C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function std_call_2 takes integer funcaddr,integer arg1,integer arg2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("std_call_2"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0xB990C98B)
call WriteRealMemory(addr+0x18,0xC359D1FF)
endif
call WriteRealMemory(addr+0x04,arg2)
call WriteRealMemory(addr+0x0C,arg1)
call WriteRealMemory(addr+0x14,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function std_call_3 takes integer funcaddr,integer arg1,integer arg2,integer arg3 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("std_call_3"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0xB990C98B)
call WriteRealMemory(addr+0x20,0xC359D1FF)
endif
call WriteRealMemory(addr+0x04,arg3)
call WriteRealMemory(addr+0x0C,arg2)
call WriteRealMemory(addr+0x14,arg1)
call WriteRealMemory(addr+0x1C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function std_call_4 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("std_call_4"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0x6890C98B)
call WriteRealMemory(addr+0x20,0xB990C98B)
call WriteRealMemory(addr+0x28,0xC359D1FF)
endif
call WriteRealMemory(addr+0x04,arg4)
call WriteRealMemory(addr+0x0C,arg3)
call WriteRealMemory(addr+0x14,arg2)
call WriteRealMemory(addr+0x1C,arg1)
call WriteRealMemory(addr+0x24,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function std_call_5 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("std_call_5"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0x6890C98B)
call WriteRealMemory(addr+0x20,0x6890C98B)
call WriteRealMemory(addr+0x28,0xB990C98B)
call WriteRealMemory(addr+0x30,0xC359D1FF)
endif
call WriteRealMemory(addr+0x04,arg5)
call WriteRealMemory(addr+0x0C,arg4)
call WriteRealMemory(addr+0x14,arg3)
call WriteRealMemory(addr+0x1C,arg2)
call WriteRealMemory(addr+0x24,arg1)
call WriteRealMemory(addr+0x2C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function std_call_6 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("std_call_6"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0x6890C98B)
call WriteRealMemory(addr+0x20,0x6890C98B)
call WriteRealMemory(addr+0x28,0x6890C98B)
call WriteRealMemory(addr+0x30,0xB990C98B)
call WriteRealMemory(addr+0x38,0xC359D1FF)
endif
call WriteRealMemory(addr+0x04,arg6)
call WriteRealMemory(addr+0x0C,arg5)
call WriteRealMemory(addr+0x14,arg4)
call WriteRealMemory(addr+0x1C,arg3)
call WriteRealMemory(addr+0x24,arg2)
call WriteRealMemory(addr+0x2C,arg1)
call WriteRealMemory(addr+0x34,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function std_call_7 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6,integer arg7 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("std_call_7"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0x6890C98B)
call WriteRealMemory(addr+0x20,0x6890C98B)
call WriteRealMemory(addr+0x28,0x6890C98B)
call WriteRealMemory(addr+0x30,0x6890C98B)
call WriteRealMemory(addr+0x38,0xB990C98B)
call WriteRealMemory(addr+0x40,0xC359D1FF)
endif
call WriteRealMemory(addr+0x04,arg7)
call WriteRealMemory(addr+0x0C,arg6)
call WriteRealMemory(addr+0x14,arg5)
call WriteRealMemory(addr+0x1C,arg4)
call WriteRealMemory(addr+0x24,arg3)
call WriteRealMemory(addr+0x2C,arg2)
call WriteRealMemory(addr+0x34,arg1)
call WriteRealMemory(addr+0x3C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function c_call_0 takes integer funcaddr returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("c_call_0"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x0,0xB9C98B51)
call WriteRealMemory(addr+0x8,0xC483D1FF)
call WriteRealMemory(addr+0xC,0xCCC35900)
endif
call WriteRealMemory(addr+0x4,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function c_call_1 takes integer funcaddr,integer arg1 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("c_call_1"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0xB990C98B)
call WriteRealMemory(addr+0x10,0xC483D1FF)
call WriteRealMemory(addr+0x14,0xCCC35904)
endif
call WriteRealMemory(addr+0x04,arg1)
call WriteRealMemory(addr+0x0C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function c_call_2 takes integer funcaddr,integer arg1,integer arg2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("c_call_2"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0xB990C98B)
call WriteRealMemory(addr+0x18,0xC483D1FF)
call WriteRealMemory(addr+0x1C,0xCCC35908)
endif
call WriteRealMemory(addr+0x04,arg2)
call WriteRealMemory(addr+0x0C,arg1)
call WriteRealMemory(addr+0x14,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function c_call_3 takes integer funcaddr,integer arg1,integer arg2,integer arg3 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("c_call_3"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0xB990C98B)
call WriteRealMemory(addr+0x20,0xC483D1FF)
call WriteRealMemory(addr+0x24,0xCCC3590C)
endif
call WriteRealMemory(addr+0x04,arg3)
call WriteRealMemory(addr+0x0C,arg2)
call WriteRealMemory(addr+0x14,arg1)
call WriteRealMemory(addr+0x1C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function c_call_4 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("c_call_4"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0x6890C98B)
call WriteRealMemory(addr+0x20,0xB990C98B)
call WriteRealMemory(addr+0x28,0xC483D1FF)
call WriteRealMemory(addr+0x2C,0xCCC35910)
endif
call WriteRealMemory(addr+0x04,arg4)
call WriteRealMemory(addr+0x0C,arg3)
call WriteRealMemory(addr+0x14,arg2)
call WriteRealMemory(addr+0x1C,arg1)
call WriteRealMemory(addr+0x24,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function c_call_5 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("c_call_5"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0x6890C98B)
call WriteRealMemory(addr+0x20,0x6890C98B)
call WriteRealMemory(addr+0x28,0xB990C98B)
call WriteRealMemory(addr+0x30,0xC483D1FF)
call WriteRealMemory(addr+0x34,0xCCC35914)
endif
call WriteRealMemory(addr+0x04,arg5)
call WriteRealMemory(addr+0x0C,arg4)
call WriteRealMemory(addr+0x14,arg3)
call WriteRealMemory(addr+0x1C,arg2)
call WriteRealMemory(addr+0x24,arg1)
call WriteRealMemory(addr+0x2C,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function c_call_6 takes integer funcaddr,integer arg1,integer arg2,integer arg3,integer arg4,integer arg5,integer arg6 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("c_call_6"),StringHash("function"))
if addr!=0 then
if ReadRealMemory(addr)==0 then
call WriteRealMemory(addr+0x00,0x68C98B51)
call WriteRealMemory(addr+0x08,0x6890C98B)
call WriteRealMemory(addr+0x10,0x6890C98B)
call WriteRealMemory(addr+0x18,0x6890C98B)
call WriteRealMemory(addr+0x20,0x6890C98B)
call WriteRealMemory(addr+0x28,0x6890C98B)
call WriteRealMemory(addr+0x30,0xB990C98B)
call WriteRealMemory(addr+0x38,0xC483D1FF)
call WriteRealMemory(addr+0x3C,0xCCC35918)
endif
call WriteRealMemory(addr+0x04,arg6)
call WriteRealMemory(addr+0x0C,arg5)
call WriteRealMemory(addr+0x14,arg4)
call WriteRealMemory(addr+0x1C,arg3)
call WriteRealMemory(addr+0x24,arg2)
call WriteRealMemory(addr+0x2C,arg1)
call WriteRealMemory(addr+0x34,funcaddr)
return ExecuteBytecode(addr)
endif
return 0
endfunction
function GetModuleHandleByAddr takes integer pDll returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetModuleHandleA"))
if addr!=0 then
return std_call_1(addr,pDll)
endif
return 0
endfunction
function GetModuleHandle takes string nDllName returns integer
return GetModuleHandleByAddr(GetStringAddress(nDllName))
endfunction
function GetModuleProcAddressByAddr takes integer pDll,integer pFunc returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetProcAddress"))
if addr!=0 then
return std_call_2(addr,GetModuleHandleByAddr(pDll),pFunc)
endif
return 0
endfunction
function GetModuleProcAddress takes string nDllName,string nProcName returns integer
return GetModuleProcAddressByAddr(GetStringAddress(nDllName),GetStringAddress(nProcName))
endfunction
function GetFuncFromDll takes string libname,string funcname,boolean save returns integer
local integer l_hash=StringHash(libname)
local integer f_hash=StringHash(funcname)
local integer addr=LoadInteger(MemHackTable,l_hash,f_hash)
if addr==0 then
set addr=GetModuleProcAddress(libname,funcname)
endif
if addr!=0 and save then
if not HaveSavedInteger(MemHackTable,l_hash,f_hash)then
call SaveInteger(MemHackTable,l_hash,f_hash,addr)
endif
endif
return addr
endfunction
function VirtualAlloc takes integer pRealOffset,integer pMemSize,integer alloctype,integer pProtectFlag returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","VirtualAlloc",true)
if addr!=0 then
return std_call_4(addr,pRealOffset,pMemSize,alloctype,pProtectFlag)
endif
return 0
endfunction
function VirtualProtect takes integer pRealOffset,integer pMemSize,integer pProtectFlag returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","VirtualProtect",true)
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if addr!=0 and arg!=0 then
call std_call_4(addr,pRealOffset,pMemSize,pProtectFlag,arg)
return ReadRealMemory(arg)
endif
return 0
endfunction
function CopyMemory takes integer dest,integer src,integer size returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLanguage"),StringHash("memcpy"))
if addr!=0 then
return c_call_3(addr,dest,src,size)
endif
return 0
endfunction
function AllocExecMemEx takes string funcname,string childName,integer size returns nothing
local integer i=0
local integer f_hash=StringHash(funcname)
local integer c_hash=StringHash(childName)
local integer addr=LoadInteger(MemHackTable,f_hash,c_hash)
if addr==0 then
set addr=AllocateExecutableMemory(size)
if addr!=0 then
call SaveInteger(MemHackTable,f_hash,c_hash,addr)
loop
exitwhen i==size
call WriteRealMemory(addr+i,0)
set i=i+0x4
endloop
endif
endif
endfunction
function AllocFunctionCall takes string funcname,integer size returns nothing
call AllocExecMemEx(funcname,"function",size)
endfunction
function ReallocateCallMemory takes nothing returns nothing
local integer i=0
if PatchVersion!="" then
call AllocFunctionCall("fast_call_0",0x0C)
call AllocFunctionCall("fast_call_1",0x14)
call AllocFunctionCall("fast_call_2",0x1C)
call AllocFunctionCall("fast_call_3",0x24)
call AllocFunctionCall("fast_call_4",0x2C)
call AllocFunctionCall("fast_call_5",0x34)
call AllocFunctionCall("fast_call_6",0x3C)
call AllocFunctionCall("fast_call_7",0x44)
call AllocFunctionCall("fast_call_8",0x4C)
call AllocFunctionCall("fast_call_9",0x5C)
call AllocFunctionCall("fast_call_10",0x64)
call AllocFunctionCall("fast_call_11",0x6C)
call AllocFunctionCall("fast_call_12",0x74)
call AllocFunctionCall("fast_call_13",0x7C)
call AllocFunctionCall("std_call_0",0x0C)
call AllocFunctionCall("std_call_1",0x14)
call AllocFunctionCall("std_call_2",0x1C)
call AllocFunctionCall("std_call_3",0x24)
call AllocFunctionCall("std_call_4",0x2C)
call AllocFunctionCall("std_call_5",0x34)
call AllocFunctionCall("std_call_6",0x3C)
call AllocFunctionCall("std_call_7",0x44)
call AllocFunctionCall("c_call_0",0x10)
call AllocFunctionCall("c_call_1",0x18)
call AllocFunctionCall("c_call_2",0x20)
call AllocFunctionCall("c_call_3",0x28)
call AllocFunctionCall("c_call_4",0x30)
call AllocFunctionCall("c_call_5",0x38)
call AllocFunctionCall("c_call_6",0x40)
endif
endfunction
function AllocateCallMemory takes nothing returns nothing
call ReallocateCallMemory()
endfunction
function Init_APIMemoryCalls takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetModuleHandleA"),ReadRealMemory(pGameDLL+0x87F204))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetProcAddress"),ReadRealMemory(pGameDLL+0x87F2BC))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("VirtualAlloc"),ReadRealMemory(pGameDLL+0x87F134))
call SaveInteger(MemHackTable,StringHash("CLanguage"),StringHash("memcpy"),ReadRealMemory(pGameDLL+0x87F47C))
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetModuleHandleA"),ReadRealMemory(pGameDLL+0x86D1D0))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetProcAddress"),ReadRealMemory(pGameDLL+0x86D280))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("VirtualAlloc"),ReadRealMemory(pGameDLL+0x86D0F4))
call SaveInteger(MemHackTable,StringHash("CLanguage"),StringHash("memcpy"),ReadRealMemory(pGameDLL+0x86D3CC))
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetModuleHandleA"),ReadRealMemory(pGameDLL+0x94E184))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetProcAddress"),ReadRealMemory(pGameDLL+0x94E168))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("VirtualAlloc"),ReadRealMemory(pGameDLL+0x94E270))
call SaveInteger(MemHackTable,StringHash("CLanguage"),StringHash("memcpy"),ReadRealMemory(pGameDLL+0x94E468))
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetModuleHandleA"),ReadRealMemory(pGameDLL+0xA7C28C))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetProcAddress"),ReadRealMemory(pGameDLL+0xA7C17C))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("VirtualAlloc"),ReadRealMemory(pGameDLL+0xA7C2D0))
call SaveInteger(MemHackTable,StringHash("CLanguage"),StringHash("memcpy"),ReadRealMemory(pGameDLL+0xA7C504))
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetModuleHandleA"),ReadRealMemory(pGameDLL+0xA6B378))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("GetProcAddress"),ReadRealMemory(pGameDLL+0xA6B24C))
call SaveInteger(MemHackTable,StringHash("Kernel32.dll"),StringHash("VirtualAlloc"),ReadRealMemory(pGameDLL+0xA6B2B8))
call SaveInteger(MemHackTable,StringHash("CLanguage"),StringHash("memcpy"),ReadRealMemory(pGameDLL+0xA6B3DC))
endif
call AllocateCallMemory()
endif
endfunction
function GetGameTypeSupported takes nothing returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GameState"))
if addr!=0 then
return ReadRealPointer2LVL(addr,0x30,0x30)
endif
return 0
endfunction
function Player2Flag takes player p returns integer
return R2I(Pow(2,GetPlayerId(p)))
endfunction
function IsFlagBitSet takes integer flags,integer bit returns boolean
return flags/ bit*2147483648!=0
endfunction
function ShiftLeftForBits takes integer byte,integer shiftval returns integer
return byte*(PowI(2,shiftval))
endfunction
function ShiftRightForBits takes integer byte,integer shiftval returns integer
return byte/(PowI(2,shiftval))
endfunction
function ShiftLeftForBytes takes integer byte,integer shiftval returns integer
return ShiftLeftForBits(byte,shiftval*8)
endfunction
function ShiftRightForBytes takes integer byte,integer shiftval returns integer
return ShiftRightForBits(byte,shiftval*8)
endfunction
function BitwiseOr takes integer arg1,integer arg2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("Bitwise"),StringHash("OR"))
if not LoadBoolean(MemHackTable,StringHash("Bitwise"),StringHash("isOR"))then
call SaveBoolean(MemHackTable,StringHash("Bitwise"),StringHash("isOR"),true)
call WriteRealMemory(addr+0x0,0x0424448B)
call WriteRealMemory(addr+0x4,0x0824548B)
call WriteRealMemory(addr+0x8,0xCCC3D009)
endif
return BitwiseOperation(addr,arg1,arg2)
endfunction
function BitwiseXor takes integer arg1,integer arg2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("Bitwise"),StringHash("XOR"))
if not LoadBoolean(MemHackTable,StringHash("Bitwise"),StringHash("isXOR"))then
call SaveBoolean(MemHackTable,StringHash("Bitwise"),StringHash("isXOR"),true)
call WriteRealMemory(addr+0x0,0x0424448B)
call WriteRealMemory(addr+0x4,0x0824548B)
call WriteRealMemory(addr+0x8,0xCCC3D031)
endif
return BitwiseOperation(addr,arg1,arg2)
endfunction
function BitwiseAnd takes integer arg1,integer arg2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("Bitwise"),StringHash("AND"))
if not LoadBoolean(MemHackTable,StringHash("Bitwise"),StringHash("isAND"))then
call SaveBoolean(MemHackTable,StringHash("Bitwise"),StringHash("isAND"),true)
call WriteRealMemory(addr+0x0,0x0424448B)
call WriteRealMemory(addr+0x4,0x0824548B)
call WriteRealMemory(addr+0x8,0xCCC3D021)
endif
return BitwiseOperation(addr,arg1,arg2)
endfunction
function Init_APIMemoryBitwise takes nothing returns nothing
local integer i=0
if PatchVersion!="" then
if PatchVersion=="1.24e" then
elseif PatchVersion=="1.26a" then
elseif PatchVersion=="1.27a" then
elseif PatchVersion=="1.27b" then
elseif PatchVersion=="1.28f" then
endif
call AllocExecMemEx("Bitwise","OR",0xC)
call AllocExecMemEx("Bitwise","XOR",0xC)
call AllocExecMemEx("Bitwise","AND",0xC)
endif
endfunction
function ToJString takes integer pCString returns string
local integer addr=LoadInteger(MemHackTable,StringHash("StringAPI"),StringHash("TojString"))
if addr!=0 and pCString!=0 then
return I2SH(this_call_1(addr,pCString))
endif
return null
endfunction
function WriteCString takes integer pAddr,string text returns nothing
call WriteRealMemory(pAddr,GetStringAddress(text))
endfunction
function ConvertNullTerminatedStringToString takes integer pNullTerminatedString returns string
return ToJString(pNullTerminatedString)
endfunction
function WriteNullTerminatedString takes string s,integer pAddr returns nothing
call WriteRealMemory(pAddr,GetStringAddress(s))
endfunction
function SearchStringValueAddress takes string str returns integer
local integer addr1=LoadInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchValue"))
local integer addr2=LoadInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress1"))
local integer addr3=LoadInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress2"))
local integer s_addr=0
local integer retaddr=0
if addr1!=0 and addr2!=0 and addr3!=0 then
set s_addr=GetStringAddress(str)
if s_addr!=0 then
set retaddr=this_call_2(addr1,addr2,s_addr)
if retaddr==0 or ReadRealMemory(retaddr+0x1C)==0 then
set retaddr=this_call_2(addr1,addr3,s_addr)
endif
if retaddr!=0 and ReadRealMemory(retaddr+0x1C)!=0 then
return ReadRealMemory(retaddr+0x1C)
endif
endif
endif
return 0
endfunction
function SearchStringValue takes string str returns string
return ToJString(SearchStringValueAddress(str))
endfunction
function ReplaceStringValue takes string str,integer newstraddress,integer str_len returns nothing
local integer retaddr=SearchStringValueAddress(str)
call CopyMemory(retaddr,newstraddress,str_len)
endfunction
function sprintf_Ex takes string format,integer arg1,integer arg2,integer arg3,integer arg4,integer argsize returns string
local integer addr=LoadInteger(MemHackTable,StringHash("StringAPI"),StringHash("sprintf"))
local integer mem=LoadInteger(MemHackTable,StringHash("StringArray"),0)
if addr!=0 then
if mem!=0 then
call WriteRealMemory(mem,0)
if argsize==1 then
call c_call_3(addr,mem,GetStringAddress(format),arg1)
elseif argsize==2 then
call c_call_4(addr,mem,GetStringAddress(format),arg1,arg2)
elseif argsize==3 then
call c_call_5(addr,mem,GetStringAddress(format),arg1,arg2,arg3)
elseif argsize==4 then
call c_call_6(addr,mem,GetStringAddress(format),arg1,arg2,arg3,arg4)
endif
return ToJString(mem)
endif
endif
return""
endfunction
function sprintf_1 takes string format,integer arg1 returns string
return sprintf_Ex(format,arg1,0,0,0,1)
endfunction
function sprintf_2 takes string format,integer arg1,integer arg2 returns string
return sprintf_Ex(format,arg1,arg2,0,0,2)
endfunction
function sprintf_3 takes string format,integer arg1,integer arg2,integer arg3 returns string
return sprintf_Ex(format,arg1,arg2,arg3,0,3)
endfunction
function sprintf_4 takes string format,integer arg1,integer arg2,integer arg3,integer arg4 returns string
return sprintf_Ex(format,arg1,arg2,arg3,arg4,4)
endfunction
function Init_APIMemoryString takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("TojString"),pGameDLL+0x3BB560)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchValue"),pGameDLL+0x5C9670)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress1"),pGameDLL+0xAE409C)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress2"),pGameDLL+0xAE4074)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("sprintf"),ReadRealMemory(pGameDLL+0x87F3AC))
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("TojString"),pGameDLL+0x3BAA20)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchValue"),pGameDLL+0x5C8ED0)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress1"),pGameDLL+0xACD23C)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress2"),pGameDLL+0xACD214)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("sprintf"),ReadRealMemory(pGameDLL+0x86D32C))
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("TojString"),pGameDLL+0x1DA520)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchValue"),pGameDLL+0x06B030)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress1"),pGameDLL+0xBB9CD4)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress2"),pGameDLL+0xBB9CAC)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("sprintf"),ReadRealMemory(pGameDLL+0x94E464))
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("TojString"),pGameDLL+0x1F7F60)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchValue"),pGameDLL+0x0BF020)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress1"),pGameDLL+0xD4776C)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress2"),pGameDLL+0xD47744)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("sprintf"),ReadRealMemory(pGameDLL+0xA7C500))
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("TojString"),pGameDLL+0x22A770)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchValue"),pGameDLL+0x0ED810)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress1"),pGameDLL+0xD0F54C)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("SearchAddress2"),pGameDLL+0xD0F524)
call SaveInteger(MemHackTable,StringHash("StringAPI"),StringHash("sprintf"),ReadRealMemory(pGameDLL+0xA6B3E0))
endif
endif
endfunction
function GetFrameType takes integer pFrame returns integer
if pFrame!=0 then
return LoadInteger(MemHackTable,StringHash("FrameTypeTable"),ReadRealMemory(pFrame))
endif
return 0
endfunction
function GetFrameTypeName takes integer pFrame returns string
if pFrame!=0 then
return LoadStr(MemHackTable,StringHash("FrameTypeTable"),ReadRealMemory(pFrame))
endif
return""
endfunction
function GetFrameTypeNameByIndex takes integer index returns string
if index>0 then
return LoadStr(MemHackTable,StringHash("FrameTypeTable"),index)
endif
return""
endfunction
function GetFrameLayoutAddress takes integer pFrame returns integer
local integer fid=GetFrameType(pFrame)
if fid!=0 then
return LoadInteger(MemHackTable,StringHash("FrameTypeTable"),fid+0x1000)
endif
return 0
endfunction
function GetFrameHasLayout takes integer pFrame returns boolean
return GetFrameLayoutAddress(pFrame)!=0
endfunction
function GetFrameLayoutByType takes integer pFrame,integer fid returns integer
local boolean haslayout=false
local string f_name1=""
if fid!=0 then
set f_name1=GetFrameTypeName(pFrame)
set haslayout=LoadInteger(MemHackTable,StringHash("FrameTypeTable"),fid+0x1000)!=0 and f_name1!="CHeroBar" and f_name1!="CPeonBar" and f_name1!="CUpperButtonBar" and f_name1!="CResourceBar"
if not haslayout or ReadRealMemory(pFrame)!=LoadInteger(MemHackTable,StringHash("FrameTypeTable"),fid)then
return pFrame
else
return pFrame+0xB4
endif
endif
return 0
endfunction
function GetFrameLayout takes integer pFrame returns integer
return GetFrameLayoutByType(pFrame,GetFrameType(pFrame))
endfunction
function IsFrameLayoutByType takes integer pFrame,integer fid returns boolean
return GetFrameLayoutByType(pFrame,fid)==pFrame
endfunction
function IsFrameLayout takes integer pFrame returns boolean
return GetFrameLayout(pFrame)==pFrame
endfunction
function AddFrameType takes string name,integer vtype,integer pVtable,integer pVTableObj returns nothing
local integer hid=StringHash("FrameTypeTable")
if pVtable!=0 then
call SaveStr(MemHackTable,hid,vtype,name)
call SaveInteger(MemHackTable,hid,vtype,pGameDLL+pVtable)
call SaveStr(MemHackTable,hid,pGameDLL+pVtable,name)
call SaveInteger(MemHackTable,hid,pGameDLL+pVtable,vtype)
if pVTableObj!=0 then
call SaveInteger(MemHackTable,hid,vtype+0x1000,pGameDLL+pVTableObj)
call SaveInteger(MemHackTable,hid,pGameDLL+pVTableObj,vtype)
call SaveStr(MemHackTable,hid,pGameDLL+pVTableObj,name)
endif
endif
endfunction
function Init_APIMemoryFrameData takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
if true then
call AddFrameType("CBackdropFrame",1,0x98109C,0x981074)
call AddFrameType("CButtonFrame",2,0x9813A4,0x98137C)
call AddFrameType("CChatMode",3,0x94CA1C,0x000000)
call AddFrameType("CCommandButton",4,0x94EA04,0x000000)
call AddFrameType("CCursorFrame",5,0x9822E4,0x9822B8)
call AddFrameType("CEditBox",6,0x980994,0x980968)
call AddFrameType("CFrame",7,0x97FB5C,0x97FB34)
call AddFrameType("CFloatingFrame",8,0x98175C,0x981730)
call AddFrameType("CGameUI",9,0x94847C,0x948454)
call AddFrameType("CHeroBarButton",10,0x951A34,0x951A14)
call AddFrameType("CHighlightFrame",11,0x98161C,0x9815F4)
call AddFrameType("CLayoutFrame",12,0x97FAF0,0x000000)
call AddFrameType("CMessageFrame",13,0x98150C,0x9814E4)
call AddFrameType("CMinimap",14,0x952184,0x95215C)
call AddFrameType("CModelFrame",15,0x981254,0x98122C)
call AddFrameType("CPortraitButton",16,0x95233C,0x952314)
call AddFrameType("CScreenFrame",17,0x97FD24,0x97FCFC)
call AddFrameType("CSimpleButton",18,0x97F934,0x000000)
call AddFrameType("CSimpleFontString",19,0x9800AC,0x000000)
call AddFrameType("CSimpleFrame",20,0x97FC5C,0x000000)
call AddFrameType("CSimpleGlueFrame",21,0x980AAC,0x000000)
call AddFrameType("CUknown_1",22,0x000000,0x000000)
call AddFrameType("CSimpleMessageFrame",23,0x97FA2C,0x000000)
call AddFrameType("CSlider",24,0x980F1C,0x980EF4)
call AddFrameType("CSpriteFrame",25,0x98022C,0x980200)
call AddFrameType("CStatBar",26,0x95075C,0x000000)
call AddFrameType("CTextArea",27,0x980C7C,0x980C54)
call AddFrameType("CTextButtonFrame",28,0x980DBC,0x980D90)
call AddFrameType("CTextFrame",29,0x98065C,0x980630)
call AddFrameType("CUberToolTipWar3",30,0x9517E4,0x000000)
call AddFrameType("CWorldFrameWar3",31,0x9536D4,0x9536A8)
call AddFrameType("CGlueButtonWar3",32,0x96EA84,0x96EA58)
call AddFrameType("CGlueTextButtonWar3",33,0x96C164,0x96C138)
call AddFrameType("CGlueCheckBoxWar3",34,0x96E944,0x96E918)
call AddFrameType("CGluePopupMenuWar3",35,0x96BFDC,0x96BFB4)
call AddFrameType("CGlueEditBoxWar3",36,0x96EBC4,0x96EB98)
call AddFrameType("CSlashChatBox",37,0x96FC44,0x96FC1C)
call AddFrameType("CTimerTextFrame",38,0x96C6BC,0x96C690)
call AddFrameType("CSimpleStatusBar",39,0x980134,0x000000)
call AddFrameType("CStatusBar",40,0x981F0C,0x981EE4)
call AddFrameType("CUpperButtonBar",41,0x94E544,0x94E524)
call AddFrameType("CResourceBar",42,0x94F38C,0x000000)
call AddFrameType("CSimpleConsole",43,0x94DE8C,0x000000)
call AddFrameType("CPeonBar",44,0x951D64,0x951D48)
call AddFrameType("CHeroBar",45,0x951ACC,0x951AB0)
call AddFrameType("CTimeOfDayIndicator",46,0x951FBC,0x951F90)
call AddFrameType("CInfoBar",47,0x9527C4,0x000000)
call AddFrameType("CTimeCover",48,0x94E1B4,0x94E188)
call AddFrameType("CProgressIndicator",49,0x94A4AC,0x000000)
call AddFrameType("CHeroLevelBar",50,0x951B7C,0x000000)
call AddFrameType("CBuildTimeIndicator",51,0x94F7E4,0x000000)
call AddFrameType("CInfoPanelDestructableDetail",52,0x94EFB4,0x000000)
call AddFrameType("CInfoPanelItemDetail",53,0x94D624,0x000000)
call AddFrameType("CInfoPanelIconAlly",54,0x94D4D4,0x000000)
call AddFrameType("CInfoPanelIconHero",55,0x94D3E4,0x000000)
call AddFrameType("CInfoPanelIconGold",56,0x94D36C,0x000000)
call AddFrameType("CInfoPanelIconFood",57,0x94D2F4,0x000000)
call AddFrameType("CInfoPanelIconRank",58,0x94D27C,0x000000)
call AddFrameType("CInfoPanelIconArmor",59,0x94D204,0x000000)
call AddFrameType("CInfoPanelIconDamage",60,0x94D18C,0x000000)
call AddFrameType("CInfoPanelCargoDetail",61,0x94F0EC,0x000000)
call AddFrameType("CInfoPanelBuildingDetail",62,0x94FFFC,0x000000)
call AddFrameType("CInfoPanelUnitDetail",63,0x94F06C,0x000000)
call AddFrameType("CSimpleTexture",64,0x9800E8,0x000000)
endif
elseif PatchVersion=="1.26a" then
if true then
call AddFrameType("CBackdropFrame",1,0x96F3F4,0x96F3CC)
call AddFrameType("CButtonFrame",2,0x96F6FC,0x96F6D4)
call AddFrameType("CChatMode",3,0x93A8BC,0x000000)
call AddFrameType("CCommandButton",4,0x93EBC4,0x000000)
call AddFrameType("CCursorFrame",5,0x97063C,0x970610)
call AddFrameType("CEditBox",6,0x96ECEC,0x96ECC0)
call AddFrameType("CFrame",7,0x96DEB4,0x96DE8C)
call AddFrameType("CFloatingFrame",8,0x96FAB4,0x96FA88)
call AddFrameType("CGameUI",9,0x93631C,0x9362F4)
call AddFrameType("CHeroBarButton",10,0x93F8DC,0x93F8BC)
call AddFrameType("CHighlightFrame",11,0x96F974,0x96F94C)
call AddFrameType("CLayoutFrame",12,0x96DE48,0x000000)
call AddFrameType("CMessageFrame",13,0x96F864,0x96F83C)
call AddFrameType("CMinimap",14,0x94002C,0x940004)
call AddFrameType("CModelFrame",15,0x96F5AC,0x96F584)
call AddFrameType("CPortraitButton",16,0x9401E4,0x9401BC)
call AddFrameType("CScreenFrame",17,0x96E07C,0x96E054)
call AddFrameType("CSimpleButton",18,0x96DC8C,0x000000)
call AddFrameType("CSimpleFontString",19,0x96E404,0x000000)
call AddFrameType("CSimpleFrame",20,0x96DFB4,0x000000)
call AddFrameType("CSimpleGlueFrame",21,0x96EE04,0x000000)
call AddFrameType("CUknown_1",22,0x000000,0x000000)
call AddFrameType("CSimpleMessageFrame",23,0x96DD84,0x000000)
call AddFrameType("CSlider",24,0x96F274,0x96F24C)
call AddFrameType("CSpriteFrame",25,0x96E584,0x96E558)
call AddFrameType("CStatBar",26,0x93E604,0x000000)
call AddFrameType("CTextArea",27,0x96EFD4,0x96EFAC)
call AddFrameType("CTextButtonFrame",28,0x96F114,0x96F0E8)
call AddFrameType("CTextFrame",29,0x96E9B4,0x96E988)
call AddFrameType("CUberToolTipWar3",30,0x93F68C,0x000000)
call AddFrameType("CWorldFrameWar3",31,0x94157C,0x941550)
call AddFrameType("CGlueButtonWar3",32,0x95C92C,0x95C900)
call AddFrameType("CGlueTextButtonWar3",33,0x95A00C,0x959FE0)
call AddFrameType("CGlueCheckBoxWar3",34,0x95C7EC,0x95C7C0)
call AddFrameType("CGluePopupMenuWar3",35,0x959E84,0x959E5C)
call AddFrameType("CGlueEditBoxWar3",36,0x95CA6C,0x95CA40)
call AddFrameType("CSlashChatBox",37,0x95DAEC,0x95DAC4)
call AddFrameType("CTimerTextFrame",38,0x95A564,0x95A538)
call AddFrameType("CSimpleStatusBar",39,0x96E48C,0x000000)
call AddFrameType("CStatusBar",40,0x970264,0x97023C)
call AddFrameType("CUpperButtonBar",41,0x93C3E4,0x93C3C4)
call AddFrameType("CResourceBar",42,0x93D22C,0x000000)
call AddFrameType("CSimpleConsole",43,0x93BD2C,0x000000)
call AddFrameType("CPeonBar",44,0x93FC0C,0x93FBF0)
call AddFrameType("CHeroBar",45,0x93F974,0x93F958)
call AddFrameType("CTimeOfDayIndicator",46,0x93FE64,0x93FE38)
call AddFrameType("CInfoBar",47,0x94066C,0x000000)
call AddFrameType("CTimeCover",48,0x93C054,0x93C028)
call AddFrameType("CProgressIndicator",49,0x93834C,0x000000)
call AddFrameType("CHeroLevelBar",50,0x93FA24,0x000000)
call AddFrameType("CBuildTimeIndicator",51,0x93D684,0x000000)
call AddFrameType("CInfoPanelDestructableDetail",52,0x93CE54,0x000000)
call AddFrameType("CInfoPanelItemDetail",53,0x93B4C4,0x000000)
call AddFrameType("CInfoPanelIconAlly",54,0x93B374,0x000000)
call AddFrameType("CInfoPanelIconHero",55,0x93B284,0x000000)
call AddFrameType("CInfoPanelIconGold",56,0x93B20C,0x000000)
call AddFrameType("CInfoPanelIconFood",57,0x93B194,0x000000)
call AddFrameType("CInfoPanelIconRank",58,0x93B11C,0x000000)
call AddFrameType("CInfoPanelIconArmor",59,0x93B0A4,0x000000)
call AddFrameType("CInfoPanelIconDamage",60,0x93B02C,0x000000)
call AddFrameType("CInfoPanelCargoDetail",61,0x93CF8C,0x000000)
call AddFrameType("CInfoPanelBuildingDetail",62,0x93DE9C,0x000000)
call AddFrameType("CInfoPanelUnitDetail",63,0x93CF0C,0x000000)
call AddFrameType("CSimpleTexture",64,0x96E440,0x000000)
endif
elseif PatchVersion=="1.27a" then
if true then
call AddFrameType("CBackdropFrame",1,0x95AC3C,0x95AD38)
call AddFrameType("CButtonFrame",2,0x95B318,0x95B42C)
call AddFrameType("CChatMode",3,0x98FB4C,0x000000)
call AddFrameType("CCommandButton",4,0x98F6A8,0x000000)
call AddFrameType("CCursorFrame",5,0x95D0BC,0x95D1AC)
call AddFrameType("CEditBox",6,0x95BCBC,0x95BDD4)
call AddFrameType("CFrame",7,0x95A760,0x95A848)
call AddFrameType("CFloatingFrame",8,0x95D1D4,0x95D2BC)
call AddFrameType("CGameUI",9,0x98C3EC,0x98C4D4)
call AddFrameType("CHeroBarButton",10,0x990E44,0x990EBC)
call AddFrameType("CHighlightFrame",11,0x95ADD4,0x95AEBC)
call AddFrameType("CLayoutFrame",12,0x95CB54,0x000000)
call AddFrameType("CMessageFrame",13,0x95AF28,0x95B010)
call AddFrameType("CMinimap",14,0x99244C,0x992538)
call AddFrameType("CModelFrame",15,0x95AAE4,0x95ABE0)
call AddFrameType("CPortraitButton",16,0x9922FC,0x992424)
call AddFrameType("CScreenFrame",17,0x95D2E4,0x95D3CC)
call AddFrameType("CSimpleButton",18,0x95C9A4,0x000000)
call AddFrameType("CSimpleFontString",19,0x95CE00,0x000000)
call AddFrameType("CSimpleFrame",20,0x95C8A4,0x000000)
call AddFrameType("CSimpleGlueFrame",21,0x95CE64,0x000000)
call AddFrameType("CUknown_1",22,0x000000,0x000000)
call AddFrameType("CSimpleMessageFrame",23,0x95CF38,0x000000)
call AddFrameType("CSlider",24,0x95B468,0x95B584)
call AddFrameType("CSpriteFrame",25,0x95A8A4,0x95A994)
call AddFrameType("CStatBar",26,0x98F52C,0x000000)
call AddFrameType("CTextArea",27,0x95C610,0x95C724)
call AddFrameType("CTextButtonFrame",28,0x95BF60,0x95C074)
call AddFrameType("CTextFrame",29,0x95B050,0x95B164)
call AddFrameType("CUberToolTipWar3",30,0x98F364,0x000000)
call AddFrameType("CWorldFrameWar3",31,0x98DCD0,0x98DDB8)
call AddFrameType("CGlueButtonWar3",32,0x975D40,0x975E54)
call AddFrameType("CGlueTextButtonWar3",33,0x975E7C,0x975F90)
call AddFrameType("CGlueCheckBoxWar3",34,0x977A44,0x977B58)
call AddFrameType("CGluePopupMenuWar3",35,0x975FB8,0x9760CC)
call AddFrameType("CGlueEditBoxWar3",36,0x9760F4,0x97620C)
call AddFrameType("CSlashChatBox",37,0x977278,0x977390)
call AddFrameType("CTimerTextFrame",38,0x979FBC,0x97A0D0)
call AddFrameType("CSimpleStatusBar",39,0x95CABC,0x000000)
call AddFrameType("CStatusBar",40,0x95B1B0,0x95B2B8)
call AddFrameType("CUpperButtonBar",41,0x98EF64,0x98EFD4)
call AddFrameType("CResourceBar",42,0x993E54,0x000000)
call AddFrameType("CSimpleConsole",43,0x992D68,0x000000)
call AddFrameType("CPeonBar",44,0x992C60,0x992CD4)
call AddFrameType("CHeroBar",45,0x990ED8,0x990F4C)
call AddFrameType("CTimeOfDayIndicator",46,0x994620,0x994710)
call AddFrameType("CInfoBar",47,0x99197C,0x000000)
call AddFrameType("CTimeCover",48,0x994510,0x9945F8)
call AddFrameType("CProgressIndicator",49,0x98B0E4,0x000000)
call AddFrameType("CHeroLevelBar",50,0x991010,0x000000)
call AddFrameType("CBuildTimeIndicator",51,0x98F438,0x000000)
call AddFrameType("CInfoPanelDestructableDetail",52,0x991778,0x000000)
call AddFrameType("CInfoPanelItemDetail",53,0x9916F8,0x000000)
call AddFrameType("CInfoPanelIconAlly",54,0x991584,0x000000)
call AddFrameType("CInfoPanelIconHero",55,0x991510,0x000000)
call AddFrameType("CInfoPanelIconGold",56,0x99149C,0x000000)
call AddFrameType("CInfoPanelIconFood",57,0x991428,0x000000)
call AddFrameType("CInfoPanelIconRank",58,0x9913B4,0x000000)
call AddFrameType("CInfoPanelIconArmor",59,0x991340,0x000000)
call AddFrameType("CInfoPanelIconDamage",60,0x9912CC,0x000000)
call AddFrameType("CInfoPanelCargoDetail",61,0x991678,0x000000)
call AddFrameType("CInfoPanelBuildingDetail",62,0x99116C,0x000000)
call AddFrameType("CInfoPanelUnitDetail",63,0x9915F8,0x000000)
call AddFrameType("CSimpleTexture",64,0x95CDC4,0x000000)
endif
elseif PatchVersion=="1.27b" then
if true then
call AddFrameType("CBackdropFrame",1,0xA8B5AC,0xA8B6A8)
call AddFrameType("CButtonFrame",2,0xA8BC88,0xA8BD9C)
call AddFrameType("CChatMode",3,0xABD488,0x000000)
call AddFrameType("CCommandButton",4,0xABCFF4,0x000000)
call AddFrameType("CCursorFrame",5,0xA8DA14,0xA8DB04)
call AddFrameType("CEditBox",6,0xA8C62C,0xA8C744)
call AddFrameType("CFrame",7,0xA8B0D0,0xA8B1B8)
call AddFrameType("CFloatingFrame",8,0xA8DB2C,0xA8DC14)
call AddFrameType("CGameUI",9,0xAB9D90,0xAB9E78)
call AddFrameType("CHeroBarButton",10,0xABE768,0xABE7E0)
call AddFrameType("CHighlightFrame",11,0xA8B744,0xA8B82C)
call AddFrameType("CLayoutFrame",12,0xA8D4B4,0x000000)
call AddFrameType("CMessageFrame",13,0xA8B898,0xA8B980)
call AddFrameType("CMinimap",14,0xAB0EE4,0xAB0FD4)
call AddFrameType("CModelFrame",15,0xA8B454,0xA8B550)
call AddFrameType("CPortraitButton",16,0xABFBC0,0xABFCE8)
call AddFrameType("CScreenFrame",17,0xA8DC3C,0xA8DD24)
call AddFrameType("CSimpleButton",18,0xA8D304,0x000000)
call AddFrameType("CSimpleFontString",19,0xA8D760,0x000000)
call AddFrameType("CSimpleFrame",20,0xA8D204,0x000000)
call AddFrameType("CSimpleGlueFrame",21,0xA8D7C4,0x000000)
call AddFrameType("CUknown_1",22,0x000000,0x000000)
call AddFrameType("CSimpleMessageFrame",23,0xA8D88C,0x000000)
call AddFrameType("CSlider",24,0xA8BDD8,0xA8BEF4)
call AddFrameType("CSpriteFrame",25,0xA8B214,0xA8B304)
call AddFrameType("CStatBar",26,0xABCE78,0x000000)
call AddFrameType("CTextArea",27,0xA8CF7C,0xA8D090)
call AddFrameType("CTextButtonFrame",28,0xA8C8CC,0xA8C9E0)
call AddFrameType("CTextFrame",29,0xA8B9C0,0xA8BAD4)
call AddFrameType("CUberToolTipWar3",30,0xABCCC8,0x000000)
call AddFrameType("CWorldFrameWar3",31,0xABB66C,0xABB754)
call AddFrameType("CGlueButtonWar3",32,0xAA3D00,0xAA3E14)
call AddFrameType("CGlueTextButtonWar3",33,0xAA3E3C,0xAA3F50)
call AddFrameType("CGlueCheckBoxWar3",34,0xAA59C0,0xAA5AD4)
call AddFrameType("CGluePopupMenuWar3",35,0xAA3F78,0xAA408C)
call AddFrameType("CGlueEditBoxWar3",36,0xAA40B4,0xAA41CC)
call AddFrameType("CSlashChatBox",37,0xAA5238,0xAA5350)
call AddFrameType("CTimerTextFrame",38,0xAA7E70,0xAA7F84)
call AddFrameType("CSimpleStatusBar",39,0xA8D41C,0x000000)
call AddFrameType("CStatusBar",40,0xA8BB20,0xA8BC28)
call AddFrameType("CUpperButtonBar",41,0xABC8D8,0xABC948)
call AddFrameType("CResourceBar",42,0xAC16A8,0x000000)
call AddFrameType("CSimpleConsole",43,0xAC05FC,0x000000)
call AddFrameType("CPeonBar",44,0xAC0504,0xAC0578)
call AddFrameType("CHeroBar",45,0xABE7FC,0xABE870)
call AddFrameType("CTimeOfDayIndicator",46,0xAC1E58,0xAC1F48)
call AddFrameType("CInfoBar",47,0xABF288,0x000000)
call AddFrameType("CTimeCover",48,0xAC1D48,0xAC1E30)
call AddFrameType("CProgressIndicator",49,0xAB8BE8,0x000000)
call AddFrameType("CHeroLevelBar",50,0xABE924,0x000000)
call AddFrameType("CBuildTimeIndicator",51,0xABCD94,0x000000)
call AddFrameType("CInfoPanelDestructableDetail",52,0xABF084,0x000000)
call AddFrameType("CInfoPanelItemDetail",53,0xABF004,0x000000)
call AddFrameType("CInfoPanelIconAlly",54,0xABEE90,0x000000)
call AddFrameType("CInfoPanelIconHero",55,0xABEE1C,0x000000)
call AddFrameType("CInfoPanelIconGold",56,0xABEDA8,0x000000)
call AddFrameType("CInfoPanelIconFood",57,0xABED34,0x000000)
call AddFrameType("CInfoPanelIconRank",58,0xABECC0,0x000000)
call AddFrameType("CInfoPanelIconArmor",59,0xABEC4C,0x000000)
call AddFrameType("CInfoPanelIconDamage",60,0xABEBD8,0x000000)
call AddFrameType("CInfoPanelCargoDetail",61,0xABEF84,0x000000)
call AddFrameType("CInfoPanelBuildingDetail",62,0xABEA78,0x000000)
call AddFrameType("CInfoPanelUnitDetail",63,0xABEF04,0x000000)
call AddFrameType("CSimpleTexture",64,0xA8D724,0x000000)
endif
elseif PatchVersion=="1.28f" then
if true then
call AddFrameType("CBackdropFrame",1,0xA7AFBC,0xA7B0B8)
call AddFrameType("CButtonFrame",2,0xA7B698,0xA7B7AC)
call AddFrameType("CChatMode",3,0xAADE54,0x000000)
call AddFrameType("CCommandButton",4,0xAAD9B8,0x000000)
call AddFrameType("CCursorFrame",5,0xA7D42C,0xA7D51C)
call AddFrameType("CEditBox",6,0xA7C03C,0xA7C154)
call AddFrameType("CFrame",7,0xA7AAE0,0xA7ABC8)
call AddFrameType("CFloatingFrame",8,0xA7D544,0xA7D62C)
call AddFrameType("CGameUI",9,0xAAA730,0xAAA818)
call AddFrameType("CHeroBarButton",10,0xAAF130,0xAAF1A8)
call AddFrameType("CHighlightFrame",11,0xA7B154,0xA7B23C)
call AddFrameType("CLayoutFrame",12,0xA7CEC4,0x000000)
call AddFrameType("CMessageFrame",13,0xA7B2A8,0xA7B390)
call AddFrameType("CMinimap",14,0xAB0704,0xAB07F0)
call AddFrameType("CModelFrame",15,0xA7AE64,0xA7AF60)
call AddFrameType("CPortraitButton",16,0xAB05B4,0xAB06DC)
call AddFrameType("CScreenFrame",17,0xA7D654,0xA7D73C)
call AddFrameType("CSimpleButton",18,0xA7CD14,0x000000)
call AddFrameType("CSimpleFontString",19,0xA7D178,0x000000)
call AddFrameType("CSimpleFrame",20,0xA7CC14,0x000000)
call AddFrameType("CSimpleGlueFrame",21,0xA7D1DC,0x000000)
call AddFrameType("CUknown_1",22,0x000000,0x000000)
call AddFrameType("CSimpleMessageFrame",23,0xA7D2A8,0x000000)
call AddFrameType("CSlider",24,0xA7B7E8,0xA7B904)
call AddFrameType("CSpriteFrame",25,0xA7AC24,0xA7AD14)
call AddFrameType("CStatBar",26,0xAAD83C,0x000000)
call AddFrameType("CTextArea",27,0xA7C98C,0xA7CAA0)
call AddFrameType("CTextButtonFrame",28,0xA7C2DC,0xA7C3F0)
call AddFrameType("CTextFrame",29,0xA7B3D0,0xA7B4E4)
call AddFrameType("CUberToolTipWar3",30,0xAAD684,0x000000)
call AddFrameType("CWorldFrameWar3",31,0xAAC008,0xAAC0F0)
call AddFrameType("CGlueButtonWar3",32,0xA93B68,0xA93C7C)
call AddFrameType("CGlueTextButtonWar3",33,0xA93CA4,0xA93DB8)
call AddFrameType("CGlueCheckBoxWar3",34,0xA95844,0xA95958)
call AddFrameType("CGluePopupMenuWar3",35,0xA93DE0,0xA93EF4)
call AddFrameType("CGlueEditBoxWar3",36,0xA93F1C,0xA94034)
call AddFrameType("CSlashChatBox",37,0xA950A0,0xA951B8)
call AddFrameType("CTimerTextFrame",38,0xA97D38,0xA97E4C)
call AddFrameType("CSimpleStatusBar",39,0xA7CE2C,0x000000)
call AddFrameType("CStatusBar",40,0xA7B530,0xA7B638)
call AddFrameType("CUpperButtonBar",41,0xAAD28C,0xAAD2FC)
call AddFrameType("CResourceBar",42,0xAB20D4,0x000000)
call AddFrameType("CSimpleConsole",43,0xAB1008,0x000000)
call AddFrameType("CPeonBar",44,0xAB0F08,0xAB0F7C)
call AddFrameType("CHeroBar",45,0xAAF1C4,0xAAF238)
call AddFrameType("CTimeOfDayIndicator",46,0xAB2890,0xAB2980)
call AddFrameType("CInfoBar",47,0xAAFC58,0x000000)
call AddFrameType("CTimeCover",48,0xAB2780,0xAB2868)
call AddFrameType("CProgressIndicator",49,0xAA950C,0x000000)
call AddFrameType("CHeroLevelBar",50,0xAAF2F0,0x000000)
call AddFrameType("CBuildTimeIndicator",51,0xAAD750,0x000000)
call AddFrameType("CInfoPanelDestructableDetail",52,0xAAFA54,0x000000)
call AddFrameType("CInfoPanelItemDetail",53,0xAAF9D4,0x000000)
call AddFrameType("CInfoPanelIconAlly",54,0xAAF860,0x000000)
call AddFrameType("CInfoPanelIconHero",55,0xAAF7EC,0x000000)
call AddFrameType("CInfoPanelIconGold",56,0xAAF778,0x000000)
call AddFrameType("CInfoPanelIconFood",57,0xAAF704,0x000000)
call AddFrameType("CInfoPanelIconRank",58,0xAAF690,0x000000)
call AddFrameType("CInfoPanelIconArmor",59,0xAAF61C,0x000000)
call AddFrameType("CInfoPanelIconDamage",60,0xAAF5A8,0x000000)
call AddFrameType("CInfoPanelCargoDetail",61,0xAAF954,0x000000)
call AddFrameType("CInfoPanelBuildingDetail",62,0xAAF448,0x000000)
call AddFrameType("CInfoPanelUnitDetail",63,0xAAF8D4,0x000000)
call AddFrameType("CSimpleTexture",64,0xA7D13C,0x000000)
endif
endif
endif
endfunction
function SaveCode takes hashtable ht,integer parentKey,integer childKey,code c returns nothing
if ht!=null then
call SaveInteger(ht,parentKey,childKey,C2I(c))
endif
endfunction
function LoadCode takes hashtable ht,integer parentKey,integer childKey returns code
if ht!=null then
return I2C(LoadInteger(ht,parentKey,childKey))
endif
return null
endfunction
function GetGameStateInstance takes nothing returns integer
return LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GameState"))
endfunction
function GetTempestThread takes nothing returns integer
return LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("TempestThread"))
endfunction
function ConvertHandleId takes integer handleid returns integer
local integer addr=GetGameStateInstance()
if addr!=0 and handleid!=0 then
return ReadRealMemory(ReadRealMemory(ReadRealMemory(ReadRealMemory(addr)+0x1C)+0x19C)+handleid*0xC-0x2FFFFF*4)
endif
return 0
endfunction
function ConvertHandle takes handle h returns integer
return ConvertHandleId(GetHandleId(h))
endfunction
function GetGameDataNode takes nothing returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetDataNode"))
local integer pData=GetGameStateInstance()
if addr!=0 and pData!=0 then
return this_call_1(addr,ReadRealMemory(pData))
endif
return 0
endfunction
function HandleIdToObject takes integer handleid returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("ConvertPointer"))
local integer pData=GetGameDataNode()
if addr!=0 and pData!=0 then
return this_call_2(addr,pData,handleid)
endif
return 0
endfunction
function ObjectToHandleId takes integer pAgent returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GenerateHandle"))
local integer pData=GetGameDataNode()
if addr!=0 and pData!=0 then
return this_call_3(addr,pData,pAgent,0)
endif
return 0
endfunction
function GetAgentType takes handle h returns integer
local integer func=ReadRealMemory(ReadRealMemory(ConvertHandle(h))+0x1C)
return ReadRealMemory(func)/ 0x100+ReadRealMemory(func+0x4)*0x1000000
endfunction
function ObjectToAbility takes integer pObject returns ability
local integer pAbil=0
if pObject>0 then
set pAbil=ObjectToHandleId(pObject)
if pAbil>0 then
return I2A(pAbil)
endif
endif
return null
endfunction
function ObjectToUnit takes integer pUnit returns unit
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("CUnitTojUnit"))
if addr!=0 and pUnit!=0 then
set pUnit=fast_call_1(addr,pUnit)
if pUnit!=0 then
return I2U(pUnit)
endif
endif
return null
endfunction
function GetAgentHashKey takes integer agentId returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetHashKey"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
local integer pData=0
if addr!=0 and arg!=0 and agentId!=0 then
call WriteRealMemory(arg,agentId)
set pData=this_call_1(addr,arg)
endif
return pData
endfunction
function GetAgentUIDefById takes integer agentId returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileUINode"))
if addr!=0 and agentId!=0 then
return this_call_1(addr,agentId)
endif
return 0
endfunction
function GetAgileDataNodeById takes integer pDataNode,integer agentId returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileDataNode"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
local integer pData=GetAgentHashKey(agentId)
if addr!=0 and arg!=0 and pData!=0 then
return this_call_3(addr,pDataNode,pData,arg)
endif
return 0
endfunction
function GetWidgetUIDefById takes integer wid returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetWidgetUIDef"))
if addr!=0 and wid!=0 then
return this_call_1(addr,wid)
endif
return 0
endfunction
function jUnitToCUnit takes unit u returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("jUnitToCUnit"))
if addr!=0 then
return this_call_1(addr,GetHandleId(u))
endif
return 0
endfunction
function GetCObjectFromHashEx takes integer pHash1,integer pHash2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetObjectFromHash"))
if addr!=0 and pHash1!=0xFFFFFFFF and pHash2!=0xFFFFFFFF then
return fast_call_2(addr,pHash1,pHash2)
endif
return 0
endfunction
function GetCObjectFromHashGroupEx takes integer pHashGroup returns integer
if pHashGroup>0 then
return GetCObjectFromHashEx(ReadRealMemory(pHashGroup+0x0),ReadRealMemory(pHashGroup+0x4))
endif
return 0
endfunction
function GetCObjectFromHash takes integer pHash1,integer pHash2 returns integer
local integer addr=GetTempestThread()
local integer pOff1=0x2C
if addr!=0 then
if BitwiseAnd(pHash1,pHash2)==-1 then
return 0
endif
if pHash1>=0 then
set pOff1=0xC
endif
set pOff1=ReadRealMemory(addr)+pOff1
set pOff1=ReadRealMemory(pOff1)
if pOff1==0 then
return 0
endif
set pOff1=ReadRealMemory(pOff1+0x8*pHash1+0x4)
if pOff1==0 or ReadRealMemory(pOff1+0x18)!=pHash2 then
return 0
endif
return pOff1
endif
return 0
endfunction
function GetCAgentFromHash takes integer pHash1,integer pHash2 returns integer
local integer pOff1=GetCObjectFromHash(pHash1,pHash2)
if pOff1==0 or ReadRealMemory(pOff1+0x20)>0 then
return 0
endif
return ReadRealMemory(pOff1+0x54)
endfunction
function GetCAgentFromHashGroup takes integer pHash returns integer
local integer pData=0
if pHash!=0 then
return GetCAgentFromHash(ReadRealMemory(pHash+0x0),ReadRealMemory(pHash+0x4))
endif
return 0
endfunction
function GetCObjectFromHashGroup takes integer pHashGroup returns integer
local integer addr=GetTempestThread()
local integer pOffset1=pHashGroup
local integer pOffset2
if addr!=0 and pHashGroup!=0 then
set pOffset2=ReadRealMemory(addr)
if pOffset2>0 then
set pOffset1=ReadRealMemory(pOffset1)
set pOffset2=ReadRealMemory(pOffset2+0xC)
set pOffset2=ReadRealMemory((pOffset1*0x8)+pOffset2+0x4)
return pOffset2
endif
endif
return 0
endfunction
function GetCObjectFromHashGroup2 takes integer pHash returns integer
if pHash>0 then
return GetCObjectFromHash(ReadRealMemory(pHash+0x0),ReadRealMemory(pHash+0x4))
endif
return 0
endfunction
function GetUnitAddressFloatsRelated takes integer pObject,integer offset returns integer
if pObject>0 then
return GetCObjectFromHashGroup(pObject+offset)
endif
return 0
endfunction
function GetAgentTimerCooldown takes integer pTimer returns real
local integer pData=0
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if pTimer!=0 and arg!=0 then
set pData=ReadRealMemory(pTimer)
if pData!=0 then
call WriteRealMemory(arg,0)
call this_call_2(ReadRealMemory(pData+0x18),pTimer,arg)
return ReadRealFloat(arg)
endif
endif
return-1.
endfunction
function GetAgentTimerExtendedCooldown takes integer pTimerExt returns real
local integer pData=0
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if pTimerExt!=0 and arg!=0 then
set pData=ReadRealMemory(pTimerExt)
if pData!=0 then
call WriteRealMemory(arg+0x0,0)
call WriteRealMemory(arg+0x4,0)
call this_call_2(ReadRealMemory(pData+0x10),pTimerExt,arg+0x0)
call this_call_2(ReadRealMemory(pData+0x1C),pTimerExt,arg+0x4)
return ReadRealFloat(arg+0x0)-ReadRealFloat(arg+0x4)
endif
endif
return-1.
endfunction
function GetSmartPositionAxis takes integer pSmartPos returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetSmartPositionAxis"))
local integer pvector2=0
if pSmartPos!=0 and addr!=0 then
set pvector2=LoadInteger(MemHackTable,StringHash("CustomData"),StringHash("Vector2"))
call this_call_2(addr,pSmartPos,pvector2)
return pvector2
endif
return 0
endfunction
function SetSmartPositionAxisEx takes integer pSmartPos,real x,real y,integer flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("SetSmartPositionAxis"))
local integer pvector2=0
if pSmartPos!=0 and addr!=0 then
set pvector2=LoadInteger(MemHackTable,StringHash("CustomData"),StringHash("Vector2"))
call WriteRealFloat(pvector2+0x0,x)
call WriteRealFloat(pvector2+0x4,y)
return this_call_3(addr,pSmartPos,pvector2,flag)
endif
return 0
endfunction
function SetSmartPositionAxis takes integer pSmartPos,real x,real y returns integer
return SetSmartPositionAxisEx(pSmartPos,x,y,1)
endfunction
function Init_APIMemoryGameData takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GameState"),pGameDLL+0xACD44C)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("TempestThread"),pGameDLL+0xACE5E0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("jUnitToCUnit"),pGameDLL+0x3BE7F0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetDataNode"),pGameDLL+0x3A8BA0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("ConvertPointer"),pGameDLL+0x428B90)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GenerateHandle"),pGameDLL+0x4317C0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetHashKey"),pGameDLL+0x4C9020)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileDataNode"),pGameDLL+0x46F230)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileUINode"),pGameDLL+0x001EC0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetWidgetUIDef"),pGameDLL+0x32D3C0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgentUIDef"),pGameDLL+0x32D420)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("CUnitTojUnit"),pGameDLL+0x2DD760)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetObjectFromHash"),pGameDLL+0x040770)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetSmartPositionAxis"),pGameDLL+0x474E00)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("SetSmartPositionAxis"),pGameDLL+0x474D60)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GameState"),pGameDLL+0xAB65F4)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("TempestThread"),pGameDLL+0xAB7788)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("jUnitToCUnit"),pGameDLL+0x3BDCB0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetDataNode"),pGameDLL+0x3A8060)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("ConvertPointer"),pGameDLL+0x428050)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GenerateHandle"),pGameDLL+0x430C80)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetHashKey"),pGameDLL+0x4C8520)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileDataNode"),pGameDLL+0x46E720)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileUINode"),pGameDLL+0x001EC0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetWidgetUIDef"),pGameDLL+0x32C880)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgentUIDef"),pGameDLL+0x32C8E0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("CUnitTojUnit"),pGameDLL+0x2DCC40)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetObjectFromHash"),pGameDLL+0x03FA30)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetSmartPositionAxis"),pGameDLL+0x4742F0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("SetSmartPositionAxis"),pGameDLL+0x474250)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GameState"),pGameDLL+0xBE4238)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("TempestThread"),pGameDLL+0xBE40A8)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("jUnitToCUnit"),pGameDLL+0x1D1550)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetDataNode"),pGameDLL+0x1C3200)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("ConvertPointer"),pGameDLL+0x268380)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GenerateHandle"),pGameDLL+0x2651D0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetHashKey"),pGameDLL+0x17A710)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileDataNode"),pGameDLL+0x0352A0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileUINode"),pGameDLL+0x021BD0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetWidgetUIDef"),pGameDLL+0x327020)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgentUIDef"),pGameDLL+0x322C30)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("CUnitTojUnit"),pGameDLL+0x88F250)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetObjectFromHash"),pGameDLL+0x037350)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetSmartPositionAxis"),pGameDLL+0x03D790)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("SetSmartPositionAxis"),pGameDLL+0x03F020)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GameState"),pGameDLL+0xD687A8)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("TempestThread"),pGameDLL+0xD68610)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("jUnitToCUnit"),pGameDLL+0x1EEF90)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetDataNode"),pGameDLL+0x1E0D70)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("ConvertPointer"),pGameDLL+0x285FE0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GenerateHandle"),pGameDLL+0x282E30)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetHashKey"),pGameDLL+0x198420)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileDataNode"),pGameDLL+0x052480)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileUINode"),pGameDLL+0x03ECD0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetWidgetUIDef"),pGameDLL+0x344760)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgentUIDef"),pGameDLL+0x340380)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("CUnitTojUnit"),pGameDLL+0x9BA350)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetObjectFromHash"),pGameDLL+0x054530)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetSmartPositionAxis"),pGameDLL+0x058900)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("SetSmartPositionAxis"),pGameDLL+0x05C200)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GameState"),pGameDLL+0xD305E0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("TempestThread"),pGameDLL+0xD30448)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("jUnitToCUnit"),pGameDLL+0x2217A0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetDataNode"),pGameDLL+0x2135F0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("ConvertPointer"),pGameDLL+0x2B8490)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GenerateHandle"),pGameDLL+0x2B52E0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetHashKey"),pGameDLL+0x1CACC0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileDataNode"),pGameDLL+0x07BFE0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgileUINode"),pGameDLL+0x069D60)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetWidgetUIDef"),pGameDLL+0x378720)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetAgentUIDef"),pGameDLL+0x374340)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("CUnitTojUnit"),pGameDLL+0x96F2E0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetObjectFromHash"),pGameDLL+0x07E090)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("GetSmartPositionAxis"),pGameDLL+0x0844D0)
call SaveInteger(MemHackTable,StringHash("CGameWar3"),StringHash("SetSmartPositionAxis"),pGameDLL+0x085D70)
endif
call SaveInteger(MemHackTable,StringHash("CustomData"),StringHash("Vector2"),Malloc(0x8))
call SaveInteger(MemHackTable,StringHash("CustomData"),StringHash("Vector3"),Malloc(0xC))
call SaveInteger(MemHackTable,StringHash("CustomData"),StringHash("Matrix3x3"),Malloc(0x24))
endif
endfunction
function StormLoadFile takes string filename,integer ppBuffer,integer pSize,integer extraSizeToAllocate,integer pOverlapped returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("StormDll"),StringHash("SFile::Load"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if addr!=0 and arg!=0 then
call WriteRealMemory(arg+0x0,ppBuffer)
call WriteRealMemory(arg+0x4,pSize)
return std_call_5(addr,GetStringAddress(filename),arg+0x0,arg+0x4,1,0)
endif
return 0
endfunction
function StormAllocateMemory takes integer size,string name,integer unk_1,integer unk_2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Alloc"))
if addr!=0 and size>0 then
return std_call_4(addr,size,GetStringAddress(name),unk_1,unk_2)
endif
return 0
endfunction
function StormFreeMemory takes integer memaddr,string name,integer unk_1,integer unk_2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Free"))
if addr!=0 and memaddr!=0 then
return std_call_4(addr,memaddr,GetStringAddress(name),unk_1,unk_2)
endif
return 0
endfunction
function StormGetMemorySize takes integer memaddr,string name,integer unk_1 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::GetSize"))
if addr!=0 and memaddr!=0 then
return std_call_3(addr,memaddr,GetStringAddress(name),unk_1)
endif
return 0
endfunction
function StormReallocateMemory takes integer memaddr,integer size,string name,integer unk_1,integer unk_2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::ReAlloc"))
if addr!=0 and memaddr!=0 and size>0 then
return std_call_5(addr,memaddr,size,GetStringAddress(name),unk_1,unk_2)
endif
return 0
endfunction
function Init_APIMemoryStormDLL takes nothing returns nothing
if PatchVersion!="" then
set pStormDLL=GetModuleHandle("Storm.dll")
if pStormDLL!=0 then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SFile::Load"),pStormDLL+0x01CF30)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Alloc"),pStormDLL+0x025F30)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Free"),pStormDLL+0x024880)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::GetSize"),pStormDLL+0x024AD0)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::ReAlloc"),pStormDLL+0x026230)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SFile::Load"),pStormDLL+0x01CF30)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Alloc"),pStormDLL+0x025F30)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Free"),pStormDLL+0x024880)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::GetSize"),pStormDLL+0x024AD0)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::ReAlloc"),pStormDLL+0x026230)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SFile::Load"),pStormDLL+0x022660)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Alloc"),pStormDLL+0x02B830)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Free"),pStormDLL+0x02BE40)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::GetSize"),pStormDLL+0x02C000)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::ReAlloc"),pStormDLL+0x02C8B0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SFile::Load"),pStormDLL+0x0224E0)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Alloc"),pStormDLL+0x02B6D0)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Free"),pStormDLL+0x02BCE0)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::GetSize"),pStormDLL+0x02BEA0)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::ReAlloc"),pStormDLL+0x02C760)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SFile::Load"),pStormDLL+0x022A50)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Alloc"),pStormDLL+0x02BC10)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::Free"),pStormDLL+0x02C220)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::GetSize"),pStormDLL+0x02C3E0)
call SaveInteger(MemHackTable,StringHash("StormDll"),StringHash("SMem::ReAlloc"),pStormDLL+0x02CC90)
endif
endif
endif
endfunction
function IsBadReadPtr takes integer pointer,integer size returns boolean
local integer addr=GetFuncFromDll("Kernel32.dll","IsBadReadPtr",true)
if addr!=0 then
return std_call_2(addr,pointer,size)==0
endif
return false
endfunction
function GetLocalTime takes integer timeId returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","GetLocalTime",true)
local integer mem=0
local integer pOff=0
local integer memval=0
if addr!=0 then
set mem=LoadInteger(MemHackTable,StringHash("KernelAPI"),StringHash("SysTimeMem"))
if mem!=0 then
call std_call_1(addr,mem)
if timeId>=0 and timeId<=7 then
set memval=ReadRealMemory(mem+(0xE-timeId*2))
if memval>0 then
return CreateInteger1(0,0,GetByteFromInteger(memval,3),GetByteFromInteger(memval,4))
endif
endif
endif
endif
return 0
endfunction
function GetCurrentProcessId takes nothing returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","GetCurrentProcessId",true)
if addr!=0 then
return c_call_1(addr,0)
endif
return 0
endfunction
function CreateDirectory takes string directorypath,integer securityAttributes returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","CreateDirectoryA",true)
if addr!=0 then
return std_call_2(addr,GetStringAddress(directorypath),securityAttributes)
endif
return 0
endfunction
function CreateFile takes string filename,integer accessType,integer shareMode,integer securityAttributes,integer creationDisposition,integer flags,integer templateFile returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","CreateFileA",true)
if addr!=0 then
return std_call_7(addr,GetStringAddress(filename),accessType,shareMode,securityAttributes,creationDisposition,flags,templateFile)
endif
return 0
endfunction
function CreateFileSimple takes string filename returns integer
return CreateFile(filename,0xC0000000,0x00000002,0,0x1,0x80,0)
endfunction
function CloseHandle takes integer hHandle returns nothing
local integer addr=GetFuncFromDll("Kernel32.dll","CloseHandle",true)
if addr!=0 and hHandle!=0 then
call std_call_1(addr,hHandle)
endif
endfunction
function ReadStringFromFile takes string sfile,string ssection,string skey,string sdefval returns string
local integer addr=GetFuncFromDll("Kernel32.dll","GetPrivateProfileStringA",true)
local integer mem=LoadInteger(MemHackTable,StringHash("StringArray"),0)
local integer size=LoadInteger(MemHackTable,StringHash("StringArraySize"),0)
if addr!=0 and mem!=0 and size!=0 then
call std_call_6(addr,GetStringAddress(ssection),GetStringAddress(skey),GetStringAddress(sdefval),mem,size,GetStringAddress(sfile))
return ToJString(mem)
endif
return""
endfunction
function WriteStringToFile takes string sfile,string ssection,string skey,string sval returns nothing
local integer addr=GetFuncFromDll("Kernel32.dll","WritePrivateProfileStringA",true)
if addr!=0 then
call std_call_4(addr,GetStringAddress(ssection),GetStringAddress(skey),GetStringAddress(sval),GetStringAddress(sfile))
endif
endfunction
function GetFileAttributes takes string s returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","GetFileAttributesA",true)
if addr!=0 then
return std_call_1(addr,GetStringAddress(s))
endif
return 0
endfunction
function LoadLibrary takes string nDllName returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","LoadLibraryA",true)
if addr!=0 then
return std_call_1(addr,GetStringAddress(nDllName))
endif
return 0
endfunction
function MessageBox takes string message,string caption returns nothing
local integer addr=GetFuncFromDll("User32.dll","MessageBoxA",true)
if addr!=0 then
call std_call_4(addr,0,GetStringAddress(message),GetStringAddress(caption),0)
endif
endfunction
function FindWindowByAddr takes integer c_addr,integer w_addr returns integer
local integer addr=GetFuncFromDll("User32.dll","FindWindowA",true)
if addr!=0 then
return std_call_2(addr,c_addr,w_addr)
endif
return 0
endfunction
function FindWindow takes string class,string window returns integer
local integer c_addr=0
local integer w_addr=0
if class!="" then
set c_addr=GetStringAddress(class)
endif
if window!="" then
set w_addr=GetStringAddress(window)
endif
return FindWindowByAddr(c_addr,w_addr)
endfunction
function FindWindowExByAddr takes integer hwid1,integer hwid2,integer c_addr,integer w_addr returns integer
local integer addr=GetFuncFromDll("User32.dll","FindWindowExA",true)
if addr!=0 then
return std_call_4(addr,hwid1,hwid2,c_addr,w_addr)
endif
return 0
endfunction
function FindWindowEx takes integer hwid1,integer hwid2,string class,string window returns integer
local integer c_addr=0
local integer w_addr=0
if class!="" then
set c_addr=GetStringAddress(class)
endif
if window!="" then
set w_addr=GetStringAddress(window)
endif
return FindWindowExByAddr(hwid1,hwid2,c_addr,w_addr)
endfunction
function GetActiveWindow takes nothing returns integer
local integer addr=GetFuncFromDll("User32.dll","GetActiveWindow",true)
if addr!=0 then
return std_call_0(addr)
endif
return 0
endfunction
function GetForegroundWindow takes nothing returns integer
local integer addr=GetFuncFromDll("User32.dll","GetForegroundWindow",true)
if addr!=0 then
return std_call_0(addr)
endif
return 0
endfunction
function GetWindowClassName takes integer hwid returns string
local integer addr=GetFuncFromDll("User32.dll","GetClassNameA",true)
local integer mem=LoadInteger(MemHackTable,StringHash("StringArray"),0)
if addr!=0 and mem!=0 and hwid!=0 then
call std_call_3(addr,hwid,mem,260)
return ToJString(mem)
endif
return""
endfunction
function GetWindowText takes integer hwid returns string
local integer addr=GetFuncFromDll("User32.dll","GetWindowTextA",true)
local integer mem=LoadInteger(MemHackTable,StringHash("StringArray"),0)
if addr!=0 and mem!=0 and hwid!=0 then
call std_call_3(addr,hwid,mem,260)
return ToJString(mem)
endif
return""
endfunction
function GetSystemMetrics takes integer id returns integer
local integer addr=GetFuncFromDll("User32.dll","GetSystemMetrics",true)
if addr!=0 then
return std_call_1(addr,id)
endif
return 0
endfunction
function GetScreenWidth takes nothing returns integer
return GetSystemMetrics(0)
endfunction
function GetScreenHeight takes nothing returns integer
return GetSystemMetrics(1)
endfunction
function GetWindowRect takes integer hwnd returns integer
local integer addr=GetFuncFromDll("User32.dll","GetWindowRect",true)
local integer mem=0
if addr!=0 then
set mem=LoadInteger(MemHackTable,StringHash("KernelAPI"),StringHash("WindowRectMem"))
if mem!=0 then
return std_call_2(addr,hwnd,mem)
endif
endif
return 0
endfunction
function GetWindowRectStruct takes integer hwnd returns integer
local integer pWRect=GetWindowRect(hwnd)
if pWRect!=0 then
return LoadInteger(MemHackTable,StringHash("KernelAPI"),StringHash("WindowRectMem"))
endif
return 0
endfunction
function GetWindowX takes integer hwnd returns integer
local integer pWRect=GetWindowRectStruct(hwnd)
if pWRect!=0 then
return ReadRealMemory(pWRect+0x0)
endif
return 0
endfunction
function GetWindowY takes integer hwnd returns integer
local integer pWRect=GetWindowRectStruct(hwnd)
if pWRect>0 then
return ReadRealMemory(pWRect+0x4)
endif
return 0
endfunction
function ScreenToClient takes integer hwnd,integer lpPoint returns integer
local integer addr=GetFuncFromDll("User32.dll","ScreenToClient",true)
if addr!=0 then
return std_call_2(addr,hwnd,lpPoint)
endif
return 0
endfunction
function PostMessage takes integer hwnd,integer msg,integer wparam,integer lparam returns nothing
local integer addr=GetFuncFromDll("User32.dll","PostMessageA",true)
if addr!=0 then
call std_call_4(addr,hwnd,msg,wparam,lparam)
endif
endfunction
function GetCursorPos takes nothing returns integer
local integer addr=GetFuncFromDll("User32.dll","GetCursorPos",true)
local integer mem=0
if addr!=0 then
set mem=LoadInteger(MemHackTable,StringHash("KernelAPI"),StringHash("CursorCoordMem"))
if mem!=0 then
return std_call_1(addr,mem)
endif
endif
return 0
endfunction
function GetCursorPosStruct takes nothing returns integer
if GetCursorPos()!=0 then
return LoadInteger(MemHackTable,StringHash("KernelAPI"),StringHash("CursorCoordMem"))
endif
return 0
endfunction
function ShellExecute takes string command,string path,string args returns nothing
local integer addr=GetFuncFromDll("Shell32.dll","ShellExecuteA",true)
if addr!=0 then
call std_call_6(addr,0,GetStringAddress(command),GetStringAddress(path),GetStringAddress(args),0,0)
endif
endfunction
function GetAsyncKeyState takes integer vk_key_code returns integer
local integer addr=GetFuncFromDll("User32.dll","GetAsyncKeyState",true)
if addr!=0 then
return std_call_1(addr,vk_key_code)
endif
return 0
endfunction
function IsKeyPressed takes integer vk_key_code returns boolean
return BitwiseAnd(GetAsyncKeyState(vk_key_code),0x8000)>0
endfunction
function ClearBenchmark takes nothing returns nothing
call SaveInteger(MemHackTable,StringHash("BenchmarkAPI"),StringHash("StartTime"),0)
call SaveInteger(MemHackTable,StringHash("BenchmarkAPI"),StringHash("EndTime"),0)
endfunction
function StartBenchmark takes nothing returns integer
local integer time=GetLocalTime(0)
call SaveInteger(MemHackTable,StringHash("BenchmarkAPI"),StringHash("StartTime"),time)
return time
endfunction
function StopBenchmark takes nothing returns integer
local integer startime=LoadInteger(MemHackTable,StringHash("BenchmarkAPI"),StringHash("StartTime"))
local integer endtime=GetLocalTime(0)
local integer result=endtime-startime
call SaveInteger(MemHackTable,StringHash("BenchmarkAPI"),StringHash("EndTime"),endtime)
return result
endfunction
function Init_APIMemoryKernel takes nothing returns nothing
if PatchVersion!="" then
call SaveInteger(MemHackTable,StringHash("KernelAPI"),StringHash("SysTimeMem"),Malloc(0x28))
call SaveInteger(MemHackTable,StringHash("KernelAPI"),StringHash("WindowRectMem"),Malloc(0x10))
call SaveInteger(MemHackTable,StringHash("KernelAPI"),StringHash("CursorCoordMem"),Malloc(0x08))
call ClearBenchmark()
endif
endfunction
function FileExists takes string s returns boolean
return GetFileAttributes(s)!=-1
endfunction
function GetFileSizeFromMPQ takes string source returns integer
return StormLoadFile(source,0,0,1,0)
endfunction
function ExportFileFromMPQByAddr takes integer saddr,integer daddr returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("MPQAPI"),StringHash("ExportFile"))
if addr!=0 and saddr!=0 and daddr!=0 then
return fast_call_2(addr,saddr,daddr)
endif
return 0
endfunction
function ExportFileFromMPQ takes string source,string dest returns boolean
return ExportFileFromMPQByAddr(GetStringAddress(source),GetStringAddress(dest))>0
endfunction
function LoadDllFromMPQEx takes string source,string dest,string dllname returns boolean
if ExportFileFromMPQ(source,dest)then
call LoadLibrary(dllname)
return true
endif
return false
endfunction
function LoadDllFromMPQ takes string dllname returns boolean
return LoadDllFromMPQEx(dllname,dllname,dllname)
endfunction
function Init_APIMemoryMPQ takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("MPQAPI"),StringHash("ExportFile"),pGameDLL+0x7386A0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("MPQAPI"),StringHash("ExportFile"),pGameDLL+0x737F00)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("MPQAPI"),StringHash("ExportFile"),pGameDLL+0x702C50)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("MPQAPI"),StringHash("ExportFile"),pGameDLL+0x720390)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("MPQAPI"),StringHash("ExportFile"),pGameDLL+0x754560)
endif
endif
endfunction
function AddNewOffsetToRestore takes integer offsetaddress,integer offsetdefaultdata returns nothing
local integer len
local integer i
local integer arr_hash=StringHash("MemRestorerArray")
local integer addr_hash=StringHash("MemRestorerArrayAddr")
local integer val_hash=StringHash("MemRestorerArrayValue")
if offsetaddress==0 or LoadBoolean(MemHackTable,StringHash("MemRestorerAPI"),StringHash("IsGameClosing"))then
return
endif
set len=LoadInteger(MemHackTable,arr_hash,StringHash("Length"))
set i=len
loop
exitwhen i==0
if LoadInteger(MemHackTable,addr_hash,i)==offsetaddress then
return
endif
set i=i-1
endloop
set len=len+1
call SaveInteger(MemHackTable,addr_hash,len,offsetaddress)
call SaveInteger(MemHackTable,val_hash,len,offsetdefaultdata)
call SaveInteger(MemHackTable,arr_hash,StringHash("Length"),len)
endfunction
function ChangeOffsetProtection takes integer pRealOffset,integer pMemSize,integer pProtectFlag returns integer
local integer addr=GetFuncFromDll("Kernel32.dll","VirtualProtect",true)
local integer a
local integer nIndex=0
if addr!=0 then
call AddNewOffsetToRestore(pRealOffset,ReadRealMemory(pRealOffset))
if pMemSize>0x4 then
set nIndex=pMemSize/ 0x4-0x1
set a=pRealOffset
loop
exitwhen nIndex<0x1
set a=a+0x4
call AddNewOffsetToRestore(a,ReadRealMemory(a))
set nIndex=nIndex-0x1
endloop
endif
return VirtualProtect(pRealOffset,pMemSize,pProtectFlag)
endif
return 0
endfunction
function PatchRealMemoryEx takes integer addr,integer val,integer size returns nothing
local integer oldprot=0
if addr!=0 then
set oldprot=VirtualProtect(addr,size,0x40)
call WriteRealMemory(addr,val)
call VirtualProtect(addr,size,oldprot)
endif
endfunction
function PatchRealMemory takes integer addr,integer val returns nothing
call PatchRealMemoryEx(addr,val,0x4)
endfunction
function PatchMemoryEx takes integer addr,integer val,integer size returns nothing
local integer oldprot=0
if addr!=0 then
set oldprot=VirtualProtect(addr,size,0x40)
call WriteMemory(addr,val)
call VirtualProtect(addr,size,oldprot)
endif
endfunction
function PatchMemory takes integer addr,integer val returns nothing
call PatchMemoryEx(addr,val,0x4)
endfunction
function RestoreAllMemory takes nothing returns nothing
local integer i=LoadInteger(MemHackTable,StringHash("MemRestorerArray"),StringHash("Length"))
local integer addr_hash=StringHash("MemRestorerArrayAddr")
local integer val_hash=StringHash("MemRestorerArrayValue")
local integer oldprot
call SaveBoolean(MemHackTable,StringHash("MemRestorerAPI"),StringHash("IsGameClosing"),true)
loop
exitwhen i<1
set oldprot=ChangeOffsetProtection(LoadInteger(MemHackTable,addr_hash,i),0x4,0x40)
call WriteRealMemory(LoadInteger(MemHackTable,addr_hash,i),LoadInteger(MemHackTable,val_hash,i))
call ChangeOffsetProtection(LoadInteger(MemHackTable,addr_hash,i),0x4,oldprot)
set i=i-1
endloop
endfunction
function InitExtrasPageDisplayOnExit takes integer pTriggerHandle returns nothing
local integer pTriggerExecute=LoadInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("TriggerExecute"))
local integer pExtrasPage=LoadInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPage"))
local integer pFinalTableHook=LoadInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPageMemory"))
local integer oldprot=0
if pTriggerExecute!=0 and pExtrasPage!=0 and pFinalTableHook==0 then
set pFinalTableHook=AllocateExecutableMemory(0x1C)
if pFinalTableHook!=0 then
set oldprot=VirtualProtect(pExtrasPage,0x8,0x40)
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPageMemory"),pFinalTableHook)
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPageVal1"),ReadRealMemory(pExtrasPage+0x0))
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPageVal2"),ReadRealMemory(pExtrasPage+0x4))
call WriteRealMemory(pExtrasPage+0x00,0xE9E9E9E9)
call WriteRealMemory(pExtrasPage+0x01,pFinalTableHook-(pExtrasPage+0x1)-0x4)
call WriteRealMemory(pFinalTableHook+0x00,0x68609090)
call WriteRealMemory(pFinalTableHook+0x04,pTriggerHandle)
call WriteRealMemory(pFinalTableHook+0x08,0xB890C08B)
call WriteRealMemory(pFinalTableHook+0x0C,pTriggerExecute)
call WriteRealMemory(pFinalTableHook+0x10,0xC483D0FF)
call WriteRealMemory(pFinalTableHook+0x14,0xE9906104)
call WriteRealMemory(pFinalTableHook+0x18,pExtrasPage-(pFinalTableHook+0x18)-0x4)
call VirtualProtect(pExtrasPage,0x8,oldprot)
endif
endif
endfunction
function DisplayExtrasPageDisplayOnExit takes nothing returns nothing
local integer pExtrasPage=LoadInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPage"))
local integer oldprot=0
if pExtrasPage!=0 then
set oldprot=VirtualProtect(pExtrasPage,0x8,0x40)
call WriteRealMemory(pExtrasPage+0x0,LoadInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPageVal1")))
call WriteRealMemory(pExtrasPage+0x4,LoadInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPageVal2")))
call VirtualProtect(pExtrasPage,0x8,oldprot)
call RestoreAllMemory()
endif
endfunction
function Init_RestoreMemoryOnExit takes trigger t returns nothing
call TriggerAddAction(t,function DisplayExtrasPageDisplayOnExit)
call InitExtrasPageDisplayOnExit(GetHandleId(t))
endfunction
function Init_APIMemoryRestorer takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("TriggerExecute"),pGameDLL+0x3C4A80)
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPage"),pGameDLL+0x5C48C0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("TriggerExecute"),pGameDLL+0x3C3F40)
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPage"),pGameDLL+0x5C4120)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("TriggerExecute"),pGameDLL+0x1F9100)
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPage"),pGameDLL+0x2847F0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("TriggerExecute"),pGameDLL+0x216D90)
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPage"),pGameDLL+0x2A23E0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("TriggerExecute"),pGameDLL+0x249410)
call SaveInteger(MemHackTable,StringHash("MemRestorerAPI"),StringHash("ExtrasPage"),pGameDLL+0x2D4940)
endif
call SaveInteger(MemHackTable,StringHash("MemRestorerArray"),StringHash("Length"),0)
call Init_RestoreMemoryOnExit(CreateTrigger())
endif
endfunction
function GetUtilityLibraryHashtable takes nothing returns hashtable
return LoadHashtableHandle(MemHackTable,StringHash("UtilityLibrary.dll"),StringHash("HashTable"))
endfunction
function InitHashtableListener takes hashtable ht returns boolean
local integer addr=GetFuncFromDll("UtilityLibrary.dll","InitHashtableListener",true)
if addr!=0 and ht!=null then
call c_call_1(addr,GetHandleId(ht))
return true
endif
return false
endfunction
function RemoveHashtableListeners takes nothing returns boolean
local integer addr=GetFuncFromDll("UtilityLibrary.dll","RemoveHashtableListeners",true)
if addr!=0 then
call c_call_0(addr)
return true
endif
return false
endfunction
function Init_APIMemoryUtilityLibraryAPI takes nothing returns nothing
if PatchVersion!="" then
if LoadDllFromMPQ("UtilityLibrary.dll")then
call SaveHashtableHandle(MemHackTable,StringHash("UtilityLibrary.dll"),StringHash("HashTable"),InitHashtable())
call InitHashtableListener(GetUtilityLibraryHashtable())
endif
endif
endfunction
function GetGameUI takes integer bInit,integer bRelease returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameUI"),StringHash("GetInstance"))
if addr!=0 then
return fast_call_2(addr,bInit,bRelease)
endif
return 0
endfunction
function GetRootFrame takes nothing returns integer
if pGameUI!=0 then
return pGameUI+0xB4
endif
return 0
endfunction
function GetUIWorldFrameWar3 takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3BC)
endif
return 0
endfunction
function GetUIMinimap takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3C0)
endif
return 0
endfunction
function GetUIInfoBar takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3C4)
endif
return 0
endfunction
function GetUICommandBar takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3C8)
endif
return 0
endfunction
function GetUIResourceBarFrame takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3CC)
endif
return 0
endfunction
function GetUIUpperButtonBarFrame takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3D0)
endif
return 0
endfunction
function GetUIUnknown1 takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3D4)
endif
return 0
endfunction
function GetUIClickableBlock takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3D8)
endif
return 0
endfunction
function GetUIHeroBar takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3DC)
endif
return 0
endfunction
function GetUIPeonBar takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3E0)
endif
return 0
endfunction
function GetUIMessage takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3E4)
endif
return 0
endfunction
function GetUIUnitMessage takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3E8)
endif
return 0
endfunction
function GetUIChatMessage takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3EC)
endif
return 0
endfunction
function GetUITopMessage takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3F0)
endif
return 0
endfunction
function GetUIPortrait takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3F4)
endif
return 0
endfunction
function GetUITimeOfDayIndicator takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3F8)
endif
return 0
endfunction
function GetUIChatEditBar takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x3FC)
endif
return 0
endfunction
function GetUICinematicPanel takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x400)
endif
return 0
endfunction
function GetUIUnknown2 takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x404)
endif
return 0
endfunction
function GetUIMinimapButton1 takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x408)
endif
return 0
endfunction
function GetUIMinimapButton2 takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x40C)
endif
return 0
endfunction
function GetUIMinimapButton3 takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x410)
endif
return 0
endfunction
function GetUIMinimapButton4 takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x414)
endif
return 0
endfunction
function GetUIMinimapButton5 takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x418)
endif
return 0
endfunction
function GetUIFrameB takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x41C)
endif
return 0
endfunction
function GetUIMouseBorders takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x420)
endif
return 0
endfunction
function GetUIFrameA takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x424)
endif
return 0
endfunction
function GetUISimpleConsole takes nothing returns integer
if pGameUI!=0 then
return ReadRealMemory(pGameUI+0x428)
endif
return 0
endfunction
function GetPanelButton takes integer pFrame,integer row,integer column returns integer
if pFrame>0 then
return ReadRealMemory(ReadRealMemory(0x10*row+ReadRealMemory(pFrame+0x154)+0x8)+0x4*column)
endif
return 0
endfunction
function GetMinimapButton takes integer id returns integer
local integer pMiniMap=GetUIMinimap()
if pMiniMap>0 then
if id>=0 and id<=4 then
return ReadRealMemory(pMiniMap+id*4)
endif
endif
return 0
endfunction
function GetUpperButtonBarButton takes integer id returns integer
local integer pOff=0
local integer pUpperButtonBar=GetUIUpperButtonBarFrame()
if pUpperButtonBar>0 then
if id==0 then
set pOff=0x138
elseif id==1 then
set pOff=0x130
elseif id==2 then
set pOff=0x134
elseif id==3 then
set pOff=0x160
endif
if pOff>0 then
return ReadRealMemory(pUpperButtonBar+pOff)
endif
endif
return 0
endfunction
function GetSkillBarButtonXY takes integer row,integer column returns integer
local integer pCommandBar=GetUICommandBar()
if pCommandBar>0 then
if row>=0 and row<=2 and column>=0 and column<=3 then
return GetPanelButton(pCommandBar,row,column)
endif
endif
return 0
endfunction
function GetSkillBarButton takes integer id returns integer
local integer pUIBar=GetUICommandBar()
local integer pSkillBar=0
if pUIBar>0 then
if id>=0 and id<=11 then
set pSkillBar=ReadRealMemory(pUIBar+0x154)
if pSkillBar>0 then
return ReadRealMemory(ReadRealMemory(pSkillBar+0x8))+id*0x1C0
endif
endif
endif
return 0
endfunction
function GetItemBarButton takes integer id returns integer
local integer pInfoBar=GetUIInfoBar()
local integer pItemBar=0
if pInfoBar>0 then
if id>=0 and id<=5 then
set pItemBar=ReadRealMemory(pInfoBar+0x148)
if pItemBar>0 then
return ReadRealMemory(ReadRealMemory(pItemBar+0x130)+0x4)+id*0x1C0
endif
endif
endif
return 0
endfunction
function GetCommandBarButton takes integer id returns integer
if id>=0 and id<=11 then
return GetSkillBarButton(id)
elseif id>=12 and id<=17 then
return GetSkillBarButton(id-12)
endif
return 0
endfunction
function GetHeroBarButton takes integer id returns integer
local integer pHeroBar=GetUIHeroBar()
if pHeroBar>0 then
if id>=0 and id<=6 then
return GetPanelButton(pHeroBar,id,0)
endif
endif
return 0
endfunction
function GetHeroBarHealthBar takes integer id returns integer
local integer pHeroBar=GetHeroBarButton(id)
if pHeroBar>0 then
return ReadRealMemory(pHeroBar+0x1CC)
endif
return 0
endfunction
function GetHeroBarManaBar takes integer id returns integer
local integer pHeroBar=GetHeroBarButton(id)
if pHeroBar>0 then
return ReadRealMemory(pHeroBar+0x1D0)
endif
return 0
endfunction
function UpdateGameUI takes nothing returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CGameUI"),StringHash("UpdateUI"))
if addr!=0 then
call this_call_1(addr,0)
endif
endfunction
function LoadImageTexture takes string texturepath,integer flag1,integer flag2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameUI"),StringHash("LoadImage"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if addr!=0 and arg!=0 and texturepath!="" then
call WriteRealMemory(arg+0x0,0)
call WriteRealMemory(arg+0x4,0)
return fast_call_3(addr,GetStringAddress(texturepath),arg+0x0,arg+0x4)
endif
return 0
endfunction
function UnloadImageTexture takes integer pTexture returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameUI"),StringHash("UnloadImage"))
if addr!=0 and pTexture!=0 then
return this_call_1(addr,pTexture)
endif
return 0
endfunction
function SetWar3MapMap takes string minimap returns integer
local integer pMiniMap=GetUIMinimap()
local integer pTexture=0
local integer pOldTexture=0
if pMiniMap!=0 and minimap!="" then
set pTexture=LoadImageTexture(minimap,0,0)
if pTexture!=0 then
set pOldTexture=ReadRealMemory(pMiniMap+0x17C)
if pOldTexture!=0 then
call WriteRealMemory(pMiniMap+0x17C,pTexture)
return UnloadImageTexture(pOldTexture)
else
return UnloadImageTexture(pTexture)
endif
endif
endif
return 0
endfunction
function Init_APIMemoryGameUI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("GetInstance"),pGameDLL+0x301250)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UpdateUI"),pGameDLL+0x333240)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("LoadImage"),pGameDLL+0x7283A0)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UnloadImage"),pGameDLL+0x4DECB0)
set pWorldFrameWar3=pGameDLL+0x9536A8
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("GetInstance"),pGameDLL+0x300710)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UpdateUI"),pGameDLL+0x332700)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("LoadImage"),pGameDLL+0x727C00)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UnloadImage"),pGameDLL+0x4DE1B0)
set pWorldFrameWar3=pGameDLL+0x941550
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("GetInstance"),pGameDLL+0x34F3A0)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UpdateUI"),pGameDLL+0x3599F0)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("LoadImage"),pGameDLL+0x6FEA00)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UnloadImage"),pGameDLL+0x197AB0)
set pWorldFrameWar3=pGameDLL+0x98DCD0
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("GetInstance"),pGameDLL+0x36CB20)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UpdateUI"),pGameDLL+0x377190)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("LoadImage"),pGameDLL+0x71C150)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UnloadImage"),pGameDLL+0x1B57E0)
set pWorldFrameWar3=pGameDLL+0xABB66C
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("GetInstance"),pGameDLL+0x3A0B70)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UpdateUI"),pGameDLL+0x3AB2A0)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("LoadImage"),pGameDLL+0x750320)
call SaveInteger(MemHackTable,StringHash("CGameUI"),StringHash("UnloadImage"),pGameDLL+0x1E8060)
set pWorldFrameWar3=pGameDLL+0xAAC008
endif
set pGameUI=GetGameUI(0,0)
endif
endfunction
function IsCommandButton takes integer pButton returns boolean
return GetFrameTypeName(pButton)=="CCommandButton"
endfunction
function GetButtonData takes integer pCommandButton returns integer
if IsCommandButton(pCommandButton)then
return ReadRealMemory(pCommandButton+0x190)
endif
return 0
endfunction
function GetButtonGoldCost takes integer pCommandButton returns integer
local integer pButton=GetButtonData(pCommandButton)
if pButton>0 then
return ReadRealMemory(pButton+0x58C)
endif
return-1
endfunction
function GetButtonLumberCost takes integer pCommandButton returns integer
local integer pButton=GetButtonData(pCommandButton)
if pButton>0 then
return ReadRealMemory(pButton+0x590)
endif
return-1
endfunction
function GetButtonManaCost takes integer pCommandButton returns integer
local integer pButton=GetButtonData(pCommandButton)
if pButton>0 then
return ReadRealMemory(pButton+0x594)
endif
return-1
endfunction
function GetButtonCooldownOld takes integer pCommandButton returns real
local integer pAbil=0
local integer pAbilId=0
local integer pOrderId=0
local integer goldcost=0
local integer pAbilVal2=0
local integer pButton=0
local real prAbilVal1=0.
local real prAbilVal2=0.
if IsCommandButton(pCommandButton)then
set pButton=ReadRealMemory(pCommandButton+0x190)
if pButton>0 then
set pAbil=ReadRealMemory(pButton+0x6D4)
set pAbilId=ReadRealMemory(pButton+0x4)
set pOrderId=ReadRealMemory(pButton+0x8)
set goldcost=ReadRealMemory(pButton+0x58C)
if pAbil!=0 and pAbilId!='AHer' and pAbilId!='Amai' and pAbilId!='Asei' and pAbilId!='Asel' then
set pAbil=ReadRealMemory(pAbil+0xDC)
if pAbil>0 then
set pAbilVal2=ReadRealMemory(pAbil+0x0C)
if pAbilVal2>0 then
set prAbilVal1=GetRealFromMemory(ReadRealMemory(pAbil+0x04))
set prAbilVal2=GetRealFromMemory(ReadRealMemory(pAbilVal2+0x40))
return prAbilVal1-prAbilVal2
endif
endif
endif
endif
endif
return 0.
endfunction
function GetButtonCooldown takes integer pCommandButton,boolean addcheck returns real
local integer i=0
local integer pAbil=0
local integer pAbilId=0
local integer flag=0
local integer pOrderId=0
local integer pButtonData=0
local integer pTimer=0
local integer pObj=0
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if IsCommandButton(pCommandButton)then
set pButtonData=ReadRealMemory(pCommandButton+0x190)
if pButtonData!=0 then
set pOrderId=ReadRealMemory(pButtonData+0x8)
set flag=ReadRealMemory(pButtonData+0x10)
set pAbil=ReadRealMemory(pButtonData+0x6D4)
if pAbil!=0 then
set pAbilId=ReadRealMemory(pAbil+0x34)
if pAbilId==0 or pAbilId=='AHer' or pAbilId=='Apit' or pAbilId=='Asid' or pAbilId=='Asud' then
return 0.
elseif pAbilId=='Amai' or pAbilId=='Asei' or pAbilId=='Asel' then
loop
exitwhen i>12
set pObj=ReadRealMemory(pAbil+0xCC+i*0x4)
if pObj==pOrderId then
if ReadRealFloat(pAbil+0x1C4+i*0x1C+0xC)!=.0 then
set pTimer=pAbil+0x1C4+i*0x1C
else
set pTimer=pAbil+0x318+i*0x1C
endif
if pTimer!=0 then
call this_call_2(ReadRealMemory(ReadRealMemory(pTimer)+0x18),pTimer,arg+0x4)
return ReadRealFloat(arg+0x4)
endif
exitwhen true
endif
set i=i+1
endloop
else
if addcheck and flag==0x2000401 then
return 0.
endif
set flag=ReadRealMemory(pAbil+0x20)
if BitwiseAnd(flag,0x200)!=0 and BitwiseAnd(flag,0x400)==0 then
set pTimer=pAbil+0xD0
if pTimer!=0 then
call this_call_2(ReadRealMemory(ReadRealMemory(pTimer)+0x18),pTimer,arg+0x4)
return ReadRealFloat(arg+0x4)
endif
endif
endif
endif
endif
endif
return 0.
endfunction
function IsButtonOnCooldown takes integer pCommandButton returns boolean
return GetButtonCooldown(pCommandButton,true)>0.
endfunction
function Init_APIMemoryGameUIButton takes nothing returns nothing
endfunction
function GetWindowWidth takes nothing returns real
local integer addr=LoadInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Width"))
if addr!=0 then
return ReadRealFloat(addr)
endif
return 0.
endfunction
function GetWindowHeight takes nothing returns real
local integer addr=LoadInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Height"))
if addr!=0 then
return ReadRealFloat(addr)
endif
return 0.
endfunction
function GetWindowCenterX takes nothing returns real
return GetWindowX(LoadInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Window")))+GetWindowWidth()*0.5
endfunction
function GetWindowCenterY takes nothing returns real
return GetWindowY(LoadInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Window")))+GetWindowHeight()*0.5
endfunction
function GetWarcraftWindow takes nothing returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("GetWindow"))
local integer hwnd=0
if addr!=0 then
set hwnd=this_call_1(addr,0)
else
set hwnd=FindWindow("Warcraft III","Warcraft III")
endif
return hwnd
endfunction
function FromPixelX takes integer i returns real
return i*0.8/ GetWindowWidth()
endfunction
function FromPixelY takes integer i returns real
return i*0.6/ GetWindowHeight()
endfunction
function Init_APIMemoryGameWindow takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Width"),pGameDLL+0xAF577C)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Height"),pGameDLL+0xAF5778)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("GetWindow"),pGameDLL+0x6BB510)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Width"),pGameDLL+0xADE91C)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Height"),pGameDLL+0xADE918)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("GetWindow"),pGameDLL+0x6BAD70)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Width"),pGameDLL+0xBBA22C)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Height"),pGameDLL+0xBBA228)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("GetWindow"),pGameDLL+0x14D670)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Width"),pGameDLL+0xD47CC4)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Height"),pGameDLL+0xD47CC0)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("GetWindow"),pGameDLL+0x08B0A0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Width"),pGameDLL+0xD0FAB4)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Height"),pGameDLL+0xD0FAB0)
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("GetWindow"),pGameDLL+0x0B49B0)
endif
call SaveInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Window"),GetWarcraftWindow())
endif
endfunction
function AchievUnlocked takes player p,integer id,integer techid returns nothing
call SetPlayerTechResearched(p,techid,1)
call DisplayTextToPlayer(p,0,0,"|cffffcc90Подсказка:|r Получено достижение!")
if GetLocalPlayer()==p then
call QuestSetEnabled(udg_Achievement[id],true)
call QuestSetEnabled(udg_Fake_Achievement[id],false)
endif
endfunction
function DictatorshipOfProletariat takes player target returns nothing
call SetPlayerTechResearched(target,'R000',1)
call SetPlayerTechResearched(target,'R004',1)
call SetPlayerTechResearched(target,'R005',1)
call SetPlayerTechResearched(target,'R001',1)
call SetPlayerTechResearched(target,'R002',1)
call SetPlayerTechResearched(target,'R003',1)
call SetPlayerTechResearched(target,'R009',1)
call SetPlayerTechResearched(target,'R00A',1)
call SetPlayerTechResearched(target,'R00B',1)
call SetPlayerTechResearched(target,'R007',1)
call SetPlayerTechResearched(target,'R008',1)
call SetPlayerTechResearched(target,'R006',1)
call SetPlayerTechResearched(target,'R00C',1)
call SetPlayerTechResearched(target,'R00D',1)
call SetPlayerTechResearched(target,'R00E',1)
call SetPlayerTechResearched(target,'R032',1)
call SetPlayerTechResearched(target,'R033',1)
call SetPlayerTechResearched(target,'R031',1)
call SetPlayerTechResearched(target,'R04R',1)
call SetPlayerTechResearched(target,'R04S',1)
call SetPlayerTechResearched(target,'R04Q',1)
call SetPlayerTechResearched(target,'R00I',1)
call SetPlayerTechResearched(target,'R00K',1)
call SetPlayerTechResearched(target,'R00M',1)
call SetPlayerTechResearched(target,'R00N',1)
call SetPlayerTechResearched(target,'R00L',1)
call SetPlayerTechResearched(target,'R00G',1)
call SetPlayerTechResearched(target,'R00J',1)
call SetPlayerTechResearched(target,'R00H',1)
call SetPlayerTechResearched(target,'R00P',1)
call SetPlayerTechResearched(target,'R00Q',1)
call SetPlayerTechResearched(target,'R00O',1)
call SetPlayerTechResearched(target,'R00R',1)
call SetPlayerTechResearched(target,'R00S',1)
call SetPlayerTechResearched(target,'R00T',1)
call SetPlayerTechResearched(target,'R01J',1)
call SetPlayerTechResearched(target,'R01K',1)
call SetPlayerTechResearched(target,'R01H',1)
call SetPlayerTechResearched(target,'R01I',1)
call SetPlayerTechResearched(target,'R01G',1)
call SetPlayerTechResearched(target,'R022',1)
call SetPlayerTechResearched(target,'R025',1)
call SetPlayerTechResearched(target,'R023',1)
call SetPlayerTechResearched(target,'R02G',1)
call SetPlayerTechResearched(target,'R02H',1)
call SetPlayerTechResearched(target,'R02F',1)
call SetPlayerTechResearched(target,'R02N',1)
call SetPlayerTechResearched(target,'R02M',1)
call SetPlayerTechResearched(target,'R02I',1)
call SetPlayerTechResearched(target,'R02W',1)
call SetPlayerTechResearched(target,'R02V',1)
call SetPlayerTechResearched(target,'R02T',1)
call SetPlayerTechResearched(target,'R02U',1)
call SetPlayerTechResearched(target,'R02S',1)
call SetPlayerTechResearched(target,'R038',1)
call SetPlayerTechResearched(target,'R039',1)
call SetPlayerTechResearched(target,'R03A',1)
call SetPlayerTechResearched(target,'R03G',1)
call SetPlayerTechResearched(target,'R03E',1)
call SetPlayerTechResearched(target,'R03F',1)
call SetPlayerTechResearched(target,'R03H',1)
call SetPlayerTechResearched(target,'R03I',1)
call SetPlayerTechResearched(target,'R03J',1)
call SetPlayerTechResearched(target,'R042',1)
call SetPlayerTechResearched(target,'R041',1)
call SetPlayerTechResearched(target,'R03Z',1)
call SetPlayerTechResearched(target,'R03Y',1)
call SetPlayerTechResearched(target,'R040',1)
endfunction
function CreateDummy takes player owner,real x,real y,integer abilityID,integer abilityLvl,real lifeTime returns unit
local unit dummy=CreateUnit(owner,'h03C',x,y,0)
call UnitAddAbility(dummy,abilityID)
call SetUnitAbilityLevel(dummy,abilityID,abilityLvl)
call UnitApplyTimedLife(dummy,'eqwe',lifeTime)
return dummy
endfunction
function MessageToAll takes string message returns nothing
local integer index=0
loop
exitwhen index>11
call DisplayTextToPlayer(Player(index),0,0,message)
set index=index+1
endloop
endfunction
function MessageToAllies takes player p,string message returns nothing
local integer index=0
loop
exitwhen index>11
if IsPlayerAlly(p,Player(index))then
call DisplayTextToPlayer(Player(index),0,0,message)
endif
set index=index+1
endloop
endfunction
function MultiboardIconForAllies takes player p,string path,integer row,integer column returns nothing
local multiboarditem mbitem=MultiboardGetItem(udg_MultiBoard,row,column)
local integer i=0
loop
exitwhen i>11
if IsPlayerAlly(p,Player(i))then
if GetLocalPlayer()==Player(i)then
call MultiboardSetItemIcon(mbitem,path)
endif
endif
set i=i+1
endloop
call MultiboardReleaseItem(mbitem)
set mbitem=null
endfunction
function isPlayerHasTitan takes player target returns boolean
local integer id=GetPlayerId(target)+1
local boolean hasTitan=GetPlayerTechCount(target,'R04I',true)>0 and udg_Hero[id]!=null
return hasTitan
endfunction
function isPlayerHasCastle takes player target returns boolean
local integer id=GetPlayerId(target)+1
local boolean hasTitan=GetPlayerTechCount(target,'R04I',true)>0 and udg_Hero[id]!=null
local boolean hasCastle=udg_Castle[id]!=null
return hasTitan or hasCastle
endfunction
function Group__Copy_enum takes nothing returns nothing
local unit caster=GetEnumUnit()
call GroupAddUnit(bj_group,caster)
set caster=null
endfunction
function Group_Copy takes group g,group gg returns nothing
set bj_group=gg
call ForGroup(g,function Group__Copy_enum)
set g=null
set gg=null
set bj_group=null
endfunction
function Group_Count takes group g returns integer
local group gg=CreateGroup()
local integer i=0
local unit dami
call Group_Copy(g,gg)
loop
set dami=FirstOfGroup(gg)
exitwhen dami==null
set i=i+1
call GroupRemoveUnit(gg,dami)
endloop
call DestroyGroup(gg)
set g=null
set gg=null
set dami=null
return i
endfunction
function LoadInt takes integer id,string Key returns integer
return LoadInteger(udg_Hash,id,StringHash(Key))
endfunction
function LoadTimer takes integer id,string Key returns timer
return LoadTimerHandle(udg_Hash,id,StringHash(Key))
endfunction
function LoadBool takes integer id,string Key returns boolean
return LoadBoolean(udg_Hash,id,StringHash(Key))
endfunction
function LoadEffect takes integer id,string Key returns effect
return LoadEffectHandle(udg_Hash,id,StringHash(Key))
endfunction
function LoadUnit takes integer id,string Key returns unit
return LoadUnitHandle(udg_Hash,id,StringHash(Key))
endfunction
function LoadRealn takes integer id,string Key returns real
return LoadReal(udg_Hash,id,StringHash(Key))
endfunction
function SaveBool takes integer id,string Key,boolean value returns nothing
call SaveBoolean(udg_Hash,id,StringHash(Key),value)
endfunction
function SaveInt takes integer id,string Key,integer value returns nothing
call SaveInteger(udg_Hash,id,StringHash(Key),value)
endfunction
function SaveRealn takes integer id,string Key,real value returns nothing
call SaveReal(udg_Hash,id,StringHash(Key),value)
endfunction
function SaveUnit takes integer id,string Key,unit value returns nothing
call SaveUnitHandle(udg_Hash,id,StringHash(Key),value)
endfunction
function SaveTimer takes integer id,string Key,timer value returns nothing
call SaveTimerHandle(udg_Hash,id,StringHash(Key),value)
endfunction
function SaveEffect takes integer id,string Key,effect value returns nothing
call SaveEffectHandle(udg_Hash,id,StringHash(Key),value)
endfunction
function InitLib__Init takes nothing returns nothing
local integer index=0
loop
exitwhen index>11
set bj_unitLimit[index]=100
set index=index+1
endloop
endfunction
function s__InvokerSpells_st_Destroy takes integer this returns nothing
local integer ndx=1
loop
exitwhen ndx>2
call UnitRemoveAbility(s__InvokerSpells_st_caster[this],s___InvokerSpells_st_Abil[s__InvokerSpells_st_Abil[this]+ndx])
set s___InvokerSpells_st_Abil[s__InvokerSpells_st_Abil[this]+ndx]=0
set ndx=ndx+1
endloop
set s__InvokerSpells_st_caster[this]=null
call s__InvokerSpells_st_deallocate(this)
endfunction
function s__InvokerSpheres_st_Destroy takes integer this returns nothing
local integer ndx=1
loop
exitwhen ndx>3
call DestroyEffect(s___InvokerSpheres_st_Effect[s__InvokerSpheres_st_Effect[this]+ndx])
call UnitRemoveAbility(s__InvokerSpheres_st_caster[this],s___InvokerSpheres_st_Buff[s__InvokerSpheres_st_Buff[this]+ndx])
set s___InvokerSpheres_st_Buff[s__InvokerSpheres_st_Buff[this]+ndx]=0
set ndx=ndx+1
endloop
set s__InvokerSpheres_st_caster[this]=null
call s__InvokerSpheres_st_deallocate(this)
endfunction
function InvokerBook_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer spells=LoadInt(GetHandleId(caster),"InvokerSpells | Structure")
local integer spheres=LoadInt(GetHandleId(caster),"InvokerSpheres | Structure")
local integer fireCount_s=0
local integer lightningCount_s=0
local integer iceCount_s=0
local integer array spellID
local integer array fireCount
local integer array lightningCount
local integer array iceCount
local integer index=1
local integer spell=0
set spellID[1]='A0HN'
set iceCount[1]=0
set fireCount[1]=3
set lightningCount[1]=0
set spellID[2]='A0HO'
set iceCount[2]=0
set fireCount[2]=0
set lightningCount[2]=3
set spellID[3]='A0HP'
set iceCount[3]=3
set fireCount[3]=0
set lightningCount[3]=0
set spellID[4]='A0HT'
set iceCount[4]=0
set fireCount[4]=1
set lightningCount[4]=2
set spellID[5]='A0HW'
set iceCount[5]=0
set fireCount[5]=2
set lightningCount[5]=1
set spellID[6]='A0HX'
set iceCount[6]=1
set fireCount[6]=1
set lightningCount[6]=1
set spellID[7]='A0HY'
set iceCount[7]=2
set fireCount[7]=0
set lightningCount[7]=1
set spellID[8]='A0I2'
set iceCount[8]=1
set fireCount[8]=2
set lightningCount[8]=0
set spellID[9]='A0I3'
set iceCount[9]=2
set fireCount[9]=1
set lightningCount[9]=0
set spellID[10]='A0I4'
set iceCount[10]=1
set fireCount[10]=0
set lightningCount[10]=2
if spheres!=0 then
loop
exitwhen index>3
if s___InvokerSpheres_st_Sphere[s__InvokerSpheres_st_Sphere[spheres]+index]=="Fire" then
set fireCount_s=fireCount_s+1
elseif s___InvokerSpheres_st_Sphere[s__InvokerSpheres_st_Sphere[spheres]+index]=="Lightning" then
set lightningCount_s=lightningCount_s+1
elseif s___InvokerSpheres_st_Sphere[s__InvokerSpheres_st_Sphere[spheres]+index]=="Ice" then
set iceCount_s=iceCount_s+1
endif
set index=index+1
endloop
set index=1
loop
exitwhen spellID[index]==0
if fireCount_s==fireCount[index]and lightningCount_s==lightningCount[index]and iceCount_s==iceCount[index]then
set spell=spellID[index]
set index=100000
endif
set index=index+1
endloop
if spells==0 then
set spells=s__InvokerSpells_st__allocate()
set s__InvokerSpells_st_caster[spells]=caster
endif
call UnitRemoveAbility(caster,s___InvokerSpells_st_Abil[s__InvokerSpells_st_Abil[spells]+s__InvokerSpells_st_index[spells]])
set s___InvokerSpells_st_Abil[s__InvokerSpells_st_Abil[spells]+s__InvokerSpells_st_index[spells]]=spell
call UnitAddAbility(caster,spell)
set s__InvokerSpells_st_index[spells]=s__InvokerSpells_st_index[spells]+1
if s__InvokerSpells_st_index[spells]>2 then
set s__InvokerSpells_st_index[spells]=1
endif
call SaveInt(GetHandleId(caster),"InvokerSpells | Structure",spells)
call s__InvokerSpheres_st_Destroy(spheres)
call SaveInt(GetHandleId(caster),"InvokerSpheres | Structure",0)
endif
set caster=null
endfunction
function InvokerSpheres_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer spheres=LoadInt(GetHandleId(caster),"InvokerSpheres | Structure")
local integer spellID=GetSpellAbilityId()
local integer buffID=0
local string sphereEffect
local string sphereName
local integer spLvl=0
local integer index=1
local integer count=1
local integer lvl=0
if spheres==0 then
set spheres=s__InvokerSpheres_st__allocate()
set s__InvokerSpheres_st_caster[spheres]=caster
set s___InvokerSpheres_st_buffEffect[s__InvokerSpheres_st_buffEffect[spheres]]="sprite, first"
set s___InvokerSpheres_st_buffEffect[s__InvokerSpheres_st_buffEffect[spheres]+1]="sprite, second"
set s___InvokerSpheres_st_buffEffect[s__InvokerSpheres_st_buffEffect[spheres]+2]="sprite, third"
endif
if spellID=='A0HG' then
set buffID='A0HL'
set sphereName="Fire"
set sphereEffect="Abilities\\Spells\\Items\\AIfb\\AIfbTarget.mdl"
elseif spellID=='A0HI' then
set buffID='A0HM'
set sphereName="Lightning"
set sphereEffect="Abilities\\Spells\\Items\\AIlb\\AIlbTarget.mdl"
elseif spellID=='A0HH' then
set buffID='A0HK'
set sphereName="Ice"
set sphereEffect="Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl"
endif
set count=s__InvokerSpheres_st_index[spheres]
set spLvl=GetUnitAbilityLevel(caster,s___InvokerSpheres_st_Buff[s__InvokerSpheres_st_Buff[spheres]+count])
if spLvl>1 then
call SetUnitAbilityLevel(caster,s___InvokerSpheres_st_Buff[s__InvokerSpheres_st_Buff[spheres]+count],spLvl-1)
else
call UnitRemoveAbility(caster,s___InvokerSpheres_st_Buff[s__InvokerSpheres_st_Buff[spheres]+count])
endif
set lvl=GetUnitAbilityLevel(caster,buffID)
set s___InvokerSpheres_st_Buff[s__InvokerSpheres_st_Buff[spheres]+count]=buffID
set s___InvokerSpheres_st_Sphere[s__InvokerSpheres_st_Sphere[spheres]+count]=sphereName
call DestroyEffect(s___InvokerSpheres_st_Effect[s__InvokerSpheres_st_Effect[spheres]+count])
set s___InvokerSpheres_st_Effect[s__InvokerSpheres_st_Effect[spheres]+count]=AddSpecialEffectTarget(sphereEffect,caster,s___InvokerSpheres_st_buffEffect[s__InvokerSpheres_st_buffEffect[spheres]+count-1])
if lvl==0 then
call UnitAddAbility(caster,buffID)
else
call SetUnitAbilityLevel(caster,buffID,lvl+1)
endif
set s__InvokerSpheres_st_index[spheres]=s__InvokerSpheres_st_index[spheres]+1
if s__InvokerSpheres_st_index[spheres]>3 then
set s__InvokerSpheres_st_index[spheres]=1
endif
call SaveInt(GetHandleId(caster),"InvokerSpheres | Structure",spheres)
set caster=null
endfunction
function InvokerDie_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer spells=LoadInt(GetHandleId(caster),"InvokerSpells | Structure")
local integer spheres=LoadInt(GetHandleId(caster),"InvokerSpheres | Structure")
if spells!=0 then
call s__InvokerSpells_st_Destroy(spells)
call SaveInt(GetHandleId(caster),"InvokerSpells | Structure",0)
endif
if spheres!=0 then
call s__InvokerSpheres_st_Destroy(spheres)
call SaveInt(GetHandleId(caster),"InvokerSpheres | Structure",0)
endif
set caster=null
endfunction
function InvokerSpheres_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HH' or GetSpellAbilityId()=='A0HI' or GetSpellAbilityId()=='A0HG'
endfunction
function InvokerBook_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HJ'
endfunction
function InvokerDie_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())=='H03K'
endfunction
function InitTrig_Invoker takes nothing returns nothing
local trigger InvokerSpheres=CreateTrigger()
local trigger InvokerBook=CreateTrigger()
local trigger InvokerDie=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(InvokerSpheres,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(InvokerSpheres,Condition(function InvokerSpheres_Conditions))
call TriggerAddAction(InvokerSpheres,function InvokerSpheres_Actions)
call TriggerRegisterAnyUnitEventBJ(InvokerBook,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(InvokerBook,Condition(function InvokerBook_Conditions))
call TriggerAddAction(InvokerBook,function InvokerBook_Actions)
call TriggerRegisterAnyUnitEventBJ(InvokerDie,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(InvokerDie,Condition(function InvokerDie_Conditions))
call TriggerAddAction(InvokerDie,function InvokerDie_Actions)
endfunction
function GetItem takes unit caster,integer item_id returns item
local integer i=0
local item Item
loop
exitwhen i>5
set Item=UnitItemInSlot(caster,i)
if(GetItemTypeId(Item)==item_id)then
return Item
endif
set i=i+1
endloop
set Item=null
return Item
endfunction
function TextUpRand takes string s,unit u,real size,integer r,integer g,integer b,integer z,real speed,real life returns nothing
local real angle=GetRandomReal(0.00,360.00)
local real vel=speed*0.071/ 128
local real x1=0.03*Cos(angle*bj_DEGTORAD)
local real y1=0.03*Sin(angle*bj_DEGTORAD)
set bj_lastCreatedTextTag=CreateTextTag()
call SetTextTagText(bj_lastCreatedTextTag,s,(size*0.023)/ 10)
call SetTextTagPosUnit(bj_lastCreatedTextTag,u,z)
call SetTextTagColor(bj_lastCreatedTextTag,r,g,b,0)
call SetTextTagVelocity(bj_lastCreatedTextTag,x1,y1)
call SetTextTagPermanent(bj_lastCreatedTextTag,false)
call SetTextTagLifespan(bj_lastCreatedTextTag,life)
call SetTextTagFadepoint(bj_lastCreatedTextTag,0)
endfunction
function PointsAngle takes real x1,real y1,real x2,real y2 returns real
return bj_RADTODEG*Atan2(y2-y1,x2-x1)
endfunction
function AngleBetweenUnits takes unit u1,unit u2 returns real
return PointsAngle(GetUnitX(u1),GetUnitY(u1),GetUnitX(u2),GetUnitY(u2))
endfunction
function GetCountOfPointsInCircle takes real range returns integer
return R2I(range/ 25.00)
endfunction
function Chance takes unit caster,real chance returns boolean
local boolean result=false
local string s
if GetUnitAbilityLevel(caster,'B007')>0 then
set chance=chance+10.00
endif
if GetUnitAbilityLevel(caster,'BNsi')>0 then
set chance=0.00
endif
set result=GetRandomReal(0.00,100.00)<=chance
if not result then
set s=I2S(R2I(chance))+"%"
call TextUpRand(s,caster,6,0,255,0,0,96.00,1.00)
endif
return result
endfunction
function PointsDistance takes real x1,real y1,real x2,real y2 returns real
local real distanceX=x2-x1
local real distanceY=y2-y1
return SquareRoot(distanceX*distanceX+distanceY*distanceY)
endfunction
function PolarPoints takes real x,real y,real range,real angle,string arg returns real
set x=x+range*Cos(angle*bj_DEGTORAD)
set y=y+range*Sin(angle*bj_DEGTORAD)
if arg=="x" then
return x
elseif arg=="y" then
return y
endif
return 0.00
endfunction
function GetRandomPointInRange takes real x,real y,real range,string arg returns real
local real totalX=GetRandomReal(x-range/ 2,x+range/ 2)
local real totalY=GetRandomReal(y-range/ 2,y+range/ 2)
if arg=="x" then
return totalX
elseif arg=="y" then
return totalY
endif
return 0.00
endfunction
function SetUnitHeightByDistance takes unit target,real distance,real maxDistance,real upSpeed,real rate returns nothing
local real height=GetUnitFlyHeight(target)
local real totalCoef=1.00
local real index=1
loop
exitwhen index>20
if distance>maxDistance*(0.05*index)then
set totalCoef=0.05*index
set totalCoef=(totalCoef*2-1)*-1
else
set index=1000
endif
set index=index+1
endloop
set upSpeed=upSpeed*totalCoef
call SetUnitFlyHeight(target,height+upSpeed,rate)
endfunction
function geoArc takes real wayAbsolute returns real
return Sin((bj_PI/ 2.0)*wayAbsolute)
endfunction
function GeoArcBetweenReal takes real wayMin,real wayMax,real wayNow returns real
return geoArc((wayNow-wayMin)/(wayMax-wayMin))
endfunction
function GeoArcRelative takes real wayMin,real wayMax,real wayNow,real resultMin,real resultMax returns real
return(GeoArcBetweenReal(wayMin,wayMax,wayNow)*(resultMax-resultMin))+resultMin
endfunction
function GetAbilityBaseDataByAddress takes integer pAbil returns integer
if pAbil>0 then
return ReadRealMemory(pAbil+0x54)
endif
return 0
endfunction
function GetAddressAbilityTypeId takes integer pAbil returns integer
if pAbil!=0 then
return ReadRealMemory(pAbil+0x34)
endif
return 0
endfunction
function GetAddressAbilityBaseTypeId takes integer pAbil returns integer
local integer base=0
if pAbil>0 then
set base=GetAbilityBaseDataByAddress(pAbil)
if base>0 then
return ReadRealMemory(base+0x34)
endif
endif
return 0
endfunction
function GetAddressAbilityBaseId takes integer pAbil returns integer
local integer base=0
if pAbil>0 then
set base=GetAbilityBaseDataByAddress(pAbil)
if base>0 and ReadRealMemory(pAbil+0x6C)>0 then
return ReadRealMemory(base+0x30)
endif
endif
return 0
endfunction
function GetAddressAbilityOrderId takes integer pAbil returns integer
local integer pOffset2=0
local integer base=0
if pAbil>0 then
set base=GetAbilityBaseDataByAddress(pAbil)
if base>0 then
set base=ReadRealMemory(base+0x30)
if base>0 then
if base=='ANcl' then
return ReadRealMemory(pAbil+0x124)
else
return c_call_1(ReadRealMemory(ReadRealMemory(pAbil)+0x308),0)
endif
endif
endif
endif
return 0
endfunction
function IsAddressAbilityOnCooldown takes integer pAbil returns boolean
if pAbil>0 then
return IsFlagBitSet(ReadRealMemory(pAbil+0x20),512)
endif
return false
endfunction
function IsAddressAbilitySafe takes integer pAbil returns boolean
local integer base=GetAddressAbilityBaseId(pAbil)
local integer order=0
if base>0 then
if base=='ANcl' then
set order=ReadRealMemory(pAbil+0x124)
else
set order=GetAddressAbilityOrderId(pAbil)
endif
if base=='AOre' or base=='Aexh' then
return true
endif
return order>0 and base!='ANeg'
endif
return false
endfunction
function IsAddressAbilityUsable takes integer pAbil returns boolean
if pAbil>0 then
return this_call_1(ReadRealMemory(ReadRealMemory(pAbil)+0x1D8),pAbil)==1 or(ReadRealMemory(pAbil+0x6C)!=0 and GetAddressAbilityBaseId(pAbil)=='ANcl')
endif
return false
endfunction
function GetAddressAbilityCastTime takes integer pAbil returns real
if pAbil>0 then
set pAbil=ReadRealMemory(pAbil+0x84)
if pAbil>0 then
return GetRealFromMemory(ReadRealMemory(pAbil))
endif
endif
return 0.
endfunction
function SetAddressAbilityCastTime takes integer pAbil,real r returns nothing
if pAbil>0 then
set pAbil=ReadRealMemory(pAbil+0x84)
if pAbil>0 then
call WriteRealMemory(pAbil,SetRealIntoMemory(r))
endif
endif
endfunction
function GetAddressAbilityCastpoint takes integer pAbil returns real
if pAbil>0 then
return GetRealFromMemory(ReadRealMemory(pAbil+0x8C))
endif
return 0.
endfunction
function SetAddressAbilityCastpoint takes integer pAbil,real dur returns nothing
if pAbil>0 then
call WriteRealMemory(pAbil+0x8C,SetRealIntoMemory(dur))
endif
endfunction
function GetAddressAbilityBackswing takes integer pAbil returns real
if pAbil>0 then
return GetRealFromMemory(ReadRealMemory(pAbil+0x94))
endif
return 0.
endfunction
function SetAddressAbilityBackswing takes integer pAbil,real dur returns nothing
if pAbil>0 then
call WriteRealMemory(pAbil+0x94,SetRealIntoMemory(dur))
endif
endfunction
function GetAddressAbilityDefaultCooldown takes integer pAbil returns real
if pAbil>0 then
return GetRealFromMemory(ReadRealMemory(pAbil+0xB4))
endif
return 0.
endfunction
function SetAddressAbilityDefaultCooldown takes integer pAbil,real dur returns nothing
if pAbil>0 then
call WriteRealMemory(pAbil+0xB4,SetRealIntoMemory(dur))
endif
endfunction
function GetAddressAbilityManaCost takes integer pAbil,integer level returns integer
if pAbil>0 then
set pAbil=GetAbilityBaseDataByAddress(pAbil)
if pAbil>0 then
return ReadRealMemory(pAbil+level*0x68)
endif
endif
return 0
endfunction
function SetAddressAbilityManaCost takes integer pAbil,integer level,integer mc returns nothing
if pAbil>0 then
set pAbil=GetAbilityBaseDataByAddress(pAbil)
if pAbil>0 then
call WriteRealMemory(pAbil+level*0x68,mc)
endif
endif
endfunction
function GetAddressAbilityCooldownStamp takes integer pAbil returns real
if pAbil>0 then
set pAbil=ReadRealMemory(pAbil+0xDC)
if pAbil>0 then
return GetRealFromMemory(ReadRealMemory(pAbil+0x4))
endif
endif
return 0.
endfunction
function GetAddressAbilityCurrentCooldown takes integer pAbil returns real
local real cd=0.
if pAbil>0 then
set pAbil=ReadRealMemory(pAbil+0xDC)
if pAbil>0 then
set cd=GetRealFromMemory(ReadRealMemory(pAbil+0x4))
set pAbil=ReadRealMemory(pAbil+0xC)
if pAbil>0 then
set pAbil=ReadRealMemory(pAbil+0x40)
if pAbil>0 then
return cd-GetRealFromMemory(pAbil)
endif
endif
endif
endif
return .0
endfunction
function SetAddressAbilityCooldown takes integer pAbil,real seconds,string mode returns nothing
local real cd=0.
if pAbil!=0 then
set pAbil=ReadRealMemory(pAbil+0xDC)
if pAbil!=0 then
set cd=ReadRealFloat(pAbil+0x4)
if mode=="+" then
set seconds=cd+seconds
elseif mode=="-" then
set seconds=cd-seconds
endif
call WriteRealMemory(pAbil+0x4,SetRealIntoMemory(seconds))
endif
endif
endfunction
function StartAddressAbilityCooldown takes integer pAbil,real cd returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("CAbility"),StringHash("StartCooldown"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if addr!=0 and pAbil!=0 and arg!=0 and IsAddressAbilitySafe(pAbil)then
call WriteRealFloat(arg+0x0,cd)
call this_call_2(addr,pAbil,arg+0x0)
return IsAddressAbilityOnCooldown(pAbil)
endif
return false
endfunction
function SetAddressAbilityDisabled takes integer pAbil,integer count returns nothing
if pAbil>0 then
call WriteRealMemory(pAbil+0x3C,count)
endif
endfunction
function GetAddressAbilityDisabled takes integer pAbil returns integer
return ReadRealMemory(pAbil+0x3C)
endfunction
function SetAddressAbilityHidden takes integer pAbil,integer count returns nothing
if pAbil>0 then
call WriteRealMemory(pAbil+0x40,count)
endif
endfunction
function AddAddressAbilityHidden takes integer pAbil,integer d returns nothing
call WriteRealMemory(pAbil+0x40,ReadRealMemory(pAbil+0x40)+d)
endfunction
function GetAddressAbilityDisabledEx takes integer pAbil returns integer
if pAbil>0 then
return ReadRealMemory(pAbil+0x44)
endif
return 0
endfunction
function SetAddressAbilityDisabledEx takes integer pAbil,integer count returns nothing
if pAbil>0 then
call WriteRealMemory(pAbil+0x44,count)
endif
endfunction
function ShowAddressAbility takes integer pAbil,boolean flag returns nothing
if pAbil>0 then
if ReadRealMemory(pAbil)>0 then
call WriteRealMemory(pAbil+0x40,B2I(not flag))
endif
endif
endfunction
function SilenceAddressAbility takes integer pAbil returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CAbility"),StringHash("Silence"))
if addr!=0 and pAbil!=0 then
call this_call_3(addr,pAbil,0,1)
endif
endfunction
function UnsilenceAddressAbility takes integer pAbil returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CAbility"),StringHash("Unsilence"))
if addr!=0 and pAbil!=0 then
call this_call_3(addr,pAbil,0,1)
endif
endfunction
function GetAddressBuffLevel takes integer pBuff returns integer
if pBuff>0 then
return ReadRealMemory(pBuff+0xB0)+1
endif
return-1
endfunction
function Init_MemHackAbilityAddressAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("StartCooldown"),pGameDLL+0x0518B0)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Silence"),pGameDLL+0x0538A0)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Unsilence"),pGameDLL+0x053900)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("StartCooldown"),pGameDLL+0x050B70)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Silence"),pGameDLL+0x052B60)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Unsilence"),pGameDLL+0x052BC0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("StartCooldown"),pGameDLL+0x418D20)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Silence"),pGameDLL+0x3E9FA0)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Unsilence"),pGameDLL+0x3EE3C0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("StartCooldown"),pGameDLL+0x436460)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Silence"),pGameDLL+0x4076E0)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Unsilence"),pGameDLL+0x40BB00)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("StartCooldown"),pGameDLL+0x46A570)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Silence"),pGameDLL+0x43B7C0)
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Unsilence"),pGameDLL+0x43FBE0)
endif
endif
endfunction
function GetAbilityBaseDataById takes integer aid returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetDataNode"))
if addr!=0 and aid!=0 then
return this_call_1(addr,aid)
endif
return 0
endfunction
function GetAbilityBaseDataByIdCaching takes integer aid returns integer
local integer pAbil=0
if HaveSavedInteger(htObjectDataPointers,0,aid)then
return LoadInteger(htObjectDataPointers,0,aid)
endif
set pAbil=GetAbilityBaseDataById(aid)
if pAbil!=0 then
call SaveInteger(htObjectDataPointers,0,aid,pAbil)
endif
return pAbil
endfunction
function GetAbilityBaseUIById takes integer aid returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetUINode"))
if addr!=0 and aid!=0 then
return this_call_1(addr,aid)
endif
return 0
endfunction
function GetAbilityBaseUIByIdCaching takes integer aid returns integer
local integer pAbil=0
if HaveSavedInteger(htObjectDataPointers,1,aid)then
return LoadInteger(htObjectDataPointers,1,aid)
endif
set pAbil=GetAbilityBaseUIById(aid)
if pAbil!=0 then
call SaveInteger(htObjectDataPointers,1,aid,pAbil)
endif
return pAbil
endfunction
function GetAbilityBaseMaxLevelById takes integer aid returns integer
local integer pAbil
if aid!=0 then
set pAbil=GetAbilityBaseDataByIdCaching(aid)
if pAbil!=0 then
return ReadRealMemory(pAbil+0x50)
endif
endif
return 0
endfunction
function SetAbilityBaseHotkeyParam takes integer aid,integer off,integer newVal returns nothing
local integer pAbil=GetAbilityBaseUIByIdCaching(aid)
if pAbil>0 then
call WriteRealMemory(ReadRealMemory(pAbil+off),newVal)
endif
endfunction
function GetAbilityBaseHotkeyParam takes integer aid,integer off returns integer
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
set pData=ReadRealMemory(pData+off)
if pData>0 then
return ReadRealMemory(pData)
endif
endif
return 0
endfunction
function SetAbilityBaseUIIntegerParam takes integer aid,integer off,integer newVal returns nothing
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
call WriteRealMemory(pData+off,newVal)
endif
endfunction
function GetAbilityBaseUIIntegerParam takes integer aid,integer off returns integer
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
return ReadRealMemory(pData+off)
endif
return 0
endfunction
function SetAbilityBaseUIRealParam takes integer aid,integer off,real newVal returns nothing
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
call WriteRealMemory(pData+off,SetRealIntoMemory(newVal))
endif
endfunction
function GetAbilityBaseUIRealParam takes integer aid,integer off returns real
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
return ReadRealFloat(pData+off)
endif
return 0.
endfunction
function SetAbilityBaseUIBoolParam takes integer aid,integer off,boolean flag returns nothing
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
call WriteRealMemory(pData+off,B2I(flag))
endif
endfunction
function GetAbilityBaseUIBoolParam takes integer aid,integer off returns boolean
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
return ReadRealMemory(pData+off)>0
endif
return false
endfunction
function GetAbilityBaseUIPStringParam takes integer aid,integer off returns string
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
set pData=ReadRealMemory(pData+off)
if pData>0 then
return ToJString(ReadRealMemory(pData))
endif
endif
return null
endfunction
function SetAbilityBaseUIPStringParam takes integer aid,integer off,string newVal returns nothing
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
set pData=ReadRealMemory(pData+off)
if pData>0 then
call WriteRealMemory(pData,GetStringAddress(newVal))
endif
endif
endfunction
function GetAbilityBaseUIStringParam takes integer aid,integer off returns string
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
set pData=ReadRealMemory(pData+off)
if pData>0 then
return ToJString(pData)
endif
endif
return null
endfunction
function SetAbilityBaseUIStringParam takes integer aid,integer off,string newVal returns nothing
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData>0 then
call WriteRealMemory(pData+off,GetStringAddress(newVal))
endif
endfunction
function GetAbilityBaseUIStringParam2 takes integer aid,integer off,integer level returns string
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData!=0 then
set pData=ReadRealMemory(pData+off)
set level=level-1
if level>=0 and level<GetAbilityBaseMaxLevelById(aid)then
if pData!=0 then
set pData=ReadRealMemory(pData+level*0x4)
if pData!=0 then
return ToJString(pData)
endif
endif
endif
endif
return null
endfunction
function SetAbilityBaseUIStringParam2 takes integer aid,integer off,string newVal,integer level returns nothing
local integer pData=GetAbilityBaseUIByIdCaching(aid)
if pData!=0 then
set pData=ReadRealMemory(pData+off)
set level=level-1
if level>=0 and level<GetAbilityBaseMaxLevelById(aid)then
if pData!=0 then
call WriteRealMemory(pData+level*0x4,GetStringAddress(newVal))
endif
endif
endif
endfunction
function GetAbilityBaseDefData takes integer aid,integer level returns integer
local integer pAbil=GetAbilityBaseDataByIdCaching(aid)
if level>0 then
set level=level-1
endif
if pAbil!=0 and level>=0 and level<GetAbilityBaseMaxLevelById(aid)then
set pAbil=ReadRealMemory(pAbil+0x54)
if pAbil!=0 then
return pAbil+level*0x68
endif
endif
return 0
endfunction
function GetAbilityBaseNormalDurationById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x8)
endif
return .0
endfunction
function SetAbilityBaseNormalDurationById takes integer aid,integer level,real duration returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x8,duration)
endif
endfunction
function GetAbilityBaseHeroDurationById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0xC)
endif
return .0
endfunction
function SetAbilityBaseHeroDurationById takes integer aid,integer level,real duration returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0xC,duration)
endif
endfunction
function GetAbilityBaseManaCostById takes integer aid,integer level returns integer
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealMemory(pAbil+0x10)
endif
return 0
endfunction
function SetAbilityBaseManaCostById takes integer aid,integer level,integer cost returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealMemory(pAbil+0x10,cost)
endif
endfunction
function GetAbilityBaseCooldownById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x14)
endif
return .0
endfunction
function SetAbilityBaseCooldownById takes integer aid,integer level,real cool returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x14,cool)
endif
endfunction
function GetAbilityBaseAoEById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x18)
endif
return .0
endfunction
function SetAbilityBaseAoEById takes integer aid,integer level,real aoe returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x18,aoe)
endif
endfunction
function GetAbilityBaseRangeById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x1C)
endif
return .0
endfunction
function SetAbilityBaseRangeById takes integer aid,integer level,real range returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x1C,range)
endif
endfunction
function GetAbilityBaseDataAById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x20)
endif
return .0
endfunction
function SetAbilityBaseDataAById takes integer aid,integer level,real dataA returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x20,dataA)
endif
endfunction
function GetAbilityBaseDataBById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x24)
endif
return .0
endfunction
function SetAbilityBaseDataBById takes integer aid,integer level,real dataB returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x24,dataB)
endif
endfunction
function GetAbilityBaseDataCById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x28)
endif
return .0
endfunction
function SetAbilityBaseDataCById takes integer aid,integer level,real dataC returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x28,dataC)
endif
endfunction
function GetAbilityBaseDataDById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x2C)
endif
return .0
endfunction
function SetAbilityBaseDataDById takes integer aid,integer level,real dataD returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x2C,dataD)
endif
endfunction
function GetAbilityBaseDataEById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x30)
endif
return .0
endfunction
function SetAbilityBaseDataEById takes integer aid,integer level,real dataE returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x30,dataE)
endif
endfunction
function GetAbilityBaseDataFById takes integer aid,integer level returns real
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealFloat(pAbil+0x34)
endif
return .0
endfunction
function SetAbilityBaseDataFById takes integer aid,integer level,real dataF returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealFloat(pAbil+0x34,dataF)
endif
endfunction
function GetAbilityBaseSummonedUnitById takes integer aid,integer level returns integer
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealMemory(pAbil+0x44)
endif
return 0
endfunction
function SetAbilityBaseSummonedUnitById takes integer aid,integer level,integer uid returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealMemory(pAbil+0x44,uid)
endif
endfunction
function GetAbilityBaseEffectIdById takes integer aid,integer level returns integer
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
return ReadRealMemory(pAbil+0x64)
endif
return 0
endfunction
function SetAbilityBaseEffectIdById takes integer aid,integer level,integer eid returns nothing
local integer pAbil=GetAbilityBaseDefData(aid,level)
if pAbil!=0 then
call WriteRealMemory(pAbil+0x64,eid)
endif
endfunction
function GetAbilityBaseEffectSoundById takes integer aid returns string
return GetAbilityBaseUIStringParam(aid,0x30)
endfunction
function SetAbilityBaseEffectSoundById takes integer aid,string s returns nothing
call SetAbilityBaseUIStringParam(aid,0x30,s)
endfunction
function GetAbilityBaseEffectSoundLoopedById takes integer aid returns string
return GetAbilityBaseUIStringParam(aid,0x34)
endfunction
function SetAbilityBaseEffectSoundLoopedById takes integer aid,string s returns nothing
call SetAbilityBaseUIStringParam(aid,0x34,s)
endfunction
function GetAbilityBaseMissingIconById takes integer aid returns string
return GetAbilityBaseUIStringParam(aid,0x38)
endfunction
function SetAbilityBaseMissingIconById takes integer aid,string s returns nothing
call SetAbilityBaseUIStringParam(aid,0x38,s)
endfunction
function GetAbilityBaseCurrentIconById takes integer aid returns string
return GetAbilityBaseUIStringParam(aid,0x3C)
endfunction
function SetAbilityBaseCurrentIconById takes integer aid,string s returns nothing
call SetAbilityBaseUIStringParam(aid,0x3C,s)
endfunction
function GetAbilityBaseCursorTextureById takes integer aid returns string
return GetAbilityBaseUIStringParam(aid,0x44)
endfunction
function SetAbilityBaseCursorTextureById takes integer aid,string s returns nothing
call SetAbilityBaseUIStringParam(aid,0x44,s)
endfunction
function GetAbilityBaseGlobalMessageById takes integer aid returns string
return GetAbilityBaseUIStringParam(aid,0x48)
endfunction
function SetAbilityBaseGlobalMessageById takes integer aid,string s returns nothing
call SetAbilityBaseUIStringParam(aid,0x48,s)
endfunction
function GetAbilityBaseGlobalSoundById takes integer aid returns string
return GetAbilityBaseUIStringParam(aid,0x4C)
endfunction
function SetAbilityBaseGlobalSoundById takes integer aid,string s returns nothing
call SetAbilityBaseUIStringParam(aid,0x4C,s)
endfunction
function GetAbilityBaseButtonXById takes integer aid returns integer
return GetAbilityBaseUIIntegerParam(aid,0x50)
endfunction
function SetAbilityBaseButtonXById takes integer aid,integer newX returns nothing
call SetAbilityBaseUIIntegerParam(aid,0x50,newX)
endfunction
function GetAbilityBaseButtonYById takes integer aid returns integer
return GetAbilityBaseUIIntegerParam(aid,0x54)
endfunction
function SetAbilityBaseButtonYById takes integer aid,integer newY returns nothing
call SetAbilityBaseUIIntegerParam(aid,0x54,newY)
endfunction
function GetAbilityBaseUnButtonXById takes integer aid returns integer
return GetAbilityBaseUIIntegerParam(aid,0x58)
endfunction
function SetAbilityBaseUnButtonXById takes integer aid,integer newX returns nothing
call SetAbilityBaseUIIntegerParam(aid,0x58,newX)
endfunction
function GetAbilityBaseUnButtonYById takes integer aid returns integer
return GetAbilityBaseUIIntegerParam(aid,0x5C)
endfunction
function SetAbilityBaseUnButtonYById takes integer aid,integer newY returns nothing
call SetAbilityBaseUIIntegerParam(aid,0x5C,newY)
endfunction
function GetAbilityBaseResearchButtonXById takes integer aid returns integer
return GetAbilityBaseUIIntegerParam(aid,0x60)
endfunction
function SetAbilityBaseResearchButtonXById takes integer aid,integer newX returns nothing
call SetAbilityBaseUIIntegerParam(aid,0x60,newX)
endfunction
function GetAbilityBaseResearchButtonYById takes integer aid returns integer
return GetAbilityBaseUIIntegerParam(aid,0x64)
endfunction
function SetAbilityBaseResearchButtonYById takes integer aid,integer newY returns nothing
call SetAbilityBaseUIIntegerParam(aid,0x64,newY)
endfunction
function GetAbilityBaseMissileSpeedById takes integer aid returns real
return GetAbilityBaseUIRealParam(aid,0x68)
endfunction
function SetAbilityBaseMissileSpeedById takes integer aid,real speed returns nothing
call SetAbilityBaseUIRealParam(aid,0x68,speed)
endfunction
function GetAbilityBaseMissileArcById takes integer aid returns real
return GetAbilityBaseUIRealParam(aid,0x6C)
endfunction
function SetAbilityBaseMissileArcById takes integer aid,real arc returns nothing
call SetAbilityBaseUIRealParam(aid,0x6C,arc)
endfunction
function IsAbilityMissileHomingById takes integer aid returns boolean
return GetAbilityBaseUIBoolParam(aid,0x70)
endfunction
function SetAbilityBaseMissileHomingById takes integer aid,boolean homing returns nothing
call SetAbilityBaseUIBoolParam(aid,0x70,homing)
endfunction
function GetAbilityBaseSpellDetailsById takes integer aid returns integer
return GetAbilityBaseUIIntegerParam(aid,0x74)
endfunction
function SetAbilityBaseSpellDetailsById takes integer aid,integer det returns nothing
call SetAbilityBaseUIIntegerParam(aid,0x74,det)
endfunction
function GetAbilityBaseHotkeyIdById takes integer aid returns integer
return GetAbilityBaseHotkeyParam(aid,0x84)
endfunction
function SetAbilityBaseHotkeyIdById takes integer aid,integer newVal returns nothing
call SetAbilityBaseHotkeyParam(aid,0x84,newVal)
endfunction
function GetAbilityBaseUnHotkeyIdById takes integer aid returns integer
return GetAbilityBaseHotkeyParam(aid,0x90)
endfunction
function SetAbilityBaseUnHotkeyIdById takes integer aid,integer newVal returns nothing
call SetAbilityBaseHotkeyParam(aid,0x90,newVal)
endfunction
function GetAbilityBaseResearchHotkeyIdById takes integer aid returns integer
return GetAbilityBaseHotkeyParam(aid,0x9C)
endfunction
function SetAbilityBaseResearchHotkeyIdById takes integer aid,integer newVal returns nothing
call SetAbilityBaseHotkeyParam(aid,0x9C,newVal)
endfunction
function GetAbilityBaseNameById takes integer aid returns string
return GetAbilityBaseUIPStringParam(aid,0xA8)
endfunction
function SetAbilityBaseNameById takes integer aid,string s returns nothing
call SetAbilityBaseUIPStringParam(aid,0xA8,s)
endfunction
function GetAbilityBaseIconById takes integer aid returns string
return GetAbilityBaseUIPStringParam(aid,0xB4)
endfunction
function SetAbilityBaseIconById takes integer aid,string s returns nothing
call SetAbilityBaseUIPStringParam(aid,0xB4,s)
endfunction
function GetAbilityBaseMissileArtById takes integer aid returns string
return GetAbilityBaseUIPStringParam(aid,0xF0)
endfunction
function SetAbilityBaseMissileArtById takes integer aid,string s returns nothing
call SetAbilityBaseUIPStringParam(aid,0xF0,s)
endfunction
function GetAbilityBaseResearchTipById takes integer aid,integer lvl returns string
return GetAbilityBaseUIStringParam2(aid,0x12C,lvl)
endfunction
function SetAbilityBaseResearchTipById takes integer aid,string s,integer lvl returns nothing
call SetAbilityBaseUIStringParam2(aid,0x12C,s,lvl)
endfunction
function GetAbilityBaseTipById takes integer aid,integer lvl returns string
return GetAbilityBaseUIStringParam2(aid,0x138,lvl)
endfunction
function SetAbilityBaseTipById takes integer aid,integer lvl,string s returns nothing
call SetAbilityBaseUIStringParam2(aid,0x138,s,lvl)
endfunction
function GetAbilityBaseUnTipById takes integer aid,integer lvl returns string
return GetAbilityBaseUIStringParam2(aid,0x144,lvl)
endfunction
function SetAbilityBaseUnTipById takes integer aid,string s,integer lvl returns nothing
call SetAbilityBaseUIStringParam2(aid,0x144,s,lvl)
endfunction
function GetAbilityBaseResearchUberTipById takes integer aid,integer lvl returns string
return GetAbilityBaseUIStringParam2(aid,0x150,lvl)
endfunction
function SetAbilityBaseResearchUberTipById takes integer aid,string s,integer lvl returns nothing
call SetAbilityBaseUIStringParam2(aid,0x150,s,lvl)
endfunction
function GetAbilityBaseUbertipById takes integer aid,integer lvl returns string
return GetAbilityBaseUIStringParam2(aid,0x15C,lvl)
endfunction
function SetAbilityBaseUbertipById takes integer aid,integer lvl,string s returns nothing
call SetAbilityBaseUIStringParam2(aid,0x15C,s,lvl)
endfunction
function GetAbilityBaseResearchUnUberTipById takes integer aid,integer lvl returns string
return GetAbilityBaseUIStringParam2(aid,0x168,lvl)
endfunction
function SetAbilityBaseResearchUnUberTipById takes integer aid,string s,integer lvl returns nothing
call SetAbilityBaseUIStringParam2(aid,0x168,s,lvl)
endfunction
function SetAbilityBaseHotkeyCommonById takes integer aid,integer newVal returns nothing
call SetAbilityBaseHotkeyIdById(aid,newVal)
call SetAbilityBaseUnHotkeyIdById(aid,newVal)
call SetAbilityBaseResearchHotkeyIdById(aid,newVal)
endfunction
function GetAbilityTypeId takes ability a returns integer
return GetAddressAbilityTypeId(ConvertHandle(a))
endfunction
function GetAbilityBaseId takes ability abil returns integer
return GetAddressAbilityBaseId(ConvertHandle(abil))
endfunction
function GetAbilityBaseData takes ability abil returns integer
return GetAbilityBaseDataById(GetAbilityTypeId(abil))
endfunction
function GetAbilityBaseDataCaching takes ability abil returns integer
return GetAbilityBaseDataByIdCaching(GetAbilityBaseDataById(GetAbilityTypeId(abil)))
endfunction
function GetAbilityBaseUI takes ability abil returns integer
return GetAbilityBaseUIById(GetAbilityTypeId(abil))
endfunction
function GetAbilityBaseUICaching takes ability abil returns integer
return GetAbilityBaseUIByIdCaching(GetAbilityTypeId(abil))
endfunction
function GetAbilityBaseMaxLevel takes ability abil returns integer
return GetAbilityBaseMaxLevelById(GetAbilityTypeId(abil))
endfunction
function GetAbilityBaseHeroDuration takes ability abil,integer level returns real
return GetAbilityBaseHeroDurationById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseHeroDuration takes ability abil,integer level,real duration returns nothing
call SetAbilityBaseHeroDurationById(GetAbilityTypeId(abil),level,duration)
endfunction
function GetAbilityBaseNormalDuration takes ability abil,integer level returns real
return GetAbilityBaseNormalDurationById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseNormalDuration takes ability abil,integer level,real duration returns nothing
call SetAbilityBaseNormalDurationById(GetAbilityTypeId(abil),level,duration)
endfunction
function GetAbilityBaseManaCost takes ability abil,integer level returns integer
return GetAbilityBaseManaCostById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseManaCost takes ability abil,integer level,integer cost returns nothing
call SetAbilityBaseManaCostById(GetAbilityTypeId(abil),level,cost)
endfunction
function GetAbilityBaseCooldown takes ability abil,integer level returns real
return GetAbilityBaseCooldownById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseCooldown takes ability abil,integer level,real cool returns nothing
call SetAbilityBaseCooldownById(GetAbilityTypeId(abil),level,cool)
endfunction
function GetAbilityBaseAoE takes ability abil,integer level returns real
return GetAbilityBaseAoEById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseAoE takes ability abil,integer level,real aoe returns nothing
call SetAbilityBaseAoEById(GetAbilityTypeId(abil),level,aoe)
endfunction
function GetAbilityBaseRange takes ability abil,integer level returns real
return GetAbilityBaseRangeById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseRange takes ability abil,integer level,real range returns nothing
call SetAbilityBaseRangeById(GetAbilityTypeId(abil),level,range)
endfunction
function GetAbilityBaseDataA takes ability abil,integer level returns real
return GetAbilityBaseDataAById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseDataA takes ability abil,integer level,real dataA returns nothing
call SetAbilityBaseDataAById(GetAbilityTypeId(abil),level,dataA)
endfunction
function GetAbilityBaseDataB takes ability abil,integer level returns real
return GetAbilityBaseDataBById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseDataB takes ability abil,integer level,real dataB returns nothing
call SetAbilityBaseDataBById(GetAbilityTypeId(abil),level,dataB)
endfunction
function GetAbilityBaseDataC takes ability abil,integer level returns real
return GetAbilityBaseDataCById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseDataC takes ability abil,integer level,real dataC returns nothing
call SetAbilityBaseDataCById(GetAbilityTypeId(abil),level,dataC)
endfunction
function GetAbilityBaseDataD takes ability abil,integer level returns real
return GetAbilityBaseDataDById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseDataD takes ability abil,integer level,real dataD returns nothing
call SetAbilityBaseDataDById(GetAbilityTypeId(abil),level,dataD)
endfunction
function GetAbilityBaseDataE takes ability abil,integer level returns real
return GetAbilityBaseDataEById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseDataE takes ability abil,integer level,real dataE returns nothing
call SetAbilityBaseDataEById(GetAbilityTypeId(abil),level,dataE)
endfunction
function GetAbilityBaseDataF takes ability abil,integer level returns real
return GetAbilityBaseDataFById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseDataF takes ability abil,integer level,real dataF returns nothing
call SetAbilityBaseDataFById(GetAbilityTypeId(abil),level,dataF)
endfunction
function GetAbilityBaseSummonedUnit takes ability abil,integer level returns integer
return GetAbilityBaseSummonedUnitById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseSummonedUnit takes ability abil,integer level,integer uid returns nothing
call SetAbilityBaseSummonedUnitById(GetAbilityTypeId(abil),level,uid)
endfunction
function GetAbilityBaseEffectId takes ability abil,integer level returns integer
return GetAbilityBaseEffectIdById(GetAbilityTypeId(abil),level)
endfunction
function SetAbilityBaseEffectId takes ability abil,integer level,integer eid returns nothing
call SetAbilityBaseEffectIdById(GetAbilityTypeId(abil),level,eid)
endfunction
function GetAbilityBaseEffectSound takes ability abil returns string
return GetAbilityBaseEffectSoundById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseEffectSound takes ability abil,string s returns nothing
call SetAbilityBaseEffectSoundById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseEffectSoundLooped takes ability abil returns string
return GetAbilityBaseEffectSoundLoopedById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseEffectSoundLooped takes ability abil,string s returns nothing
call SetAbilityBaseEffectSoundLoopedById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseMissingIcon takes ability abil returns string
return GetAbilityBaseMissingIconById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseMissingIcon takes ability abil,string s returns nothing
call SetAbilityBaseMissingIconById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseCurrentIcon takes ability abil returns string
return GetAbilityBaseCurrentIconById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseCurrentIcon takes ability abil,string s returns nothing
call SetAbilityBaseCurrentIconById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseCursorTexture takes ability abil returns string
return GetAbilityBaseCursorTextureById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseCursorTexture takes ability abil,string s returns nothing
call SetAbilityBaseCursorTextureById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseGlobalMessage takes ability abil returns string
return GetAbilityBaseGlobalMessageById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseGlobalMessage takes ability abil,string s returns nothing
call SetAbilityBaseGlobalMessageById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseGlobalSound takes ability abil returns string
return GetAbilityBaseGlobalSoundById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseGlobalSound takes ability abil,string s returns nothing
call SetAbilityBaseGlobalSoundById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseButtonX takes ability abil returns integer
return GetAbilityBaseButtonXById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseButtonX takes ability abil,integer newX returns nothing
call SetAbilityBaseButtonXById(GetAbilityTypeId(abil),newX)
endfunction
function GetAbilityBaseButtonY takes ability abil returns integer
return GetAbilityBaseButtonYById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseButtonY takes ability abil,integer newY returns nothing
call SetAbilityBaseButtonYById(GetAbilityTypeId(abil),newY)
endfunction
function GetAbilityBaseUnButtonX takes ability abil returns integer
return GetAbilityBaseUnButtonXById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseUnButtonX takes ability abil,integer newX returns nothing
call SetAbilityBaseUnButtonXById(GetAbilityTypeId(abil),newX)
endfunction
function GetAbilityBaseUnButtonY takes ability abil returns integer
return GetAbilityBaseUnButtonYById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseUnButtonY takes ability abil,integer newY returns nothing
call SetAbilityBaseUnButtonYById(GetAbilityTypeId(abil),newY)
endfunction
function GetAbilityBaseResearchButtonX takes ability abil returns integer
return GetAbilityBaseResearchButtonXById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseResearchButtonX takes ability abil,integer newX returns nothing
call SetAbilityBaseResearchButtonXById(GetAbilityTypeId(abil),newX)
endfunction
function GetAbilityBaseResearchButtonY takes ability abil returns integer
return GetAbilityBaseResearchButtonYById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseResearchButtonY takes ability abil,integer newY returns nothing
call SetAbilityBaseResearchButtonYById(GetAbilityTypeId(abil),newY)
endfunction
function GetAbilityBaseMissileSpeed takes ability abil returns real
return GetAbilityBaseMissileSpeedById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseMissileSpeed takes ability abil,real speed returns nothing
call SetAbilityBaseMissileSpeedById(GetAbilityTypeId(abil),speed)
endfunction
function GetAbilityBaseMissileArc takes ability abil returns real
return GetAbilityBaseMissileArcById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseMissileArc takes ability abil,real arc returns nothing
call SetAbilityBaseMissileArcById(GetAbilityTypeId(abil),arc)
endfunction
function IsAbilityMissileHoming takes ability abil returns boolean
return IsAbilityMissileHomingById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseMissileHoming takes ability abil,boolean homing returns nothing
call SetAbilityBaseMissileHomingById(GetAbilityTypeId(abil),homing)
endfunction
function GetAbilityBaseSpellDetails takes ability abil returns integer
return GetAbilityBaseSpellDetailsById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseSpellDetails takes ability abil,integer det returns nothing
call SetAbilityBaseSpellDetailsById(GetAbilityTypeId(abil),det)
endfunction
function GetAbilityBaseHotkeyId takes ability abil returns integer
return GetAbilityBaseHotkeyIdById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseHotkeyId takes ability abil,integer newVal returns nothing
call SetAbilityBaseHotkeyIdById(GetAbilityTypeId(abil),newVal)
endfunction
function GetAbilityBaseUnHotkeyId takes ability abil returns integer
return GetAbilityBaseUnHotkeyIdById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseUnHotkeyId takes ability abil,integer newVal returns nothing
call SetAbilityBaseUnHotkeyIdById(GetAbilityTypeId(abil),newVal)
endfunction
function GetAbilityBaseResearchHotkeyId takes ability abil returns integer
return GetAbilityBaseResearchHotkeyIdById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseResearchHotkeyId takes ability abil,integer newVal returns nothing
call SetAbilityBaseResearchHotkeyIdById(GetAbilityTypeId(abil),newVal)
endfunction
function GetAbilityBaseName takes ability abil returns string
return GetAbilityBaseNameById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseName takes ability abil,string s returns nothing
call SetAbilityBaseNameById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseIcon takes ability abil returns string
return GetAbilityBaseIconById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseIcon takes ability abil,string s returns nothing
call SetAbilityBaseIconById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseMissileArt takes ability abil returns string
return GetAbilityBaseMissileArtById(GetAbilityTypeId(abil))
endfunction
function SetAbilityBaseMissileArt takes ability abil,string s returns nothing
call SetAbilityBaseMissileArtById(GetAbilityTypeId(abil),s)
endfunction
function GetAbilityBaseResearchTip takes ability abil,integer lvl returns string
return GetAbilityBaseResearchTipById(GetAbilityTypeId(abil),lvl)
endfunction
function SetAbilityBaseResearchTip takes ability abil,string s,integer lvl returns nothing
call SetAbilityBaseResearchTipById(GetAbilityTypeId(abil),s,lvl)
endfunction
function GetAbilityBaseTip takes ability abil,integer lvl returns string
return GetAbilityBaseTipById(GetAbilityTypeId(abil),lvl)
endfunction
function SetAbilityBaseTip takes ability abil,integer lvl,string s returns nothing
call SetAbilityBaseTipById(GetAbilityTypeId(abil),lvl,s)
endfunction
function GetAbilityBaseUnTip takes ability abil,integer lvl returns string
return GetAbilityBaseUnTipById(GetAbilityTypeId(abil),lvl)
endfunction
function SetAbilityBaseUnTip takes ability abil,string s,integer lvl returns nothing
call SetAbilityBaseUnTipById(GetAbilityTypeId(abil),s,lvl)
endfunction
function GetAbilityBaseResearchUberTip takes ability abil,integer lvl returns string
return GetAbilityBaseResearchUberTipById(GetAbilityTypeId(abil),lvl)
endfunction
function SetAbilityBaseResearchUberTip takes ability abil,string s,integer lvl returns nothing
call SetAbilityBaseResearchUberTipById(GetAbilityTypeId(abil),s,lvl)
endfunction
function GetAbilityBaseUbertip takes ability abil,integer lvl returns string
return GetAbilityBaseUbertipById(GetAbilityTypeId(abil),lvl)
endfunction
function SetAbilityBaseUbertip takes ability abil,integer lvl,string s returns nothing
call SetAbilityBaseUbertipById(GetAbilityTypeId(abil),lvl,s)
endfunction
function GetAbilityBaseResearchUnUberTip takes ability abil,integer lvl returns string
return GetAbilityBaseResearchUnUberTipById(GetAbilityTypeId(abil),lvl)
endfunction
function SetAbilityBaseResearchUnUberTip takes ability abil,string s,integer lvl returns nothing
call SetAbilityBaseResearchUnUberTipById(GetAbilityTypeId(abil),s,lvl)
endfunction
function SetAbilityBaseHotkeyCommon takes ability abil,integer newVal returns nothing
call SetAbilityBaseHotkeyCommonById(GetAbilityTypeId(abil),newVal)
endfunction
function Init_MemHackAbilityBaseAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetDataNode"),pGameDLL+0x2669E0)
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetUINode"),pGameDLL+0x32D420)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetDataNode"),pGameDLL+0x265ED0)
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetUINode"),pGameDLL+0x32C8E0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetDataNode"),pGameDLL+0x68EDF0)
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetUINode"),pGameDLL+0x322C30)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetDataNode"),pGameDLL+0x6AC530)
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetUINode"),pGameDLL+0x340380)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetDataNode"),pGameDLL+0x6E06E0)
call SaveInteger(MemHackTable,StringHash("CAbilityBase"),StringHash("GetUINode"),pGameDLL+0x374340)
endif
endif
endfunction
function GetAbilityOrderId takes ability a returns integer
return GetAddressAbilityOrderId(ConvertHandle(a))
endfunction
function IsAbilityOnCooldown takes ability a returns boolean
return IsAddressAbilityOnCooldown(ConvertHandle(a))
endfunction
function IsAbilitySafe takes ability a returns boolean
return IsAddressAbilitySafe(ConvertHandle(a))
endfunction
function IsAbilityUsable takes ability a returns boolean
return IsAddressAbilityUsable(ConvertHandle(a))
endfunction
function GetAbilityCastpoint takes ability a returns real
return GetAddressAbilityCastpoint(ConvertHandle(a))
endfunction
function SetAbilityCastpoint takes ability a,real dur returns nothing
call SetAddressAbilityCastpoint(ConvertHandle(a),dur)
endfunction
function GetAbilityBackswing takes ability a returns real
return GetAddressAbilityBackswing(ConvertHandle(a))
endfunction
function SetAbilityBackswing takes ability a,real dur returns nothing
call SetAddressAbilityBackswing(ConvertHandle(a),dur)
endfunction
function GetAbilityManaCost takes ability a,integer level returns integer
return GetAddressAbilityManaCost(ConvertHandle(a),level)
endfunction
function SetAbilityManaCost takes ability a,integer level,integer mc returns nothing
call SetAddressAbilityManaCost(ConvertHandle(a),level,mc)
endfunction
function GetAbilityCooldownStamp takes ability a returns real
return GetAddressAbilityCooldownStamp(ConvertHandle(a))
endfunction
function GetAbilityCurrentCooldown takes ability a returns real
return GetAddressAbilityCurrentCooldown(ConvertHandle(a))
endfunction
function SetAbilityCooldown takes ability a,real seconds,string mode returns nothing
call SetAddressAbilityCooldown(ConvertHandle(a),seconds,mode)
endfunction
function AddAbilityCooldown takes ability a,real seconds returns nothing
call SetAbilityCooldown(a,seconds,"+")
endfunction
function ReduceAbilityCooldown takes ability a,real seconds returns nothing
call SetAbilityCooldown(a,seconds,"-")
endfunction
function ResetAbilityCooldown takes ability a returns nothing
call SetAbilityCooldown(a,-1.,"")
endfunction
function StartAbilityCooldown takes ability a,real cd returns nothing
call StartAddressAbilityCooldown(ConvertHandle(a),cd)
endfunction
function GetAbilityCastTime takes ability a returns real
return GetAddressAbilityCastTime(ConvertHandle(a))
endfunction
function SetAbilityCastTime takes ability a,real r returns nothing
call SetAddressAbilityCastTime(ConvertHandle(a),r)
endfunction
function SetAbilityDisabled takes ability a,integer count returns nothing
call SetAddressAbilityDisabled(ConvertHandle(a),count)
endfunction
function GetAbilityDisabled takes ability a returns integer
return GetAddressAbilityDisabled(ConvertHandle(a))
endfunction
function SetAbilityHidden takes ability a,integer count returns nothing
call SetAddressAbilityHidden(ConvertHandle(a),count)
endfunction
function AddAbilityHidden takes ability a,integer count returns nothing
call AddAddressAbilityHidden(ConvertHandle(a),count)
endfunction
function GetAbilityDisabledEx takes ability a returns integer
return GetAddressAbilityDisabledEx(ConvertHandle(a))
endfunction
function SetAbilityDisabledEx takes ability a,integer count returns nothing
call SetAddressAbilityDisabledEx(ConvertHandle(a),count)
endfunction
function SilenceAbility takes ability a returns nothing
call SilenceAddressAbility(ConvertHandle(a))
endfunction
function UnsilenceAbility takes ability a returns nothing
call UnsilenceAddressAbility(ConvertHandle(a))
endfunction
function ShowAbility takes ability a,boolean flag returns nothing
call ShowAddressAbility(ConvertHandle(a),flag)
endfunction
function GetBuffLevel takes buff b returns integer
return GetAddressBuffLevel(ConvertHandle(b))
endfunction
function Init_MemHackAbilityNormalAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
elseif PatchVersion=="1.26a" then
elseif PatchVersion=="1.27a" then
elseif PatchVersion=="1.27b" then
elseif PatchVersion=="1.28f" then
endif
endif
endfunction
function GetUnitAbilityReal takes integer pUnit,integer aid,integer unk1,integer unk2,integer unk3,integer unk4 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("GetAbility"))
if addr!=0 and pUnit>0 and aid>0 then
return this_call_6(addr,pUnit,aid,unk1,unk2,unk3,unk4)
endif
return 0
endfunction
function CUnitAddAbility takes integer pUnit,integer aid returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("AddAbility"))
if addr!=0 and pUnit!=0 and aid!=0 then
return fast_call_5(addr,pUnit,aid,0,0,0)>0
endif
return false
endfunction
function CUnitRemoveAbility takes integer pUnit,integer pAbil returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("RemoveAbility"))
if addr!=0 and pUnit!=0 and pAbil!=0 then
call this_call_2(addr,pUnit,pAbil)
return true
endif
return false
endfunction
function CUnitRemoveAbilityById takes integer pUnit,integer aid returns boolean
local integer pAbil=0
if pUnit!=0 and aid!=0 then
set pAbil=GetUnitAbilityReal(pUnit,aid,0,1,1,1)
if pAbil!=0 then
return CUnitRemoveAbility(pUnit,pAbil)
endif
endif
return false
endfunction
function GetUnitAbilityData takes unit u,integer aid,integer flag returns integer
local integer pUnit
if u!=null and aid>0 then
set pUnit=ConvertHandle(u)
if pUnit>0 then
return GetUnitAbilityReal(pUnit,aid,0,flag,1,1)
endif
endif
return 0
endfunction
function GetUnitAbility takes unit u,integer aid returns integer
if GetUnitAbilityLevel(u,aid)>0 then
return GetUnitAbilityData(u,aid,1)
endif
return 0
endfunction
function GetUnitAbilityByIndex takes unit u,integer index returns ability
local integer pData=ConvertHandle(u)
local integer pAbil=0
local integer i=0
if pData!=0 then
set pAbil=GetCAgentFromHashGroup(pData+0x1DC)
if pAbil!=0 then
loop
exitwhen pAbil==0 or i==index
set pAbil=GetCAgentFromHashGroup(pAbil+0x24)
set i=i+1
endloop
if pAbil!=0 then
return ObjectToAbility(pAbil)
endif
endif
endif
return null
endfunction
function GetUnitJAbility takes unit u,integer aid returns ability
return ObjectToAbility(GetUnitAbility(u,aid))
endfunction
function AddUnitAbility takes unit u,integer aid returns boolean
return CUnitAddAbility(ConvertHandle(u),aid)
endfunction
function RemoveUnitAbility takes unit u,integer aid,boolean removeduplicates returns nothing
call CUnitRemoveAbility(ConvertHandle(u),aid)
endfunction
function GetUnitAbilityBase takes unit u,integer aid returns integer
return GetUnitAbilityData(u,aid,0)
endfunction
function GetUnitAbilityOrderId takes unit u,integer aid returns integer
return GetAddressAbilityOrderId(GetUnitAbility(u,aid))
endfunction
function IsUnitAbilityOnCooldown takes unit u,integer aid returns boolean
return IsAddressAbilityOnCooldown(GetUnitAbility(u,aid))
endfunction
function IsUnitAbilitySafe takes unit u,integer aid returns boolean
return IsAddressAbilitySafe(GetUnitAbility(u,aid))
endfunction
function IsUnitAbilityUsable takes unit u,integer aid returns boolean
return IsAddressAbilityUsable(GetUnitAbility(u,aid))
endfunction
function GetUnitAbilityCastpoint takes unit u,integer aid returns real
return GetAddressAbilityCastpoint(GetUnitAbility(u,aid))
endfunction
function SetUnitAbilityCastpoint takes unit u,integer aid,real dur returns nothing
call SetAddressAbilityCastpoint(GetUnitAbility(u,aid),dur)
endfunction
function GetUnitAbilityBackswing takes unit u,integer aid returns real
return GetAddressAbilityBackswing(GetUnitAbility(u,aid))
endfunction
function SetUnitAbilityBackswing takes unit u,integer aid,real dur returns nothing
call SetAddressAbilityBackswing(GetUnitAbility(u,aid),dur)
endfunction
function GetUnitAbilityManaCost takes unit u,integer aid,integer level returns integer
return GetAddressAbilityManaCost(GetUnitAbility(u,aid),level)
endfunction
function SetUnitAbilityManaCost takes unit u,integer aid,integer level,integer mc returns nothing
call SetAddressAbilityManaCost(GetUnitAbility(u,aid),level,mc)
endfunction
function GetUnitAbilityCooldownStamp takes unit u,integer aid returns real
return GetAddressAbilityCooldownStamp(GetUnitAbility(u,aid))
endfunction
function GetUnitAbilityCurrentCooldown takes unit u,integer aid returns real
return GetAddressAbilityCurrentCooldown(GetUnitAbility(u,aid))
endfunction
function SetUnitAbilityCooldown takes unit u,integer aid,real seconds,string mode returns nothing
call SetAddressAbilityCooldown(GetUnitAbility(u,aid),seconds,mode)
endfunction
function AddUnitAbilityCooldown takes unit u,integer aid,real seconds returns nothing
call SetUnitAbilityCooldown(u,aid,seconds,"+")
endfunction
function ReduceUnitAbilityCooldown takes unit u,integer aid,real seconds returns nothing
call SetUnitAbilityCooldown(u,aid,seconds,"-")
endfunction
function ResetUnitAbilityCooldown takes unit u,integer aid returns nothing
call SetUnitAbilityCooldown(u,aid,-1.,"")
endfunction
function StartUnitAbilityCooldown takes unit u,integer aid,real cd returns nothing
call StartAddressAbilityCooldown(GetUnitAbility(u,aid),cd)
endfunction
function GetUnitAbilityCastTime takes unit u,integer aid returns real
return GetAddressAbilityCastTime(GetUnitAbility(u,aid))
endfunction
function SetUnitAbilityCastTime takes unit u,integer aid,real r returns nothing
call SetAddressAbilityCastTime(GetUnitAbility(u,aid),r)
endfunction
function SetUnitAbilityDisabled takes unit u,integer aid,integer count returns nothing
call SetAddressAbilityDisabled(GetUnitAbility(u,aid),count)
endfunction
function GetUnitAbilityDisabled takes unit u,integer aid returns integer
return GetAddressAbilityDisabled(GetUnitAbility(u,aid))
endfunction
function SetUnitAbilityHidden takes unit u,integer aid,integer count returns nothing
call SetAddressAbilityHidden(GetUnitAbility(u,aid),count)
endfunction
function AddUnitAbilityHidden takes unit u,integer aid,integer count returns nothing
call AddAddressAbilityHidden(GetUnitAbility(u,aid),count)
endfunction
function GetUnitAbilityDisabledEx takes unit u,integer aid returns integer
return GetAddressAbilityDisabledEx(GetUnitAbility(u,aid))
endfunction
function SetUnitAbilityDisabledEx takes unit u,integer aid,integer count returns nothing
call SetAddressAbilityDisabledEx(GetUnitAbility(u,aid),count)
endfunction
function SilenceUnitAbility takes unit u,integer aid returns nothing
call SilenceAddressAbility(GetUnitAbility(u,aid))
endfunction
function UnsilenceUnitAbility takes unit u,integer aid returns nothing
call UnsilenceAddressAbility(GetUnitAbility(u,aid))
endfunction
function ShowUnitAbility takes unit u,integer aid,boolean flag returns nothing
call ShowAddressAbility(GetUnitAbility(u,aid),flag)
endfunction
function GetUnitBuffLevel takes unit u,integer bid returns integer
return GetAddressBuffLevel(GetUnitAbility(u,bid))
endfunction
function Init_MemHackAbilityUnitAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("GetAbility"),pGameDLL+0x079400)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("AddAbility"),pGameDLL+0x24D900)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("RemoveAbility"),pGameDLL+0x07A8F0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("GetAbility"),pGameDLL+0x0787D0)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("AddAbility"),pGameDLL+0x24CDF0)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("RemoveAbility"),pGameDLL+0x079CC0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("GetAbility"),pGameDLL+0x46F440)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("AddAbility"),pGameDLL+0x454EB0)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("RemoveAbility"),pGameDLL+0x471160)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("GetAbility"),pGameDLL+0x48CB80)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("AddAbility"),pGameDLL+0x4725F0)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("RemoveAbility"),pGameDLL+0x48E8A0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("GetAbility"),pGameDLL+0x4C0C90)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("AddAbility"),pGameDLL+0x4A6700)
call SaveInteger(MemHackTable,StringHash("CAbilityUnit"),StringHash("RemoveAbility"),pGameDLL+0x4C29B0)
endif
endif
endfunction
function GetSpriteBaseType takes integer pSpriteBase returns integer
local integer vtable=0
if pSpriteBase!=0 then
set vtable=ReadRealMemory(pSpriteBase)
if vtable!=0 then
if vtable==LoadInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableBase"))then
return 1
elseif vtable==LoadInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableExt"))then
return 1
elseif vtable==LoadInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableBase"))then
return 2
elseif vtable==LoadInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableExt"))then
return 2
endif
endif
endif
return 0
endfunction
function GetSpriteBaseModelComplex takes integer pSpriteBase returns integer
if pSpriteBase!=0 then
return ReadRealMemory(pSpriteBase+0x20)
endif
return 0
endfunction
function GetSpriteBaseAnimComplex takes integer pSpriteBase returns integer
local integer pData=GetSpriteBaseModelComplex(pSpriteBase)
if pData!=0 then
return ReadRealMemory(pSpriteBase+0x98)
endif
return 0
endfunction
function GetSpriteBaseFloat takes integer pSpriteBase,integer offset returns real
if pSpriteBase!=0 then
return ReadRealFloat(pSpriteBase+offset)
endif
return 0.
endfunction
function SetSpriteBaseFloat takes integer pSpriteBase,integer offset,real value returns real
if pSpriteBase!=0 then
call WriteRealFloat(pSpriteBase+offset,value)
endif
return 0.
endfunction
function GetSpriteBaseX takes integer pSpriteBase returns real
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=0x88
else
set offset=0xC0
endif
return GetSpriteBaseFloat(pSpriteBase,offset)
endif
return 0.
endfunction
function SetSpriteBaseX takes integer pSpriteBase,real x returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=0x88
else
set offset=0xC0
endif
call SetSpriteBaseFloat(pSpriteBase,offset,x)
endif
endfunction
function GetSpriteBaseY takes integer pSpriteBase returns real
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=0x8C
else
set offset=0xC4
endif
return GetSpriteBaseFloat(pSpriteBase,offset)
endif
return 0.
endfunction
function SetSpriteBaseY takes integer pSpriteBase,real y returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=0x8C
else
set offset=0xC4
endif
call SetSpriteBaseFloat(pSpriteBase,offset,y)
endif
endfunction
function GetSpriteBaseZ takes integer pSpriteBase returns real
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=0x90
else
set offset=0xC8
endif
return GetSpriteBaseFloat(pSpriteBase,offset)
endif
return 0.
endfunction
function SetSpriteBaseZ takes integer pSpriteBase,real z returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=0x90
else
set offset=0xC8
endif
call SetSpriteBaseFloat(pSpriteBase,offset,z)
endif
endfunction
function SetSpriteBasePosition takes integer pSpriteBase,real x,real y,real z returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=pSpriteBase+0x88
else
set offset=pSpriteBase+0xC0
endif
call WriteRealFloat(pSpriteBase+0x0,x)
call WriteRealFloat(pSpriteBase+0x4,y)
call WriteRealFloat(pSpriteBase+0x8,z)
endif
endfunction
function GetSpriteBaseTimeScale takes integer pSpriteBase returns real
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pData=0
if s_type==1 or s_type==2 then
if s_type==1 then
set pData=GetSpriteBaseAnimComplex(pSpriteBase)
if pData!=0 then
return ReadRealFloat(pSpriteBase+0x48)
endif
else
return ReadRealFloat(pSpriteBase+0x190)
endif
endif
return 0.
endfunction
function SetSpriteBaseTimeScale takes integer pSpriteBase,real timescale returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pData=0
if s_type==1 or s_type==2 then
if s_type==1 then
set pData=GetSpriteBaseAnimComplex(pSpriteBase)
if pData!=0 then
call WriteRealFloat(pSpriteBase+0x48,timescale)
endif
else
call WriteRealFloat(pSpriteBase+0x190,timescale)
endif
endif
endfunction
function GetSpriteBaseScale takes integer pSpriteBase returns real
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=0x94
else
set offset=0xE8
endif
return ReadRealFloat(pSpriteBase+offset)
endif
return 0.
endfunction
function SetSpriteBaseScale takes integer pSpriteBase,real scale returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer offset=0
if s_type==1 or s_type==2 then
if s_type==1 then
set offset=0x94
else
set offset=0xE8
endif
call WriteRealFloat(pSpriteBase+offset,scale)
endif
endfunction
function SetSpriteBaseMaterialScale takes integer pSpriteBase,real scaleX,real scaleY,real scaleZ returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x64
else
set pMatrix=pSpriteBase+0x108
endif
call WriteRealFloat(pMatrix+0x00,scaleX)
call WriteRealFloat(pMatrix+0x10,scaleY)
call WriteRealFloat(pMatrix+0x20,scaleZ)
endif
endfunction
function UpdateSpriteBase takes integer pSpriteBase returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
if s_type==1 or s_type==2 then
call this_call_1(ReadRealMemory(ReadRealMemory(pSpriteBase)+0x14),pSpriteBase)
endif
endfunction
function SetSpriteBasePositionEx takes integer pSpriteBase,real x,real y,real z returns nothing
local integer pvector3=0
local integer s_type=GetSpriteBaseType(pSpriteBase)
if s_type==1 or s_type==2 then
set pvector3=LoadInteger(MemHackTable,StringHash("CustomData"),StringHash("Vector3"))
call WriteRealFloat(pvector3+0x0,x)
call WriteRealFloat(pvector3+0x4,y)
call WriteRealFloat(pvector3+0x8,z)
call this_call_2(ReadRealMemory(ReadRealMemory(pSpriteBase)+0x1C),pSpriteBase,pvector3)
endif
endfunction
function SetSpriteBaseScaleEx takes integer pSpriteBase,real scale returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
if s_type==1 or s_type==2 then
call this_call_2(ReadRealMemory(ReadRealMemory(pSpriteBase)+0x24),pSpriteBase,SetRealIntoMemory(scale))
endif
endfunction
function SetSpriteBaseTimeScaleEx takes integer pSpriteBase,real timescale returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
if s_type==1 or s_type==2 then
call this_call_2(ReadRealMemory(ReadRealMemory(pSpriteBase)+0x28),pSpriteBase,SetRealIntoMemory(timescale))
endif
endfunction
function SetSpriteBaseColourEx takes integer pSpriteBase,integer colour,boolean flag returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if arg!=0 and(s_type==1 or s_type==2)then
call WriteRealMemory(arg+0x0,colour)
call this_call_2(ReadRealMemory(ReadRealMemory(pSpriteBase)+0x30),pSpriteBase,arg+0x0)
if flag then
call UpdateSpriteBase(pSpriteBase)
endif
endif
endfunction
function SetSpriteBaseAlphaEx takes integer pSpriteBase,integer alpha,boolean flag returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
if s_type==1 or s_type==2 and alpha>=0 and alpha<=0xFF then
call this_call_2(ReadRealMemory(ReadRealMemory(pSpriteBase)+0x34),pSpriteBase,alpha)
if flag then
call UpdateSpriteBase(pSpriteBase)
endif
endif
endfunction
function SetSpriteBaseAnimationByIndexWithRarity takes integer pSpriteBase,integer index,integer rarity returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CSpriteBase"),StringHash("SetAnimation"))
local integer s_type=GetSpriteBaseType(pSpriteBase)
if addr!=0 and(s_type==1 or s_type==2)then
call fast_call_3(addr,pSpriteBase,index,rarity)
endif
endfunction
function SetSpriteBaseAnimationByIndex takes integer pSpriteBase,integer index returns nothing
call SetSpriteBaseAnimationByIndexWithRarity(pSpriteBase,index,0)
endfunction
function GetSpriteBaseYawRad takes integer pSpriteBase returns real
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
local real r11=0.
local real r21=0.
local real r31=0.
local real yaw=0.
local real pitch=0.
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x64
else
set pMatrix=pSpriteBase+0x108
endif
set r11=ReadRealFloat(pMatrix+0x0)
set r21=ReadRealFloat(pMatrix+0xC)
set r31=ReadRealFloat(pMatrix+0x18)
set pitch=-Asin(r31)
set yaw=-Atan2(r21,r11)
if yaw<0 then
set yaw=6.28319+yaw
endif
endif
return yaw
endfunction
function GetSpriteBasePitchRad takes integer pSpriteBase returns real
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
local real r31=0.
local real r32=0.
local real r33=0.
local real pitch=0.
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x7C
else
set pMatrix=pSpriteBase+0x120
endif
set r31=ReadRealFloat(pMatrix+0x0)
set r32=ReadRealFloat(pMatrix+0x4)
set r33=ReadRealFloat(pMatrix+0x8)
set pitch=-Asin(r31)
if r31<0. and r33>0. then
set pitch=pitch
elseif r31<0. and r33<0. then
set pitch=3.14159-pitch
elseif r31>0. and r33<0. then
set pitch=3.14159-pitch
elseif r31>0. and r33>0. then
set pitch=6.28319+pitch
endif
endif
return pitch
endfunction
function GetSpriteBaseRollRad takes integer pSpriteBase returns real
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
local real r31=0.
local real r32=0.
local real r33=0.
local real pitch=0.
local real roll=0.
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x7C
else
set pMatrix=pSpriteBase+0x120
endif
set r31=ReadRealFloat(pMatrix+0x0)
set r32=ReadRealFloat(pMatrix+0x4)
set r33=ReadRealFloat(pMatrix+0x8)
set pitch=-Asin(r31)
set roll=Atan2(r32/ Cos(pitch),r33/ Cos(pitch))
if roll<0. then
set roll=6.28319+roll
endif
endif
return roll
endfunction
function GetSpriteBaseFacingRad takes integer pSpriteBase returns real
return GetSpriteBaseYawRad(pSpriteBase)
endfunction
function SetSpriteBaseSpaceRotationRad takes integer pSpriteBase,real yaw,real pitch,real roll returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
local real Sx=Sin(roll)
local real Sy=Sin(pitch)
local real Sz=Sin(-yaw)
local real Cx=Cos(roll)
local real Cy=Cos(pitch)
local real Cz=Cos(-yaw)
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x64
else
set pMatrix=pSpriteBase+0x108
endif
call WriteRealFloat(pMatrix+0x0,Cy*Cz)
call WriteRealFloat(pMatrix+0x4,-Cy*Sz)
call WriteRealFloat(pMatrix+0x8,Sy)
call WriteRealFloat(pMatrix+0xC,Cz*Sx*Sy+Cx*Sz)
call WriteRealFloat(pMatrix+0x10,Cx*Cz-Sx*Sy*Sz)
call WriteRealFloat(pMatrix+0x14,-Cy*Sx)
call WriteRealFloat(pMatrix+0x18,-Cx*Cz*Sy+Sx*Sz)
call WriteRealFloat(pMatrix+0x1C,Cz*Sx+Cx*Sy*Sz)
call WriteRealFloat(pMatrix+0x20,Cx*Cy)
endif
endfunction
function SetSpriteBaseYawRad takes integer pSpriteBase,real angle returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
local real r31=0.
local real r32=0.
local real r33=0.
local real pitch=0.
local real roll=0.
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x7C
else
set pMatrix=pSpriteBase+0x120
endif
set r31=ReadRealFloat(pMatrix+0x0)
set r32=ReadRealFloat(pMatrix+0x4)
set r33=ReadRealFloat(pMatrix+0x8)
set pitch=-Asin(r31)
set roll=Atan2(r32/ Cos(pitch),r33/ Cos(pitch))
call SetSpriteBaseSpaceRotationRad(pSpriteBase,angle,pitch,roll)
endif
endfunction
function SetSpriteBasePitchRad takes integer pSpriteBase,real angle returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
local real r11=0.
local real r21=0.
local real r32=0.
local real r33=0.
local real yaw=0.
local real roll=0.
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x64
else
set pMatrix=pSpriteBase+0x108
endif
set r11=ReadRealFloat(pMatrix+0x0)
set r21=ReadRealFloat(pMatrix+0xC)
set r32=ReadRealFloat(pMatrix+0x1C)
set r33=ReadRealFloat(pMatrix+0x20)
set yaw=Atan2(r21/ Cos(angle),r11/ Cos(angle))
set roll=Atan2(r32/ Cos(angle),r33/ Cos(angle))
call SetSpriteBaseSpaceRotationRad(pSpriteBase,yaw,angle,roll)
endif
endfunction
function SetSpriteBaseRollRad takes integer pSpriteBase,real angle returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
local real r11=0.
local real r21=0.
local real r31=0.
local real yaw=0.
local real pitch=0.
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x64
else
set pMatrix=pSpriteBase+0x108
endif
set r11=ReadRealFloat(pMatrix+0x0)
set r21=ReadRealFloat(pMatrix+0xC)
set r31=ReadRealFloat(pMatrix+0x18)
set pitch=-Asin(r31)
set yaw=Atan2(r21/ Cos(pitch),r11/ Cos(pitch))
call SetSpriteBaseSpaceRotationRad(pSpriteBase,yaw,pitch,angle)
endif
endfunction
function SetSpriteBaseOrientationRad takes integer pSpriteBase,real yaw,real pitch,real roll returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
if s_type==1 or s_type==2 then
call SetSpriteBaseSpaceRotationRad(pSpriteBase,yaw,pitch,roll)
endif
endfunction
function SetSpriteBaseSpaceRotation takes integer pSpriteBase,real yaw,real pitch,real roll returns nothing
call SetSpriteBaseSpaceRotationRad(pSpriteBase,Deg2Rad(yaw),Deg2Rad(pitch),Deg2Rad(roll))
endfunction
function GetSpriteBaseYaw takes integer pSpriteBase returns real
return Rad2Deg(GetSpriteBaseYawRad(pSpriteBase))
endfunction
function GetSpriteBaseFacing takes integer pSpriteBase returns real
return Rad2Deg(GetSpriteBaseFacingRad(pSpriteBase))
endfunction
function GetSpriteBasePitch takes integer pSpriteBase returns real
return Rad2Deg(GetSpriteBasePitchRad(pSpriteBase))
endfunction
function GetSpriteBaseRoll takes integer pSpriteBase returns real
return Rad2Deg(GetSpriteBaseRollRad(pSpriteBase))
endfunction
function SetSpriteBaseYaw takes integer pSpriteBase,real angle returns nothing
call SetSpriteBaseYawRad(pSpriteBase,Deg2Rad(angle))
endfunction
function SetSpriteBaseFacing takes integer pSpriteBase,real angle returns nothing
call SetSpriteBaseYawRad(pSpriteBase,Deg2Rad(angle))
endfunction
function SetSpriteBasePitch takes integer pSpriteBase,real angle returns nothing
call SetSpriteBasePitchRad(pSpriteBase,Deg2Rad(angle))
endfunction
function SetSpriteBaseRoll takes integer pSpriteBase,real angle returns nothing
call SetSpriteBaseRollRad(pSpriteBase,Deg2Rad(angle))
endfunction
function SetSpriteBaseOrientation takes integer pSpriteBase,real yaw,real pitch,real roll returns nothing
call SetSpriteBaseOrientationRad(pSpriteBase,Deg2Rad(yaw),Deg2Rad(pitch),Deg2Rad(roll))
endfunction
function SetSpriteBaseScaleXYZ takes integer pSpriteBase,real x,real y,real z returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x64
else
set pMatrix=pSpriteBase+0x108
endif
call WriteRealFloat(pMatrix+0x0,x)
call WriteRealFloat(pMatrix+0x10,y)
call WriteRealFloat(pMatrix+0x20,z)
endif
endfunction
function ResetSpriteBaseMatrix takes integer pSpriteBase returns nothing
local integer s_type=GetSpriteBaseType(pSpriteBase)
local integer pMatrix=0
if s_type==1 or s_type==2 then
if s_type==1 then
set pMatrix=pSpriteBase+0x64
else
set pMatrix=pSpriteBase+0x108
endif
call WriteRealFloat(pMatrix+0x0,1.)
call WriteRealFloat(pMatrix+0x4,0.)
call WriteRealFloat(pMatrix+0x8,0.)
call WriteRealFloat(pMatrix+0xC,0.)
call WriteRealFloat(pMatrix+0x10,1.)
call WriteRealFloat(pMatrix+0x14,0.)
call WriteRealFloat(pMatrix+0x18,0.)
call WriteRealFloat(pMatrix+0x1C,0.)
call WriteRealFloat(pMatrix+0x20,1.)
endif
endfunction
function Init_MemHackCSpriteBaseAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSpriteBase"),StringHash("SetAnimation"),pGameDLL+0x4D8700)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSpriteBase"),StringHash("SetAnimation"),pGameDLL+0x4D7C00)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSpriteBase"),StringHash("SetAnimation"),pGameDLL+0x186820)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSpriteBase"),StringHash("SetAnimation"),pGameDLL+0x1A4540)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSpriteBase"),StringHash("SetAnimation"),pGameDLL+0x1D6DD0)
endif
endif
endfunction
function GetSpriteMiniX takes integer pSpriteMini returns real
return GetSpriteBaseX(pSpriteMini)
endfunction
function SetSpriteMiniX takes integer pSpriteMini,real x returns nothing
call SetSpriteBaseX(pSpriteMini,x)
endfunction
function GetSpriteMiniY takes integer pSpriteMini returns real
return GetSpriteBaseY(pSpriteMini)
endfunction
function SetSpriteMiniY takes integer pSpriteMini,real y returns nothing
call SetSpriteBaseY(pSpriteMini,y)
endfunction
function GetSpriteMiniZ takes integer pSpriteMini returns real
return GetSpriteBaseZ(pSpriteMini)
endfunction
function SetSpriteMiniZ takes integer pSpriteMini,real z returns nothing
call SetSpriteBaseZ(pSpriteMini,z)
endfunction
function SetSpriteMiniPosition takes integer pSpriteMini,real x,real y,real z returns nothing
call SetSpriteBasePosition(pSpriteMini,x,y,z)
endfunction
function GetSpriteMiniTimeScale takes integer pSpriteMini returns real
return 0.
endfunction
function SetSpriteMiniTimeScale takes integer pSpriteMini,real speed returns nothing
call SetSpriteBaseTimeScaleEx(pSpriteMini,speed)
endfunction
function GetSpriteMiniScale takes integer pSpriteMini returns real
return GetSpriteBaseScale(pSpriteMini)
endfunction
function SetSpriteMiniScale takes integer pSpriteMini,real scale returns nothing
call SetSpriteBaseScale(pSpriteMini,scale)
endfunction
function SetSpriteMiniPositionEx takes integer pSpriteMini,real x,real y,real z returns nothing
call SetSpriteBasePositionEx(pSpriteMini,x,y,z)
endfunction
function SetSpriteMiniScaleEx takes integer pSpriteMini,real scale returns nothing
call SetSpriteBaseScaleEx(pSpriteMini,scale)
endfunction
function SetSpriteMiniColour takes integer pSpriteMini,integer colour,boolean flag returns nothing
call SetSpriteBaseColourEx(pSpriteMini,colour,flag)
endfunction
function SetSpriteMiniAlpha takes integer pSpriteMini,integer alpha,boolean flag returns nothing
call SetSpriteBaseAlphaEx(pSpriteMini,alpha,flag)
endfunction
function SetSpriteMiniAnimationByIndexWithRarity takes integer pSpriteMini,integer index,integer rarity returns nothing
call SetSpriteBaseAnimationByIndexWithRarity(pSpriteMini,index,rarity)
endfunction
function SetSpriteMiniAnimationByIndex takes integer pSpriteMini,integer index returns nothing
call SetSpriteMiniAnimationByIndexWithRarity(pSpriteMini,index,0)
endfunction
function GetSpriteMiniYawRad takes integer pSpriteMini returns real
return GetSpriteBaseYawRad(pSpriteMini)
endfunction
function GetSpriteMiniPitchRad takes integer pSpriteMini returns real
return GetSpriteBasePitchRad(pSpriteMini)
endfunction
function GetSpriteMiniRollRad takes integer pSpriteMini returns real
return GetSpriteBaseRollRad(pSpriteMini)
endfunction
function GetSpriteMiniFacingRad takes integer pSpriteMini returns real
return GetSpriteMiniYawRad(pSpriteMini)
endfunction
function SetSpriteMiniSpaceRotationRad takes integer pSpriteMini,real yaw,real pitch,real roll returns nothing
call SetSpriteBaseSpaceRotationRad(pSpriteMini,yaw,pitch,roll)
endfunction
function SetSpriteMiniYawRad takes integer pSpriteMini,real angle returns nothing
call SetSpriteBaseYawRad(pSpriteMini,angle)
endfunction
function SetSpriteMiniPitchRad takes integer pSpriteMini,real angle returns nothing
call SetSpriteBasePitchRad(pSpriteMini,angle)
endfunction
function SetSpriteMiniRollRad takes integer pSpriteMini,real angle returns nothing
call SetSpriteBaseRollRad(pSpriteMini,angle)
endfunction
function SetSpriteMiniOrientationRad takes integer pSpriteMini,real yaw,real pitch,real roll returns nothing
call SetSpriteBaseOrientationRad(pSpriteMini,yaw,pitch,roll)
endfunction
function SetSpriteMiniSpaceRotation takes integer pSpriteMini,real yaw,real pitch,real roll returns nothing
call SetSpriteMiniSpaceRotationRad(pSpriteMini,Deg2Rad(yaw),Deg2Rad(pitch),Deg2Rad(roll))
endfunction
function GetSpriteMiniYaw takes integer pSpriteMini returns real
return Rad2Deg(GetSpriteMiniYawRad(pSpriteMini))
endfunction
function GetSpriteMiniFacing takes integer pSpriteMini returns real
return Rad2Deg(GetSpriteMiniFacingRad(pSpriteMini))
endfunction
function GetSpriteMiniPitch takes integer pSpriteMini returns real
return Rad2Deg(GetSpriteMiniPitchRad(pSpriteMini))
endfunction
function GetSpriteMiniRoll takes integer pSpriteMini returns real
return Rad2Deg(GetSpriteMiniRollRad(pSpriteMini))
endfunction
function SetSpriteMiniYaw takes integer pSpriteMini,real angle returns nothing
call SetSpriteMiniYawRad(pSpriteMini,Deg2Rad(angle))
endfunction
function SetSpriteMiniFacing takes integer pSpriteMini,real angle returns nothing
call SetSpriteMiniYawRad(pSpriteMini,Deg2Rad(angle))
endfunction
function SetSpriteMiniPitch takes integer pSpriteMini,real angle returns nothing
call SetSpriteMiniPitchRad(pSpriteMini,Deg2Rad(angle))
endfunction
function SetSpriteMiniRoll takes integer pSpriteMini,real angle returns nothing
call SetSpriteMiniRollRad(pSpriteMini,Deg2Rad(angle))
endfunction
function SetSpriteMiniOrientation takes integer pSpriteMini,real yaw,real pitch,real roll returns nothing
call SetSpriteMiniOrientationRad(pSpriteMini,Deg2Rad(yaw),Deg2Rad(pitch),Deg2Rad(roll))
endfunction
function SetSpriteMiniScaleXYZ takes integer pSpriteMini,real x,real y,real z returns nothing
call SetSpriteBaseScaleXYZ(pSpriteMini,x,y,z)
endfunction
function ResetSpriteMiniMatrix takes integer pSpriteMini returns nothing
call ResetSpriteBaseMatrix(pSpriteMini)
endfunction
function Init_MemHackCSpriteMiniAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableBase"),pGameDLL+0x966E2C)
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableExt"),pGameDLL+0x966F2C)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableBase"),pGameDLL+0x954CD4)
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableExt"),pGameDLL+0x954DD4)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableBase"),pGameDLL+0x9646F4)
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableExt"),pGameDLL+0x9648D4)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableBase"),pGameDLL+0xA927BC)
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableExt"),pGameDLL+0xA9299C)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableBase"),pGameDLL+0xA825A4)
call SaveInteger(MemHackTable,StringHash("CSpriteMini"),StringHash("vtableExt"),pGameDLL+0xA82784)
endif
endif
endfunction
function GetSpriteUberColour takes integer pSpriteUber returns integer
if pSpriteUber!=0 then
return ReadRealMemory(pSpriteUber+0x148)
endif
return 0
endfunction
function SetSpriteUberAlpha takes integer pSpriteUber,integer alpha returns nothing
call SetSpriteBaseAlphaEx(pSpriteUber,alpha,true)
endfunction
function SetSpriteUberColour takes integer pSpriteUber,integer colour returns nothing
call SetSpriteBaseColourEx(pSpriteUber,colour,true)
endfunction
function SetSpriteUberColourEx takes integer pSpriteUber,integer red,integer green,integer blue,integer alpha returns nothing
if pSpriteUber!=0 then
call SetSpriteUberColour(pSpriteUber,CreateInteger1(alpha,red,green,blue))
endif
endfunction
function SetSpriteUberVertexColour takes integer pSpriteUber,integer red,integer green,integer blue,integer alpha returns nothing
call SetSpriteUberColourEx(pSpriteUber,red,green,blue,alpha)
call SetSpriteUberAlpha(pSpriteUber,alpha)
endfunction
function GetSpriteUberColourA takes integer pSpriteUber returns integer
if pSpriteUber!=0 then
return GetByteFromInteger(GetSpriteUberColour(pSpriteUber),1)
endif
return-1
endfunction
function SetSpriteUberColourA takes integer pSpriteUber,integer alpha returns nothing
local integer colour=0
if pSpriteUber!=0 then
set colour=GetSpriteUberColour(pSpriteUber)
call SetSpriteUberColour(pSpriteUber,CreateInteger1(alpha,GetByteFromInteger(colour,2),GetByteFromInteger(colour,3),GetByteFromInteger(colour,4)))
endif
endfunction
function GetSpriteUberColourR takes integer pSpriteUber returns integer
if pSpriteUber!=0 then
return GetByteFromInteger(GetSpriteUberColour(pSpriteUber),2)
endif
return-1
endfunction
function SetSpriteUberColourR takes integer pSpriteUber,integer red returns nothing
local integer colour=0
if pSpriteUber!=0 then
set colour=GetSpriteUberColour(pSpriteUber)
call SetSpriteUberColour(pSpriteUber,CreateInteger1(GetByteFromInteger(colour,1),red,GetByteFromInteger(colour,3),GetByteFromInteger(colour,4)))
endif
endfunction
function GetSpriteUberColourG takes integer pSpriteUber returns integer
if pSpriteUber!=0 then
return GetByteFromInteger(GetSpriteUberColour(pSpriteUber),3)
endif
return-1
endfunction
function SetSpriteUberColourG takes integer pSpriteUber,integer green returns nothing
local integer colour=0
if pSpriteUber!=0 then
set colour=GetSpriteUberColour(pSpriteUber)
call SetSpriteUberColour(pSpriteUber,CreateInteger1(GetByteFromInteger(colour,1),GetByteFromInteger(colour,2),green,GetByteFromInteger(colour,4)))
endif
endfunction
function GetSpriteUberColourB takes integer pSpriteUber returns integer
if pSpriteUber!=0 then
return GetByteFromInteger(GetSpriteUberColour(pSpriteUber),4)
endif
return-1
endfunction
function SetSpriteUberColourB takes integer pSpriteUber,integer blue returns nothing
local integer colour=0
if pSpriteUber!=0 then
set colour=GetSpriteUberColour(pSpriteUber)
call SetSpriteUberColour(pSpriteUber,CreateInteger1(GetByteFromInteger(colour,1),GetByteFromInteger(colour,2),GetByteFromInteger(colour,3),blue))
endif
endfunction
function SetSpriteUberAnimationByIndex takes integer pSpriteUber,integer index returns nothing
call SetSpriteBaseAnimationByIndex(pSpriteUber,index)
endfunction
function SetSpriteUberAnimationByIndexWithRarity takes integer pSpriteUber,integer index,integer rarity returns nothing
call SetSpriteBaseAnimationByIndexWithRarity(pSpriteUber,index,rarity)
endfunction
function GetSpriteUberX takes integer pSpriteUber returns real
return GetSpriteBaseX(pSpriteUber)
endfunction
function SetSpriteUberX takes integer pSpriteUber,real x returns nothing
call SetSpriteBaseX(pSpriteUber,x)
endfunction
function GetSpriteUberY takes integer pSpriteUber returns real
return GetSpriteBaseY(pSpriteUber)
endfunction
function SetSpriteUberY takes integer pSpriteUber,real y returns nothing
call SetSpriteBaseY(pSpriteUber,y)
endfunction
function GetSpriteUberZ takes integer pSpriteUber returns real
return GetSpriteBaseZ(pSpriteUber)
endfunction
function SetSpriteUberZ takes integer pSpriteUber,real z returns nothing
call SetSpriteBaseZ(pSpriteUber,z)
endfunction
function SetSpriteUberPosition takes integer pSpriteUber,real x,real y,real z returns nothing
call SetSpriteBasePosition(pSpriteUber,x,y,z)
endfunction
function GetSpriteUberTimeScale takes integer pSpriteUber returns real
return GetSpriteBaseTimeScale(pSpriteUber)
endfunction
function SetSpriteUberTimeScale takes integer pSpriteUber,real speed returns nothing
call SetSpriteBaseTimeScale(pSpriteUber,speed)
endfunction
function GetSpriteUberScale takes integer pSpriteUber returns real
return GetSpriteBaseScale(pSpriteUber)
endfunction
function SetSpriteUberScale takes integer pSpriteUber,real scale returns nothing
call SetSpriteBaseScale(pSpriteUber,scale)
endfunction
function GetSpriteUberYawRad takes integer pSpriteUber returns real
return GetSpriteBaseYawRad(pSpriteUber)
endfunction
function GetSpriteUberPitchRad takes integer pSpriteUber returns real
return GetSpriteBasePitchRad(pSpriteUber)
endfunction
function GetSpriteUberRollRad takes integer pSpriteUber returns real
return GetSpriteBaseRollRad(pSpriteUber)
endfunction
function GetSpriteUberFacingRad takes integer pSpriteUber returns real
return GetSpriteUberYawRad(pSpriteUber)
endfunction
function SetSpriteUberSpaceRotationRad takes integer pSpriteUber,real yaw,real pitch,real roll returns nothing
call SetSpriteBaseSpaceRotationRad(pSpriteUber,yaw,pitch,roll)
endfunction
function SetSpriteUberYawRad takes integer pSpriteUber,real angle returns nothing
call SetSpriteBaseYawRad(pSpriteUber,angle)
endfunction
function SetSpriteUberPitchRad takes integer pSpriteUber,real angle returns nothing
call SetSpriteBasePitchRad(pSpriteUber,angle)
endfunction
function SetSpriteUberRollRad takes integer pSpriteUber,real angle returns nothing
call SetSpriteBaseRollRad(pSpriteUber,angle)
endfunction
function SetSpriteUberOrientationRad takes integer pSpriteUber,real yaw,real pitch,real roll returns nothing
call SetSpriteBaseOrientationRad(pSpriteUber,yaw,pitch,roll)
endfunction
function SetSpriteUberSpaceRotation takes integer pSpriteUber,real yaw,real pitch,real roll returns nothing
call SetSpriteUberSpaceRotationRad(pSpriteUber,Deg2Rad(yaw),Deg2Rad(pitch),Deg2Rad(roll))
endfunction
function GetSpriteUberYaw takes integer pSpriteUber returns real
return Rad2Deg(GetSpriteUberYawRad(pSpriteUber))
endfunction
function GetSpriteUberFacing takes integer pSpriteUber returns real
return Rad2Deg(GetSpriteUberFacingRad(pSpriteUber))
endfunction
function GetSpriteUberPitch takes integer pSpriteUber returns real
return Rad2Deg(GetSpriteUberPitchRad(pSpriteUber))
endfunction
function GetSpriteUberRoll takes integer pSpriteUber returns real
return Rad2Deg(GetSpriteUberRollRad(pSpriteUber))
endfunction
function SetSpriteUberYaw takes integer pSpriteUber,real angle returns nothing
call SetSpriteUberYawRad(pSpriteUber,Deg2Rad(angle))
endfunction
function SetSpriteUberFacing takes integer pSpriteUber,real angle returns nothing
call SetSpriteUberYawRad(pSpriteUber,Deg2Rad(angle))
endfunction
function SetSpriteUberPitch takes integer pSpriteUber,real angle returns nothing
call SetSpriteUberPitchRad(pSpriteUber,Deg2Rad(angle))
endfunction
function SetSpriteUberRoll takes integer pSpriteUber,real angle returns nothing
call SetSpriteUberRollRad(pSpriteUber,Deg2Rad(angle))
endfunction
function SetSpriteUberOrientation takes integer pSpriteUber,real yaw,real pitch,real roll returns nothing
call SetSpriteUberOrientationRad(pSpriteUber,Deg2Rad(yaw),Deg2Rad(pitch),Deg2Rad(roll))
endfunction
function SetSpriteUberScaleXYZ takes integer pSpriteUber,real x,real y,real z returns nothing
call SetSpriteBaseScaleXYZ(pSpriteUber,x,y,z)
endfunction
function ResetSpriteUberMatrix takes integer pSpriteUber returns nothing
call ResetSpriteBaseMatrix(pSpriteUber)
endfunction
function Init_MemHackCSpriteUberAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableBase"),pGameDLL+0x966EA4)
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableExt"),pGameDLL+0x966FC4)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableBase"),pGameDLL+0x954D4C)
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableExt"),pGameDLL+0x954E6C)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableBase"),pGameDLL+0x9647BC)
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableExt"),pGameDLL+0x96485C)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableBase"),pGameDLL+0xA92884)
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableExt"),pGameDLL+0xA92924)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableBase"),pGameDLL+0xA8266C)
call SaveInteger(MemHackTable,StringHash("CSpriteUber"),StringHash("vtableExt"),pGameDLL+0xA8270C)
endif
endif
endfunction
function CreateCFrameByTagNameEx takes string baseframe,integer parent,integer unk1,integer createContext,integer priority returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CFrame"),StringHash("CreateByTagName"))
if addr!=0 and baseframe!="" then
return fast_call_5(addr,GetStringAddress(baseframe),parent,unk1,createContext,priority)
endif
return 0
endfunction
function CreateCFrameByTagName takes string baseframe,integer parent,integer id returns integer
return CreateCFrameByTagNameEx(baseframe,parent,0,0,id)
endfunction
function GetCFrameByName takes string name,integer id returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CFrame"),StringHash("GetByName"))
if addr!=0 and name!="" then
return fast_call_2(addr,GetStringAddress(name),id)
endif
return 0
endfunction
function SetStringHashNodeListSize takes integer size returns boolean
local integer addr1=LoadInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowStringHashNode"))
local integer addr2=LoadInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("StringManager"))
if addr1!=0 and addr2!=0 then
if ReadRealMemory(addr2+0x14)<size then
call this_call_2(addr1,addr2,size)
endif
return true
endif
return false
endfunction
function SetBaseFrameHashNodeListSize takes integer size returns boolean
local integer addr1=LoadInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowFrameHashNode"))
local integer addr2=LoadInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("FDFHashList"))
if addr1!=0 and addr2!=0 then
if ReadRealMemory(addr2+0x14)<size then
call this_call_2(addr1,addr2,size)
endif
return true
endif
return false
endfunction
function LoadTOCFile takes string filename returns integer
local integer addr1=LoadInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("ReadTOCFile"))
local integer addr2=LoadInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("DefaultCStatus"))
local integer addr3=LoadInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("StringManager"))
local integer addr4=LoadInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("FDFHashList"))
local integer retval=0
if addr1!=0 and addr2!=0 and SetStringHashNodeListSize(0xFFFF)and SetBaseFrameHashNodeListSize(0xFFFF)then
set retval=fast_call_4(addr1,GetStringAddress(filename),addr3,addr4,addr2)
endif
return retval
endfunction
function Init_MemHackCFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("CreateByTagName"),pGameDLL+0x5C9D00)
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("GetByName"),pGameDLL+0x5FB110)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("DefaultCStatus"),pGameDLL+0xAA2824)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("StringManager"),pGameDLL+0xAE4074)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("FDFHashList"),pGameDLL+0xAE40C4)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowStringHashNode"),pGameDLL+0x5CB150)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowFrameHashNode"),pGameDLL+0x5D5DF0)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("ReadTOCFile"),pGameDLL+0x5D9580)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("CreateByTagName"),pGameDLL+0x5C9560)
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("GetByName"),pGameDLL+0x5FA970)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("DefaultCStatus"),pGameDLL+0xA8C804)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("StringManager"),pGameDLL+0xACD214)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("FDFHashList"),pGameDLL+0xACD264)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowStringHashNode"),pGameDLL+0x5CA9B0)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowFrameHashNode"),pGameDLL+0x5D5650)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("ReadTOCFile"),pGameDLL+0x5D8DE0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("CreateByTagName"),pGameDLL+0x0909C0)
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("GetByName"),pGameDLL+0x09EF40)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("DefaultCStatus"),pGameDLL+0xB662CC)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("StringManager"),pGameDLL+0xBB9CAC)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("FDFHashList"),pGameDLL+0xBB9CFC)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowStringHashNode"),pGameDLL+0x067560)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowFrameHashNode"),pGameDLL+0x066ED0)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("ReadTOCFile"),pGameDLL+0x066590)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("CreateByTagName"),pGameDLL+0x0E4740)
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("GetByName"),pGameDLL+0x0F2CA0)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("DefaultCStatus"),pGameDLL+0xCE3A4C)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("StringManager"),pGameDLL+0xD47744)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("FDFHashList"),pGameDLL+0xD47794)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowStringHashNode"),pGameDLL+0x0BB550)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowFrameHashNode"),pGameDLL+0x0BAEC0)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("ReadTOCFile"),pGameDLL+0x0BA580)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("CreateByTagName"),pGameDLL+0x112D90)
call SaveInteger(MemHackTable,StringHash("CFrame"),StringHash("GetByName"),pGameDLL+0x1212F0)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("DefaultCStatus"),pGameDLL+0xCB1A94)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("StringManager"),pGameDLL+0xD0F524)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("FDFHashList"),pGameDLL+0xD0F574)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowStringHashNode"),pGameDLL+0x0E9D40)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("GrowFrameHashNode"),pGameDLL+0x0E96B0)
call SaveInteger(MemHackTable,StringHash("CFrameAPI"),StringHash("ReadTOCFile"),pGameDLL+0x0E8D70)
endif
endif
endfunction
function AllocateCBackdropFrameMemory takes nothing returns integer
return StormAllocateMemory(0x1DC,"MemHackCBackdropFrame",4,0)
endfunction
function CreateCBackdropFrameEx takes integer pBackDrop,integer pParent,integer createContext,integer priority returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("Create"))
if addr!=0 and pBackDrop!=0 then
return this_call_4(addr,pBackDrop,pParent,createContext,priority)
endif
return 0
endfunction
function CreateCBackdropFrame takes integer pParent,integer priority returns integer
return CreateCBackdropFrameEx(AllocateCBackdropFrameMemory(),pParent,0,priority)
endfunction
function LoadCBackDropFrameTexture takes string texturepath,boolean create returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("LoadTexture"))
if addr!=0 and texturepath!="" then
return std_call_2(addr,GetStringAddress(texturepath),B2I(create))
endif
return 0
endfunction
function SetCBackDropFrameTexture takes integer pFrame,string texturepath,boolean flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("SetTexture"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CBackdropFrame" then
return this_call_6(addr,pFrame,GetStringAddress(texturepath),0,B2I(flag),0,1)
endif
endif
return 0
endfunction
function Init_MemHackCBackDropFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("Create"),pGameDLL+0x621670)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("LoadTexture"),pGameDLL+0x621780)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("SetTexture"),pGameDLL+0x621A70)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("Create"),pGameDLL+0x620ED0)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("LoadTexture"),pGameDLL+0x620FE0)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("SetTexture"),pGameDLL+0x6212D0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("Create"),pGameDLL+0x0A4700)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("LoadTexture"),pGameDLL+0x0A4AE0)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("SetTexture"),pGameDLL+0x0A62A0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("Create"),pGameDLL+0x0F8460)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("LoadTexture"),pGameDLL+0x0F8840)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("SetTexture"),pGameDLL+0x0FA000)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("Create"),pGameDLL+0x126AD0)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("LoadTexture"),pGameDLL+0x126EB0)
call SaveInteger(MemHackTable,StringHash("CBackDropFrame"),StringHash("SetTexture"),pGameDLL+0x128670)
endif
endif
endfunction
function SetCEditBoxFocus takes integer pFrame,boolean flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFocus"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CEditBox" then
return this_call_2(addr,pFrame,B2I(flag))
endif
endif
return 0
endfunction
function SetCEditBoxFont takes integer pFrame,string filename,real height,integer flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFont"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CEditBox" then
return this_call_4(addr,pFrame,GetStringAddress(filename),SetRealIntoMemory(height),flag)
endif
endif
return 0
endfunction
function GetCEditBoxText takes integer pFrame returns string
local integer addr=LoadInteger(MemHackTable,StringHash("CEditBox"),StringHash("GetText"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CEditBox" then
return ToJString(this_call_1(addr,pFrame))
endif
endif
return""
endfunction
function SetCEditBoxText takes integer pFrame,string text returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetText"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CEditBox" or f_name=="CGlueEditBoxWar3" or f_name=="CSlashChatBox" then
return B2I(this_call_3(addr,pFrame,GetStringAddress(text),1)>0)
endif
endif
return 0
endfunction
function Init_MemHackCEditBoxAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("GetText"),pGameDLL+0x614640)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetText"),pGameDLL+0x6162F0)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFont"),pGameDLL+0x614440)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFocus"),pGameDLL+0x615920)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("GetText"),pGameDLL+0x613EA0)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetText"),pGameDLL+0x615B50)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFont"),pGameDLL+0x613CA0)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFocus"),pGameDLL+0x615180)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("GetText"),pGameDLL+0x0AEDF0)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetText"),pGameDLL+0x0B0450)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFont"),pGameDLL+0x0B0350)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFocus"),pGameDLL+0x0B0260)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("GetText"),pGameDLL+0x102B50)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetText"),pGameDLL+0x1041B0)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFont"),pGameDLL+0x1040B0)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFocus"),pGameDLL+0x103FC0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("GetText"),pGameDLL+0x1311C0)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetText"),pGameDLL+0x132820)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFont"),pGameDLL+0x132720)
call SaveInteger(MemHackTable,StringHash("CEditBox"),StringHash("SetFocus"),pGameDLL+0x132630)
endif
endif
endfunction
function FindCLayerUnderCursorEx takes integer pActiveLayer,integer pMouseEvent returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayer"),StringHash("FindUnderCursor"))
local integer pData=0
local integer value=0
if addr!=0 and pActiveLayer!=0 and pMouseEvent!=0 then
set pData=ReadRealMemory(pActiveLayer)
if pData!=0 then
set pData=this_call_2(addr,pData,pMouseEvent)
if pData!=0 then
if ReadRealMemory(pData)!=pWorldFrameWar3 then
return pData
endif
endif
endif
endif
return 0
endfunction
function FindCLayerUnderCursor takes nothing returns integer
return FindCLayerUnderCursorEx(LoadInteger(MemHackTable,StringHash("CLayer"),StringHash("ActiveFrame")),LoadInteger(MemHackTable,StringHash("CMouse"),StringHash("Event")))
endfunction
function SetCLayerOwner takes integer pFrame,integer pParentFrame returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayer"),StringHash("SetOwner"))
if addr!=0 and pFrame!=0 and pParentFrame!=0 then
return this_call_4(addr,pFrame,pParentFrame,1,0)
endif
return 0
endfunction
function HideCLayer takes integer pFrame returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayer"),StringHash("Hide"))
if addr!=0 and pFrame!=0 then
return this_call_1(addr,pFrame)
endif
return 0
endfunction
function ShowCLayer takes integer pFrame returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayer"),StringHash("Show"))
if addr!=0 and pFrame!=0 then
return this_call_1(addr,pFrame)
endif
return 0
endfunction
function SetCLayerVisibility takes integer pFrame,boolean flag returns boolean
if flag then
return I2B(ShowCLayer(pFrame))
else
return I2B(HideCLayer(pFrame))
endif
return false
endfunction
function IsCLayerHidden takes integer pFrame returns boolean
if pFrame!=0 then
return IsFlagBitSet(ReadRealMemory(pFrame+0xB0),0x1)
endif
return false
endfunction
function IsCLayerVisible takes integer pFrame returns boolean
return not IsCLayerHidden(pFrame)
endfunction
function SetCLayerPriority takes integer pFrame,integer priority returns boolean
if pFrame!=0 then
call HideCLayer(pFrame)
call WriteRealMemory(pFrame+0xA8,priority)
return I2B(ShowCLayer(pFrame))
endif
return false
endfunction
function SetCLayerAlpha takes integer pFrame,integer alpha returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayer"),StringHash("SetAlpha"))
local integer fid=0
if addr!=0 and pFrame!=0 then
set fid=GetFrameType(pFrame)
if fid!=0 and fid!=6 then
return this_call_3(addr,pFrame,alpha,0)
endif
endif
return 0
endfunction
function SetCLayerFont takes integer pFrame,string filename,real height,integer flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayer"),StringHash("SetFont"))
local integer fid=0
if addr!=0 and pFrame!=0 then
set fid=GetFrameType(pFrame)
if fid!=6 and fid!=19 and fid!=23 then
if not IsFrameLayoutByType(pFrame,fid)then
return this_call_4(addr,pFrame,GetStringAddress(filename),SetRealIntoMemory(height),flag)
endif
endif
endif
return 0
endfunction
function SetCLayerTooltip takes integer pFrame,integer pTooltip returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAllPoints"))
local integer fid=0
if addr!=0 then
set fid=GetFrameType(pFrame)
if fid>0 then
if pTooltip>0 then
endif
set addr=LoadInteger(MemHackTable,StringHash("CLayer"),StringHash("SetTooltip"))
if addr!=0 then
return this_call_2(addr,pFrame,pTooltip)
endif
endif
endif
return 0
endfunction
function Init_MemHackCLayerAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("FindUnderCursor"),pGameDLL+0x5FE1C0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetOwner"),pGameDLL+0x5FFE70)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Hide"),pGameDLL+0x5FEE90)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Show"),pGameDLL+0x5FEE30)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetAlpha"),pGameDLL+0x5FE660)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetFont"),pGameDLL+0x5FC100)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetTooltip"),pGameDLL+0x5FFFA0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("ActiveFrame"),pGameDLL+0xAE54CC)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("FindUnderCursor"),pGameDLL+0x5FDA20)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetOwner"),pGameDLL+0x5FF6D0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Hide"),pGameDLL+0x5FE6F0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Show"),pGameDLL+0x5FE690)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetAlpha"),pGameDLL+0x5FDEC0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetFont"),pGameDLL+0x5FB960)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetTooltip"),pGameDLL+0x5FF800)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("ActiveFrame"),pGameDLL+0xACE66C)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("FindUnderCursor"),pGameDLL+0x0996E0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetOwner"),pGameDLL+0x09D2B0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Hide"),pGameDLL+0x09A320)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Show"),pGameDLL+0x09D450)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetAlpha"),pGameDLL+0x09CA50)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetFont"),pGameDLL+0x09CE60)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetTooltip"),pGameDLL+0x09D3D0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("ActiveFrame"),pGameDLL+0xBB9D88)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("FindUnderCursor"),pGameDLL+0x0ED440)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetOwner"),pGameDLL+0x0F1010)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Hide"),pGameDLL+0x0EE080)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Show"),pGameDLL+0x0F11B0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetAlpha"),pGameDLL+0x0F07B0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetFont"),pGameDLL+0x0F0BC0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetTooltip"),pGameDLL+0x0F1130)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("ActiveFrame"),pGameDLL+0xD47820)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("FindUnderCursor"),pGameDLL+0x11BA90)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetOwner"),pGameDLL+0x11F660)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Hide"),pGameDLL+0x11C6D0)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("Show"),pGameDLL+0x11F800)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetAlpha"),pGameDLL+0x11EE00)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetFont"),pGameDLL+0x11F210)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("SetTooltip"),pGameDLL+0x11F780)
call SaveInteger(MemHackTable,StringHash("CLayer"),StringHash("ActiveFrame"),pGameDLL+0xD0F600)
endif
endif
endfunction
function SetCLayoutFrameAbsolutePoint takes integer pFrame,integer point,real offsetX,real offsetY returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAbsolutePoint"))
local integer fid=0
if addr!=0 and pFrame!=0 then
set fid=GetFrameLayout(pFrame)
if fid!=0 then
return this_call_5(addr,pFrame,point,SetRealIntoMemory(offsetX),SetRealIntoMemory(offsetY),1)
endif
endif
return 0
endfunction
function SetCLayoutFrameCageMouse takes integer pFrame,boolean flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("CageMouse"))
local integer fid=0
if addr!=0 and pFrame!=0 then
set fid=GetFrameType(pFrame)
if fid!=0 then
return this_call_2(addr,pFrame,B2I(flag))
endif
endif
return 0
endfunction
function ClearCLayoutFrameAllPoints takes integer pFrame returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("ClearAllPoints"))
if addr!=0 and pFrame!=0 then
set pFrame=GetFrameLayout(pFrame)
if pFrame!=0 then
return this_call_2(addr,pFrame,1)
endif
endif
return 0
endfunction
function SetCLayoutFrameWidth takes integer pFrame,real width returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetWidth"))
local integer fid=0
if addr!=0 and pFrame!=0 then
set fid=GetFrameType(pFrame)
if fid!=0 then
set pFrame=GetFrameLayout(pFrame)
return this_call_2(addr,pFrame,SetRealIntoMemory(width))
endif
endif
return 0
endfunction
function SetCLayoutFrameHeight takes integer pFrame,real height returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetHeight"))
local integer fid=0
if addr!=0 and pFrame!=0 then
set fid=GetFrameType(pFrame)
if fid!=0 then
set pFrame=GetFrameLayout(pFrame)
return this_call_2(addr,pFrame,SetRealIntoMemory(height))
endif
endif
return 0
endfunction
function SetCLayoutFrameAllPoints takes integer pFrame,integer relativeframe returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAllPoints"))
if addr!=0 and pFrame!=0 then
set pFrame=GetFrameLayout(pFrame)
if pFrame!=0 and GetFrameLayout(relativeframe)>0 then
return this_call_3(addr,pFrame,relativeframe,1)
endif
endif
return 0
endfunction
function SetCLayoutFrameSize takes integer pFrame,real width,real height returns integer
if pFrame!=0 and GetFrameLayout(pFrame)!=0 then
call SetCLayoutFrameWidth(pFrame,width)
call SetCLayoutFrameHeight(pFrame,height)
return 1
endif
return 0
endfunction
function SetCLayoutFramePoint takes integer pFrame,integer point,integer pParentFrame,integer relativePoint,real x,real y returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetRelativePoint"))
if addr!=0 and pFrame!=0 and pParentFrame!=0 then
call this_call_7(addr,pFrame,point,pParentFrame,relativePoint,SetRealIntoMemory(x),SetRealIntoMemory(y),1)
return 1
endif
return 0
endfunction
function SetCLayoutFrameScale takes integer pFrame,real scale returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetScale"))
if addr!=0 and pFrame!=0 then
set pFrame=GetFrameLayout(pFrame)
if pFrame!=0 then
return this_call_2(addr,pFrame,SetRealIntoMemory(scale))
endif
endif
return 0
endfunction
function GetCLayoutFrameHeight takes integer pFrame returns real
local integer addr=LoadInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("GetHeight"))
local string f_name=""
if addr!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name!="CModelFrame" and f_name!="CSimpleFontString" and f_name!="CSpriteFrame" and f_name!="CTextFrame" then
set pFrame=GetFrameLayoutByType(pFrame,GetFrameType(pFrame))
if pFrame!=0 then
return GetRealFromMemory(this_call_1(addr,pFrame))
endif
endif
endif
return 0.
endfunction
function Init_MemHackCLayoutFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("GetHeight"),pGameDLL+0x605740)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetScale"),pGameDLL+0x6064E0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetRelativePoint"),pGameDLL+0x606F10)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("ClearAllPoints"),pGameDLL+0x606A10)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetWidth"),pGameDLL+0x606530)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetHeight"),pGameDLL+0x606550)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAbsolutePoint"),pGameDLL+0x606950)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("CaseMouse"),pGameDLL+0x605760)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAllPoints"),pGameDLL+0x606F90)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("GetHeight"),pGameDLL+0x604FA0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetScale"),pGameDLL+0x605D40)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetRelativePoint"),pGameDLL+0x606770)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("ClearAllPoints"),pGameDLL+0x606270)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetWidth"),pGameDLL+0x605D90)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetHeight"),pGameDLL+0x605DB0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAbsolutePoint"),pGameDLL+0x6061B0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("CaseMouse"),pGameDLL+0x604FC0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAllPoints"),pGameDLL+0x6067F0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("GetHeight"),pGameDLL+0x0BCDF0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetScale"),pGameDLL+0x0BD7E0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetRelativePoint"),pGameDLL+0x0BD8A0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("ClearAllPoints"),pGameDLL+0x0BCB50)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetWidth"),pGameDLL+0x0BD960)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetHeight"),pGameDLL+0x0BD7C0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAbsolutePoint"),pGameDLL+0x0BD830)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("CaseMouse"),pGameDLL+0x0BC8D0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAllPoints"),pGameDLL+0x0BD750)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("GetHeight"),pGameDLL+0x110B50)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetScale"),pGameDLL+0x111540)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetRelativePoint"),pGameDLL+0x111600)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("ClearAllPoints"),pGameDLL+0x1108B0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetWidth"),pGameDLL+0x1116C0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetHeight"),pGameDLL+0x111520)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAbsolutePoint"),pGameDLL+0x111590)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("CaseMouse"),pGameDLL+0x110630)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAllPoints"),pGameDLL+0x1114B0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("GetHeight"),pGameDLL+0x13F170)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetScale"),pGameDLL+0x13FB60)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetRelativePoint"),pGameDLL+0x13FC20)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("ClearAllPoints"),pGameDLL+0x13EE90)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetWidth"),pGameDLL+0x13FCE0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetHeight"),pGameDLL+0x13FB40)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAbsolutePoint"),pGameDLL+0x13FBB0)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("CaseMouse"),pGameDLL+0x13EB60)
call SaveInteger(MemHackTable,StringHash("CLayoutFrame"),StringHash("SetAllPoints"),pGameDLL+0x13FAD0)
endif
endif
endfunction
function AddCModelFrameModel takes integer pFrame,string model,integer modeltype returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CModelFrame"),StringHash("AddModel"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CModelFrame" then
return this_call_3(addr,pFrame,GetStringAddress(model),modeltype)
endif
endif
return 0
endfunction
function GetCModelFrameHeight takes integer pFrame returns real
local integer addr=LoadInteger(MemHackTable,StringHash("CModelFrame"),StringHash("GetHeight"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CModelFrame" then
return GetRealFromMemory(this_call_1(addr,pFrame))
endif
endif
return 0.
endfunction
function Init_MemHackCModelFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("AddModel"),pGameDLL+0x621D70)
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("GetHeight"),pGameDLL+0x622100)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("AddModel"),pGameDLL+0x6215D0)
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("GetHeight"),pGameDLL+0x621960)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("AddModel"),pGameDLL+0x0A3FA0)
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("GetHeight"),pGameDLL+0x0A4180)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("AddModel"),pGameDLL+0x0F7D00)
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("GetHeight"),pGameDLL+0x0F7EE0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("AddModel"),pGameDLL+0x126370)
call SaveInteger(MemHackTable,StringHash("CModelFrame"),StringHash("GetHeight"),pGameDLL+0x126550)
endif
endif
endfunction
function GetARGBColour takes integer alpha,integer red,integer green,integer blue returns integer
return CreateInteger1(alpha,red,green,blue)
endfunction
function IsObjectHidden takes integer pObject returns boolean
if pObject>0 then
return IsFlagBitSet(ReadRealMemory(pObject+0x20),1)
endif
return false
endfunction
function ShowObject takes integer pObject,boolean flag returns nothing
if pObject>0 then
call WriteRealMemory(pObject+0x20,B2I(not flag))
endif
endfunction
function GetObjectTypeId takes integer pObj returns integer
if pObj>0 then
return ReadRealMemory(pObj+0x30)
endif
return 0
endfunction
function GetObjectSprite takes integer pObject returns integer
if pObject!=0 then
return ReadRealMemory(pObject+0x28)
endif
return 0
endfunction
function GetObjectSpriteFloat takes integer pObject,integer offset returns real
local integer pSprite=GetObjectSprite(pObject)
if pSprite!=0 then
return ReadRealFloat(pSprite+offset)
endif
return 0.
endfunction
function SetObjectSpriteFloat takes integer pObject,integer offset,real value returns real
local integer pSprite=GetObjectSprite(pObject)
if pSprite!=0 then
call WriteRealFloat(pSprite+offset,value)
endif
return 0.
endfunction
function UpdateObjectColour takes integer pObject returns nothing
local integer pSprite=GetObjectSprite(pObject)
local integer flag=0
if pSprite!=0 then
call WriteRealMemory(pSprite+0x140,0)
call WriteRealMemory(pSprite+0x13C,0)
set flag=ReadRealMemory(pSprite+0x138)
if not IsFlagBitSet(flag,0x800)then
call WriteRealMemory(pSprite+0x138,flag+0x800)
endif
endif
endfunction
function SetObjectAlpha takes integer pObject,integer alpha returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CObject"),StringHash("SetAlpha"))
local integer pSprite=GetObjectSprite(pObject)
if addr!=0 and pSprite!=0 then
if alpha>=0x00 and alpha<=0xFF then
call fast_call_3(addr,pSprite,alpha,0)
endif
endif
endfunction
function GetObjectColour takes integer pObject returns integer
local integer pSprite=GetObjectSprite(pObject)
if pSprite!=0 then
return ReadRealMemory(pSprite+0x148)
endif
return 0
endfunction
function SetObjectColour takes integer pObject,integer colour returns nothing
local integer pSprite=GetObjectSprite(pObject)
if pSprite!=0 then
call WriteRealMemory(pSprite+0x148,colour)
call UpdateObjectColour(pObject)
endif
endfunction
function SetObjectColourEx takes integer pObject,integer red,integer green,integer blue,integer alpha returns nothing
if pObject!=0 then
call SetObjectColour(pObject,CreateInteger1(alpha,red,green,blue))
endif
endfunction
function SetObjectVertexColour takes integer pObject,integer red,integer green,integer blue,integer alpha returns nothing
call SetObjectColourEx(pObject,red,green,blue,alpha)
call SetObjectAlpha(pObject,alpha)
endfunction
function GetObjectColourA takes integer pObject returns integer
if pObject!=0 then
return GetByteFromInteger(GetObjectColour(pObject),1)
endif
return-1
endfunction
function SetObjectColourA takes integer pObject,integer alpha returns nothing
local integer colour=0
if pObject!=0 then
set colour=GetObjectColour(pObject)
call SetObjectColour(pObject,CreateInteger1(alpha,GetByteFromInteger(colour,2),GetByteFromInteger(colour,3),GetByteFromInteger(colour,4)))
endif
endfunction
function GetObjectColourR takes integer pObject returns integer
if pObject!=0 then
return GetByteFromInteger(GetObjectColour(pObject),2)
endif
return-1
endfunction
function SetObjectColourR takes integer pObject,integer red returns nothing
local integer colour=0
if pObject!=0 then
set colour=GetObjectColour(pObject)
call SetObjectColour(pObject,CreateInteger1(GetByteFromInteger(colour,1),red,GetByteFromInteger(colour,3),GetByteFromInteger(colour,4)))
endif
endfunction
function GetObjectColourG takes integer pObject returns integer
if pObject!=0 then
return GetByteFromInteger(GetObjectColour(pObject),3)
endif
return-1
endfunction
function SetObjectColourG takes integer pObject,integer green returns nothing
local integer colour=0
if pObject!=0 then
set colour=GetObjectColour(pObject)
call SetObjectColour(pObject,CreateInteger1(GetByteFromInteger(colour,1),GetByteFromInteger(colour,2),green,GetByteFromInteger(colour,4)))
endif
endfunction
function GetObjectColourB takes integer pObject returns integer
if pObject!=0 then
return GetByteFromInteger(GetObjectColour(pObject),4)
endif
return-1
endfunction
function SetObjectColourB takes integer pObject,integer blue returns nothing
local integer colour=0
if pObject!=0 then
set colour=GetObjectColour(pObject)
call SetObjectColour(pObject,CreateInteger1(GetByteFromInteger(colour,1),GetByteFromInteger(colour,2),GetByteFromInteger(colour,3),blue))
endif
endfunction
function SetObjectAnimationByIndex takes integer pObject,integer index returns nothing
call SetSpriteBaseAnimationByIndex(GetObjectSprite(pObject),index)
endfunction
function SetObjectAnimationByIndexWithRarity takes integer pObject,integer index,integer rarity returns nothing
call SetSpriteBaseAnimationByIndexWithRarity(GetObjectSprite(pObject),index,rarity)
endfunction
function SetObjectModel takes integer pObject,string model,boolean flag returns nothing
local integer pData=0
if pObject>0 then
set pData=ReadRealMemory(pObject)+0x88
if pData>0 then
set pData=ReadRealMemory(pData)
if pData>0 then
call this_call_3(pData,pObject,GetStringAddress(model),B2I(flag))
endif
endif
endif
endfunction
function GetObjectX takes integer pObject returns real
return GetObjectSpriteFloat(pObject,0xC0)
endfunction
function SetObjectX takes integer pObject,real x returns nothing
local integer pSprite=GetObjectSprite(pObject)
local integer pSmartPos=0
if pSprite!=0 then
set pSmartPos=this_call_1(ReadRealMemory(ReadRealMemory(pObject)+0xB0),pObject)
call SetSmartPositionAxisEx(pSmartPos,x,ReadRealFloat(pSprite+0xC4),1)
call WriteRealFloat(pSprite+0xC0,x)
endif
endfunction
function GetObjectY takes integer pObject returns real
return GetObjectSpriteFloat(pObject,0xC4)
endfunction
function SetObjectY takes integer pObject,real y returns nothing
local integer pSprite=GetObjectSprite(pObject)
local integer pSmartPos=0
if pSprite!=0 then
set pSmartPos=this_call_1(ReadRealMemory(ReadRealMemory(pObject)+0xB0),pObject)
call SetSmartPositionAxisEx(pSmartPos,ReadRealFloat(pSprite+0xC0),y,1)
call WriteRealFloat(pSprite+0xC4,y)
endif
endfunction
function GetObjectZ takes integer pObject returns real
return GetObjectSpriteFloat(pObject,0xC8)
endfunction
function SetObjectZ takes integer pObject,real z returns nothing
call SetObjectSpriteFloat(pObject,0xC8,z)
endfunction
function SetObjectPosition takes integer pObject,real x,real y,real z returns nothing
local integer pSprite=GetObjectSprite(pObject)
local integer pSmartPos=0
if pSprite!=0 then
set pSmartPos=this_call_1(ReadRealMemory(ReadRealMemory(pObject)+0xB0),pObject)
call SetSmartPositionAxisEx(pSmartPos,x,y,1)
call WriteRealFloat(pSprite+0xC0,x)
call WriteRealFloat(pSprite+0xC4,y)
call WriteRealFloat(pSprite+0xC8,z)
endif
endfunction
function GetObjectTimeScale takes integer pObject returns real
return GetObjectSpriteFloat(pObject,0x190)
endfunction
function SetObjectTimeScale takes integer pObject,real speed returns nothing
call SetObjectSpriteFloat(pObject,0x190,speed)
endfunction
function GetObjectScale takes integer pObject returns real
return GetObjectSpriteFloat(pObject,0xE8)
endfunction
function SetObjectScale takes integer pObject,real scale returns nothing
call SetObjectSpriteFloat(pObject,0xE8,scale)
endfunction
function GetObjectYawRad takes integer pObject returns real
local integer pSprite=GetObjectSprite(pObject)
local real r11=0.
local real r21=0.
local real r31=0.
local real yaw=0.
local real pitch=0.
if pSprite!=0 then
set r11=ReadRealFloat(pSprite+0x108)
set r21=ReadRealFloat(pSprite+0x114)
set r31=ReadRealFloat(pSprite+0x120)
set pitch=-Asin(r31)
set yaw=-Atan2(r21,r11)
if yaw<0 then
set yaw=6.28319+yaw
endif
endif
return yaw
endfunction
function GetObjectPitchRad takes integer pObject returns real
local integer pSprite=GetObjectSprite(pObject)
local real r31=0.
local real r32=0.
local real r33=0.
local real pitch=0.
if pSprite!=0 then
set r31=ReadRealFloat(pSprite+0x120)
set r32=ReadRealFloat(pSprite+0x124)
set r33=ReadRealFloat(pSprite+0x128)
set pitch=-Asin(r31)
if r31<0. and r33>0. then
set pitch=pitch
elseif r31<0. and r33<0. then
set pitch=3.14159-pitch
elseif r31>0. and r33<0. then
set pitch=3.14159-pitch
elseif r31>0. and r33>0. then
set pitch=6.28319+pitch
endif
endif
return pitch
endfunction
function GetObjectRollRad takes integer pObject returns real
local integer pSprite=GetObjectSprite(pObject)
local real r31=0.
local real r32=0.
local real r33=0.
local real pitch=0.
local real roll=0.
if pSprite!=0 then
set r31=ReadRealFloat(pSprite+0x120)
set r32=ReadRealFloat(pSprite+0x124)
set r33=ReadRealFloat(pSprite+0x128)
set pitch=-Asin(r31)
set roll=Atan2(r32/ Cos(pitch),r33/ Cos(pitch))
if roll<0. then
set roll=6.28319+roll
endif
endif
return roll
endfunction
function GetObjectFacingRad takes integer pObject returns real
return GetObjectYawRad(pObject)
endfunction
function SetObjectSpaceRotationRad takes integer pObject,real yaw,real pitch,real roll returns nothing
local integer pSprite=GetObjectSprite(pObject)
local real Sx=Sin(roll)
local real Sy=Sin(pitch)
local real Sz=Sin(-yaw)
local real Cx=Cos(roll)
local real Cy=Cos(pitch)
local real Cz=Cos(-yaw)
if pSprite!=0 then
call WriteRealFloat(pSprite+0x108,Cy*Cz)
call WriteRealFloat(pSprite+0x10C,-Cy*Sz)
call WriteRealFloat(pSprite+0x110,Sy)
call WriteRealFloat(pSprite+0x114,Cz*Sx*Sy+Cx*Sz)
call WriteRealFloat(pSprite+0x118,Cx*Cz-Sx*Sy*Sz)
call WriteRealFloat(pSprite+0x11C,-Cy*Sx)
call WriteRealFloat(pSprite+0x120,-Cx*Cz*Sy+Sx*Sz)
call WriteRealFloat(pSprite+0x124,Cz*Sx+Cx*Sy*Sz)
call WriteRealFloat(pSprite+0x128,Cx*Cy)
endif
endfunction
function SetObjectYawRad takes integer pObject,real angle returns nothing
local integer pSprite=GetObjectSprite(pObject)
local real r31=0.
local real r32=0.
local real r33=0.
local real pitch=0.
local real roll=0.
if pSprite!=0 then
set r31=ReadRealFloat(pSprite+0x120)
set r32=ReadRealFloat(pSprite+0x124)
set r33=ReadRealFloat(pSprite+0x128)
set pitch=-Asin(r31)
set roll=Atan2(r32/ Cos(pitch),r33/ Cos(pitch))
call SetObjectSpaceRotationRad(pObject,angle,pitch,roll)
endif
endfunction
function SetObjectPitchRad takes integer pObject,real angle returns nothing
local integer pSprite=GetObjectSprite(pObject)
local real r11=0.
local real r21=0.
local real r32=0.
local real r33=0.
local real yaw=0.
local real roll=0.
if pSprite!=0 then
set r11=ReadRealFloat(pSprite+0x108)
set r21=ReadRealFloat(pSprite+0x114)
set r32=ReadRealFloat(pSprite+0x124)
set r33=ReadRealFloat(pSprite+0x128)
set yaw=Atan2(r21/ Cos(angle),r11/ Cos(angle))
set roll=Atan2(r32/ Cos(angle),r33/ Cos(angle))
call SetObjectSpaceRotationRad(pObject,yaw,angle,roll)
endif
endfunction
function SetObjectRollRad takes integer pObject,real angle returns nothing
local integer pSprite=GetObjectSprite(pObject)
local real r11=0.
local real r21=0.
local real r31=0.
local real yaw=0.
local real pitch=0.
if pSprite!=0 then
set r11=ReadRealFloat(pSprite+0x108)
set r21=ReadRealFloat(pSprite+0x114)
set r31=ReadRealFloat(pSprite+0x120)
set pitch=-Asin(r31)
set yaw=Atan2(r21/ Cos(pitch),r11/ Cos(pitch))
call SetObjectSpaceRotationRad(pObject,yaw,pitch,angle)
endif
endfunction
function SetObjectOrientationRad takes integer pObject,real yaw,real pitch,real roll returns nothing
if pObject>0 then
call SetObjectSpaceRotationRad(pObject,yaw,pitch,roll)
endif
endfunction
function SetObjectSpaceRotation takes integer pObject,real yaw,real pitch,real roll returns nothing
call SetObjectSpaceRotationRad(pObject,Deg2Rad(yaw),Deg2Rad(pitch),Deg2Rad(roll))
endfunction
function GetObjectYaw takes integer pObject returns real
return Rad2Deg(GetObjectYawRad(pObject))
endfunction
function GetObjectFacing takes integer pObject returns real
return Rad2Deg(GetObjectFacingRad(pObject))
endfunction
function GetObjectPitch takes integer pObject returns real
return Rad2Deg(GetObjectPitchRad(pObject))
endfunction
function GetObjectRoll takes integer pObject returns real
return Rad2Deg(GetObjectRollRad(pObject))
endfunction
function SetObjectYaw takes integer pObject,real angle returns nothing
call SetObjectYawRad(pObject,Deg2Rad(angle))
endfunction
function SetObjectFacing takes integer pObject,real angle returns nothing
call SetObjectYawRad(pObject,Deg2Rad(angle))
endfunction
function SetObjectPitch takes integer pObject,real angle returns nothing
call SetObjectPitchRad(pObject,Deg2Rad(angle))
endfunction
function SetObjectRoll takes integer pObject,real angle returns nothing
call SetObjectRollRad(pObject,Deg2Rad(angle))
endfunction
function SetObjectOrientation takes integer pObject,real yaw,real pitch,real roll returns nothing
call SetObjectOrientationRad(pObject,Deg2Rad(yaw),Deg2Rad(pitch),Deg2Rad(roll))
endfunction
function SetObjectScaleEx takes integer pObject,real x,real y,real z returns nothing
call SetSpriteBaseMaterialScale(GetObjectSprite(pObject),x,y,z)
endfunction
function ResetObjectMatrix takes integer pObject returns nothing
call ResetSpriteBaseMatrix(GetObjectSprite(pObject))
endfunction
function Init_APIMemoryObjectData takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CObject"),StringHash("SetAlpha"),pGameDLL+0x4D3D50)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CObject"),StringHash("SetAlpha"),pGameDLL+0x4D3250)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CObject"),StringHash("SetAlpha"),pGameDLL+0x186FA0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CObject"),StringHash("SetAlpha"),pGameDLL+0x1A4CC0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CObject"),StringHash("SetAlpha"),pGameDLL+0x1D7550)
endif
endif
endfunction
function CreateCSimpleButton takes integer pParent returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Create"))
local integer baseobj=0
if addr!=0 then
set baseobj=StormAllocateMemory(0x168,"MemHackCSimpleButton",14,0)
if baseobj>0 then
return this_call_2(addr,baseobj,pParent)
endif
endif
return 0
endfunction
function DestroyCSimpleButton takes integer pButton returns boolean
if pButton>0 then
return this_call_2(ReadRealMemory(pButton+0x8),pButton,1)>0
endif
return false
endfunction
function SetCSimpleButtonStateTexture takes integer pButton,integer state,string texturepath returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetStateTexture"))
if addr!=0 and pButton!=0 then
return this_call_3(addr,pButton,state,GetStringAddress(texturepath))>0
endif
return false
endfunction
function SetCSimpleButtonState takes integer pButton,integer state returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetState"))
if addr!=0 and pButton!=0 then
return this_call_2(addr,pButton,state)>0
endif
return false
endfunction
function ClickCSimpleButton takes integer pButton,integer buttonType returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Click"))
if addr!=0 and pButton!=0 then
return this_call_2(addr,pButton,buttonType)
endif
return 0
endfunction
function ClickCSimpleButtonEx takes integer pButton,integer buttonType returns boolean
local integer oldflag=0
local integer retval=0
if pButton!=0 then
set oldflag=ReadRealMemory(pButton+0x138)
if not IsFlagBitSet(oldflag,0x2)then
call WriteRealMemory(pButton+0x138,BitwiseXor(oldflag,0x2))
endif
set retval=ClickCSimpleButton(pButton,buttonType)
call WriteRealMemory(pButton+0x138,oldflag)
endif
return retval!=0
endfunction
function Init_MemHackCSimpleButtonAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Create"),pGameDLL+0x603880)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetState"),pGameDLL+0x603780)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetStateTexture"),pGameDLL+0x6039C0)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Click"),pGameDLL+0x603BE0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Create"),pGameDLL+0x6030E0)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetState"),pGameDLL+0x602FE0)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetStateTexture"),pGameDLL+0x603220)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Click"),pGameDLL+0x603440)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Create"),pGameDLL+0x0BB2A0)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetState"),pGameDLL+0x0BB4E0)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetStateTexture"),pGameDLL+0x0BBA40)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Click"),pGameDLL+0x0BB560)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Create"),pGameDLL+0x3A1620)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetState"),pGameDLL+0x10F240)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetStateTexture"),pGameDLL+0x10F7A0)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Click"),pGameDLL+0x10F2C0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Create"),pGameDLL+0x3D5730)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetState"),pGameDLL+0x13D770)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("SetStateTexture"),pGameDLL+0x13DCD0)
call SaveInteger(MemHackTable,StringHash("CSimpleButton"),StringHash("Click"),pGameDLL+0x13D7F0)
endif
endif
endfunction
function CreateCSimpleConsoleByTagName takes string tagName,integer parent,integer id returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleConsole"),StringHash("CreateByTagName"))
if addr!=0 and tagName!="" then
return fast_call_3(addr,GetStringAddress(tagName),parent,id)
endif
return 0
endfunction
function Init_MemHackCSimpleConsoleAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleConsole"),StringHash("CreateByTagName"),pGameDLL+0x5C9DB0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleConsole"),StringHash("CreateByTagName"),pGameDLL+0x5C9610)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleConsole"),StringHash("CreateByTagName"),pGameDLL+0x090A60)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleConsole"),StringHash("CreateByTagName"),pGameDLL+0x0E47E0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleConsole"),StringHash("CreateByTagName"),pGameDLL+0x112E30)
endif
endif
endfunction
function AllocCSimpleFont takes nothing returns integer
return StormAllocateMemory(0xC4,"MemHackCSimpleFontString",4,0)
endfunction
function CreateCSimpleFontEx takes integer pParent,integer arg1,integer arg2 returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("Create"))
local integer baseobj=0
if addr!=0 then
set baseobj=AllocCSimpleFont()
if baseobj!=0 then
return this_call_4(addr,baseobj,pParent,arg1,arg2)
endif
endif
return 0
endfunction
function CreateCSimpleFont takes integer pParent returns integer
return CreateCSimpleFontEx(pParent,2,1)
endfunction
function GetCSimpleFontByName takes string name,integer id returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetByName"))
if addr!=0 and name!="" then
return fast_call_2(addr,GetStringAddress(name),id)
endif
return 0
endfunction
function GetCSimpleFontTextByName takes string name,integer id returns string
local integer pFrame=GetCSimpleFontByName(name,id)
if pFrame>0 then
return ToJString(ReadRealMemory(pFrame+0x9C))
endif
return""
endfunction
function SetCSimpleFontStringScale takes integer pFrame,real scale returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetScale"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleFontString" then
return this_call_2(addr,pFrame,SetRealIntoMemory(scale))
endif
endif
return 0
endfunction
function SetCSimpleFontStringFont takes integer pFrame,string filename,real height,integer flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetFont"))
local string f_name=""
if addr!=0 and pFrame!=0 and filename!="" then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleFontString" then
return this_call_4(addr,pFrame,GetStringAddress(filename),SetRealIntoMemory(height),flag)
endif
endif
return 0
endfunction
function GetCSimpleFontStringHeight takes integer pFrame returns real
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetHeight"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleFontString" then
return GetRealFromMemory(this_call_1(addr,pFrame))
endif
endif
return 0.
endfunction
function SetCSimpleFontText takes integer pFrame,string text returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetText"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleFontString" then
return B2I(this_call_2(addr,pFrame,GetStringAddress(text))>0)
endif
endif
return 0
endfunction
function Init_MemHackCSimpleFontAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("Create"),pGameDLL+0x60DD20)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetByName"),pGameDLL+0x61CF50)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetText"),pGameDLL+0x60D1B0)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetFont"),pGameDLL+0x60E1C0)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetHeight"),pGameDLL+0x60D710)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetScale"),pGameDLL+0x60E470)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("Create"),pGameDLL+0x60D580)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetByName"),pGameDLL+0x61C7B0)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetText"),pGameDLL+0x60CA10)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetFont"),pGameDLL+0x60DA20)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetHeight"),pGameDLL+0x60CF70)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetScale"),pGameDLL+0x60DCD0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("Create"),pGameDLL+0x0BFB10)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetByName"),pGameDLL+0x0C8EF0)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetText"),pGameDLL+0x0C1020)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetFont"),pGameDLL+0x0C0B40)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetHeight"),pGameDLL+0x0C0490)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetScale"),pGameDLL+0x0C0D90)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("Create"),pGameDLL+0x113870)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetByName"),pGameDLL+0x11CC50)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetText"),pGameDLL+0x114D80)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetFont"),pGameDLL+0x1148A0)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetHeight"),pGameDLL+0x1141F0)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetScale"),pGameDLL+0x114AF0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("Create"),pGameDLL+0x141F20)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetByName"),pGameDLL+0x14B300)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetText"),pGameDLL+0x143430)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetFont"),pGameDLL+0x142F50)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("GetHeight"),pGameDLL+0x1428A0)
call SaveInteger(MemHackTable,StringHash("CSimpleFontString"),StringHash("SetScale"),pGameDLL+0x1431A0)
endif
endif
endfunction
function AllocCSimpleFrame takes nothing returns integer
return StormAllocateMemory(0x124,"MemHackCSimpleFrame",4,0)
endfunction
function CreateCSimpleFrame takes integer pParent returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Create"))
local integer baseobj=0
if addr!=0 then
set baseobj=AllocCSimpleFrame()
if baseobj!=0 then
return this_call_2(addr,baseobj,pParent)
endif
endif
return 0
endfunction
function GetCSimpleFrameByName takes string name,integer id returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("GetByName"))
if addr!=0 and name!="" then
return fast_call_2(addr,GetStringAddress(name),id)
endif
return 0
endfunction
function HideCSimpleFrame takes integer pCSimpleFrame returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Hide"))
if addr!=0 and pCSimpleFrame!=0 then
call this_call_1(addr,pCSimpleFrame)
return true
endif
return false
endfunction
function ShowCSimpleFrame takes integer pCSimpleFrame returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Show"))
if addr!=0 and pCSimpleFrame!=0 then
call this_call_1(addr,pCSimpleFrame)
return true
endif
return false
endfunction
function SetCSimpleFrameVisibility takes integer pCSimpleFrame,boolean flag returns boolean
if flag then
return ShowCSimpleFrame(pCSimpleFrame)
else
return HideCSimpleFrame(pCSimpleFrame)
endif
return false
endfunction
function IsCSimpleFrameVisible takes integer pCSimpleFrame returns boolean
if pCSimpleFrame!=0 then
return ReadRealMemory(pCSimpleFrame+0x94)==1
endif
return false
endfunction
function SetCSimpleFrameScale takes integer pCSimpleFrame,real scale returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetScale"))
local string f_name=""
if addr!=0 and pCSimpleFrame!=0 then
set f_name=GetFrameTypeName(pCSimpleFrame)
if SubString(f_name,0,7)=="CSimple" then
return this_call_2(addr,pCSimpleFrame,SetRealIntoMemory(scale))
endif
endif
return 0
endfunction
function SetCSimpleFramePriority takes integer pCSimpleFrame,integer priority returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetPriority"))
local integer fid=0
if addr!=0 and pCSimpleFrame!=0 and priority>=0 and priority<=8 then
set fid=GetFrameType(pCSimpleFrame)
if fid!=0 then
if IsFrameLayout(pCSimpleFrame)then
return this_call_2(addr,pCSimpleFrame,priority)
else
call WriteRealMemory(pCSimpleFrame+0xA8,priority)
return 1
endif
endif
endif
return 0
endfunction
function SetCSimpleFrameParent takes integer pCSimpleFrame,integer pParentCSimpleFrame returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetParent"))
if addr!=0 and pCSimpleFrame!=0 and pParentCSimpleFrame!=0 then
if IsFrameLayout(pCSimpleFrame)and IsFrameLayout(pParentCSimpleFrame)then
return this_call_2(addr,pCSimpleFrame,pParentCSimpleFrame)
endif
endif
return 0
endfunction
function Init_MemHackCSimpleFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Create"),pGameDLL+0x60A410)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("GetByName"),pGameDLL+0x61CF10)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Hide"),pGameDLL+0x60A270)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Show"),pGameDLL+0x60A2F0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetScale"),pGameDLL+0x60A1C0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetPriority"),pGameDLL+0x2F64F0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetParent"),pGameDLL+0x60A120)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Create"),pGameDLL+0x609C70)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("GetByName"),pGameDLL+0x61C770)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Hide"),pGameDLL+0x609AD0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Show"),pGameDLL+0x609B50)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetScale"),pGameDLL+0x609A20)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetPriority"),pGameDLL+0x2F59B0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetParent"),pGameDLL+0x609980)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Create"),pGameDLL+0x0B8C00)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("GetByName"),pGameDLL+0x0C8FD0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Hide"),pGameDLL+0x0B96B0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Show"),pGameDLL+0x0BA100)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetScale"),pGameDLL+0x0B9FA0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetPriority"),pGameDLL+0x356430)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetParent"),pGameDLL+0x0BA040)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Create"),pGameDLL+0x10C960)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("GetByName"),pGameDLL+0x11CD30)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Hide"),pGameDLL+0x10D410)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Show"),pGameDLL+0x10DE60)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetScale"),pGameDLL+0x10DD00)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetPriority"),pGameDLL+0x373BD0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetParent"),pGameDLL+0x10DDA0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Create"),pGameDLL+0x13AE90)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("GetByName"),pGameDLL+0x14B3E0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Hide"),pGameDLL+0x13B940)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("Show"),pGameDLL+0x13C390)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetScale"),pGameDLL+0x13C230)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetPriority"),pGameDLL+0x3A7CA0)
call SaveInteger(MemHackTable,StringHash("CSimpleFrame"),StringHash("SetParent"),pGameDLL+0x13C2D0)
endif
endif
endfunction
function SetCSimpleGlueFrameScale takes integer pGlueFrame,real scale returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleGlueFrame"),StringHash("SetScale"))
local string f_name=""
if addr!=0 and pGlueFrame!=0 then
set f_name=GetFrameTypeName(pGlueFrame)
if f_name=="CSimpleGlueFrame" then
return this_call_2(addr,pGlueFrame,SetRealIntoMemory(scale))
endif
endif
return 0
endfunction
function Init_MemHackCSimpleGlueAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleGlueFrame"),StringHash("SetScale"),pGameDLL+0x617270)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleGlueFrame"),StringHash("SetScale"),pGameDLL+0x616AD0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleGlueFrame"),StringHash("SetScale"),pGameDLL+0x0C19C0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleGlueFrame"),StringHash("SetScale"),pGameDLL+0x115720)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleGlueFrame"),StringHash("SetScale"),pGameDLL+0x143DD0)
endif
endif
endfunction
function SetCSimpleMessageFrameFont takes integer pFrame,string filename,real height,integer flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleMessageFrame"),StringHash("SetFont"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleMessageFrame" then
return this_call_4(addr,pFrame,GetStringAddress(filename),SetRealIntoMemory(height),flag)
endif
endif
return 0
endfunction
function Init_MemHackCSimpleMessageFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleMessageFrame"),StringHash("SetFont"),pGameDLL+0x6042B0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleMessageFrame"),StringHash("SetFont"),pGameDLL+0x603B10)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleMessageFrame"),StringHash("SetFont"),pGameDLL+0x0C2E80)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleMessageFrame"),StringHash("SetFont"),pGameDLL+0x116BE0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleMessageFrame"),StringHash("SetFont"),pGameDLL+0x145290)
endif
endif
endfunction
function ShowCSimpleRegion takes integer pSimpleRegion returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Show"))
if addr!=0 and pSimpleRegion!=0 then
call this_call_1(addr,pSimpleRegion)
endif
endfunction
function HideCSimpleRegion takes integer pSimpleRegion returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Hide"))
if addr!=0 and pSimpleRegion!=0 then
call this_call_1(addr,pSimpleRegion)
endif
endfunction
function SetCSimpleRegionVisibility takes integer pSimpleRegion,boolean flag returns nothing
if flag then
call ShowCSimpleRegion(pSimpleRegion)
else
call HideCSimpleRegion(pSimpleRegion)
endif
endfunction
function SetCSimpleRegionVertexColour takes integer pFrame,integer colour returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("SetVertexColour"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
local string f_name=""
if addr!=0 and arg!=0 then
set f_name=GetFrameTypeName(pFrame)
if SubString(f_name,0,7)=="CSimple" then
if f_name=="CSimpleStatusBar" then
set pFrame=ReadRealMemory(pFrame+0x134)
endif
if pFrame!=0 then
call WriteRealMemory(arg+0x0,colour)
return this_call_2(addr,pFrame,arg+0x0)
endif
endif
endif
return 0
endfunction
function SetCSimpleRegionVertexColourEx takes integer pFrame,integer alpha,integer red,integer blue,integer green returns integer
return SetCSimpleRegionVertexColour(pFrame,GetARGBColour(alpha,red,blue,green))
endfunction
function Init_MemHackCSimpleRegionAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Show"),pGameDLL+0x60EF60)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Hide"),pGameDLL+0x60EF80)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("SetVertexColour"),pGameDLL+0x60EEE0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Show"),pGameDLL+0x60E7C0)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Hide"),pGameDLL+0x60E7E0)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("SetVertexColour"),pGameDLL+0x60E740)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Show"),pGameDLL+0x0BFA70)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Hide"),pGameDLL+0x0BF8D0)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("SetVertexColour"),pGameDLL+0x0BFA30)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Show"),pGameDLL+0x1137D0)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Hide"),pGameDLL+0x113630)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("SetVertexColour"),pGameDLL+0x113790)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Show"),pGameDLL+0x141E80)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("Hide"),pGameDLL+0x141CE0)
call SaveInteger(MemHackTable,StringHash("CSimpleRegion"),StringHash("SetVertexColour"),pGameDLL+0x141E40)
endif
endif
endfunction
function SetCSimpleStatusBarTexture takes integer pFrame,string texturepath,boolean flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetTexture"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleStatusBar" then
return this_call_3(addr,pFrame,GetStringAddress(texturepath),B2I(flag))
endif
endif
return 0
endfunction
function SetCSimpleStatusBarValue takes integer pFrame,real value returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetValue"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleStatusBar" then
return this_call_2(addr,pFrame,SetRealIntoMemory(value))
endif
endif
return 0
endfunction
function SetCSimpleStatusBarMinMaxValue takes integer pFrame,real minval,real maxval returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetMinMaxValue"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleStatusBar" then
return this_call_3(addr,pFrame,SetRealIntoMemory(minval),SetRealIntoMemory(maxval))
endif
endif
return 0
endfunction
function Init_MemHackCSimpleStatusBarAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetTexture"),pGameDLL+0x60EDB0)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetValue"),pGameDLL+0x60EBD0)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x60EB50)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetTexture"),pGameDLL+0x60E610)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetValue"),pGameDLL+0x60E430)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x60E3B0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetTexture"),pGameDLL+0x0BC130)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetValue"),pGameDLL+0x0BC2E0)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x0BC270)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetTexture"),pGameDLL+0x10FE90)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetValue"),pGameDLL+0x110040)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x10FFD0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetTexture"),pGameDLL+0x13E3C0)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetValue"),pGameDLL+0x13E570)
call SaveInteger(MemHackTable,StringHash("CSimpleStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x13E500)
endif
endif
endfunction
function AllocCSimpleTexture takes nothing returns integer
return StormAllocateMemory(0xE8,"MemHackCSimpleTexture",4,0)
endfunction
function CreateCSimpleTexture takes integer pParent returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Create"))
local integer baseobj=0
if addr!=0 then
set baseobj=AllocCSimpleTexture()
if baseobj>0 then
return this_call_4(addr,baseobj,pParent,2,1)
endif
endif
return 0
endfunction
function FillCSimpleTexture takes integer pFrame,integer colour returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Fill"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if addr!=0 and arg!=0 and pFrame!=0 then
call WriteRealMemory(arg+0x0,colour)
return B2I(this_call_2(addr,pFrame,arg+0x0)==0)
endif
return 0
endfunction
function GetCSimpleTextureByName takes string name,integer id returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("GetByName"))
if addr!=0 and name!="" then
return fast_call_2(addr,GetStringAddress(name),id)
endif
return 0
endfunction
function SetCSimpleTextureTexture takes integer pFrame,string texturepath,boolean flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("SetTexture"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSimpleTexture" then
return this_call_3(addr,pFrame,GetStringAddress(texturepath),B2I(flag))
endif
endif
return 0
endfunction
function Init_MemHackCSimpleTextureAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Create"),pGameDLL+0x60E0A0)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Fill"),pGameDLL+0x60DB50)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("GetByName"),pGameDLL+0x61CF30)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("SetTexture"),pGameDLL+0x60E830)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Create"),pGameDLL+0x60D900)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Fill"),pGameDLL+0x60D3B0)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("GetByName"),pGameDLL+0x61C790)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("SetTexture"),pGameDLL+0x60E090)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Create"),pGameDLL+0x0C90B0)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Fill"),pGameDLL+0x324AD0)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("GetByName"),pGameDLL+0x0C1170)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("SetTexture"),pGameDLL+0x0C11E0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Create"),pGameDLL+0x113930)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Fill"),pGameDLL+0x342220)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("GetByName"),pGameDLL+0x114ED0)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("SetTexture"),pGameDLL+0x114F40)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Create"),pGameDLL+0x141FE0)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("Fill"),pGameDLL+0x3761E0)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("GetByName"),pGameDLL+0x143580)
call SaveInteger(MemHackTable,StringHash("CSimpleTexture"),StringHash("SetTexture"),pGameDLL+0x1435F0)
endif
endif
endfunction
function SetCSliderCurrentValue takes integer pFrame,real value returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSlider"),StringHash("SetCurrentValue"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSlider" then
return this_call_3(addr,pFrame,SetRealIntoMemory(value),1)
endif
endif
return 0
endfunction
function Init_MemHackCSliderAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSlider"),StringHash("SetCurrentValue"),pGameDLL+0x61F610)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSlider"),StringHash("SetCurrentValue"),pGameDLL+0x61EE70)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSlider"),StringHash("SetCurrentValue"),pGameDLL+0x0AB3B0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSlider"),StringHash("SetCurrentValue"),pGameDLL+0x0FF110)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSlider"),StringHash("SetCurrentValue"),pGameDLL+0x12D780)
endif
endif
endfunction
function SetCSpriteFrameArt takes integer pFrame,string model,integer modeltype,boolean flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetArt"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSpriteFrame" then
return this_call_4(addr,pFrame,GetStringAddress(model),modeltype,B2I(flag))
endif
endif
return 0
endfunction
function GetCSpriteFrameHeight takes integer pFrame returns real
local integer addr=LoadInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("GetHeight"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSpriteFrame" then
return GetRealFromMemory(this_call_1(addr,pFrame))
endif
endif
return 0.
endfunction
function SetCSpriteFrameScale takes integer pFrame,real scale returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetScale"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CSpriteFrame" then
return this_call_2(addr,pFrame,SetRealIntoMemory(scale))
endif
endif
return 0
endfunction
function Init_MemHackCSpriteFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetArt"),pGameDLL+0x60FB00)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("GetHeight"),pGameDLL+0x60F2A0)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetScale"),pGameDLL+0x60F600)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetArt"),pGameDLL+0x60F360)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("GetHeight"),pGameDLL+0x60EB00)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetScale"),pGameDLL+0x60EE60)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetArt"),pGameDLL+0x0A38C0)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("GetHeight"),pGameDLL+0x0A3260)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetScale"),pGameDLL+0x0A39A0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetArt"),pGameDLL+0x0F7620)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("GetHeight"),pGameDLL+0x0F6FC0)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetScale"),pGameDLL+0x0F7700)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetArt"),pGameDLL+0x125C90)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("GetHeight"),pGameDLL+0x125630)
call SaveInteger(MemHackTable,StringHash("CSpriteFrame"),StringHash("SetScale"),pGameDLL+0x125D70)
endif
endif
endfunction
function SetCStatusBarArt takes integer pFrame,string model,integer modeltype returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetArt"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CStatusBar" then
return this_call_3(addr,pFrame,GetStringAddress(model),modeltype)
endif
endif
return 0
endfunction
function SetCStatusBarValue takes integer pFrame,real value returns integer
local real minval=0.
local real maxval=0.
local real curval=0.
local real newval=0.
local string f_name=""
if pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CStatusBar" then
set minval=GetRealFromMemory(ReadRealMemory(pFrame+0x1B4))
set maxval=GetRealFromMemory(ReadRealMemory(pFrame+0x1B8))
set curval=GetRealFromMemory(ReadRealMemory(pFrame+0x1BC))
if value<=minval then
set value=minval
endif
call WriteRealMemory(pFrame+0x1BC,SetRealIntoMemory(value))
return 1
endif
endif
return 0
endfunction
function SetCStatusBarMinMaxValue takes integer pFrame,real minval,real maxval returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetMinMaxValue"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CStatusBar" then
return this_call_3(addr,pFrame,SetRealIntoMemory(minval),SetRealIntoMemory(maxval))
endif
endif
return 0
endfunction
function Init_MemHackCStatusBarAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetArt"),pGameDLL+0x628140)
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x627F60)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetArt"),pGameDLL+0x6279A0)
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x6277C0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetArt"),pGameDLL+0x0AA760)
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x0AA7F0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetArt"),pGameDLL+0x0FE4C0)
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x0FE550)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetArt"),pGameDLL+0x12CB30)
call SaveInteger(MemHackTable,StringHash("CStatusBar"),StringHash("SetMinMaxValue"),pGameDLL+0x12CBC0)
endif
endif
endfunction
function SetCTextAreaText takes integer pFrame,string text returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CTextArea"),StringHash("SetText"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CTextArea" then
return B2I(this_call_2(addr,pFrame,GetStringAddress(text))>0)
endif
endif
return 0
endfunction
function Init_MemHackCTextAreaAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CTextArea"),StringHash("SetText"),pGameDLL+0x61E830)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CTextArea"),StringHash("SetText"),pGameDLL+0x61E090)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CTextArea"),StringHash("SetText"),pGameDLL+0x0B6500)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CTextArea"),StringHash("SetText"),pGameDLL+0x10A260)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CTextArea"),StringHash("SetText"),pGameDLL+0x138790)
endif
endif
endfunction
function SetCTextFrameTextColour takes integer pFrame,integer colour returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetTextColour"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CEditBox" or f_name=="CTextFrame" then
return this_call_2(addr,pFrame,colour)
endif
endif
return 0
endfunction
function SetCTextFrameTextColourEx takes integer pFrame,integer alpha,integer red,integer blue,integer green returns integer
return SetCTextFrameTextColour(pFrame,CreateInteger1(alpha,red,green,blue))
endfunction
function GetCTextFrameHeight takes integer pFrame returns real
local integer addr=LoadInteger(MemHackTable,StringHash("CTextFrame"),StringHash("GetHeight"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CTextFrame" then
return GetRealFromMemory(this_call_1(addr,pFrame))
endif
endif
return 0.
endfunction
function SetCTextFrameText takes integer pFrame,string text returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetText"))
local string f_name=""
if addr!=0 and pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name=="CTextButtonFrame" or f_name=="CTextFrame" or f_name=="CGlueTextButtonWar3" or f_name=="CTimerTextFrame" then
if f_name=="CTextButtonFrame" or f_name=="CGlueTextButtonWar3" then
set pFrame=ReadRealMemory(pFrame+0x1E4)
endif
return B2I(this_call_2(addr,pFrame,GetStringAddress(text))>0)
endif
endif
return 0
endfunction
function Init_MemHackCTextFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("GetHeight"),pGameDLL+0x612040)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetText"),pGameDLL+0x6124E0)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetTextColour"),pGameDLL+0x611D30)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("GetHeight"),pGameDLL+0x6118A0)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetText"),pGameDLL+0x611D40)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetTextColour"),pGameDLL+0x611590)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("GetHeight"),pGameDLL+0x0A9770)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetText"),pGameDLL+0x0AA130)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetTextColour"),pGameDLL+0x0AA210)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("GetHeight"),pGameDLL+0x0FD4D0)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetText"),pGameDLL+0x0FDE90)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetTextColour"),pGameDLL+0x0FDF70)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("GetHeight"),pGameDLL+0x12BB40)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetText"),pGameDLL+0x12C500)
call SaveInteger(MemHackTable,StringHash("CTextFrame"),StringHash("SetTextColour"),pGameDLL+0x12C5E0)
endif
endif
endfunction
function GetTerrainZ takes real axisX,real axisY returns real
local integer addr=LoadInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAxisZ"))
if addr!=0 then
return GetRealFromMemory(fast_call_5(addr,-1,0,SetRealIntoMemory(axisX),SetRealIntoMemory(axisY),1))
endif
return 0.
endfunction
function SetCWidgetCoordinates takes integer pWidget,real x,real y returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CWidget"),StringHash("SetCoordinates"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if addr!=0 and arg!=0 and pWidget!=0 then
call WriteRealFloat(arg+0x0,x)
call WriteRealFloat(arg+0x4,y)
return this_call_12(addr,pWidget,arg+0x0,arg+0x4,1,1,-1,0,0,0,0,-1,0)
endif
return 0
endfunction
function GetCWidgetAgent takes integer pWidget returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAgent"))
if addr!=0 and pWidget!=0 then
return this_call_1(addr,pWidget+0x8C)
endif
return 0
endfunction
function GetCWidgetPresence takes integer pWidget returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CWidget"),StringHash("GetPresence"))
if addr!=0 and pWidget!=0 then
set pWidget=GetCWidgetAgent(pWidget)
if pWidget!=0 then
return fast_call_2(addr,ReadRealMemory(pWidget+0xC),ReadRealMemory(pWidget+0x10))
endif
endif
return 0
endfunction
function UpdateCWidget takes integer pWidget returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CWidget"),StringHash("UpdateAgent"))
local integer pAgent=0
local integer pPres=0
if addr!=0 and pWidget!=0 then
set pAgent=GetCWidgetAgent(pWidget)
if pAgent!=0 then
set pPres=GetCWidgetPresence(pWidget)
if pPres!=0 then
if ReadRealMemory(pPres+0x0C)=='+agl' and ReadRealMemory(pPres+0x20)==0 then
call this_call_2(addr,pAgent,pWidget)
endif
endif
endif
endif
endfunction
function SetCWidgetPosition takes integer pWidget,real x,real y returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CWidget"),StringHash("SetPosition"))
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if addr!=0 and arg!=0 and pWidget!=0 then
if BitwiseAnd(ReadRealMemory(pWidget+0x8C),ReadRealMemory(pWidget+0x90))!=-1 then
call UpdateCWidget(pWidget)
endif
call WriteRealFloat(arg+0x0,x)
call WriteRealFloat(arg+0x4,y)
return this_call_4(addr,pWidget,arg+0x0,arg+0x4,-1)
endif
return 0
endfunction
function GetWidgetTerrainZ takes widget Widget returns real
if Widget!=null then
return GetTerrainZ(GetWidgetX(Widget),GetWidgetY(Widget))
endif
return 0.
endfunction
function SetWidgetCoordinates takes widget Widget,real x,real y returns integer
return SetCWidgetCoordinates(ConvertHandle(Widget),x,y)
endfunction
function GetWidgetAgent takes widget Widget returns integer
return GetCWidgetAgent(ConvertHandle(Widget))
endfunction
function GetWidgetPresence takes widget Widget returns integer
return GetCWidgetPresence(ConvertHandle(Widget))
endfunction
function UpdateWidget takes widget Widget returns nothing
call UpdateCWidget(ConvertHandle(Widget))
endfunction
function SetWidgetPosition takes widget Widget,real x,real y returns integer
return SetCWidgetPosition(ConvertHandle(Widget),x,y)
endfunction
function SetDestructablePosition takes destructable dest,real x,real y returns integer
return SetWidgetPosition(dest,x,y)
endfunction
function SetWidgetFacing takes widget Widget,real facing returns nothing
local integer pWidget=ConvertHandle(Widget)
if pWidget!=0 then
call SetObjectFacing(pWidget,facing)
endif
endfunction
function Init_MemHackCWidgetNormalAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAxisZ"),pGameDLL+0x24FEF0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAgent"),pGameDLL+0x4791C0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetPresence"),pGameDLL+0x040770)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("UpdateAgent"),pGameDLL+0x283960)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetPosition"),pGameDLL+0x2B7600)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetCoordinates"),pGameDLL+0x2E6EC0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAxisZ"),pGameDLL+0x24F3E0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAgent"),pGameDLL+0x4786B0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetPresence"),pGameDLL+0x03FA30)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("UpdateAgent"),pGameDLL+0x282E40)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetPosition"),pGameDLL+0x2B6AE0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetCoordinates"),pGameDLL+0x2AC220)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAxisZ"),pGameDLL+0x6320B0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAgent"),pGameDLL+0x044150)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetPresence"),pGameDLL+0x037350)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("UpdateAgent"),pGameDLL+0x6775B0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetPosition"),pGameDLL+0x63CC10)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetCoordinates"),pGameDLL+0x635DE0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAxisZ"),pGameDLL+0x64F7E0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAgent"),pGameDLL+0x061320)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetPresence"),pGameDLL+0x054530)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("UpdateAgent"),pGameDLL+0x694CE0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetPosition"),pGameDLL+0x65A340)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetCoordinates"),pGameDLL+0x9D7AC0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAxisZ"),pGameDLL+0x683900)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetAgent"),pGameDLL+0x08AE90)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("GetPresence"),pGameDLL+0x07E090)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("UpdateAgent"),pGameDLL+0x6C8EA0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetPosition"),pGameDLL+0x2B6AE0)
call SaveInteger(MemHackTable,StringHash("CWidget"),StringHash("SetCoordinates"),pGameDLL+0x98CA60)
endif
endif
endfunction
function GetWidgetTypeId takes widget w returns integer
local integer pWidget=0
if w!=null then
set pWidget=ConvertHandle(w)
if pWidget!=0 then
return ReadRealMemory(pWidget+0x30)
endif
endif
return 0
endfunction
function GetWidgetBaseDataById takes integer pDataNode,integer wid returns integer
return GetAgileDataNodeById(pDataNode,wid)
endfunction
function GetWidgetBaseUIDataById takes integer id returns integer
return GetWidgetUIDefById(id)
endfunction
function GetWidgetBaseData takes integer pDataNode,widget w returns integer
return GetAgileDataNodeById(pDataNode,GetWidgetTypeId(w))
endfunction
function GetWidgetBaseDataByIdCachingEx takes integer pDataNode,integer index,integer id,integer mode returns integer
local integer pData=0
if id>0 then
if HaveSavedInteger(htObjectDataPointers,index,id)then
return LoadInteger(htObjectDataPointers,index,id)
endif
if mode==0 then
set pData=GetWidgetBaseDataById(pDataNode,id)
elseif mode==1 then
set pData=GetWidgetBaseUIDataById(id)
endif
if pData>0 then
call SaveInteger(htObjectDataPointers,index,id,pData)
endif
return pData
endif
return 0
endfunction
function GetWidgetBaseDataByIdCaching takes integer pDataNode,integer id returns integer
return GetWidgetBaseDataByIdCachingEx(pDataNode,2,id,0)
endfunction
function GetWidgetBaseDataCaching takes integer pDataNode,widget w returns integer
return GetWidgetBaseDataByIdCaching(pDataNode,GetWidgetTypeId(w))
endfunction
function GetWidgetBaseUIData takes widget w returns integer
return GetWidgetBaseUIDataById(GetWidgetTypeId(w))
endfunction
function GetWidgetBaseUIDataByIdCaching takes integer id returns integer
return GetWidgetBaseDataByIdCachingEx(0,3,id,1)
endfunction
function GetWidgetBaseUIDataCaching takes widget w returns integer
return GetWidgetBaseUIDataByIdCaching(GetWidgetTypeId(w))
endfunction
function GetWidgetBaseUIIntegerParamById takes integer id,integer pointerlevel,integer offset returns integer
local integer pData=0
if id>0 then
set pData=GetWidgetBaseUIDataByIdCaching(id)
if pData>0 then
set pData=ReadRealMemory(pData+offset)
if pData>0 then
if pointerlevel==0 then
return pData
elseif pointerlevel==1 then
return ReadRealMemory(pData)
endif
endif
endif
endif
return 0
endfunction
function SetWidgetBaseUIIntegerParamById takes integer id,integer pointerlevel,integer offset,integer val returns nothing
local integer pData=0
if id>0 then
set pData=GetWidgetBaseUIDataByIdCaching(id)
if pData>0 then
set pData=pData+offset
if offset==0x274 then
call WriteRealMemory(pData,pData-0x4)
else
if pointerlevel==0 then
call WriteRealMemory(pData,val)
elseif pointerlevel==1 then
if ReadRealMemory(pData)==0 then
call WriteRealMemory(pData,GetStringAddress(I2S(val)))
endif
call WriteRealMemory(ReadRealMemory(pData),val)
endif
endif
endif
endif
endfunction
function GetWidgetBaseUIStringParamById takes integer id,integer pointerlevel,integer offset returns string
local integer pData=0
if id>0 then
set pData=GetWidgetBaseUIDataByIdCaching(id)
if pData>0 then
set pData=ReadRealMemory(pData+offset)
if pData>0 then
if pointerlevel==1 then
set pData=ReadRealMemory(pData)
endif
if pData>0 then
return ToJString(pData)
endif
endif
endif
endif
return null
endfunction
function SetWidgetBaseUIStringParamById takes integer id,integer pointerlevel,integer offset,string val returns nothing
local integer pData=0
if id>0 then
set pData=GetWidgetBaseUIDataByIdCaching(id)
if pData>0 then
set pData=pData+offset
if pointerlevel==0 then
call WriteRealMemory(pData,GetStringAddress(val))
elseif pointerlevel==1 then
if ReadRealMemory(pData)==0 then
call WriteRealMemory(pData,GetStringAddress(val))
endif
call WriteRealMemory(ReadRealMemory(pData),GetStringAddress(val))
endif
endif
endif
endfunction
function Init_MemHackCWidgetBaseAPI takes nothing returns nothing
if PatchVersion!="" then
endif
endfunction
function CastAbilityBasic takes integer pAbil returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CAbility"),StringHash("Cast"))
if addr!=0 and pAbil!=0 then
return this_call_1(addr,pAbil)
endif
return 0
endfunction
function CastAbilityPosition takes integer aid,unit source,real targX,real targY returns nothing
local integer pData=ConvertHandle(source)
if pData>0 then
set pData=GetUnitAbility(source,aid)
if pData>0 then
call WriteRealMemory(pData+0xF8,SetRealIntoMemory(targX))
call WriteRealMemory(pData+0x100,SetRealIntoMemory(targY))
call WriteRealMemory(pData+0x20,0x9800)
set pData=CastAbilityBasic(pData)
endif
endif
endfunction
function CastAbilityTarget takes integer aid,unit source,widget target returns nothing
local integer pData=0
local integer unitHashA=0
local integer unitHashB=0
local integer flags=0
if GetUnitAbilityLevel(source,aid)>0 and target!=null then
set pData=ConvertHandle(target)
if pData>0 then
set unitHashA=ReadRealMemory(pData+0x0C)
set unitHashB=ReadRealMemory(pData+0x10)
if unitHashA>0 and unitHashB>0 then
set pData=ConvertHandle(source)
if pData>0 then
set pData=GetUnitAbility(source,aid)
if pData>0 then
call WriteRealMemory(pData+0xE4,unitHashA)
call WriteRealMemory(pData+0xE8,unitHashB)
set flags=ReadRealMemory(pData+0x20)
if not IsFlagBitSet(flags,0x10000)then
call WriteRealMemory(pData+0x20,flags+0x10000)
set flags=flags+0x10000
if not IsFlagBitSet(flags,0x1)then
call WriteRealMemory(pData+0x20,flags+0x1)
endif
endif
set pData=CastAbilityBasic(pData)
endif
endif
endif
endif
endif
endfunction
function CastAbilityTargetGround takes integer aid,unit source,integer lvl,real targX,real targY,boolean remove returns nothing
call UnitAddAbility(source,aid)
if lvl>1 then
call SetUnitAbilityLevel(source,aid,lvl)
endif
call CastAbilityPosition(aid,source,targX,targY)
if remove then
call UnitRemoveAbility(source,aid)
endif
endfunction
function CastAbilityTargetWidget takes integer aid,unit source,widget target,integer lvl,boolean remove returns nothing
call UnitAddAbility(source,aid)
if lvl>1 then
call SetUnitAbilityLevel(source,aid,lvl)
endif
call CastAbilityTarget(aid,source,target)
if remove then
call UnitRemoveAbility(source,aid)
endif
endfunction
function CastAbilityTargetSelf takes integer aid,unit source,integer lvl returns nothing
call CastAbilityTargetWidget(aid,source,source,lvl,true)
endfunction
function Init_MemHackCastAbility takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Cast"),pGameDLL+0x05CFD0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Cast"),pGameDLL+0x05C3A0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Cast"),pGameDLL+0x3ECB70)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Cast"),pGameDLL+0x40A2B0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CAbility"),StringHash("Cast"),pGameDLL+0x43E390)
endif
endif
endfunction
function IsOPLimitRemoved takes nothing returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr1"))
if addr!=0 then
return ReadRealMemory(addr)==0x6A570FFF
endif
return false
endfunction
function EnableOPLimitEx takes boolean flag,integer id returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr"+I2S(id)))
local integer oldvalue=LoadInteger(MemHackTable,StringHash("OPLimit"),StringHash("Value"+I2S(id)))
local integer value=0
local integer oldprotection1=0
if addr!=0 then
if oldvalue==0 then
set oldvalue=ReadRealMemory(addr)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Value"+I2S(id)),oldvalue)
endif
if oldvalue!=0 then
if flag then
set value=oldvalue
else
set value=0x6A570FFF
endif
set oldprotection1=ChangeOffsetProtection(addr,0x4,0x40)
call WriteRealMemory(addr,value)
call ChangeOffsetProtection(addr,0x4,oldprotection1)
endif
endif
endfunction
function EnableOPLimit takes boolean flag returns nothing
local integer i=1
loop
exitwhen i>9
call EnableOPLimitEx(flag,i)
set i=i+1
endloop
endfunction
function Init_MemHackConstantsAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr1"),pGameDLL+0x3A8ECC)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr2"),pGameDLL+0x2DED64)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr3"),pGameDLL+0x2E1718)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr4"),pGameDLL+0x2E1728)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr5"),pGameDLL+0x3B5F02)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr6"),pGameDLL+0x3B5FC1)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr7"),pGameDLL+0x3B5FF3)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr8"),pGameDLL+0x460489)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr9"),pGameDLL+0x460818)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr1"),pGameDLL+0x3A838C)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr2"),pGameDLL+0x2DE244)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr3"),pGameDLL+0x2E0BF8)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr4"),pGameDLL+0x2E0C08)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr5"),pGameDLL+0x3B53C2)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr6"),pGameDLL+0x3B5481)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr7"),pGameDLL+0x3B54B3)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr8"),pGameDLL+0x45F979)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr9"),pGameDLL+0x45FD08)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr1"),pGameDLL+0x1BFB4B)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr2"),pGameDLL+0x1E9A01)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr3"),pGameDLL+0x1EF713)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr4"),pGameDLL+0x1F224D)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr5"),pGameDLL+0x7F1975)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr6"),pGameDLL+0x7F2A1C)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr7"),pGameDLL+0x8909F7)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr8"),pGameDLL+0x890A07)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr9"),pGameDLL+0x8920A6)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr1"),pGameDLL+0x1DD83B)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr2"),pGameDLL+0x207451)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr3"),pGameDLL+0x20D153)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr4"),pGameDLL+0x20FECD)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr5"),pGameDLL+0x91B3B5)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr6"),pGameDLL+0x91C3EC)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr7"),pGameDLL+0x9BBAF7)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr8"),pGameDLL+0x9BBB07)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr9"),pGameDLL+0x9BD1A6)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr1"),pGameDLL+0x2100BB)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr2"),pGameDLL+0x239C21)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr3"),pGameDLL+0x23F943)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr4"),pGameDLL+0x24255C)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr5"),pGameDLL+0x8D0305)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr6"),pGameDLL+0x8D133C)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr7"),pGameDLL+0x970A87)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr8"),pGameDLL+0x970A97)
call SaveInteger(MemHackTable,StringHash("OPLimit"),StringHash("Addr9"),pGameDLL+0x972136)
endif
endif
endfunction
function GetDamageEventESPData takes nothing returns integer
local integer Length=ReadRealMemory(pDamageStack)
if(Length>0)then
return ReadRealMemory(pDamageStack+0x04+0x04*(Length-1))
endif
return 0
endfunction
function SetEventDamage takes real r returns nothing
local integer a=this_call_1(pGameDLL+0x3C1D40,0)
if(a!=0)then
set a=this_call_1(pGameDLL+0x3C1D60,0)
if(a!=0)then
call WriteRealMemory(a+0x30,SetRealIntoMemory(r))
endif
endif
endfunction
function Init_DamageEventHook takes nothing returns nothing
local integer pSlot72=pUnitVtable+(0x4*0x48)
local integer OldProtection=ChangeOffsetProtection(pSlot72,4,0x04)
local integer PreviousMethod=ReadRealMemory(pSlot72)
set pDamageStack=Malloc(0x4+0x4*1024)
set pDamageHook=AllocateExecutableMemory(1024)
call WriteRealMemory(pSlot72,pDamageHook)
call ChangeOffsetProtection(pSlot72,4,OldProtection)
call WriteRealMemory(pDamageHook+0x00,0x8DE58955)
call WriteRealMemory(pDamageHook+0x04,0x53E82464)
call WriteRealMemory(pDamageHook+0x08,0xB8F84D89)
call WriteRealMemory(pDamageHook+0x0C,pDamageStack)
call WriteRealMemory(pDamageHook+0x10,0x890C558B)
call WriteRealMemory(pDamageHook+0x14,0x558BE855)
call WriteRealMemory(pDamageHook+0x18,0x10528B0C)
call WriteRealMemory(pDamageHook+0x1C,0x8BEC5589)
call WriteRealMemory(pDamageHook+0x20,0x55891055)
call WriteRealMemory(pDamageHook+0x24,0x14558BF0)
call WriteRealMemory(pDamageHook+0x28,0x8DF45589)
call WriteRealMemory(pDamageHook+0x2C,0xC389E84D)
call WriteRealMemory(pDamageHook+0x30,0x4C89138B)
call WriteRealMemory(pDamageHook+0x34,0x03830490)
call WriteRealMemory(pDamageHook+0x38,0x4D8B9001)
call WriteRealMemory(pDamageHook+0x3C,0x1475FFF8)
call WriteRealMemory(pDamageHook+0x40,0x8B1075FF)
call WriteRealMemory(pDamageHook+0x44,0x8B500C45)
call WriteRealMemory(pDamageHook+0x48,0xB8500845)
call WriteRealMemory(pDamageHook+0x4C,PreviousMethod)
call WriteRealMemory(pDamageHook+0x50,0x4589D0FF)
call WriteRealMemory(pDamageHook+0x54,0x012B83FC)
call WriteRealMemory(pDamageHook+0x58,0x5BFC458B)
call WriteRealMemory(pDamageHook+0x5C,0x0010C2C9)
endfunction
function isDamageFromWindwalk takes nothing returns boolean
local integer EventData=GetDamageEventESPData()
local integer Data=ReadRealMemory(EventData+$00)
local integer Flags=ReadRealMemory(Data+0x0C)
return IsFlagBitSet(Flags,0x500)
endfunction
function isDamageFromHand takes nothing returns boolean
local integer EventData=GetDamageEventESPData()
local integer Data=ReadRealMemory(EventData+$00)
local integer Flags=ReadRealMemory(Data+0x0C)
local integer AttackType=ReadRealMemory(Data+$20)
return(IsFlagBitSet(Flags,0x100)or IsFlagBitSet(Flags,0x101))and AttackType!=0
endfunction
function Init_MemHackDamageEventHook takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.26a" then
set pUnitVtable=pGameDLL+0x931934
elseif PatchVersion=="1.27a" then
set pUnitVtable=pGameDLL+0xA4A704
elseif PatchVersion=="1.27b" then
set pUnitVtable=pGameDLL+0xB77EB0
elseif PatchVersion=="1.28f" then
set pUnitVtable=pGameDLL+0xB68914
endif
if pUnitVtable>0 then
call Init_DamageEventHook()
endif
endif
endfunction
function IsEffectHidden takes effect e returns boolean
return IsObjectHidden(ConvertHandle(e))
endfunction
function ShowEffect takes effect e,boolean flag returns nothing
call ShowObject(ConvertHandle(e),flag)
endfunction
function SetEffectAlpha takes effect e,integer alpha returns nothing
call SetObjectAlpha(ConvertHandle(e),alpha)
endfunction
function GetEffectColour takes effect e returns integer
return GetObjectColour(ConvertHandle(e))
endfunction
function SetEffectColour takes effect e,integer colour returns nothing
call SetObjectColour(ConvertHandle(e),colour)
endfunction
function SetEffectColourEx takes effect e,integer red,integer green,integer blue,integer alpha returns nothing
call SetObjectColourEx(ConvertHandle(e),red,green,blue,alpha)
endfunction
function SetEffectVertexColour takes effect e,integer red,integer green,integer blue,integer alpha returns nothing
local integer pObject=ConvertHandle(e)
if pObject>0 then
call SetObjectColourEx(pObject,red,green,blue,alpha)
call SetObjectAlpha(pObject,alpha)
endif
endfunction
function GetEffectColourA takes effect e returns integer
return GetObjectColourA(ConvertHandle(e))
endfunction
function SetEffectColourA takes effect e,integer alpha returns nothing
call SetObjectColourA(ConvertHandle(e),alpha)
endfunction
function GetEffectColourR takes effect e returns integer
return GetObjectColourR(ConvertHandle(e))
endfunction
function SetEffectColourR takes effect e,integer red returns nothing
call SetObjectColourR(ConvertHandle(e),red)
endfunction
function GetEffectColourG takes effect e returns integer
return GetObjectColourG(ConvertHandle(e))
endfunction
function SetEffectColourG takes effect e,integer green returns nothing
call SetObjectColourG(ConvertHandle(e),green)
endfunction
function GetEffectColourB takes effect e returns integer
return GetObjectColourB(ConvertHandle(e))
endfunction
function SetEffectColourB takes effect e,integer blue returns nothing
call SetObjectColourB(ConvertHandle(e),blue)
endfunction
function SetEffectModel takes effect e,string model,boolean flag returns nothing
call SetObjectModel(ConvertHandle(e),model,flag)
endfunction
function GetEffectX takes effect e returns real
return GetObjectX(ConvertHandle(e))
endfunction
function SetEffectX takes effect e,real x returns nothing
call SetObjectX(ConvertHandle(e),x)
endfunction
function GetEffectY takes effect e returns real
return GetObjectY(ConvertHandle(e))
endfunction
function SetEffectY takes effect e,real y returns nothing
call SetObjectY(ConvertHandle(e),y)
endfunction
function GetEffectZ takes effect e returns real
return GetObjectZ(ConvertHandle(e))
endfunction
function SetEffectZ takes effect e,real z returns nothing
call SetObjectZ(ConvertHandle(e),z)
endfunction
function SetEffectPosition takes effect e,real x,real y,real z returns nothing
call SetObjectPosition(ConvertHandle(e),x,y,z)
endfunction
function GetEffectTimeScale takes effect e returns real
return GetObjectTimeScale(ConvertHandle(e))
endfunction
function SetEffectTimeScale takes effect e,real speed returns nothing
call SetObjectTimeScale(ConvertHandle(e),speed)
endfunction
function GetEffectScale takes effect e returns real
return GetObjectScale(ConvertHandle(e))
endfunction
function SetEffectScale takes effect e,real scale returns nothing
call SetObjectScale(ConvertHandle(e),scale)
endfunction
function SetEffectScaleEx takes effect e,real x,real y,real z returns nothing
call SetObjectScaleEx(ConvertHandle(e),x,y,z)
endfunction
function GetEffectRoll takes effect e returns real
return GetObjectRoll(ConvertHandle(e))
endfunction
function SetEffectRoll takes effect e,real angle returns nothing
call SetObjectRoll(ConvertHandle(e),angle)
endfunction
function GetEffectPitch takes effect e returns real
return GetObjectPitch(ConvertHandle(e))
endfunction
function SetEffectPitch takes effect e,real angle returns nothing
call SetObjectPitch(ConvertHandle(e),angle)
endfunction
function GetEffectYaw takes effect e returns real
return GetObjectYaw(ConvertHandle(e))
endfunction
function GetEffectFacing takes effect e returns real
return GetObjectFacing(ConvertHandle(e))
endfunction
function SetEffectYaw takes effect e,real angle returns nothing
call SetObjectYaw(ConvertHandle(e),angle)
endfunction
function SetEffectFacing takes effect e,real angle returns nothing
call SetObjectFacing(ConvertHandle(e),angle)
endfunction
function SetEffectSpaceRotation takes effect e,real yaw,real pitch,real roll returns nothing
call SetObjectSpaceRotation(ConvertHandle(e),yaw,pitch,roll)
endfunction
function SetEffectOrientation takes effect e,real yaw,real pitch,real roll returns nothing
call SetObjectOrientation(ConvertHandle(e),yaw,pitch,roll)
endfunction
function ResetEffectMatrix takes effect e returns nothing
call ResetObjectMatrix(ConvertHandle(e))
endfunction
function SetEffectAnimationByIndex takes effect e,integer index returns nothing
call SetObjectAnimationByIndex(ConvertHandle(e),index)
endfunction
function SetEffectAnimationByIndexWithRarity takes effect e,integer index,integer rarity returns nothing
call SetObjectAnimationByIndexWithRarity(ConvertHandle(e),index,rarity)
endfunction
function Init_MemHackEffectAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
elseif PatchVersion=="1.26a" then
elseif PatchVersion=="1.27a" then
elseif PatchVersion=="1.27b" then
elseif PatchVersion=="1.28f" then
endif
endif
endfunction
function GetFrameByName takes string name,integer id returns integer
local integer addr=GetCFrameByName(name,id)
if addr==0 then
set addr=GetCSimpleFrameByName(name,id)
if addr==0 then
set addr=GetCSimpleTextureByName(name,id)
if addr==0 then
set addr=GetCSimpleFontByName(name,id)
endif
endif
endif
return addr
endfunction
function GetTooltipUberFrame takes nothing returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetTooltipFrame"))
if addr!=0 then
return fast_call_1(addr,0)
endif
return 0
endfunction
function CreateFrameEx takes string baseframe,integer parent,integer point,integer relativepoint,integer id returns integer
return CreateCFrameByTagNameEx(baseframe,parent,point,relativepoint,id)
endfunction
function CreateFrame takes string baseframe,integer parent,integer id returns integer
return CreateFrameEx(baseframe,parent,0,0,id)
endfunction
function CreateSimpleFrame takes integer parent returns integer
return CreateCSimpleFrame(parent)
endfunction
function HideFrame takes integer pFrame returns integer
return HideCLayer(pFrame)
endfunction
function ShowFrame takes integer pFrame returns integer
return ShowCLayer(pFrame)
endfunction
function SetFrameAlpha takes integer pFrame,integer alpha returns integer
return SetCLayerAlpha(pFrame,alpha)
endfunction
function SetLayerFont takes integer pFrame,string filename,real height,integer flag returns integer
return SetCLayerFont(pFrame,filename,height,flag)
endfunction
function SetFrameTooltip takes integer pFrame,integer pTooltip returns integer
return SetCLayerTooltip(pFrame,pTooltip)
endfunction
function SetFrameFocus takes integer pFrame,boolean flag returns integer
return SetCEditBoxFocus(pFrame,flag)
endfunction
function SetFrameCageMouse takes integer pFrame,boolean flag returns integer
return SetCLayoutFrameCageMouse(pFrame,flag)
endfunction
function SetFrameAbsolutePoint takes integer pFrame,integer point,real x,real y returns integer
local integer fid_1=GetFrameType(pFrame)
if fid_1>0 then
set pFrame=GetFrameLayoutByType(pFrame,fid_1)
return SetCLayoutFrameAbsolutePoint(pFrame,point,x,y)
endif
return 0
endfunction
function SetFramePoint takes integer pFrame,integer point,integer pParentFrame,integer relativePoint,real x,real y returns integer
local integer fid_1=GetFrameType(pFrame)
local integer fid_2=GetFrameType(pParentFrame)
if fid_1>0 and fid_2>0 then
set pFrame=GetFrameLayoutByType(pFrame,fid_1)
set pParentFrame=GetFrameLayoutByType(pParentFrame,fid_2)
return SetCLayoutFramePoint(pFrame,point,pParentFrame,relativePoint,x,y)
endif
return 0
endfunction
function ClearFrameAllPoints takes integer pFrame returns integer
return ClearCLayoutFrameAllPoints(pFrame)
endfunction
function SetFrameWidth takes integer pFrame,real width returns integer
return SetCLayoutFrameWidth(pFrame,width)
endfunction
function SetFrameHeight takes integer pFrame,real height returns integer
return SetCLayoutFrameHeight(pFrame,height)
endfunction
function SetFrameAllPoints takes integer pFrame,integer relativeframe returns integer
return SetCLayoutFrameAllPoints(pFrame,relativeframe)
endfunction
function SetFrameSize takes integer pFrame,real width,real height returns integer
return SetCLayoutFrameSize(pFrame,width,height)
endfunction
function SetLayoutFrameScale takes integer pFrame,real scale returns integer
return SetCLayoutFrameScale(pFrame,scale)
endfunction
function SetFrameVertexColour takes integer pFrame,integer colour returns integer
return SetCSimpleRegionVertexColour(pFrame,colour)
endfunction
function SetFrameVertexColourEx takes integer pFrame,integer alpha,integer red,integer blue,integer green returns integer
return SetCSimpleRegionVertexColourEx(pFrame,alpha,red,blue,green)
endfunction
function GetFrameSkinByName takes string name,integer id returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetSkinByName"))
if addr!=0 and name!="" then
return fast_call_2(addr,GetStringAddress(name),id)
endif
return 0
endfunction
function DestroyFrame takes integer pFrame returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("FrameAPI"),StringHash("DestroyFrame"))
if addr!=0 and pFrame!=0 then
return this_call_2(addr,pFrame,1)
endif
return 0
endfunction
function GetFrameState takes integer pFrame,integer state returns boolean
if pFrame!=0 then
return BitwiseAnd(state,ReadRealMemory(pFrame+0x1D4))==state
endif
return false
endfunction
function IsFrameEnabled takes integer pFrame returns boolean
return GetFrameState(pFrame,1)
endfunction
function SetFrameState takes integer pFrame,boolean flag returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("FrameAPI"),StringHash("SetFrameState"))
if addr!=0 and pFrame!=0 then
return this_call_2(addr,pFrame,B2I(flag))
endif
return 0
endfunction
function EnableFrame takes integer pFrame returns integer
return SetFrameState(pFrame,true)
endfunction
function DisableFrame takes integer pFrame returns integer
return SetFrameState(pFrame,false)
endfunction
function GetFrameTextByName takes string name,integer id returns string
return GetCSimpleFontTextByName(name,id)
endfunction
function SetFrameTextColour takes integer pFrame,integer colour returns integer
return SetCTextFrameTextColour(pFrame,colour)
endfunction
function SetFrameTextColourEx takes integer pFrame,integer alpha,integer red,integer blue,integer green returns integer
return SetCTextFrameTextColourEx(pFrame,alpha,red,green,blue)
endfunction
function FindLayerUnderCursor takes nothing returns integer
return FindCLayerUnderCursor()
endfunction
function ClickCControl takes integer pFrame,integer buttonType returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("FrameAPI"),StringHash("ClickCControl"))
if addr!=0 and pFrame!=0 then
return this_call_2(addr,pFrame,buttonType)
endif
return 0
endfunction
function ClickFrameEx takes integer pFrame,integer buttonType returns integer
local string f_name=""
if pFrame!=0 then
set f_name=GetFrameTypeName(pFrame)
if f_name!="CSimpleButton" and f_name!="CCommandButton" then
return ClickCControl(pFrame,buttonType)
else
return ClickCSimpleButton(pFrame,buttonType)
endif
endif
return 0
endfunction
function ClickFrame takes integer pFrame returns integer
return ClickFrameEx(pFrame,1)
endfunction
function SetFrameModel takes integer pFrame,string model,integer modeltype,boolean flag returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name=="CModelFrame" then
return AddCModelFrameModel(pFrame,model,modeltype)
elseif f_name=="CSpriteFrame" then
return SetCSpriteFrameArt(pFrame,model,modeltype,flag)
elseif f_name=="CStatusBar" then
return SetCStatusBarArt(pFrame,model,modeltype)
endif
return 0
endfunction
function GetFrameAlpha takes integer pFrame returns integer
local integer fid=GetFrameType(pFrame)
if fid>0 then
return ReadRealMemory(pFrame+0xAC)
endif
return 0
endfunction
function UpdateFrame takes integer pFrame returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("FrameAPI"),StringHash("UpdateFrame"))
if addr!=0 and pFrame!=0 then
return this_call_2(addr,pFrame,0)
endif
return 0
endfunction
function SetFrameStepValue takes integer pFrame,real step returns nothing
local string f_name=GetFrameTypeName(pFrame)
if f_name=="CSlider" then
call WriteRealMemory(pFrame+0x1F8,SetRealIntoMemory(step))
endif
endfunction
function GetFrameParent takes integer pFrame returns integer
local integer fid=GetFrameType(pFrame)
local integer pOff=0
if fid>0 then
if not IsFrameLayout(pFrame)then
set pOff=0x20
else
set pOff=0x68
endif
if pOff>0 then
return ReadRealMemory(pFrame+pOff)
endif
endif
return 0
endfunction
function SetFrameParent takes integer pFrame,integer pParentFrame returns integer
if GetFrameType(pFrame)>0 and GetFrameType(pParentFrame)>0 then
if IsFrameLayout(pFrame)then
if IsFrameLayout(pParentFrame)then
return SetCSimpleFrameParent(pFrame,pParentFrame)
endif
else
if IsFrameLayout(pParentFrame)then
return SetCLayerOwner(pFrame,pParentFrame)
endif
endif
endif
return 0
endfunction
function GetFrameName takes integer pFrame returns string
local integer fid=GetFrameType(pFrame)
local integer pText=0
if fid>0 then
if IsFrameLayout(pFrame)then
set pText=pFrame+0x7C
else
set pText=pFrame+0x160
endif
if pText>0 then
return ToJString(ReadRealMemory(pText))
endif
endif
return""
endfunction
function SetFrameTexture takes integer pFrame,string texturepath,boolean flag returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name=="CBackdropFrame" then
return SetCBackDropFrameTexture(pFrame,texturepath,flag)
elseif f_name=="CSimpleStatusBar" then
return SetCSimpleStatusBarTexture(pFrame,texturepath,flag)
elseif f_name=="CSimpleTexture" then
return SetCSimpleTextureTexture(pFrame,texturepath,flag)
endif
return 0
endfunction
function SetFrameScale takes integer pFrame,real scale returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name!="" then
if f_name=="CSimpleFontString" then
return SetCSimpleFontStringScale(pFrame,scale)
elseif f_name=="CSimpleGlueFrame" then
return SetCSimpleGlueFrameScale(pFrame,scale)
elseif f_name=="CSimpleMessageFrame" or f_name=="CSimpleStatusBar" then
return SetCSimpleFrameScale(pFrame,scale)
else
return SetLayoutFrameScale(pFrame,scale)
endif
endif
return 0
endfunction
function GetFrameValue takes integer pFrame returns real
local string f_name=GetFrameTypeName(pFrame)
local integer pOff=0
if f_name=="CSlider" then
set pOff=0x500
elseif f_name=="CSimpleStatusBar" then
set pOff=0x130
elseif f_name=="CStatusBar" then
set pOff=0x1BC
endif
if pOff!=0 then
return ReadRealFloat(pFrame+pOff)
endif
return 0.
endfunction
function SetFrameValue takes integer pFrame,real value returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name=="CSlider" then
return SetCSliderCurrentValue(pFrame,value)
elseif f_name=="CSimpleStatusBar" then
return SetCSimpleStatusBarValue(pFrame,value)
elseif f_name=="CStatusBar" then
return SetCStatusBarValue(pFrame,value)
endif
return 0
endfunction
function SetFrameMinMaxValue takes integer pFrame,real minval,real maxval returns integer
local string f_name=GetFrameTypeName(pFrame)
local real cur_val=0.
local real new_val=0.
if f_name!="" and minval<maxval then
if f_name=="CSlider" then
call WriteRealMemory(pFrame+0x1EC,SetRealIntoMemory(minval))
call WriteRealMemory(pFrame+0x1F0,SetRealIntoMemory(maxval))
set cur_val=GetRealFromMemory(ReadRealMemory(pFrame+0x1F4))
if minval<=cur_val then
if cur_val>maxval then
set new_val=maxval
endif
else
set new_val=minval
endif
return SetCSliderCurrentValue(pFrame,new_val)
endif
if f_name=="CSimpleStatusBar" then
return SetCSimpleStatusBarMinMaxValue(pFrame,minval,maxval)
endif
if f_name=="CStatusBar" then
return SetCStatusBarMinMaxValue(pFrame,minval,maxval)
endif
endif
return 0
endfunction
function SetFrameFont takes integer pFrame,string filename,real height,integer flag returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name!="" then
if f_name=="CEditBox" then
return SetCEditBoxFont(pFrame,filename,height,flag)
elseif f_name=="CSimpleFontString" then
return SetCSimpleFontStringFont(pFrame,filename,height,flag)
elseif f_name=="CSimpleMessageFrame" then
return SetCSimpleMessageFrameFont(pFrame,filename,height,flag)
else
if not IsFrameLayoutByType(pFrame,GetFrameType(pFrame))then
return SetLayerFont(pFrame,filename,height,flag)
endif
endif
endif
return 0
endfunction
function GetFrameWidth takes integer pFrame returns real
local string f_name=GetFrameTypeName(pFrame)
if f_name!="" then
return GetRealFromMemory(ReadRealMemory(pFrame+0x58))
endif
return 0.
endfunction
function GetFrameHeight takes integer pFrame returns real
local string f_name=GetFrameTypeName(pFrame)
if f_name!="" then
if f_name=="CModelFrame" then
return GetCModelFrameHeight(pFrame)
elseif f_name=="CSimpleFontString" then
return GetCSimpleFontStringHeight(pFrame)
elseif f_name=="CSpriteFrame" then
return GetCSpriteFrameHeight(pFrame)
elseif f_name=="CTextFrame" then
return GetCTextFrameHeight(pFrame)
else
return GetCLayoutFrameHeight(pFrame)
endif
endif
return 0.
endfunction
function GetFramePoint takes integer pFrame,integer point returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name!="" then
return ReadRealMemory(pFrame+0x4*point+0x8)
endif
return 0
endfunction
function GetFrameAbsolutePoint takes integer pFrame,integer point returns integer
return GetFramePoint(pFrame,point)
endfunction
function GetFrameAbsolutePointX takes integer pFrame,integer point returns real
local integer pFramePoint=GetFramePoint(pFrame,point)
if pFramePoint>0 then
return GetRealFromMemory(ReadRealMemory(pFramePoint+0x4))
endif
return 0.
endfunction
function GetFrameAbsolutePointY takes integer pFrame,integer point returns real
local integer pFramePoint=GetFramePoint(pFrame,point)
if pFramePoint>0 then
return GetRealFromMemory(ReadRealMemory(pFramePoint+0x8))
endif
return 0.
endfunction
function GetFrameRelativePoint takes integer pFrame,integer point returns integer
return GetFramePoint(pFrame,point)
endfunction
function GetFrameRelativePointParent takes integer pFrame,integer point returns integer
local integer pFramePoint=GetFramePoint(pFrame,point)
if pFramePoint>0 then
return ReadRealMemory(pFramePoint+0x4)
endif
return 0
endfunction
function GetFramePointRelativePoint takes integer pFrame,integer point returns integer
local integer pFramePoint=GetFramePoint(pFrame,point)
if pFramePoint>0 then
return ReadRealMemory(pFramePoint+0x8)
endif
return 0
endfunction
function GetFrameRelativePointX takes integer pFrame,integer point returns real
local integer pFramePoint=GetFramePoint(pFrame,point)
if pFramePoint>0 then
return GetRealFromMemory(ReadRealMemory(pFramePoint+0xC))
endif
return 0.
endfunction
function GetFrameRelativePointY takes integer pFrame,integer point returns real
local integer pFramePoint=GetFramePoint(pFrame,point)
if pFramePoint>0 then
return GetRealFromMemory(ReadRealMemory(pFramePoint+0x10))
endif
return 0.
endfunction
function GetFrameTextMaxLength takes integer pFrame returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name=="CEditBox" then
return ReadRealMemory(pFrame+0x1F0)
endif
return 0
endfunction
function SetFrameMaxTextLength takes integer pFrame,integer length returns nothing
local string f_name=GetFrameTypeName(pFrame)
if f_name=="CEditBox" then
call WriteRealMemory(pFrame+0x1F0,length)
endif
endfunction
function GetFrameTextLength takes integer pFrame returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name=="CEditBox" then
return ReadRealMemory(pFrame+0x1F4)
endif
return 0
endfunction
function GetFrameText takes integer pFrame returns string
local string f_name=GetFrameTypeName(pFrame)
local integer pFrameText=0
if f_name!="" then
if f_name=="CEditBox" then
set pFrameText=ReadRealMemory(pFrame+0x1E4)
elseif f_name=="CSimpleFontString" then
set pFrameText=ReadRealMemory(pFrame+0x01C)
elseif f_name=="CTextArea" then
set pFrameText=ReadRealMemory(pFrame+0x230)
elseif f_name=="CTextFrame" then
set pFrameText=ReadRealMemory(pFrame+0x1E8)
endif
if pFrameText>0 then
return ToJString(pFrameText)
endif
endif
return""
endfunction
function SetFrameText takes integer pFrame,string text returns integer
local string f_name=GetFrameTypeName(pFrame)
if f_name!="" then
if f_name=="CEditBox" or f_name=="CGlueEditBoxWar3" or f_name=="CSlashChatBox" then
return SetCEditBoxText(pFrame,text)
elseif f_name=="CSimpleFontString" then
return SetCSimpleFontText(pFrame,text)
elseif f_name=="CTextArea" then
return SetCTextAreaText(pFrame,text)
elseif f_name=="CTextButtonFrame" or f_name=="CTextFrame" or f_name=="CGlueTextButtonWar3" or f_name=="CTimerTextFrame" then
return SetCTextFrameText(pFrame,text)
endif
endif
return 0
endfunction
function IsReplay takes nothing returns boolean
return GetCFrameByName("ReplayVisionMenu",0)!=0
endfunction
function SetAllyCheckbox takes integer mode returns nothing
local integer i=0
local integer pAllyCheckBoxAddr
loop
exitwhen i>11
set pAllyCheckBoxAddr=GetCFrameByName("UnitsCheckBox",i)
if pAllyCheckBoxAddr>0 then
set pAllyCheckBoxAddr=pAllyCheckBoxAddr+0x1D4
if BitwiseAnd(ReadRealMemory(pAllyCheckBoxAddr),mode)==0 then
call WriteRealMemory(pAllyCheckBoxAddr,BitwiseOr(ReadRealMemory(pAllyCheckBoxAddr),mode))
endif
endif
set i=i+1
endloop
endfunction
function EnableAllyCheckbox takes nothing returns nothing
call SetAllyCheckbox(1)
endfunction
function DisableAllyCheckbox takes nothing returns nothing
call SetAllyCheckbox(0)
endfunction
function DisableSaveGameMenu takes nothing returns nothing
local integer pSaveGameSaveButton=GetCFrameByName("SaveGameFileEditBox",0)
if pSaveGameSaveButton>0 then
call WriteRealMemory(pSaveGameSaveButton+0x1D4,0)
call WriteRealMemory(pSaveGameSaveButton+0x108,0)
call WriteRealMemory(pSaveGameSaveButton+0x1E8,0)
set pSaveGameSaveButton=GetCFrameByName("FileListFrame",0)
if pSaveGameSaveButton>0 then
call WriteRealMemory(pSaveGameSaveButton+0x10C,0x3B03123E)
endif
endif
endfunction
function Init_MemHackFrameAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetTooltipFrame"),pGameDLL+0x337D80)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetSkinByName"),pGameDLL+0x320070)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("DestroyFrame"),pGameDLL+0x6070B0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("SetFrameState"),pGameDLL+0x602580)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("ClickCControl"),pGameDLL+0x6026C0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("UpdateFrame"),pGameDLL+0x606460)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetTooltipFrame"),pGameDLL+0x337240)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetSkinByName"),pGameDLL+0x31F530)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("DestroyFrame"),pGameDLL+0x606910)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("SetFrameState"),pGameDLL+0x336C20)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("ClickCControl"),pGameDLL+0x601F20)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("UpdateFrame"),pGameDLL+0x605CC0)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetTooltipFrame"),pGameDLL+0x399720)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetSkinByName"),pGameDLL+0x324AD0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("DestroyFrame"),pGameDLL+0x0A1870)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("SetFrameState"),pGameDLL+0x0A95F0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("ClickCControl"),pGameDLL+0x0BE3A0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("UpdateFrame"),pGameDLL+0x0BD630)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetTooltipFrame"),pGameDLL+0x3B6ED0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetSkinByName"),pGameDLL+0x342220)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("DestroyFrame"),pGameDLL+0x0F55D0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("SetFrameState"),pGameDLL+0x112030)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("ClickCControl"),pGameDLL+0x112100)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("UpdateFrame"),pGameDLL+0x111390)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetTooltipFrame"),pGameDLL+0x3EAFC0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("GetSkinByName"),pGameDLL+0x3761E0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("DestroyFrame"),pGameDLL+0x123C20)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("SetFrameState"),pGameDLL+0x1406E0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("ClickCControl"),pGameDLL+0x1407B0)
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("UpdateFrame"),pGameDLL+0x13F9B0)
endif
call SaveInteger(MemHackTable,StringHash("FrameAPI"),StringHash("TooltipUberFrame"),GetTooltipUberFrame())
endif
endfunction
function GetAddressGroupUnitCount takes integer pObj returns integer
if pObj>0 then
return ReadRealMemory(pObj+0x34)
endif
return 0
endfunction
function GetAddressGroupAddressUnitByIndex takes integer pObj,integer index returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGroup"),StringHash("GetUnitByIndex"))
if addr!=0 and pObj!=0 then
return this_call_2(addr,pObj+0x24,index)
endif
return 0
endfunction
function GetGroupUnitCount takes group g returns integer
return GetAddressGroupUnitCount(ConvertHandle(g))
endfunction
function GetUnitFromGroupByIndex takes group g,integer index returns unit
local integer pObj=GetAddressGroupAddressUnitByIndex(ConvertHandle(g),index)
if pObj!=0 then
set pObj=ObjectToHandleId(pObj)
if pObj!=0 then
return I2U(pObj)
endif
endif
return null
endfunction
function GetRandomUnitFromGroup takes group g returns unit
local integer pObj=ConvertHandle(g)
local integer count=0
if pObj!=0 then
set count=GetAddressGroupUnitCount(pObj)
if count!=0 then
set pObj=GetAddressGroupAddressUnitByIndex(pObj,GetRandomInt(0,count-1))
if pObj!=0 then
set pObj=ObjectToHandleId(pObj)
if pObj!=0 then
return I2U(pObj)
endif
endif
endif
endif
return null
endfunction
function ForEach takes group g returns unit
local integer iterator=LoadInteger(MemHackTable,StringHash("CGroup"),StringHash("Iterator"))
local integer pObj=GetAddressGroupAddressUnitByIndex(ConvertHandle(g),iterator)
if pObj!=0 then
call SaveInteger(MemHackTable,StringHash("CGroup"),StringHash("Iterator"),iterator+1)
set pObj=ObjectToHandleId(pObj)
if pObj!=0 then
return I2U(pObj)
endif
else
call SaveInteger(MemHackTable,StringHash("CGroup"),StringHash("Iterator"),0)
endif
return null
endfunction
function Init_MemHackGroupAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CGroup"),StringHash("GetUnitByIndex"),pGameDLL+0x422560)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CGroup"),StringHash("GetUnitByIndex"),pGameDLL+0x421A20)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CGroup"),StringHash("GetUnitByIndex"),pGameDLL+0x272910)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CGroup"),StringHash("GetUnitByIndex"),pGameDLL+0x290570)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CGroup"),StringHash("GetUnitByIndex"),pGameDLL+0x230AA0)
endif
call SaveInteger(MemHackTable,StringHash("CGroup"),StringHash("Iterator"),0)
endif
endfunction
function GetItemBaseDataById takes integer iid returns integer
return GetAgileDataNodeById(LoadInteger(MemHackTable,StringHash("CItemBase"),StringHash("DataNode")),iid)
endfunction
function GetItemBaseData takes item it returns integer
return GetItemBaseDataById(GetItemTypeId(it))
endfunction
function GetItemBaseDataByIdCaching takes integer iid returns integer
return GetWidgetBaseDataByIdCachingEx(LoadInteger(MemHackTable,StringHash("CItemBase"),StringHash("DataNode")),2,iid,0)
endfunction
function GetItemBaseDataCaching takes item it returns integer
return GetItemBaseDataByIdCaching(GetItemTypeId(it))
endfunction
function GetItemBaseUIDataById takes integer iid returns integer
return GetWidgetBaseUIDataById(iid)
endfunction
function GetItemBaseUIData takes item it returns integer
return GetItemBaseUIDataById(GetItemTypeId(it))
endfunction
function GetItemBaseUIDataByIdCaching takes integer iid returns integer
return GetWidgetBaseDataByIdCachingEx(0,3,iid,1)
endfunction
function GetItemBaseUIDataCaching takes item it returns integer
return GetItemBaseUIDataByIdCaching(GetItemTypeId(it))
endfunction
function GetItemBaseUIStringParamById takes integer iid,integer pointerlevel,integer offset returns string
return GetWidgetBaseUIStringParamById(iid,pointerlevel,offset)
endfunction
function SetItemBaseUIStringParamById takes integer iid,integer pointerlevel,integer offset,string text returns nothing
call SetWidgetBaseUIStringParamById(iid,pointerlevel,offset,text)
endfunction
function GetItemBaseNameById takes integer iid returns string
return GetItemBaseUIStringParamById(iid,1,0x2C)
endfunction
function SetItemBaseNameById takes integer iid,string text returns nothing
call SetItemBaseUIStringParamById(iid,1,0x2C,text)
endfunction
function GetItemBaseIconPathById takes integer iid returns string
return GetItemBaseUIStringParamById(iid,1,0x24C)
endfunction
function SetItemBaseIconPathById takes integer iid,string text returns nothing
call SetItemBaseUIStringParamById(iid,1,0x24C,text)
endfunction
function GetItemBaseTipById takes integer iid returns string
return GetItemBaseUIStringParamById(iid,1,0x260)
endfunction
function SetItemBaseTipById takes integer iid,string text returns nothing
call SetItemBaseUIStringParamById(iid,1,0x260,text)
endfunction
function GetItemBaseUbertipById takes integer iid returns string
return GetItemBaseUIStringParamById(iid,1,0x26C)
endfunction
function SetItemBaseUbertipById takes integer iid,string text returns nothing
call SetItemBaseUIStringParamById(iid,1,0x26C,text)
endfunction
function GetItemBaseHotkeyById takes integer iid returns integer
if iid>0 then
if GetWidgetBaseUIIntegerParamById(iid,0,0x270)>0 or GetWidgetBaseUIIntegerParamById(iid,0,0x274)>0 then
return GetWidgetBaseUIIntegerParamById(iid,1,0x278)
endif
endif
return 0
endfunction
function SetItemBaseHotkeyById takes integer iid,integer key returns nothing
if iid>0 then
call SetWidgetBaseUIIntegerParamById(iid,0,0x270,1)
call SetWidgetBaseUIIntegerParamById(iid,0,0x274,key)
call SetWidgetBaseUIIntegerParamById(iid,1,0x278,key)
endif
endfunction
function GetItemBaseUIStringParam takes item it,integer pointerlevel,integer offset returns string
return GetItemBaseUIStringParamById(GetItemTypeId(it),pointerlevel,offset)
endfunction
function SetItemBaseUIStringParam takes item it,integer pointerlevel,integer offset,string text returns nothing
call SetItemBaseUIStringParamById(GetItemTypeId(it),pointerlevel,offset,text)
endfunction
function GetItemBaseName takes item it returns string
return GetItemBaseNameById(GetItemTypeId(it))
endfunction
function SetItemBaseName takes item it,string text returns nothing
call SetItemBaseNameById(GetItemTypeId(it),text)
endfunction
function GetItemBaseIconPath takes item it returns string
return GetItemBaseIconPathById(GetItemTypeId(it))
endfunction
function SetItemBaseIconPath takes item it,string text returns nothing
call SetItemBaseIconPathById(GetItemTypeId(it),text)
endfunction
function GetItemBaseTip takes item it returns string
return GetItemBaseTipById(GetItemTypeId(it))
endfunction
function SetItemBaseTip takes item it,string text returns nothing
call SetItemBaseTipById(GetItemTypeId(it),text)
endfunction
function GetItemBaseUbertip takes item it returns string
return GetItemBaseUbertipById(GetItemTypeId(it))
endfunction
function SetItemBaseUbertip takes item it,string text returns nothing
call SetItemBaseUbertipById(GetItemTypeId(it),text)
endfunction
function GetItemBaseHotkey takes item it returns integer
return GetItemBaseHotkeyById(GetItemTypeId(it))
endfunction
function SetItemBaseHotkey takes item it,integer key returns nothing
call SetItemBaseHotkeyById(GetItemTypeId(it),key)
endfunction
function GetItemBaseTypeIdById takes integer iid returns integer
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
return ReadRealMemory(pData+0x14)
endif
return 0
endfunction
function GetItemBaseGoldCostById takes integer iid returns integer
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
return ReadRealMemory(pData+0x20)
endif
return 0
endfunction
function SetItemBaseGoldCostById takes integer iid,integer cost returns nothing
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
call WriteRealMemory(pData+0x20,cost)
endif
endfunction
function GetItemBaseLumberCostById takes integer iid returns integer
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
return ReadRealMemory(pData+0x24)
endif
return 0
endfunction
function SetItemBaseLumberCostById takes integer iid,integer cost returns nothing
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
call WriteRealMemory(pData+0x24,cost)
endif
endfunction
function GetItemBaseLevelById takes integer iid returns integer
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
return ReadRealMemory(pData+0x38)
endif
return 0
endfunction
function SetItemBaseLevelById takes integer iid,integer level returns nothing
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
call WriteRealMemory(pData+0x38,level)
endif
endfunction
function IsItemBaseSellableById takes integer iid returns boolean
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
return ReadRealMemory(pData+0x50)>1
endif
return false
endfunction
function IsItemBasePawnableById takes integer iid returns boolean
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
return ReadRealMemory(pData+0x54)>1
endif
return false
endfunction
function IsItemBaseDroppableById takes integer iid returns boolean
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
return ReadRealMemory(pData+0x60)>1
endif
return false
endfunction
function IsItemBaseDroppedOnDeathById takes integer iid returns boolean
local integer pData=GetItemBaseDataById(iid)
if pData>0 then
return ReadRealMemory(pData+0x64)>1
endif
return false
endfunction
function GetItemBaseTypeId takes item it returns integer
return GetItemBaseTypeIdById(GetItemTypeId(it))
endfunction
function GetItemBaseGoldCost takes item it returns integer
return GetItemBaseGoldCostById(GetItemTypeId(it))
endfunction
function SetItemBaseGoldCost takes item it,integer cost returns nothing
call SetItemBaseGoldCostById(GetItemTypeId(it),cost)
endfunction
function GetItemBaseLumberCost takes item it returns integer
return GetItemBaseLumberCostById(GetItemTypeId(it))
endfunction
function SetItemBaseLumberCost takes item it,integer cost returns nothing
call SetItemBaseLumberCostById(GetItemTypeId(it),cost)
endfunction
function GetItemBaseLevel takes item it returns integer
return GetItemBaseLevelById(GetItemTypeId(it))
endfunction
function SetItemBaseLevel takes item it,integer lvl returns nothing
call SetItemBaseLevelById(GetItemTypeId(it),lvl)
endfunction
function IsItemBaseSellable takes item it returns boolean
return IsItemBaseSellableById(GetItemTypeId(it))
endfunction
function IsItemBasePawnable takes item it returns boolean
return IsItemBasePawnableById(GetItemTypeId(it))
endfunction
function IsItemBaseDroppable takes item it returns boolean
return IsItemBaseDroppableById(GetItemTypeId(it))
endfunction
function IsItemBaseDroppedOnDeath takes item it returns boolean
return IsItemBaseDroppedOnDeathById(GetItemTypeId(it))
endfunction
function Init_MemHackItemBaseAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CItemBase"),StringHash("DataNode"),pGameDLL+0xACBA24)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CItemBase"),StringHash("DataNode"),pGameDLL+0xAB4BCC)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CItemBase"),StringHash("DataNode"),pGameDLL+0xBEC238)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CItemBase"),StringHash("DataNode"),pGameDLL+0xD707A0)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CItemBase"),StringHash("DataNode"),pGameDLL+0xD385D8)
endif
endif
endfunction
function CItemGetAbilityByIndex takes integer pItem,integer index returns ability
local integer pData=pItem
local integer pAbil=0
local integer i=0
if pData!=0 then
set pAbil=GetCAgentFromHashGroup(pData+0x9C+0x8*index)
if pAbil!=0 then
return ObjectToAbility(pAbil)
endif
endif
return null
endfunction
function CItemStartCooldown takes integer pUnit,integer pItem,real cd returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CItem"),StringHash("StatCooldown"))
local integer mem=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
local integer pInv=0
if addr!=0 and mem!=0 and pUnit!=0 and pItem!=0 then
set pInv=ReadRealMemory(pUnit+0x1F8)
if pInv!=0 then
call WriteRealFloat(mem,cd)
call this_call_4(addr,pInv,pItem,mem,mem)
endif
endif
endfunction
function CItemSetTypeId takes integer pItem,integer id returns nothing
local integer oldId=0
if pItem>0 then
set oldId=ReadRealMemory(pItem+0x30)
if oldId>0 then
call WriteRealMemory(pItem+0x30,id)
endif
endif
endfunction
function CItemSetModel takes integer pItem,string model,boolean flag returns nothing
call SetObjectModel(pItem,model,flag)
endfunction
function CItemGetLife takes integer pItem returns real
if pItem>0 then
return GetRealFromMemory(ReadRealMemory(pItem+0x58))
endif
return 0.
endfunction
function CItemSetLife takes integer pItem,real life returns nothing
if pItem>0 then
call WriteRealMemory(pItem+0x58,SetRealIntoMemory(life))
endif
endfunction
function CItemGetMaxLife takes integer pItem returns real
if pItem>0 then
return GetRealFromMemory(ReadRealMemory(pItem+0x60))
endif
return 0.
endfunction
function CItemSetMaxLife takes integer pItem,real life returns nothing
if pItem>0 then
call WriteRealMemory(pItem+0x60,SetRealIntoMemory(life))
endif
endfunction
function GetItemAbilityByIndex takes item it,integer index returns ability
return CItemGetAbilityByIndex(ConvertHandle(it),index)
endfunction
function StartItemCooldown takes unit u,item it,real cd returns nothing
call CItemStartCooldown(ConvertHandle(u),ConvertHandle(it),cd)
endfunction
function SetItemIdType takes item it,integer id returns nothing
call CItemSetTypeId(ConvertHandle(it),id)
endfunction
function SetItemModel takes item it,string model,boolean flag returns nothing
call CItemSetModel(ConvertHandle(it),model,flag)
endfunction
function GetItemLife takes item it returns real
return CItemGetLife(ConvertHandle(it))
endfunction
function SetItemLife takes item it,real life returns nothing
call CItemSetLife(ConvertHandle(it),life)
endfunction
function GetItemMaxLife takes item it returns real
return CItemGetMaxLife(ConvertHandle(it))
endfunction
function SetItemMaxLife takes item it,real life returns nothing
call CItemSetMaxLife(ConvertHandle(it),life)
endfunction
function Init_MemHackItemNormalAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CItem"),StringHash("StatCooldown"),pGameDLL+0x0E4B50)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CItem"),StringHash("StatCooldown"),pGameDLL+0x0E3F30)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CItem"),StringHash("StatCooldown"),pGameDLL+0x54C2E0)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CItem"),StringHash("StatCooldown"),pGameDLL+0x569A40)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CItem"),StringHash("StatCooldown"),pGameDLL+0x59DB70)
endif
endif
endfunction
function GetCMouseEvent takes nothing returns integer
return LoadInteger(MemHackTable,StringHash("CMouse"),StringHash("Event"))
endfunction
function GetCursorX takes nothing returns integer
local integer pMouse=GetCursorPosStruct()
if pMouse!=0 then
return ReadRealMemory(pMouse+0x0)
endif
return 0
endfunction
function GetCursorY takes nothing returns integer
local integer pMouse=GetCursorPosStruct()
if pMouse!=0 then
return ReadRealMemory(pMouse+0x4)
endif
return 0
endfunction
function GetCursorRelativeAxis takes nothing returns integer
local integer window=LoadInteger(MemHackTable,StringHash("GameWindowAPI"),StringHash("Window"))
local integer pMouse=0
if window!=0 then
set pMouse=GetCursorPosStruct()
if pMouse!=0 then
if ScreenToClient(window,pMouse)>0 then
return pMouse
endif
endif
endif
return 0
endfunction
function GetCursorXRelative takes nothing returns integer
local integer pMouse=GetCursorRelativeAxis()
if pMouse!=0 then
return ReadRealMemory(pMouse+0x0)
endif
return 0
endfunction
function GetCursorYRelative takes nothing returns integer
local integer pMouse=GetCursorRelativeAxis()
if pMouse!=0 then
return ReadRealMemory(pMouse+0x4)
endif
return 0
endfunction
function GetMouseWorldEnv takes nothing returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CMouse"),StringHash("CGameUIObject"))
if addr!=0 then
set addr=ReadRealMemory(addr)
if addr!=0 then
set addr=ReadRealMemory(addr+0x3BC)
if addr!=0 then
return addr+0x310
endif
endif
endif
return 0
endfunction
function GetMouseWorldAxis takes integer offset returns real
local integer addr=GetMouseWorldEnv()
if addr!=0 then
return ReadRealFloat(GetMouseWorldEnv()+offset)
endif
return 0.
endfunction
function GetMouseWorldX takes nothing returns real
return GetMouseWorldAxis(0x0)
endfunction
function GetMouseWorldY takes nothing returns real
return GetMouseWorldAxis(0x4)
endfunction
function GetMouseWorldZ takes nothing returns real
return GetMouseWorldAxis(0x8)
endfunction
function Init_MemHackMouseAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("CGameUIObject"),pGameDLL+0xACBDD8)
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("Event"),pGameDLL+0xAB0454)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("CGameUIObject"),pGameDLL+0xAB4F80)
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("Event"),pGameDLL+0xA9A434)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("CGameUIObject"),pGameDLL+0xBE6350)
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("Event"),pGameDLL+0xB66308)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("CGameUIObject"),pGameDLL+0xD6A8B8)
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("Event"),pGameDLL+0xCE3A8C)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("CGameUIObject"),pGameDLL+0xD326F0)
call SaveInteger(MemHackTable,StringHash("CMouse"),StringHash("Event"),pGameDLL+0xCB1AD4)
endif
endif
endfunction
function GetCGameObjectStruct takes nothing returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CGameWar3"),StringHash("Instance"))
if addr!=0 then
return ReadRealMemory(addr)
endif
return 0
endfunction
function GetRealPlayerById takes integer i returns integer
local integer addr=GetCGameObjectStruct()
if addr!=0 then
return ReadRealMemory(addr+(i*4)+0x58)
endif
return 0
endfunction
function GetLocalPlayerIdReal takes nothing returns integer
local integer addr=GetCGameObjectStruct()
if addr!=0 then
return ReadRealMemory(addr+0xA)
endif
return-1
endfunction
function GetLocalPlayerReal takes nothing returns integer
return GetRealPlayerById(GetLocalPlayerIdReal())
endfunction
function GetPlayerSelectedUnitReal takes integer cplayer returns integer
local integer addr=0
if cplayer!=0 then
set addr=ReadRealMemory(addr+0x34)
if addr!=0 then
return ReadRealMemory(addr+0x1E0)
endif
endif
return-1
endfunction
function SetPlayerSelectedUnitReal takes integer cplayer,integer pConvertedHandle returns nothing
local integer addr=0
if cplayer!=0 and pConvertedHandle!=0 then
set addr=ReadRealMemory(addr+0x34)
if addr!=0 then
call WriteRealMemory(addr+0x1E0,pConvertedHandle)
endif
endif
endfunction
function GetOrderPlayerId takes unit u returns integer
local integer pHandle=ConvertHandle(u)
local integer pAddr1
local integer pAddr2
if pHandle>0 then
set pAddr1=ReadRealMemory(pHandle+0x1A8)
set pAddr2=ReadRealMemory(pHandle+0x1AC)
if pAddr1>0 and pAddr2>0 then
return ReadRealMemory(GetCAgentFromHash(pAddr1,pAddr2)+0x28)
endif
endif
return 0xF
endfunction
function Init_MemHackPlayerAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
elseif PatchVersion=="1.26a" then
elseif PatchVersion=="1.27a" then
elseif PatchVersion=="1.27b" then
elseif PatchVersion=="1.28f" then
endif
endif
endfunction
function IsTrackableHidden takes trackable track returns boolean
return IsObjectHidden(ConvertHandle(track))
endfunction
function ShowTrackable takes trackable track,boolean flag returns nothing
call ShowObject(ConvertHandle(track),flag)
endfunction
function SetTrackableAlpha takes trackable track,integer alpha returns nothing
call SetObjectAlpha(ConvertHandle(track),alpha)
endfunction
function GetTrackableColour takes trackable track returns integer
return GetObjectColour(ConvertHandle(track))
endfunction
function SetTrackableColour takes trackable track,integer colour returns nothing
call SetObjectColour(ConvertHandle(track),colour)
endfunction
function SetTrackableColourEx takes trackable track,integer red,integer green,integer blue,integer alpha returns nothing
call SetObjectColourEx(ConvertHandle(track),red,green,blue,alpha)
endfunction
function SetTrackableVertexColour takes trackable track,integer red,integer green,integer blue,integer alpha returns nothing
local integer pObject=ConvertHandle(track)
if pObject>0 then
call SetObjectColourEx(pObject,red,green,blue,alpha)
call SetObjectAlpha(pObject,alpha)
endif
endfunction
function GetTrackableColourA takes trackable track returns integer
return GetObjectColourA(ConvertHandle(track))
endfunction
function SetTrackableColourA takes trackable track,integer alpha returns nothing
call SetObjectColourA(ConvertHandle(track),alpha)
endfunction
function GetTrackableColourR takes trackable track returns integer
return GetObjectColourR(ConvertHandle(track))
endfunction
function SetTrackableColourR takes trackable track,integer red returns nothing
call SetObjectColourR(ConvertHandle(track),red)
endfunction
function GetTrackableColourG takes trackable track returns integer
return GetObjectColourG(ConvertHandle(track))
endfunction
function SetTrackableColourG takes trackable track,integer green returns nothing
call SetObjectColourG(ConvertHandle(track),green)
endfunction
function GetTrackableColourB takes trackable track returns integer
return GetObjectColourB(ConvertHandle(track))
endfunction
function SetTrackableColourB takes trackable track,integer blue returns nothing
call SetObjectColourB(ConvertHandle(track),blue)
endfunction
function SetTrackableAnimationByIndex takes trackable track,integer index returns nothing
call SetObjectAnimationByIndex(ConvertHandle(track),index)
endfunction
function SetTrackableModel takes trackable track,string model,boolean flag returns nothing
call SetObjectModel(ConvertHandle(track),model,flag)
endfunction
function GetTrackableX takes trackable track returns real
return GetObjectX(ConvertHandle(track))
endfunction
function SetTrackableX takes trackable track,real x returns nothing
call SetObjectX(ConvertHandle(track),x)
endfunction
function GetTrackableY takes trackable track returns real
return GetObjectY(ConvertHandle(track))
endfunction
function SetTrackableY takes trackable track,real y returns nothing
call SetObjectY(ConvertHandle(track),y)
endfunction
function GetTrackableZ takes trackable track returns real
return GetObjectZ(ConvertHandle(track))
endfunction
function SetTrackableZ takes trackable track,real z returns nothing
call SetObjectZ(ConvertHandle(track),z)
endfunction
function SetTrackablePosition takes trackable track,real x,real y,real z returns nothing
call SetObjectPosition(ConvertHandle(track),x,y,z)
endfunction
function GetTrackableTimeScale takes trackable track returns real
return GetObjectTimeScale(ConvertHandle(track))
endfunction
function SetTrackableTimeScale takes trackable track,real speed returns nothing
call SetObjectTimeScale(ConvertHandle(track),speed)
endfunction
function GetTrackableScale takes trackable track returns real
return GetObjectScale(ConvertHandle(track))
endfunction
function SetTrackableScale takes trackable track,real scale returns nothing
call SetObjectScale(ConvertHandle(track),scale)
endfunction
function SetTrackableScaleEx takes trackable track,real x,real y,real z returns nothing
call SetObjectScaleEx(ConvertHandle(track),x,y,z)
endfunction
function GetTrackableRoll takes trackable track returns real
return GetObjectRoll(ConvertHandle(track))
endfunction
function SetTrackableRoll takes trackable track,real angle returns nothing
call SetObjectRoll(ConvertHandle(track),angle)
endfunction
function GetTrackablePitch takes trackable track returns real
return GetObjectPitch(ConvertHandle(track))
endfunction
function SetTrackablePitch takes trackable track,real angle returns nothing
call SetObjectPitch(ConvertHandle(track),angle)
endfunction
function GetTrackableYaw takes trackable track returns real
return GetObjectYaw(ConvertHandle(track))
endfunction
function GetTrackableFacing takes trackable track returns real
return GetObjectFacing(ConvertHandle(track))
endfunction
function SetTrackableYaw takes trackable track,real angle returns nothing
call SetObjectYaw(ConvertHandle(track),angle)
endfunction
function SetTrackableFacing takes trackable track,real angle returns nothing
call SetObjectFacing(ConvertHandle(track),angle)
endfunction
function SetTrackableSpaceRotation takes trackable track,real yaw,real pitch,real roll returns nothing
call SetObjectSpaceRotation(ConvertHandle(track),yaw,pitch,roll)
endfunction
function SetTrackableOrientation takes trackable track,real yaw,real pitch,real roll returns nothing
call SetObjectOrientation(ConvertHandle(track),yaw,pitch,roll)
endfunction
function ResetTrackableMatrix takes trackable track returns nothing
call ResetObjectMatrix(ConvertHandle(track))
endfunction
function Init_MemHackTrackableAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
elseif PatchVersion=="1.26a" then
elseif PatchVersion=="1.27a" then
elseif PatchVersion=="1.27b" then
elseif PatchVersion=="1.28f" then
endif
endif
endfunction
function SetUIFramePoint takes integer pFrame,integer point,integer pParentFrame,integer relativePoint,real x,real y returns integer
if pFrame!=0 and pParentFrame!=0 then
return SetCLayoutFramePoint(GetFrameLayoutByType(pFrame,GetFrameType(pFrame)),point,GetFrameLayoutByType(pParentFrame,GetFrameType(pParentFrame)),relativePoint,x,y)
endif
return 0
endfunction
function HideUI takes nothing returns nothing
local integer pRootFrame=GetRootFrame()
if pRootFrame!=0 then
call SetUIFramePoint(GetUIUpperButtonBarFrame(),ANCHOR_TOPLEFT,pRootFrame,ANCHOR_TOPLEFT,0.0,1.0)
call SetUIFramePoint(GetUIResourceBarFrame(),ANCHOR_TOPRIGHT,pRootFrame,ANCHOR_TOPRIGHT,0.0,1.0)
call SetUIFramePoint(GetUISimpleConsole(),ANCHOR_TOPLEFT,pRootFrame,ANCHOR_TOPLEFT,10.0,0.0)
call SetUIFramePoint(GetUISimpleConsole(),ANCHOR_TOPRIGHT,pRootFrame,ANCHOR_TOPRIGHT,-10.0,0.0)
call SetUIFramePoint(GetUIPortrait(),ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,1.0,1.0)
call SetUIFramePoint(GetUIMinimap(),ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,1.0,1.0)
call SetUIFramePoint(GetUIPeonBar(),ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,1.0,1.0)
call SetUIFramePoint(GetUIHeroBar(),ANCHOR_TOPLEFT,pRootFrame,ANCHOR_TOPLEFT,0.0,1.0)
call SetUIFramePoint(GetUITimeOfDayIndicator(),ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,1.0,1.0)
call SetUIFramePoint(ReadRealMemory(GetUITimeOfDayIndicator()+0x1B0),ANCHOR_TOP,pRootFrame,ANCHOR_TOP,1.0,0.0)
call SetUIFramePoint(ReadRealMemory(GetUIInfoBar()+0x14C),ANCHOR_BOTTOMRIGHT,pRootFrame,ANCHOR_TOPLEFT,1.0,0.0)
call HideFrame(GetUITimeOfDayIndicator())
endif
endfunction
function ShowUI takes nothing returns nothing
local integer pRootFrame=GetRootFrame()
if pRootFrame!=0 then
call SetUIFramePoint(GetUIUpperButtonBarFrame(),ANCHOR_TOPLEFT,pRootFrame,ANCHOR_TOPLEFT,0.0,0.0)
call SetUIFramePoint(GetUIResourceBarFrame(),ANCHOR_TOPRIGHT,pRootFrame,ANCHOR_TOPRIGHT,0.0,0.0)
call SetUIFramePoint(GetUISimpleConsole(),ANCHOR_TOPLEFT,pRootFrame,ANCHOR_TOPLEFT,0.0,0.0)
call SetUIFramePoint(GetUISimpleConsole(),ANCHOR_TOPRIGHT,pRootFrame,ANCHOR_TOPRIGHT,0.0,0.0)
call SetUIFramePoint(GetUIPortrait(),ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,0.207500,0.030625)
call SetUIFramePoint(GetUIMinimap(),ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,0.009375,0.006875)
call SetUIFramePoint(GetUIPeonBar(),ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,0.003750,0.170000)
call SetUIFramePoint(GetUIHeroBar(),ANCHOR_TOPLEFT,pRootFrame,ANCHOR_TOPLEFT,0.003750,-0.026250)
call SetUIFramePoint(GetUITimeOfDayIndicator(),ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,0.0,0.0)
call SetUIFramePoint(ReadRealMemory(GetUITimeOfDayIndicator()+0x1B0),ANCHOR_TOP,pRootFrame,ANCHOR_TOP,0.0,0.0)
call SetUIFramePoint(ReadRealMemory(GetUIInfoBar()+0x14C),ANCHOR_BOTTOMRIGHT,pRootFrame,ANCHOR_TOPLEFT,-0.200000,0.0)
call ShowFrame(GetUITimeOfDayIndicator())
endif
endfunction
function EditBlackBorders takes real topX,real topY,real botX,real botY returns nothing
local integer pRootFrame=GetRootFrame()
local integer l__pWorldFrameWar3=GetUIWorldFrameWar3()
if pRootFrame!=0 then
call SetUIFramePoint(l__pWorldFrameWar3,ANCHOR_TOPRIGHT,pRootFrame,ANCHOR_TOPRIGHT,topX,topY)
call SetUIFramePoint(l__pWorldFrameWar3,ANCHOR_BOTTOMLEFT,pRootFrame,ANCHOR_BOTTOMLEFT,botX,botY)
endif
endfunction
function HideBlackBorders takes nothing returns nothing
call EditBlackBorders(0.,0.,0.,0.)
endfunction
function ShowBlackBorders takes nothing returns nothing
call EditBlackBorders(0.,-.02,0.,.13)
endfunction
function EditMiniMap takes integer point,real topX,real topY,real botX,real botY returns nothing
local integer pRootFrame=GetRootFrame()
local integer pMiniMapFrame=GetUIMinimap()
if pRootFrame>0 then
call SetUIFramePoint(pMiniMapFrame,ANCHOR_TOPRIGHT,pRootFrame,point,topX,topY)
call SetUIFramePoint(pMiniMapFrame,ANCHOR_BOTTOMLEFT,pRootFrame,point,botX,botY)
endif
endfunction
function HideMiniMap takes nothing returns nothing
local real xMul=.8/ GetWindowWidth()
local real yMul=.6/ GetWindowHeight()
call EditMiniMap(ANCHOR_TOPRIGHT,-2.*xMul+xMul,0.,-2.*xMul,-yMul)
endfunction
function ShowMiniMap takes nothing returns nothing
call EditMiniMap(ANCHOR_BOTTOMLEFT,0.14875,0.145,0.009375,0.006875)
endfunction
function EditCommandBarButton takes integer row,integer column,integer anchor,real offsetX,real offsetY,real width,real height returns nothing
local integer pButtonFrame=GetSkillBarButtonXY(row,column)
local integer pRootFrame=GetRootFrame()
if pButtonFrame>0 then
if width>=0. then
call SetFrameWidth(pButtonFrame,width)
endif
if height>=0. then
call SetFrameHeight(pButtonFrame,height)
endif
call SetUIFramePoint(pButtonFrame,ANCHOR_TOPLEFT,pRootFrame,anchor,offsetX,-offsetY)
endif
endfunction
function EditItemBarButton takes integer buttonId,integer anchor,real offsetX,real offsetY,real width,real height returns nothing
local integer pButtonFrame=GetItemBarButton(buttonId)
local integer pRootFrame=GetRootFrame()
if pButtonFrame>0 then
if width>=0. then
call SetFrameWidth(pButtonFrame,width)
endif
if height>=0. then
call SetFrameHeight(pButtonFrame,height)
endif
call SetUIFramePoint(pButtonFrame,ANCHOR_TOPLEFT,pRootFrame,anchor,offsetX,-offsetY)
endif
endfunction
function EditMinimapButton takes integer buttonId,integer anchor,real offsetX,real offsetY,real width,real height returns nothing
local integer pButtonFrame=GetMinimapButton(buttonId)
local integer pRootFrame=GetRootFrame()
if pButtonFrame>0 then
if width>=0. then
call SetFrameWidth(pButtonFrame,width)
endif
if height>=0. then
call SetFrameHeight(pButtonFrame,height)
endif
call SetUIFramePoint(pButtonFrame,ANCHOR_TOPLEFT,pRootFrame,anchor,offsetX,-offsetY)
endif
endfunction
function EditUpperButtonBarButton takes integer buttonId,integer anchor,real offsetX,real offsetY,real width,real height returns nothing
local integer pButtonFrame=GetUpperButtonBarButton(buttonId)
local integer pRootFrame=GetRootFrame()
if pButtonFrame>0 then
if width>=0. then
call SetFrameWidth(pButtonFrame,width)
endif
if height>=0. then
call SetFrameHeight(pButtonFrame,height)
endif
if buttonId==0 then
call SetUIFramePoint(pButtonFrame,ANCHOR_TOPLEFT,pRootFrame,anchor,offsetX,-offsetY)
else
call SetUIFramePoint(pButtonFrame,ANCHOR_LEFT,pRootFrame,anchor,offsetX,-(offsetY+GetFrameHeight(pButtonFrame)/ 2.))
endif
endif
endfunction
function EditHeroBarButton takes integer buttonId,integer anchor,real offsetX,real offsetY,real width,real height returns nothing
local integer pButtonFrame=GetHeroBarButton(buttonId)
local integer pRootFrame=GetRootFrame()
if pButtonFrame>0 then
if width>=0. then
call SetFrameWidth(pButtonFrame,width)
endif
if height>=0. then
call SetFrameHeight(pButtonFrame,height)
endif
call SetUIFramePoint(pButtonFrame,ANCHOR_TOPLEFT,pRootFrame,anchor,offsetX,-offsetY)
endif
endfunction
function EditHeroBarHealthBar takes integer buttonId,integer anchor,real offsetX,real offsetY,real width,real height returns nothing
local integer pHealthFrame=GetHeroBarHealthBar(buttonId)
local integer pRootFrame=GetRootFrame()
if pHealthFrame>0 then
if width>=0. then
call SetFrameWidth(pHealthFrame,width)
endif
if height>=0. then
call SetFrameHeight(pHealthFrame,height)
endif
call SetUIFramePoint(pHealthFrame,ANCHOR_TOP,pRootFrame,anchor,offsetX+GetFrameWidth(pHealthFrame)/ 2.,-offsetY)
endif
endfunction
function EditHeroBarManaBar takes integer buttonId,integer anchor,real offsetX,real offsetY,real width,real height returns nothing
local integer pManaFrame=GetHeroBarManaBar(buttonId)
local integer pRootFrame=GetRootFrame()
if pManaFrame>0 then
if width>=0. then
call SetFrameWidth(pManaFrame,width)
endif
if height>=0. then
call SetFrameHeight(pManaFrame,height)
endif
call SetUIFramePoint(pManaFrame,ANCHOR_TOP,pRootFrame,anchor,offsetX+GetFrameWidth(pManaFrame)/ 2.,-offsetY)
endif
endfunction
function EditTooltipUber takes integer anchor,real offsetX,real offsetY,real width returns nothing
local integer pTooltipUberFrame=GetTooltipUberFrame()
local integer pRootFrame=GetRootFrame()
if pTooltipUberFrame!=0 then
if width>=0. then
call SetFrameWidth(pTooltipUberFrame,width)
call SetFrameWidth(ReadRealMemory(pTooltipUberFrame+0x180),width)
endif
call SetUIFramePoint(pTooltipUberFrame,ANCHOR_BOTTOMRIGHT,pRootFrame,anchor,offsetX,-offsetY)
endif
endfunction
function ShowAllUI takes nothing returns nothing
call ShowBlackBorders()
call ShowUI()
call ShowMiniMap()
endfunction
function HideAllUI takes nothing returns nothing
call HideBlackBorders()
call HideUI()
call HideMiniMap()
endfunction
function ToggleUI takes nothing returns nothing
set IsGameUIEnabled=not IsGameUIEnabled
if IsGameUIEnabled then
call ShowAllUI()
else
call HideAllUI()
endif
endfunction
function Init_MemHackUIAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
elseif PatchVersion=="1.26a" then
elseif PatchVersion=="1.27a" then
elseif PatchVersion=="1.27b" then
elseif PatchVersion=="1.28f" then
endif
endif
endfunction
function GetUnitBaseDataById takes integer uid returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CUnitBase"),StringHash("DataNode"))
if addr!=0 and uid!=0 then
return GetAgileDataNodeById(addr,uid)
endif
return 0
endfunction
function GetUnitBaseData takes unit u returns integer
return GetUnitBaseDataById(GetUnitTypeId(u))
endfunction
function GetUnitBaseDataByIdCaching takes integer uid returns integer
local integer pUnit=0
if uid>0 then
if HaveSavedInteger(htObjectDataPointers,2,uid)then
return LoadInteger(htObjectDataPointers,2,uid)
endif
set pUnit=GetUnitBaseDataById(uid)
if pUnit>0 then
call SaveInteger(htObjectDataPointers,2,uid,pUnit)
endif
return pUnit
endif
return 0
endfunction
function GetUnitBaseDataCaching takes unit u returns integer
return GetUnitBaseDataByIdCaching(GetUnitTypeId(u))
endfunction
function GetUnitBaseUIDataById takes integer uid returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CUnitBase"),StringHash("UINode"))
if addr!=0 and uid!=0 then
return this_call_1(addr,uid)
endif
return 0
endfunction
function GetUnitBaseUIData takes unit u returns integer
return GetUnitBaseUIDataById(GetUnitTypeId(u))
endfunction
function GetUnitBaseUIDataByIdCaching takes integer uid returns integer
local integer pUnit=0
if uid>0 then
if HaveSavedInteger(htObjectDataPointers,3,uid)then
return LoadInteger(htObjectDataPointers,3,uid)
endif
set pUnit=GetUnitBaseUIDataById(uid)
if pUnit>0 then
call SaveInteger(htObjectDataPointers,3,uid,pUnit)
endif
return pUnit
endif
return 0
endfunction
function GetUnitBaseUIDataCaching takes unit u returns integer
return GetUnitBaseUIDataByIdCaching(GetUnitTypeId(u))
endfunction
function GetUnitBaseUIIntegerParam takes integer uid,integer pointerlevel,integer offset returns integer
return GetWidgetBaseUIIntegerParamById(uid,pointerlevel,offset)
endfunction
function SetUnitBaseUIIntegerParam takes integer uid,integer pointerlevel,integer offset,integer val returns nothing
call SetWidgetBaseUIIntegerParamById(uid,pointerlevel,offset,val)
endfunction
function GetUnitBaseUIStringParam takes integer uid,integer pointerlevel,integer offset returns string
return GetWidgetBaseUIStringParamById(uid,pointerlevel,offset)
endfunction
function SetUnitBaseUIStringParam takes integer uid,integer pointerlevel,integer offset,string val returns nothing
call SetWidgetBaseUIStringParamById(uid,pointerlevel,offset,val)
endfunction
function GetUnitBasePortraitById takes integer uid returns string
local integer pData=0
if uid>0 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
set pData=ReadRealMemory(pData+0x38)
if pData>0 then
return ToJString(pData)
endif
endif
endif
return null
endfunction
function SetUnitBasePortraitById takes integer uid,string model returns nothing
local integer pData=0
if uid>0 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
call WriteNullTerminatedString(model,pData+0x38)
endif
endif
endfunction
function GetUnitBaseMissileArtById takes integer uid,integer index returns string
local integer pData=0
if uid>0 then
if index==0 or index==1 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
set pData=ReadRealMemory(pData+0x44)
if pData>0 then
return ToJString(ReadRealMemory(pData+index*4))
endif
endif
endif
endif
return null
endfunction
function SetUnitBaseMissileArtById takes integer uid,string model,integer index returns nothing
local integer pData=0
if uid>0 then
if index==0 or index==1 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
set pData=ReadRealMemory(pData+0x44)
if pData>0 then
call WriteRealMemory(pData+index*4,GetStringAddress(model))
endif
endif
endif
endif
endfunction
function GetUnitBaseMissileSpeedById takes integer uid,integer index returns real
local integer pData=0
if uid>0 then
if index==0 or index==1 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
set pData=ReadRealMemory(pData+0x64)
if pData>0 then
return ReadRealFloat(pData+index*4)
endif
endif
endif
endif
return-1.
endfunction
function SetUnitBaseMissileSpeedById takes integer uid,integer index,real speed returns nothing
local integer pData=0
if uid>0 then
if index==0 or index==1 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
set pData=ReadRealMemory(pData+0x64)
if pData>0 then
call WriteRealMemory(pData+index*4,SetRealIntoMemory(speed))
endif
endif
endif
endif
endfunction
function GetUnitBaseMissileArcById takes integer uid,integer index returns real
local integer pData=0
if uid>0 then
if index==0 or index==1 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
set pData=ReadRealMemory(pData+0x70)
if pData>0 then
return ReadRealFloat(pData+index*4)
endif
endif
endif
endif
return-1.
endfunction
function SetUnitBaseMissileArcById takes integer uid,integer index,real arc returns nothing
local integer pData=0
if uid>0 then
if index==0 or index==1 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
set pData=ReadRealMemory(pData+0x70)
if pData>0 then
call WriteRealMemory(pData+index*4,SetRealIntoMemory(arc))
endif
endif
endif
endif
endfunction
function GetUnitBaseColorById takes integer uid returns integer
local integer pData=0
if uid>0 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
return ReadRealMemory(pData+0xAC)
endif
endif
return 0
endfunction
function GetUnitBaseModelById takes integer uid returns string
local integer pData=0
if uid>0 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
set pData=ReadRealMemory(pData+0x34)
if pData>0 then
return ToJString(pData)
endif
endif
endif
return null
endfunction
function SetUnitBaseModelById takes integer uid,string model returns nothing
local integer pData=0
if uid>0 then
set pData=GetUnitBaseUIDataByIdCaching(uid)
if pData>0 then
call WriteNullTerminatedString(model,pData+0x34)
endif
endif
endfunction
function GetUnitBaseIconPathById takes integer uid returns string
return GetUnitBaseUIStringParam(uid,1,0x24C)
endfunction
function SetUnitBaseIconPathById takes integer uid,string iconpath returns nothing
call SetUnitBaseUIStringParam(uid,1,0x24C,iconpath)
endfunction
function GetUnitBaseTipById takes integer uid returns string
return GetUnitBaseUIStringParam(uid,1,0x260)
endfunction
function SetUnitBaseTipById takes integer uid,string text returns nothing
call SetUnitBaseUIStringParam(uid,1,0x260,text)
endfunction
function GetUnitBaseUbertipById takes integer uid returns string
return GetUnitBaseUIStringParam(uid,1,0x26C)
endfunction
function SetUnitBaseUbertipById takes integer uid,string text returns nothing
call SetUnitBaseUIStringParam(uid,1,0x26C,text)
endfunction
function GetUnitBaseHotkeyById takes integer uid returns integer
if uid>0 then
if GetUnitBaseUIIntegerParam(uid,0,0x270)>0 or GetUnitBaseUIIntegerParam(uid,0,0x274)>0 then
return GetUnitBaseUIIntegerParam(uid,1,0x278)
endif
endif
return 0
endfunction
function SetUnitBaseHotkeyById takes integer uid,integer key returns nothing
if uid>0 then
call SetUnitBaseUIIntegerParam(uid,0,0x270,1)
call SetUnitBaseUIIntegerParam(uid,0,0x274,key)
call SetUnitBaseUIIntegerParam(uid,1,0x278,key)
endif
endfunction
function GetUnitBaseModel takes unit u returns string
return GetUnitBaseModelById(GetUnitTypeId(u))
endfunction
function SetUnitBaseModel takes unit u,string model returns nothing
call SetUnitBaseModelById(GetUnitTypeId(u),model)
endfunction
function GetUnitBasePortrait takes unit u returns string
return GetUnitBasePortraitById(GetUnitTypeId(u))
endfunction
function SetUnitBasePortrait takes unit u,string model returns nothing
call SetUnitBasePortraitById(GetUnitTypeId(u),model)
endfunction
function GetUnitBaseMissileArt takes unit u,integer index returns string
return GetUnitBaseMissileArtById(GetUnitTypeId(u),index)
endfunction
function SetUnitBaseMissileArt takes unit u,string model,integer index returns nothing
call SetUnitBaseMissileArtById(GetUnitTypeId(u),model,index)
endfunction
function GetUnitBaseMissileSpeed takes unit u,integer index returns real
return GetUnitBaseMissileSpeedById(GetUnitTypeId(u),index)
endfunction
function SetUnitBaseMissileSpeed takes unit u,integer index,real speed returns nothing
call SetUnitBaseMissileSpeedById(GetUnitTypeId(u),index,speed)
endfunction
function GetUnitBaseColor takes unit u returns integer
return GetUnitBaseColorById(GetUnitTypeId(u))
endfunction
function GetUnitBaseIconPath takes unit u returns string
return GetUnitBaseIconPathById(GetUnitTypeId(u))
endfunction
function SetUnitBaseIconPath takes unit u,string iconpath returns nothing
call SetUnitBaseIconPathById(GetUnitTypeId(u),iconpath)
endfunction
function GetUnitBaseTip takes unit u returns string
return GetUnitBaseTipById(GetUnitTypeId(u))
endfunction
function SetUnitBaseTip takes unit u,string text returns nothing
call SetUnitBaseTipById(GetUnitTypeId(u),text)
endfunction
function GetUnitBaseUbertip takes unit u returns string
return GetUnitBaseUbertipById(GetUnitTypeId(u))
endfunction
function SetUnitBaseUbertip takes unit u,string text returns nothing
call SetUnitBaseUbertipById(GetUnitTypeId(u),text)
endfunction
function GetUnitBaseHotkey takes unit u returns integer
return GetUnitBaseHotkeyById(GetUnitTypeId(u))
endfunction
function SetUnitBaseHotkey takes unit u,integer key returns nothing
call SetUnitBaseHotkeyById(GetUnitTypeId(u),key)
endfunction
function GetUnitGoldCostById takes integer uid returns integer
local integer pData=GetUnitBaseDataById(uid)
if pData>0 then
return ReadRealMemory(pData+0x20)
endif
return-1
endfunction
function SetUnitGoldCostById takes integer uid,integer value returns nothing
local integer pData=GetUnitBaseDataById(uid)
if pData>0 and value>=0 then
call WriteRealMemory(pData+0x20,value)
endif
endfunction
function GetUnitLumberCostById takes integer uid returns integer
local integer pData=GetUnitBaseDataById(uid)
if pData>0 then
return ReadRealMemory(pData+0x24)
endif
return-1
endfunction
function SetUnitLumberCostById takes integer uid,integer value returns nothing
local integer pData=GetUnitBaseDataById(uid)
if pData>0 and value>=0 then
call WriteRealMemory(pData+0x24,value)
endif
endfunction
function GetUnitFoodCostById takes integer uid returns integer
local integer pData=GetUnitBaseDataById(uid)
if pData>0 then
return ReadRealMemory(pData+0x5C)
endif
return-1
endfunction
function SetUnitFoodCostById takes integer uid,integer value returns nothing
local integer pData=GetUnitBaseDataById(uid)
if pData>0 and value>=0 then
call WriteRealMemory(pData+0x5C,value)
endif
endfunction
function GetHeroBasePrimaryAttributeById takes integer uid returns integer
local integer pData=GetUnitBaseDataById(uid)
if pData>0 then
return ReadRealMemory(pData+0x17C)
endif
return-1
endfunction
function SetHeroBasePrimaryAttributeById takes integer uid,integer index returns nothing
local integer pData=GetUnitBaseDataById(uid)
if pData>0 then
if index>=0 and index<=2 then
call WriteRealMemory(pData+0x17C,index)
endif
endif
endfunction
function GetUnitCollisionSizeById takes integer uid returns real
local integer pData=GetUnitBaseDataById(uid)
if pData>0 then
return GetRealFromMemory(ReadRealMemory(pData+0x19C))
endif
return-1.234
endfunction
function GetUnitGoldCostEx takes unit u returns integer
return GetUnitGoldCostById(GetUnitTypeId(u))
endfunction
function SetUnitGoldCostEx takes unit u,integer value returns nothing
call SetUnitGoldCostById(GetUnitTypeId(u),value)
endfunction
function GetUnitLumberCost takes unit u returns integer
return GetUnitLumberCostById(GetUnitTypeId(u))
endfunction
function SetUnitLumberCost takes unit u,integer value returns nothing
call SetUnitLumberCostById(GetUnitTypeId(u),value)
endfunction
function GetUnitFoodCost takes unit u returns integer
return GetUnitFoodCostById(GetUnitTypeId(u))
endfunction
function SetUnitFoodCost takes unit u,integer value returns nothing
call SetUnitFoodCostById(GetUnitTypeId(u),value)
endfunction
function GetHeroBasePrimaryAttribute takes unit u returns integer
return GetHeroBasePrimaryAttributeById(GetUnitTypeId(u))
endfunction
function SetHeroBasePrimaryAttribute takes unit u,integer index returns nothing
call SetHeroBasePrimaryAttributeById(GetUnitTypeId(u),index)
endfunction
function GetUnitCollisionSize takes unit u returns real
return GetUnitCollisionSizeById(GetUnitTypeId(u))
endfunction
function Init_MemHackUnitBaseAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("DataNode"),pGameDLL+0xACB2B4)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("UINode"),pGameDLL+0xACC72C)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("GetUnitUIData"),pGameDLL+0x32D3C0)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("DataNode"),pGameDLL+0xAB445C)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("UINode"),pGameDLL+0xAB58D4)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("GetUnitUIData"),pGameDLL+0x32C880)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("DataNode"),pGameDLL+0xBEC470)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("UINode"),pGameDLL+0xBE6114)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("GetUnitUIData"),pGameDLL+0x327020)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("DataNode"),pGameDLL+0xD709D8)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("UINode"),pGameDLL+0xBE6114)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("GetUnitUIData"),pGameDLL+0x344760)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("DataNode"),pGameDLL+0xD38810)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("UINode"),pGameDLL+0xD324B4)
call SaveInteger(MemHackTable,StringHash("CUnitBase"),StringHash("GetUnitUIData"),pGameDLL+0x378720)
endif
endif
endfunction
function CUnitApplyUpgrades takes integer pUnit returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("ApplyUpgrades"))
if addr!=0 and pUnit!=0 then
call this_call_1(addr,pUnit)
endif
endfunction
function CUnitUnapplyUpgrades takes integer pUnit returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("UnapplyUpgrades"))
if addr!=0 and pUnit!=0 then
call this_call_1(addr,pUnit)
endif
endfunction
function CUnitUpdateInfoBar takes integer pUnit returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateInfoBar"))
if addr!=0 and pUnit!=0 then
call this_call_1(addr,pUnit)
endif
endfunction
function CUnitUpdateHeroBar takes integer pUnit,integer unk1 returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateHeroBar"))
if addr!=0 and pUnit!=0 then
call this_call_2(addr,pUnit,unk1)
endif
endfunction
function CUnitRefreshPortraitOnSelect takes integer pUnit,integer unk1 returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshPortraitOnSelect"))
if addr!=0 and pUnit!=0 then
call this_call_2(addr,pUnit,unk1)
endif
endfunction
function CUnitRefreshInfoBarOnSelect takes integer pUnit returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshInforBarOnSelect"))
if addr!=0 and pUnit!=0 then
return this_call_1(addr,pUnit)
endif
return 0
endfunction
function CUnitAddAbilityEx takes integer pUnit,integer aid,boolean checkduplicate returns nothing
local boolean flag=false
if pUnit!=0 and aid!=0 then
if not(checkduplicate and GetUnitAbilityReal(pUnit,aid,0,1,1,1)!=0)then
call CUnitUnapplyUpgrades(pUnit)
set flag=CUnitAddAbility(pUnit,aid)
call CUnitApplyUpgrades(pUnit)
if flag then
call CUnitUpdateInfoBar(pUnit)
endif
endif
endif
endfunction
function CUnitRemoveAbilityEx takes integer pUnit,integer aid,boolean removeduplicates returns nothing
local integer pAbil=0
local boolean flag=false
if pUnit!=0 and aid!=0 then
loop
set pAbil=GetUnitAbilityReal(pUnit,aid,0,1,1,1)
if pAbil!=0 then
set flag=CUnitRemoveAbility(pUnit,pAbil)
if not removeduplicates then
set pAbil=0
endif
endif
exitwhen pAbil==0
endloop
if flag then
call CUnitUpdateInfoBar(pUnit)
endif
endif
endfunction
function CUnitMorphToTypeIdEx takes integer pUnit,integer id,integer unk1,integer unk2,integer unk3,integer unk4,integer unk5,integer unk6,integer unk7,integer unk8,integer unk9 returns boolean
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("MorphToTypeId"))
if addr!=0 and pUnit!=0 then
if ReadRealMemory(pUnit+0x30)!=id then
return this_call_11(addr,pUnit,id,unk1,unk2,unk3,unk4,unk5,unk6,unk7,unk8,unk9)!=0
endif
endif
return false
endfunction
function CUnitMorphToTypeId takes integer pUnit,integer id returns boolean
return CUnitMorphToTypeIdEx(pUnit,id,1282,0,0,2,2,1,0,0,0)
endfunction
function GetUnitTypeIdReal takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealMemory(pData+0x30)
endif
return 0
endfunction
function SetUnitTypeId takes unit u,integer i returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
call WriteRealMemory(pData+0x30,i)
endif
endfunction
function MorphUnitToTypeId takes unit u,integer id returns boolean
return CUnitMorphToTypeId(ConvertHandle(u),id)
endfunction
function UpdateHeroBar takes unit u returns nothing
call CUnitUpdateHeroBar(ConvertHandle(u),0)
endfunction
function RefreshUnitPortraitOnSelect takes unit u returns nothing
call CUnitRefreshPortraitOnSelect(ConvertHandle(u),1)
endfunction
function RefreshUnitInfoBarOnSelect takes unit u returns nothing
call CUnitRefreshInfoBarOnSelect(ConvertHandle(u))
endfunction
function MorphUnitToTypeIdEx takes unit u,integer id returns integer
local integer pUnit=ConvertHandle(u)
if pUnit>0 then
if ReadRealMemory(pUnit+0x30)!=id then
call CUnitMorphToTypeId(pUnit,id)
call CUnitUpdateHeroBar(pUnit,0)
call CUnitRefreshPortraitOnSelect(pUnit,1)
return CUnitRefreshInfoBarOnSelect(pUnit)
endif
endif
return 0
endfunction
function GetHeroNeededXPForLevel takes unit u,integer level returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("GetHeroNeededXP"))
local integer pUnit=ConvertHandle(u)
if addr!=0 and pUnit!=0 then
if IsUnitType(u,UNIT_TYPE_HERO)then
return this_call_2(addr,pUnit,level)
endif
endif
return 0
endfunction
function ApplyUnitUpgrades takes unit u returns nothing
call CUnitApplyUpgrades(ConvertHandle(u))
endfunction
function UnapplyUnitUpgrades takes unit u returns nothing
call CUnitUnapplyUpgrades(ConvertHandle(u))
endfunction
function UpdateUnitInfoBar takes unit u returns nothing
call CUnitUpdateInfoBar(ConvertHandle(u))
endfunction
function AddUnitAbilityEx takes unit u,integer aid,boolean checkduplicate returns nothing
call CUnitAddAbilityEx(ConvertHandle(u),aid,checkduplicate)
endfunction
function RemoveUnitAbilityEx takes unit u,integer aid,boolean removeduplicates returns nothing
call CUnitRemoveAbilityEx(ConvertHandle(u),aid,removeduplicates)
endfunction
function GetHeroNeededXP takes unit u returns integer
return GetHeroNeededXPForLevel(u,GetUnitLevel(u))
endfunction
function GetUnitVertexColour takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealMemory(pData+0x2D4)
endif
return 0
endfunction
function GetUnitVertexColourA takes unit u returns integer
return GetByteFromInteger(GetUnitVertexColour(u),1)
endfunction
function GetUnitVertexColourR takes unit u returns integer
return GetByteFromInteger(GetUnitVertexColour(u),2)
endfunction
function GetUnitVertexColourG takes unit u returns integer
return GetByteFromInteger(GetUnitVertexColour(u),3)
endfunction
function GetUnitVertexColourB takes unit u returns integer
return GetByteFromInteger(GetUnitVertexColour(u),4)
endfunction
function SetUnitModel takes unit u,string model,boolean flag returns nothing
call SetObjectModel(ConvertHandle(u),model,flag)
endfunction
function SetUnitTexture takes unit u,string texturepath,integer textureId returns integer
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("SetReplaceableTexture"))
local integer pUnit=ConvertHandle(u)
local integer pTexture=0
if addr!=0 and pUnit!=0 then
if texturepath!="" then
set pTexture=LoadCBackDropFrameTexture(texturepath,false)
if pTexture>0 and textureId>0 then
return fast_call_3(addr,ReadRealMemory(pUnit+0x28),pTexture,textureId)
endif
endif
endif
return 0
endfunction
function GetUnitImpactZ takes unit u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealFloat(pData+0x228)
endif
return 0.
endfunction
function SetUnitImpactZ takes unit u,real impactZ returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
call WriteRealFloat(pData+0x228,impactZ)
endif
endfunction
function RedrawUnit takes unit u returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("Redraw"))
local integer pData=ConvertHandle(u)
if addr!=0 and pData!=0 then
call this_call_1(addr,pData)
endif
endfunction
function IsAttackDisabled takes unit u returns boolean
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1E8)
if pData>0 then
return ReadRealMemory(pData+0x40)>0
endif
endif
return false
endfunction
function UnitDisableAttack takes unit u returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1E8)
if pData>0 then
call WriteRealMemory(pData+0x40,0)
endif
endif
endfunction
function UnitEnableAttack takes unit u returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1E8)
if pData>0 then
call WriteRealMemory(pData+0x40,1)
endif
endif
endfunction
function GetUnitCritterFlag takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealMemory(pData+0x60)
endif
return-1
endfunction
function SetUnitCritterFlag takes unit u,integer id returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
if id>=0 and id<=1 then
call WriteRealMemory(pData+0x60,id)
endif
endif
endfunction
function GetUnitTimedLife takes unit u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetUnitAbility(u,'BTLF')
if pData>0 then
set pData=ReadRealMemory(pData+0x90)
if pData>0 then
return ReadRealFloat(pData+0x4)
endif
endif
endif
return 0.
endfunction
function SetUnitTimedLife takes unit u,real dur returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetUnitAbility(u,'BTLF')
if pData>0 then
set pData=ReadRealMemory(pData+0x90)
if pData>0 then
call WriteRealFloat(pData+0x4,dur)
endif
endif
endif
endfunction
function SetUnitPhased takes unit u returns nothing
local integer data=GetUnitBaseDataById(GetUnitTypeId(u))+0x1AC
local integer p1=ReadRealMemory(data)
local integer p2=ReadRealMemory(data+0x4)
call WriteRealMemory(data,0x8)
call WriteRealMemory(data+0x4,0x10)
call SetUnitPathing(u,true)
call WriteRealMemory(data,p1)
call WriteRealMemory(data+0x4,p2)
endfunction
function UnitApplySilence takes unit u,boolean flag returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("Silence"))
local integer pUnit=ConvertHandle(u)
if addr!=0 and pUnit!=0 then
call this_call_2(addr,pUnit,B2I(flag))
endif
endfunction
function UnitDisableAbilities takes unit u,boolean flag returns nothing
local integer addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("Pause"))
local integer pUnit=ConvertHandle(u)
if addr!=0 and pUnit!=0 then
call this_call_5(addr,pUnit,1,B2I(flag),0,0)
endif
endfunction
function UnitSetStunFlag takes unit u,boolean add returns nothing
local integer addr=0
local integer pData=ConvertHandle(u)
if pData>0 then
if add then
set addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("Stun"))
if addr!=0 then
call this_call_2(addr,ConvertHandle(u),ConvertHandle(u))
endif
else
set addr=LoadInteger(MemHackTable,StringHash("CUnit"),StringHash("Unstun"))
if addr!=0 then
call this_call_1(addr,ConvertHandle(u))
endif
endif
endif
endfunction
function IsUnitStunned takes unit u returns boolean
local integer pHandle=ConvertHandle(u)
if pHandle>0 then
return ReadRealMemory(pHandle+0x198)>0
endif
return false
endfunction
function UnitApplyStun takes unit u returns nothing
local integer pHandle=ConvertHandle(u)
if pHandle>0 then
call WriteRealMemory(pHandle+0x198,0)
endif
endfunction
function IsUnitMovementDisabled takes unit u returns boolean
local integer pdata=GetHandleId(u)
if pdata>0 then
set pdata=ConvertHandle(u)
if pdata>0 then
set pdata=ReadRealMemory(pdata+0x1EC)
if pdata>0 then
return ReadRealMemory(pdata+0x7C)>0
endif
endif
endif
return false
endfunction
function SetUnitControl takes unit u,integer flagval,integer moveval,integer atackval,integer invval returns nothing
local boolean isFlag=false
local integer pUnit=ConvertHandle(u)
local integer flags=0
local integer Amov=0
local integer Aatk=0
local integer AInv=0
if pUnit>0 then
set flags=ReadRealMemory(pUnit+0x248)
set Aatk=ReadRealMemory(pUnit+0x1E8)
set Amov=ReadRealMemory(pUnit+0x1EC)
set AInv=ReadRealMemory(pUnit+0x1F8)
set isFlag=not IsFlagBitSet(flags,absI(flagval))
if flagval<0 then
set isFlag=not isFlag
endif
if isFlag then
call WriteRealMemory(pUnit+0x248,flags+flagval)
endif
if Amov>0 then
call WriteRealMemory(Amov+0x40,ReadRealMemory(Amov+0x40)+moveval)
endif
if Aatk>0 then
call WriteRealMemory(Aatk+0x40,ReadRealMemory(Aatk+0x40)+atackval)
endif
if AInv>0 then
call WriteRealMemory(AInv+0x3C,ReadRealMemory(AInv+0x3C)+invval)
endif
endif
endfunction
function UnitDisableControl takes unit u returns nothing
call SetUnitControl(u,512,1,1,1)
endfunction
function UnitEnableControl takes unit u returns nothing
call SetUnitControl(u,-512,-1,-1,-1)
endfunction
function UnitRemoveMovementDisables takes unit u returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1EC)
if pData>0 then
call WriteRealMemory(ReadRealMemory(pData+0x1EC)+0x7C,0)
endif
endif
endfunction
function SetUnitMovement takes integer pData,boolean flag returns nothing
if pData>0 then
set pData=ReadRealMemory(pData+0x1EC)
if pData>0 then
call WriteRealMemory(pData+0x7C,B2I(not flag))
endif
endif
endfunction
function UnitEnableMovement takes unit u returns nothing
if u==null then
return
endif
call SetUnitMovement(ConvertHandle(u),false)
endfunction
function UnitDisableMovement takes unit u returns nothing
if u==null then
return
endif
call SetUnitMovement(ConvertHandle(u),true)
endfunction
function UnitDisableMovementEx takes unit u,boolean disable returns nothing
local integer i=2
local integer pData=ConvertHandle(u)
if pData>0 then
if not disable then
set i=1
endif
call PauseUnit(u,true)
set pData=ReadRealMemory(pData+0x1EC)
if pData>0 then
call SetAddressAbilityDisabled(pData,i)
endif
call PauseUnit(u,false)
endif
endfunction
function IsUnitInventoryDisabled takes unit u returns boolean
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1F8)
if pData>0 then
return I2B(ReadRealMemory(pData+0x3C))
endif
endif
return false
endfunction
function UnitEnableInventory takes unit u,boolean flag returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1F8)
if pData>0 then
set pData=pData+0x3C
call WriteRealMemory(pData,B2I(not flag))
endif
endif
endfunction
function GetAddressLocustFlags takes integer pHash1,integer pHash2 returns integer
local integer pObj=GetCObjectFromHash(pHash1,pHash2)
if pObj>0 then
return ReadRealMemory(pObj+0x94)
endif
return 0
endfunction
function SetLocustFlags takes unit u,integer i returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=pData+0x16C
set pData=GetAddressLocustFlags(ReadRealMemory(pData),ReadRealMemory(pData+4))
if pData>0 then
call WriteRealMemory(pData+0x34,i)
endif
endif
endfunction
function UnitEnableTruesightImmunity takes unit u returns nothing
call SetLocustFlags(u,0x08000000)
endfunction
function UnitDisableTruesightImmunity takes unit u returns nothing
call SetLocustFlags(u,0)
endfunction
function GetUnitFlags takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealMemory(pData+0x20)
endif
return 0
endfunction
function SetUnitFlags takes unit u,integer i returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
call WriteRealMemory(pData+0x20,i)
endif
endfunction
function AddUnitFlags takes unit u,integer i returns nothing
call SetUnitFlags(u,GetUnitFlags(u)+i)
endfunction
function GetUnitFlags_2 takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealMemory(pData+0x5C)
endif
return 0
endfunction
function SetUnitFlags_2 takes unit u,integer i returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
call WriteRealMemory(pData+0x5C,i)
endif
endfunction
function AddUnitFlags_2 takes unit u,integer i returns nothing
call SetUnitFlags_2(u,GetUnitFlags_2(u)+i)
endfunction
function GetUnitVisibilityClass takes unit u returns integer
local integer a=ConvertHandle(u)
local integer res=0
if a>0 then
set res=ReadRealMemory(a+0x130)
if res>0 then
set res=GetCAgentFromHash(res,ReadRealMemory(a+0x134))
endif
endif
return res
endfunction
function SetUnitVisibleByPlayer takes unit u,player p,integer c returns nothing
local integer a=GetUnitVisibilityClass(u)
if a>0 then
call WriteRealMemory(a+0x2C+4*GetPlayerId(p),c)
if c>0 and not IsFlagBitSet(ReadRealMemory(a+0x24),Player2Flag(p))then
call WriteRealMemory(a+0x24,ReadRealMemory(a+0x24)+Player2Flag(p))
elseif c==0 and IsFlagBitSet(ReadRealMemory(a+0x24),Player2Flag(p))then
call WriteRealMemory(a+0x24,ReadRealMemory(a+0x24)-Player2Flag(p))
endif
endif
endfunction
function IsUnitInvulnerable takes unit u returns boolean
local integer pData=ConvertHandle(u)
if pData>0 then
return IsFlagBitSet(ReadRealMemory(pData+0x20),8)
endif
return false
endfunction
function GetUnitInvulnerableCounter takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealMemory(pData+0xE8)
endif
return 0
endfunction
function SetUnitInvulnerableCounter takes unit u,integer i returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
call WriteRealMemory(pData+0xE8,i)
endif
endfunction
function ModifyInvulnerableCounter takes unit u,integer diff returns nothing
if u!=null then
call SetUnitInvulnerableCounter(u,GetUnitInvulnerableCounter(u)+diff)
endif
endfunction
function IsUnitInvulnerable2 takes unit u returns boolean
return GetUnitInvulnerableCounter(u)>0
endfunction
function SetUnitFacingEx takes unit u,real facing,boolean isinstant returns nothing
local integer pObject=ConvertHandle(u)
local integer vtable=0
local integer pSmartPos=0
local integer pPosPos=0
local integer arg=LoadInteger(MemHackTable,StringHash("PointerArray"),0)
if pObject!=0 and arg!=0 then
set vtable=ReadRealMemory(pObject)
if vtable!=0 then
set pSmartPos=this_call_1(ReadRealMemory(vtable+0xB8),pObject)
if pSmartPos!=0 then
set pPosPos=GetCObjectFromHashGroup(pSmartPos+0x08)
if pPosPos!=0 then
set vtable=ReadRealMemory(pPosPos)
if vtable!=0 then
set facing=Deg2Rad(facing)
call WriteRealFloat(arg+0x0,facing)
call this_call_2(ReadRealMemory(vtable+0x4C),pPosPos,arg+0x0)
if isinstant then
call this_call_1(ReadRealMemory(vtable+0x58),pPosPos)
endif
endif
endif
endif
endif
endif
endfunction
function SetUnitFacingInstantOld takes unit u,real angle returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0xA0)
if pData>0 then
set pData=ReadRealMemory(pData+0x28)
if pData>0 then
call SetUnitFacing(u,angle)
call WriteRealFloat(pData+0xA4,Deg2Rad(angle))
endif
endif
endif
endfunction
function GetUnitMoveType takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0x16C)
if pData>0 then
set pData=ReadRealMemory(pData+0xA8)
if pData>0 then
return ReadRealMemory(pData+0x9C)
endif
endif
endif
return 0
endfunction
function SetUnitMoveType takes unit u,integer m_type returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0x16C)
if pData>0 then
set pData=ReadRealMemory(pData+0xA8)
if pData>0 then
call WriteRealMemory(pData+0x9C,m_type)
endif
endif
endif
endfunction
function GetHeroPrimaryAttribute takes unit u returns integer
local integer a=ConvertHandle(u)
if a>0 then
set a=ReadRealMemory(a+0x1F0)
if a>0 then
return ReadRealMemory(a+0xCC)
endif
endif
return 0
endfunction
function SetHeroPrimaryAttribute takes unit u,integer i returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
if IsUnitIdType(GetUnitTypeId(u),UNIT_TYPE_HERO)then
set pData=ReadRealMemory(pData+0x1F0)
if pData>0 then
call WriteRealMemory(pData+0xCC,i)
endif
endif
endif
endfunction
function GetUnitAttackAbility takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealMemory(pData+0x1E8)
endif
return 0
endfunction
function SetUnitAttackAbility takes unit u,integer pAddr returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
call WriteRealMemory(pData+0x1E8,pAddr)
endif
endfunction
function GetUnitAttackOffsetValue takes unit u,integer pOff returns integer
local integer pData=GetUnitAttackAbility(u)
if pData>0 then
return ReadRealMemory(pData+pOff)
endif
return 0
endfunction
function GetUnitNextAttackTimestamp takes unit u returns real
local integer pData=GetUnitAttackAbility(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1E4)
if pData>0 then
return ReadRealFloat(pData+0x4)
endif
endif
return-1.
endfunction
function UnitResetAttackCooldown takes unit u returns boolean
local integer pData=GetUnitAttackAbility(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1E4)
if pData>0 then
call WriteRealMemory(pData+0x1E4,0)
return true
endif
endif
return false
endfunction
function UnitNullifyCurrentAttack takes unit u returns string
local integer pData=GetUnitAttackAbility(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1F4)
if pData>0 then
call WriteRealMemory(pData+0x1F4,0)
return"nulled"
else
return"already empty"
endif
else
return"cannot attack"
endif
return"no attack has been found"
endfunction
function AddUnitExtraAttack takes unit u returns boolean
local integer pData=GetUnitAttackAbility(u)
local real attackdelay
if pData>0 then
set pData=ReadRealMemory(pData+0x1E4)
if pData>0 then
set attackdelay=CleanReal(IndexToReal(ReadRealMemory(pData+0x8)))
if attackdelay>0 then
call WriteRealMemory(pData+0x4,CleanInt(RealToIndex(GetUnitNextAttackTimestamp(u)-attackdelay)))
return true
endif
endif
endif
return false
endfunction
function GetUnitAttackTypeByIndex takes unit u,integer index returns integer
if index==0 or index==1 then
return GetUnitAttackOffsetValue(u,0xF4+4*index)
endif
return-1
endfunction
function GetUnitAttackType1 takes unit u returns integer
return GetUnitAttackTypeByIndex(u,0)
endfunction
function GetUnitAttackType2 takes unit u returns integer
return GetUnitAttackTypeByIndex(u,1)
endfunction
function SetUnitAttackOffsetValue takes unit u,integer offset,integer val returns nothing
local integer pData=GetUnitAttackAbility(u)
if pData>0 then
call WriteRealMemory(pData+offset,val)
endif
endfunction
function SetUnitAttackTypeByIndex takes unit u,integer i,integer attacknum returns nothing
call SetUnitAttackOffsetValue(u,0xF4+4*attacknum,i)
endfunction
function SetUnitAttackType1 takes unit u,integer i returns nothing
call SetUnitAttackTypeByIndex(u,i,0)
endfunction
function SetUnitAttackType2 takes unit u,integer i returns nothing
call SetUnitAttackTypeByIndex(u,i,1)
endfunction
function GetUnitWeaponSound takes unit u returns integer
return GetUnitAttackOffsetValue(u,0xE8)
endfunction
function SetUnitWeaponSound takes unit u,integer i returns nothing
call SetUnitAttackOffsetValue(u,0xE8,i)
endfunction
function GetUnitWeaponType takes unit u returns integer
return GetUnitAttackOffsetValue(u,0xDC)
endfunction
function SetUnitWeaponType takes unit u,integer i returns nothing
call SetUnitAttackOffsetValue(u,0xDC,i)
endfunction
function GetUnitBaseDamage takes unit u returns integer
return GetUnitAttackOffsetValue(u,0xA0)
endfunction
function SetUnitBaseDamage takes unit u,integer i returns nothing
call SetUnitAttackOffsetValue(u,0xA0,i)
endfunction
function AddUnitBaseDamage takes unit u,integer bonus returns nothing
call SetUnitBaseDamage(u,GetUnitBaseDamage(u)+bonus)
endfunction
function GetUnitBonusDamage takes unit u returns integer
return GetUnitAttackOffsetValue(u,0xAC)
endfunction
function SetUnitBonusDamage takes unit u,integer i returns nothing
call SetUnitAttackOffsetValue(u,0xAC,i)
endfunction
function AddUnitBonusDamage takes unit u,integer i returns nothing
call SetUnitBonusDamage(u,GetUnitBonusDamage(u)+i)
endfunction
function GetUnitTotalDamage takes unit u returns integer
return GetUnitBaseDamage(u)+GetUnitBonusDamage(u)
endfunction
function GetUnitBaseAttributeDamage takes unit u returns integer
return GetUnitAttackOffsetValue(u,0xA4)
endfunction
function SetUnitBaseAttributeDamage takes unit u,integer i returns nothing
call SetUnitAttackOffsetValue(u,0xA4,i)
endfunction
function GetUnitDamageDicesSideCount takes unit u returns integer
return GetUnitAttackOffsetValue(u,0x94)
endfunction
function SetUnitDamageDicesSideCount takes unit u,integer i returns nothing
call SetUnitAttackOffsetValue(u,0x94,i)
endfunction
function GetUnitDamageDicesCount takes unit u returns integer
return GetUnitAttackOffsetValue(u,0x88)
endfunction
function SetUnitDamageDicesCount takes unit u,integer i returns nothing
call SetUnitAttackOffsetValue(u,0x88,i)
endfunction
function GetUnitAttackRangeByIndex takes unit u,integer index returns real
if index==0 or index==1 then
return GetRealFromMemory(GetUnitAttackOffsetValue(u,0x258+0x24*index))
endif
return 0.
endfunction
function SetUnitAttackRangeByIndex takes unit u,integer index,real range returns nothing
if index==0 or index==1 then
call SetUnitAttackOffsetValue(u,0x258+0x24*index,SetRealIntoMemory(range))
endif
endfunction
function GetUnitAttackRange1 takes unit u returns real
return GetUnitAttackRangeByIndex(u,0)
endfunction
function SetUnitAttackRange1 takes unit u,real range returns nothing
call SetUnitAttackRangeByIndex(u,0,range)
endfunction
function GetUnitAttackRange2 takes unit u returns real
return GetUnitAttackRangeByIndex(u,1)
endfunction
function SetUnitAttackRange2 takes unit u,real range returns nothing
call SetUnitAttackRangeByIndex(u,1,range)
endfunction
function GetUnitBATByIndex takes unit u,integer index returns real
if index==0 or index==1 then
return GetRealFromMemory(GetUnitAttackOffsetValue(u,0x158+0x8*index))
endif
return 0.
endfunction
function SetUnitBATByIndex takes unit u,integer index,real baseas returns nothing
if index==0 or index==1 then
call SetUnitAttackOffsetValue(u,0x158+0x8*index,SetRealIntoMemory(baseas))
endif
endfunction
function GetUnitBAT1 takes unit u returns real
return GetUnitBATByIndex(u,0)
endfunction
function SetUnitBAT1 takes unit u,real baseas returns nothing
call SetUnitBATByIndex(u,0,baseas)
endfunction
function GetUnitBAT2 takes unit u returns real
return GetUnitBATByIndex(u,1)
endfunction
function SetUnitBAT2 takes unit u,real baseas returns nothing
call SetUnitBATByIndex(u,1,baseas)
endfunction
function GetUnitAttackPointByIndex takes unit u,integer index returns real
if index==0 or index==1 then
return GetRealFromMemory(GetUnitAttackOffsetValue(u,0x16C+0x10*index))
endif
return 0.
endfunction
function SetUnitAttackPointByIndex takes unit u,integer index,real atckpoint returns nothing
if index==0 or index==1 then
call SetUnitAttackOffsetValue(u,0x16C+0x10*index,SetRealIntoMemory(atckpoint))
endif
endfunction
function GetUnitAttackPoint1 takes unit u returns real
return GetUnitAttackPointByIndex(u,0)
endfunction
function SetUnitAttackPoint1 takes unit u,real atckpoint returns nothing
call SetUnitAttackPointByIndex(u,0,atckpoint)
endfunction
function GetUnitAttackPoint2 takes unit u returns real
return GetUnitAttackPointByIndex(u,1)
endfunction
function SetUnitAttackPoint2 takes unit u,real atckpoint returns nothing
call SetUnitAttackPointByIndex(u,1,atckpoint)
endfunction
function GetUnitAttackEnabledIndex takes unit u returns integer
return GetUnitAttackOffsetValue(u,0x104)
endfunction
function GetUnitAttackBackswing takes unit u returns real
return GetRealFromMemory(GetUnitAttackOffsetValue(u,0x190))
endfunction
function SetUnitAttackBackswing takes unit u,real backswing returns nothing
call SetUnitAttackOffsetValue(u,0x190,SetRealIntoMemory(backswing))
endfunction
function GetUnitAttackSpeed takes unit u returns real
return GetRealFromMemory(GetUnitAttackOffsetValue(u,0x1B0))
endfunction
function SetUnitAttackSpeed takes unit u,real atckspeed returns nothing
call SetUnitAttackOffsetValue(u,0x1B0,SetRealIntoMemory(atckspeed))
endfunction
function AddUnitAttackSpeed takes unit u,real atckspeed returns nothing
call SetUnitAttackSpeed(u,GetUnitAttackSpeed(u)+atckspeed)
endfunction
function GetUnitAttackDamage takes unit u returns real
local integer dmg=GetUnitDamageDicesCount(u)
local integer spread=GetRandomInt(dmg,dmg*GetUnitDamageDicesSideCount(u))
return I2R(GetUnitBaseDamage(u)+GetUnitBonusDamage(u)+spread)
endfunction
function GetUnitArmourType takes unit u returns integer
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealMemory(pData+0xE4)
endif
return 0
endfunction
function SetUnitArmourType takes unit u,integer id returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
call WriteRealMemory(pData+0xE4,id)
endif
endfunction
function GetUnitArmour takes unit u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealFloat(pData+0xE0)
endif
return 0.
endfunction
function SetUnitArmour takes unit u,real armour returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
call WriteRealFloat(pData+0xE0,armour)
endif
endfunction
function AddUnitArmour takes unit u,real value returns nothing
call SetUnitArmour(u,GetUnitArmour(u)+value)
endfunction
function GetUnitTimeScale takes unit u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
return ReadRealFloat(pData+0x300)
endif
return 0.
endfunction
function GetUnitBaseMoveSpeed takes unit u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1EC)
if pData>0 then
return ReadRealFloat(pData+0x70)
endif
endif
return 0.
endfunction
function GetUnitBonusMoveSpeed takes unit u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1EC)
if pData>0 then
return ReadRealFloat(pData+0x78)
endif
endif
return-1000.
endfunction
function SetUnitBonusMoveSpeed takes unit u,real bonusms returns boolean
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=ReadRealMemory(pData+0x1EC)
if pData>0 then
call WriteRealFloat(pData+0x78,bonusms)
call SetUnitMoveSpeed(u,ReadRealFloat(pData+0x70))
return true
endif
endif
return false
endfunction
function AddUnitBonusMovespeed takes unit u,real bonusms returns nothing
call SetUnitBonusMoveSpeed(u,GetUnitBonusMoveSpeed(u)+bonusms)
endfunction
function GetUnitCurrentSight takes unit u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0x104)
if pData>0 then
return ReadRealFloat(pData+0x78)
endif
endif
return 0.
endfunction
function SetUnitCurrentSight takes unit u,real newsight returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0x104)
if pData>0 then
call UnitAddAbility(u,'AIsi')
call UnitRemoveAbility(u,'AIsi')
call WriteRealFloat(pData+0x78,newsight)
endif
endif
endfunction
function SetUnitMaxLife takes unit u,real newhp returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0xA0)
if pData>0 then
call WriteRealFloat(pData+0x84,newhp)
endif
endif
endfunction
function AddUnitMaxLife takes unit u,real value returns nothing
call SetUnitMaxLife(u,GetUnitState(u,UNIT_STATE_MAX_LIFE)+value)
endfunction
function SetUnitMaxMana takes unit u,real newmp returns nothing
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0xC0)
if pData>0 then
call WriteRealFloat(pData+0x84,newmp)
endif
endif
endfunction
function AddUnitMaxMana takes unit u,real value returns nothing
call SetUnitMaxMana(u,GetUnitState(u,UNIT_STATE_MAX_MANA)+value)
endfunction
function GetWidgetLifeRegen takes widget u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0xA0)
if pData>0 then
return ReadRealFloat(pData+0x7C)
endif
endif
return 0.
endfunction
function GetUnitLifeRegen takes unit u returns real
return GetWidgetLifeRegen(u)
endfunction
function SetUnitLifeRegen takes unit u,real regen returns nothing
local integer pData=ConvertHandle(u)
local real curhp=GetWidgetLife(u)
if pData>0 then
if curhp>0 then
set pData=GetCObjectFromHashGroup(pData+0xA0)
if pData>0 then
call WriteRealFloat(pData+0x7C,regen)
call SetWidgetLife(u,curhp)
endif
endif
endif
endfunction
function AddUnitLifeRegen takes unit u,real regen returns nothing
call SetUnitLifeRegen(u,GetUnitLifeRegen(u)+regen)
endfunction
function GetUnitManaRegen takes unit u returns real
local integer pData=ConvertHandle(u)
if pData>0 then
set pData=GetCObjectFromHashGroup(pData+0xC0)
if pData>0 then
return ReadRealFloat(pData+0x7C)
endif
endif
return 0.
endfunction
function SetUnitManaRegen takes unit u,real regen returns nothing
local integer pData=ConvertHandle(u)
local real curmp=GetUnitState(u,UNIT_STATE_MANA)
if pData>0 then
if curmp>0 then
set pData=GetCObjectFromHashGroup(pData+0xC0)
if pData>0 then
call WriteRealFloat(pData+0x7C,regen)
call SetUnitState(u,UNIT_STATE_MANA,curmp)
endif
endif
endif
endfunction
function AddUnitManaRegen takes unit u,real regen returns nothing
call SetUnitManaRegen(u,GetUnitManaRegen(u)+regen)
endfunction
function Init_MemHackUnitNormalAPI takes nothing returns nothing
if PatchVersion!="" then
if PatchVersion=="1.24e" then
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("vtable"),pGameDLL+0x943A94)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Redraw"),pGameDLL+0x285350)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Silence"),pGameDLL+0x0773A0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Pause"),pGameDLL+0x077420)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Stun"),pGameDLL+0x270420)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Unstun"),pGameDLL+0x283650)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("SetReplaceableTexture"),pGameDLL+0x4D3DE0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("GetHeroNeededXP"),pGameDLL+0x208270)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateInfoBar"),pGameDLL+0x333370)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("MorphToTypeId"),pGameDLL+0x2A2A40)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateHeroBar"),pGameDLL+0x270970)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("ApplyUpgrades"),pGameDLL+0x2B3FC0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UnapplyUpgrades"),pGameDLL+0x2B3FF0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshPortraitOnSelect"),pGameDLL+0x270930)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshInforBarOnSelect"),pGameDLL+0x270940)
elseif PatchVersion=="1.26a" then
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("vtable"),pGameDLL+0x931934)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Redraw"),pGameDLL+0x284830)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Silence"),pGameDLL+0x076770)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Pause"),pGameDLL+0x0767F0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Stun"),pGameDLL+0x2A6440)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Unstun"),pGameDLL+0x282B30)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("SetReplaceableTexture"),pGameDLL+0x4D32E0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("GetHeroNeededXP"),pGameDLL+0x26EB50)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateInfoBar"),pGameDLL+0x332830)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("MorphToTypeId"),pGameDLL+0x2A1F20)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateHeroBar"),pGameDLL+0x26FE50)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("ApplyUpgrades"),pGameDLL+0x2B34A0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UnapplyUpgrades"),pGameDLL+0x2B34D0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshPortraitOnSelect"),pGameDLL+0x26FE10)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshInforBarOnSelect"),pGameDLL+0x26FE20)
elseif PatchVersion=="1.27a" then
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("vtable"),pGameDLL+0xA4A704)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Redraw"),pGameDLL+0x67FB00)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Silence"),pGameDLL+0x471C40)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Pause"),pGameDLL+0x46F180)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Stun"),pGameDLL+0x66B600)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Unstun"),pGameDLL+0x65AE60)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("SetReplaceableTexture"),pGameDLL+0x186F40)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("GetHeroNeededXP"),pGameDLL+0x668050)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateInfoBar"),pGameDLL+0x3598C0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("MorphToTypeId"),pGameDLL+0x653220)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateHeroBar"),pGameDLL+0x67FA80)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("ApplyUpgrades"),pGameDLL+0x6AA8E0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UnapplyUpgrades"),pGameDLL+0x6AD4E0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshPortraitOnSelect"),pGameDLL+0x676610)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshInforBarOnSelect"),pGameDLL+0x676600)
elseif PatchVersion=="1.27b" then
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("vtable"),pGameDLL+0xB77EB0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Redraw"),pGameDLL+0x69D240)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Silence"),pGameDLL+0x48F380)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Pause"),pGameDLL+0x48C8C0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Stun"),pGameDLL+0x688D30)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Unstun"),pGameDLL+0x678590)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("SetReplaceableTexture"),pGameDLL+0x1A4C60)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("GetHeroNeededXP"),pGameDLL+0x685780)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateInfoBar"),pGameDLL+0x377060)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("MorphToTypeId"),pGameDLL+0x670950)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateHeroBar"),pGameDLL+0x69D1C0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("ApplyUpgrades"),pGameDLL+0x6C8020)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UnapplyUpgrades"),pGameDLL+0x6CAC20)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshPortraitOnSelect"),pGameDLL+0x693D40)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshInforBarOnSelect"),pGameDLL+0x693D30)
elseif PatchVersion=="1.28f" then
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("vtable"),pGameDLL+0xB68914)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Redraw"),pGameDLL+0x6D13F0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Silence"),pGameDLL+0x4C3490)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Pause"),pGameDLL+0x4C09D0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Stun"),pGameDLL+0x6BCEC0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("Unstun"),pGameDLL+0x6AC6C0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("SetReplaceableTexture"),pGameDLL+0x1D74F0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("GetHeroNeededXP"),pGameDLL+0x6B9910)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateInfoBar"),pGameDLL+0x3AB170)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("MorphToTypeId"),pGameDLL+0x6A4A80)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UpdateHeroBar"),pGameDLL+0x6D1370)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("ApplyUpgrades"),pGameDLL+0x6FC1D0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("UnapplyUpgrades"),pGameDLL+0x6FEDD0)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshPortraitOnSelect"),pGameDLL+0x6C7F00)
call SaveInteger(MemHackTable,StringHash("CUnit"),StringHash("RefreshInforBarOnSelect"),pGameDLL+0x6C7EF0)
endif
endif
endfunction
function PeriodicDamage__initTypes takes nothing returns nothing
set pd_DamageType[1]="Fire"
set pd_DamageType[2]="Poison"
set pd_DamageType[3]="Cold"
set pd_DamageType[4]="Electro"
set pd_DamageType[4]="Cutting"
endfunction
function s__PeriodicDamage__Damager_Destroy takes integer this returns nothing
call DestroyEffect(s__PeriodicDamage__Damager_eff[this])
call UnitRemoveAbility(s__PeriodicDamage__Damager_target[this],s__PeriodicDamage__Damager_movementAbil[this])
set s__PeriodicDamage__Damager_caster[this]=null
set s__PeriodicDamage__Damager_target[this]=null
set s__PeriodicDamage__Damager_eff[this]=null
call s__PeriodicDamage__Damager_deallocate(this)
endfunction
function PeriodicDamage__MagDamage takes unit caster,unit target,real dmg returns nothing
call UnitDamageTarget(caster,target,dmg,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,null)
endfunction
function PeriodicDamage_DestroyDamagers takes unit target returns nothing
local integer targetID=GetHandleId(target)
local integer index=1
local string Type=""
local integer id=0
local integer dmg
local timer t
loop
set Type=pd_DamageType[index]
exitwhen Type=="" or Type==null
set t=LoadTimerHandle(udg_Hash,targetID,StringHash("PeriodicDamage|"+Type+"|Timer"))
if t!=null then
set id=GetHandleId(t)
set dmg=LoadInteger(udg_Hash,id,StringHash("PeriodicDamage|"+Type+"|Damager"))
if dmg!=0 then
call s__PeriodicDamage__Damager_Destroy(dmg)
endif
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
endif
set index=index+1
endloop
set t=null
endfunction
function DispelPeriodicDamage takes unit target returns nothing
call PeriodicDamage_DestroyDamagers(target)
endfunction
function PeriodicDamage__Timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local string Type=LoadStr(udg_Hash,id,StringHash("PeriodicDamage|Type"))
local integer dmg=LoadInteger(udg_Hash,id,StringHash("PeriodicDamage|"+Type+"|Damager"))
local integer targetID=GetHandleId(s__PeriodicDamage__Damager_target[dmg])
if s__PeriodicDamage__Damager_time[dmg]>0.00 and GetWidgetLife(s__PeriodicDamage__Damager_target[dmg])>0 then
set s__PeriodicDamage__Damager_time[dmg]=s__PeriodicDamage__Damager_time[dmg]-s__PeriodicDamage__Damager_periodic[dmg]
call PeriodicDamage__MagDamage(s__PeriodicDamage__Damager_caster[dmg],s__PeriodicDamage__Damager_target[dmg],s__PeriodicDamage__Damager_damage[dmg])
else
call s__PeriodicDamage__Damager_Destroy(dmg)
call DestroyTimer(t)
call SaveTimerHandle(udg_Hash,targetID,StringHash("PeriodicDamage|"+Type+"|Timer"),null)
call FlushChildHashtable(udg_Hash,id)
endif
set t=null
endfunction
function PeriodicDamage_Start takes string Type,string path,unit caster,unit target,real l__damage,real time,integer movementAbil returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer targetID=GetHandleId(target)
local timer lastTimer=LoadTimerHandle(udg_Hash,targetID,StringHash("PeriodicDamage|"+Type+"|Timer"))
local integer dmg=s__PeriodicDamage__Damager__allocate()
if lastTimer==null then
set s__PeriodicDamage__Damager_movementAbil[dmg]=movementAbil
call UnitAddAbility(target,movementAbil)
set s__PeriodicDamage__Damager_eff[dmg]=AddSpecialEffectTarget(path,target,"chest")
set s__PeriodicDamage__Damager_caster[dmg]=caster
set s__PeriodicDamage__Damager_target[dmg]=target
set s__PeriodicDamage__Damager_damage[dmg]=l__damage/ 5
set s__PeriodicDamage__Damager_periodic[dmg]=0.20
set s__PeriodicDamage__Damager_time[dmg]=time
set s__PeriodicDamage__Damager_Type[dmg]=Type
call SaveTimerHandle(udg_Hash,targetID,StringHash("PeriodicDamage|"+Type+"|Timer"),t)
call SaveStr(udg_Hash,id,StringHash("PeriodicDamage|Type"),Type)
call SaveInteger(udg_Hash,id,StringHash("PeriodicDamage|"+Type+"|Damager"),dmg)
call TimerStart(t,s__PeriodicDamage__Damager_periodic[dmg],true,function PeriodicDamage__Timer)
else
call s__PeriodicDamage__Damager_Destroy(dmg)
set id=GetHandleId(lastTimer)
set dmg=LoadInteger(udg_Hash,id,StringHash("PeriodicDamage|"+Type+"|Damager"))
call UnitRemoveAbility(target,s__PeriodicDamage__Damager_movementAbil[dmg])
set s__PeriodicDamage__Damager_movementAbil[dmg]=movementAbil
call UnitAddAbility(target,movementAbil)
set s__PeriodicDamage__Damager_damage[dmg]=l__damage/ 10
set s__PeriodicDamage__Damager_time[dmg]=time
set s__PeriodicDamage__Damager_caster[dmg]=caster
call SaveInteger(udg_Hash,id,StringHash("PeriodicDamage|"+Type+"|Damager"),dmg)
endif
set t=null
set lastTimer=null
endfunction
function GetUnitHealth takes unit target returns real
return GetUnitState(target,UNIT_STATE_LIFE)
endfunction
function GetUnitMaxHealth takes unit target returns real
return GetUnitState(target,UNIT_STATE_MAX_LIFE)
endfunction
function GetUnitHealthPercent takes unit target returns real
return GetUnitHealth(target)/ GetUnitMaxHealth(target)
endfunction
function SetUnitHealth takes unit target,real health returns nothing
call SetUnitState(target,UNIT_STATE_LIFE,health)
endfunction
function UnitRestoreHealth takes unit target,real health returns nothing
call SetUnitState(target,UNIT_STATE_LIFE,GetUnitHealth(target)+health)
endfunction
function GetUnitMaxMana takes unit target returns real
return GetUnitState(target,UNIT_STATE_MAX_MANA)
endfunction
function GetUnitMana takes unit target returns real
return GetUnitState(target,UNIT_STATE_MANA)
endfunction
function GetUnitManaPercent_new takes unit target returns real
return GetUnitMana(target)/ GetUnitMaxMana(target)
endfunction
function SetUnitMana takes unit target,real mana returns nothing
call SetUnitState(target,UNIT_STATE_MANA,mana)
endfunction
function UnitRestoreMana takes unit target,real mana returns nothing
call SetUnitState(target,UNIT_STATE_MANA,GetUnitMana(target)+mana)
endfunction
function isUnitHero takes unit target returns boolean
return IsUnitType(target,UNIT_TYPE_HERO)
endfunction
function isUnitStruct takes unit target returns boolean
local integer id=GetUnitTypeId(target)
return IsUnitType(target,UNIT_TYPE_STRUCTURE)and id!='n01M' and id!='n01L'
endfunction
function isUnitSummon takes unit target returns boolean
return IsUnitType(target,UNIT_TYPE_SUMMONED)
endfunction
function isUnitJustUnit takes unit target returns boolean
return not isUnitSummon(target)and not isUnitStruct(target)and not isUnitHero(target)
endfunction
function isUnitUndead takes unit target returns boolean
return IsUnitType(target,UNIT_TYPE_UNDEAD)
endfunction
function isUnitMechanical takes unit target returns boolean
return IsUnitType(target,UNIT_TYPE_MECHANICAL)
endfunction
function isPlayerActive takes player target returns boolean
return IsPlayerSlotState(target,PLAYER_SLOT_STATE_PLAYING)
endfunction
function isPlayerActiveUser takes player target returns boolean
return IsPlayerSlotState(target,PLAYER_SLOT_STATE_PLAYING)and GetPlayerController(target)==MAP_CONTROL_USER
endfunction
function GetPlayerGold takes player targetPlayer returns integer
return GetPlayerState(targetPlayer,PLAYER_STATE_RESOURCE_GOLD)
endfunction
function PlayerAddGold takes player targetPlayer,integer gold returns nothing
call SetPlayerState(targetPlayer,PLAYER_STATE_RESOURCE_GOLD,GetPlayerGold(targetPlayer)+gold)
endfunction
function GetPlayerLumber takes player targetPlayer returns integer
return GetPlayerState(targetPlayer,PLAYER_STATE_RESOURCE_LUMBER)
endfunction
function PlayerAddLumber takes player targetPlayer,integer lumber returns nothing
call SetPlayerState(targetPlayer,PLAYER_STATE_RESOURCE_LUMBER,GetPlayerLumber(targetPlayer)+lumber)
endfunction
function mB2S takes boolean var returns string
if var then
return"true"
else
return"false"
endif
endfunction
function mS2B takes string var returns boolean
if var=="true" then
return true
else
return false
endif
endfunction
function RandGoodMess takes nothing returns string
local integer min=1
local integer max=7
local integer i=GetRandomInt(min,max)
local string array mess
set mess[1]="Есть!"
set mess[2]="Сасать!"
set mess[3]="Хохоу, офкос!"
set mess[4]="Изи!"
set mess[5]="Азазазаза!"
set mess[6]="Хихихи!"
set mess[7]="Лёгкая, лёгкая!"
return mess[i]
endfunction
function RandBadMess takes nothing returns string
local integer min=1
local integer max=8
local integer i=GetRandomInt(min,max)
local string array mess
set mess[1]="Ёмаё..."
set mess[2]="Ай ай ай..."
set mess[3]="Ох ты батюшки..."
set mess[4]="Стёпи больше нет..."
set mess[5]="Мама пачиму я хачю умиреть..."
set mess[6]="Вот и помер дед максим..."
set mess[7]="Ек макарек..."
set mess[8]="Саня, ты чо..."
return mess[i]
endfunction
function TextUp takes string s,unit u,real size,integer r,integer g,integer b,integer z,real speed,real life returns nothing
local real vel=speed*0.071/ 128
local real x1=vel*Cos(90.*bj_DEGTORAD)
local real y1=vel*Sin(90.*bj_DEGTORAD)
set bj_lastCreatedTextTag=CreateTextTag()
call SetTextTagText(bj_lastCreatedTextTag,s,(size*0.023)/ 10)
call SetTextTagPosUnit(bj_lastCreatedTextTag,u,z)
call SetTextTagColor(bj_lastCreatedTextTag,r,g,b,25)
call SetTextTagVelocity(bj_lastCreatedTextTag,x1,y1)
call SetTextTagPermanent(bj_lastCreatedTextTag,false)
call SetTextTagLifespan(bj_lastCreatedTextTag,life)
call SetTextTagFadepoint(bj_lastCreatedTextTag,0)
endfunction
function SetTextColor takes string text,string color returns string
local string array colorName
local string array colorCode
local integer index=1
set colorName[1]="hint"
set colorCode[1]="|cffffcc00"
loop
exitwhen colorName[index]=="" or colorName[index]==null
if colorName[index]==color then
return colorCode[index]+text+"|r"
endif
set index=index+1
endloop
return text
endfunction
function Tooltip takes string text,player p returns nothing
local string totalText=SetTextColor("Подсказка","hint")+" "+text
call DisplayTextToPlayer(p,0,0,totalText)
endfunction
function Log takes string text returns nothing
local string totalText="["+SetTextColor("SYSTEM","hint")+"] "+text
call BJDebugMsg(totalText)
endfunction
function s__AbilityLib___TimedAbility_st_Destroy takes integer this returns nothing
call UnitRemoveAbility(s__AbilityLib___TimedAbility_st_target[this],s__AbilityLib___TimedAbility_st_id[this])
call SaveTimer(GetHandleId(s__AbilityLib___TimedAbility_st_target[this]),"TimedAbility | Timer | "+I2S(s__AbilityLib___TimedAbility_st_id[this]),null)
set s__AbilityLib___TimedAbility_st_id[this]=0
set s__AbilityLib___TimedAbility_st_target[this]=null
call s__AbilityLib___TimedAbility_st_deallocate(this)
endfunction
function TimedAbility_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer abil=LoadInt(id,"TimedAbility | Structure")
if s__AbilityLib___TimedAbility_st_time[abil]>0 then
set s__AbilityLib___TimedAbility_st_time[abil]=s__AbilityLib___TimedAbility_st_time[abil]-0.1
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__AbilityLib___TimedAbility_st_Destroy(abil)
endif
set t=null
endfunction
function TimedAbility takes unit target,integer abilID,real time returns nothing
local timer lastAbilTimer=LoadTimer(GetHandleId(target),"TimedAbility | Timer | "+I2S(abilID))
local integer abil=0
local timer t=null
local integer id=0
if lastAbilTimer==null then
set t=CreateTimer()
set id=GetHandleId(t)
set abil=s__AbilityLib___TimedAbility_st__allocate()
set s__AbilityLib___TimedAbility_st_target[abil]=target
set s__AbilityLib___TimedAbility_st_time[abil]=time
set s__AbilityLib___TimedAbility_st_id[abil]=abilID
call UnitAddAbility(target,abilID)
call SaveInt(id,"TimedAbility | Structure",abil)
call SaveTimer(GetHandleId(target),"TimedAbility | Timer | "+I2S(s__AbilityLib___TimedAbility_st_id[abil]),t)
call TimerStart(t,0.1,true,function TimedAbility_remove)
else
set t=lastAbilTimer
set id=GetHandleId(t)
set abil=LoadInt(id,"TimedAbility | Structure")
set s__AbilityLib___TimedAbility_st_time[abil]=time
endif
set t=null
set lastAbilTimer=null
endfunction
function s__AbilityLib___AbilityCooldown_st_Destroy takes integer this returns nothing
call UnitAddAbility(s__AbilityLib___AbilityCooldown_st_target[this],s__AbilityLib___AbilityCooldown_st_id[this])
set s__AbilityLib___AbilityCooldown_st_target[this]=null
call s__AbilityLib___AbilityCooldown_st_deallocate(this)
endfunction
function AbilityCooldown_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer abil=LoadInt(id,"AbilityCooldown | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__AbilityLib___AbilityCooldown_st_Destroy(abil)
set t=null
endfunction
function AbilityCooldown takes unit target,integer abilID,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer abil=s__AbilityLib___AbilityCooldown_st__allocate()
set s__AbilityLib___AbilityCooldown_st_target[abil]=target
set s__AbilityLib___AbilityCooldown_st_id[abil]=abilID
call UnitRemoveAbility(target,s__AbilityLib___AbilityCooldown_st_id[abil])
call SaveInt(id,"AbilityCooldown | Structure",abil)
call TimerStart(t,time,false,function AbilityCooldown_remove)
set t=null
endfunction
function s__Controler_Destroy takes integer this returns nothing
call DestroyEffect(s__Controler_eff[this])
set s__Controler_caster[this]=null
set s__Controler_target[this]=null
set s__Controler_eff[this]=null
call s__Controler_deallocate(this)
endfunction
function DispelControl takes unit target returns nothing
local timer t=LoadTimer(GetHandleId(target),"ControlUnit | Timer")
local integer id=GetHandleId(t)
local integer ctrl=LoadInt(id,"ControlUnit | Controler")
local real x=GetUnitX(s__Controler_target[ctrl])
local real y=GetUnitY(s__Controler_target[ctrl])
local effect eff
if t!=null then
if GetUnitHealth(s__Controler_target[ctrl])>0 then
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl",x,y)
call DestroyEffect(eff)
endif
if GetOwningPlayer(s__Controler_target[ctrl])==GetOwningPlayer(s__Controler_caster[ctrl])then
call SetUnitOwner(s__Controler_target[ctrl],Player(s__Controler_ownerID[ctrl]),true)
endif
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__Controler_Destroy(ctrl)
endif
set t=null
set eff=null
endfunction
function UncontrolUnit takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer ctrl=LoadInt(id,"ControlUnit | Controler")
local real x=GetUnitX(s__Controler_target[ctrl])
local real y=GetUnitY(s__Controler_target[ctrl])
local effect eff
if GetUnitHealth(s__Controler_target[ctrl])>0 then
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl",x,y)
call DestroyEffect(eff)
endif
if GetOwningPlayer(s__Controler_target[ctrl])==GetOwningPlayer(s__Controler_caster[ctrl])then
call SetUnitOwner(s__Controler_target[ctrl],Player(s__Controler_ownerID[ctrl]),true)
endif
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__Controler_Destroy(ctrl)
set t=null
set eff=null
endfunction
function ControlUnit takes unit caster,unit target,real time returns nothing
local timer t=LoadTimer(GetHandleId(target),"ControlUnit | Timer")
local integer id=GetHandleId(t)
local integer ctrl=s__Controler__allocate()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local effect eff=null
if t==null then
set t=CreateTimer()
set id=GetHandleId(t)
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl",x,y)
call DestroyEffect(eff)
set s__Controler_eff[ctrl]=AddSpecialEffectTarget("Abilities\\Spells\\Human\\ManaFlare\\ManaFlareTarget.mdl",target,"overhead")
set s__Controler_ownerID[ctrl]=GetPlayerId(GetOwningPlayer(target))
set s__Controler_caster[ctrl]=caster
set s__Controler_target[ctrl]=target
call SetUnitOwner(target,GetOwningPlayer(caster),true)
call SaveInt(id,"ControlUnit | Controler",ctrl)
call SaveTimer(GetHandleId(target),"ControlUnit | Timer",t)
call TimerStart(t,time,false,function UncontrolUnit)
endif
set t=null
set eff=null
endfunction
function SetEffectHeightByDistance takes effect target,real distance,real maxDistance,real upSpeed returns nothing
local real height=GetEffectZ(target)
local real totalCoef=1.00
local real index=1
loop
exitwhen index>20
if distance>maxDistance*(0.05*index)then
set totalCoef=0.05*index
set totalCoef=(totalCoef*2-1)*-1
else
set index=1000
endif
set index=index+1
endloop
set upSpeed=upSpeed*totalCoef
call SetEffectZ(target,height+upSpeed)
endfunction
function s__EffectsLib__TimedRoundedEffectTarget_st_Destroy takes integer this returns nothing
call DestroyEffect(s__EffectsLib__TimedRoundedEffectTarget_st_eff[this])
set s__EffectsLib__TimedRoundedEffectTarget_st_eff[this]=null
set s__EffectsLib__TimedRoundedEffectTarget_st_target[this]=null
call s__EffectsLib__TimedRoundedEffectTarget_st_deallocate(this)
endfunction
function TimedRoundedEffectTarget_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer ef=LoadInt(id,"RoundedEffect | Structure")
local real x=GetUnitX(s__EffectsLib__TimedRoundedEffectTarget_st_target[ef])
local real y=GetUnitY(s__EffectsLib__TimedRoundedEffectTarget_st_target[ef])
local real x1
local real y1
if s__EffectsLib__TimedRoundedEffectTarget_st_time[ef]>0.00 and GetUnitHealth(s__EffectsLib__TimedRoundedEffectTarget_st_target[ef])>0.00 then
set s__EffectsLib__TimedRoundedEffectTarget_st_time[ef]=s__EffectsLib__TimedRoundedEffectTarget_st_time[ef]-s__EffectsLib__TimedRoundedEffectTarget_st_periodic[ef]
set s__EffectsLib__TimedRoundedEffectTarget_st_angle[ef]=s__EffectsLib__TimedRoundedEffectTarget_st_angle[ef]+s__EffectsLib__TimedRoundedEffectTarget_st_speed[ef]
if s__EffectsLib__TimedRoundedEffectTarget_st_angle[ef]>=360.00 then
set s__EffectsLib__TimedRoundedEffectTarget_st_angle[ef]=s__EffectsLib__TimedRoundedEffectTarget_st_angle[ef]-360.00
endif
call SetEffectFacing(s__EffectsLib__TimedRoundedEffectTarget_st_eff[ef],s__EffectsLib__TimedRoundedEffectTarget_st_angle[ef])
set x1=PolarPoints(x,y,s__EffectsLib__TimedRoundedEffectTarget_st_range[ef],s__EffectsLib__TimedRoundedEffectTarget_st_angle[ef],"x")
set y1=PolarPoints(x,y,s__EffectsLib__TimedRoundedEffectTarget_st_range[ef],s__EffectsLib__TimedRoundedEffectTarget_st_angle[ef],"y")
call SetEffectX(s__EffectsLib__TimedRoundedEffectTarget_st_eff[ef],x1)
call SetEffectY(s__EffectsLib__TimedRoundedEffectTarget_st_eff[ef],y1)
call SetEffectZ(s__EffectsLib__TimedRoundedEffectTarget_st_eff[ef],s__EffectsLib__TimedRoundedEffectTarget_st_height[ef])
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__EffectsLib__TimedRoundedEffectTarget_st_Destroy(ef)
endif
set t=null
endfunction
function TimedRoundedEffectTarget takes string path,unit target,real height,real range,real time returns nothing
local integer ef=s__EffectsLib__TimedRoundedEffectTarget_st__allocate()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
set s__EffectsLib__TimedRoundedEffectTarget_st_target[ef]=target
set s__EffectsLib__TimedRoundedEffectTarget_st_eff[ef]=AddSpecialEffect(path,x,y)
set s__EffectsLib__TimedRoundedEffectTarget_st_range[ef]=range
set s__EffectsLib__TimedRoundedEffectTarget_st_speed[ef]=12.50
set s__EffectsLib__TimedRoundedEffectTarget_st_height[ef]=height
set s__EffectsLib__TimedRoundedEffectTarget_st_time[ef]=time
set s__EffectsLib__TimedRoundedEffectTarget_st_periodic[ef]=0.04
call SaveInt(id,"RoundedEffect | Structure",ef)
call TimerStart(t,s__EffectsLib__TimedRoundedEffectTarget_st_periodic[ef],true,function TimedRoundedEffectTarget_timer)
set t=null
endfunction
function s__EffectsLib__TimedEffectTarget_st_Destroy takes integer this returns nothing
call DestroyEffect(s__EffectsLib__TimedEffectTarget_st_eff[this])
set s__EffectsLib__TimedEffectTarget_st_eff[this]=null
set s__EffectsLib__TimedEffectTarget_st_target[this]=null
call s__EffectsLib__TimedEffectTarget_st_deallocate(this)
endfunction
function TimedEffectTarget_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer eff=LoadInt(id,"TimedEffectTarget | Structure")
if s__EffectsLib__TimedEffectTarget_st_time[eff]>0.00 and GetUnitHealth(s__EffectsLib__TimedEffectTarget_st_target[eff])>0.405 then
set s__EffectsLib__TimedEffectTarget_st_time[eff]=s__EffectsLib__TimedEffectTarget_st_time[eff]-s__EffectsLib__TimedEffectTarget_st_periodic[eff]
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__EffectsLib__TimedEffectTarget_st_Destroy(eff)
endif
set t=null
endfunction
function TimedEffectTarget takes string path,unit target,string attach,real time returns effect
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer e=s__EffectsLib__TimedEffectTarget_st__allocate()
set s__EffectsLib__TimedEffectTarget_st_target[e]=target
set s__EffectsLib__TimedEffectTarget_st_eff[e]=AddSpecialEffectTarget(path,target,attach)
set s__EffectsLib__TimedEffectTarget_st_time[e]=time
set s__EffectsLib__TimedEffectTarget_st_periodic[e]=0.1
call SaveInt(id,"TimedEffectTarget | Structure",e)
call TimerStart(t,s__EffectsLib__TimedEffectTarget_st_periodic[e],true,function TimedEffectTarget_remove)
set t=null
return s__EffectsLib__TimedEffectTarget_st_eff[e]
endfunction
function s__EffectsLib__TimedEffect_st_Destroy takes integer this returns nothing
call DestroyEffect(s__EffectsLib__TimedEffect_st_eff[this])
set s__EffectsLib__TimedEffect_st_eff[this]=null
call s__EffectsLib__TimedEffect_st_deallocate(this)
endfunction
function TimedEffect_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer eff=LoadInt(id,"TimedEffect | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__EffectsLib__TimedEffect_st_Destroy(eff)
set t=null
endfunction
function TimedEffect takes string path,real x,real y,real time returns effect
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer Effect=s__EffectsLib__TimedEffect_st__allocate()
set s__EffectsLib__TimedEffect_st_eff[Effect]=AddSpecialEffect(path,x,y)
call SaveInt(id,"TimedEffect | Structure",Effect)
call TimerStart(t,time,false,function TimedEffect_remove)
set t=null
return s__EffectsLib__TimedEffect_st_eff[Effect]
endfunction
function s__EffectsLib__DestroyLightningN_st_Destroy takes integer this returns nothing
call DestroyLightning(s__EffectsLib__DestroyLightningN_st_light[this])
set s__EffectsLib__DestroyLightningN_st_light[this]=null
call s__EffectsLib__DestroyLightningN_st_deallocate(this)
endfunction
function DestroyLightningN_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer ln=LoadInt(id,"DestroyLightningN | Structure")
if s__EffectsLib__DestroyLightningN_st_percent[ln]<100 then
set s__EffectsLib__DestroyLightningN_st_percent[ln]=s__EffectsLib__DestroyLightningN_st_percent[ln]+1
call SetLightningColor(s__EffectsLib__DestroyLightningN_st_light[ln],GetLightningColorR(s__EffectsLib__DestroyLightningN_st_light[ln]),GetLightningColorG(s__EffectsLib__DestroyLightningN_st_light[ln]),GetLightningColorB(s__EffectsLib__DestroyLightningN_st_light[ln]),PercentTo255(1.00-(I2R(s__EffectsLib__DestroyLightningN_st_percent[ln])/ 100.00)))
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__EffectsLib__DestroyLightningN_st_Destroy(ln)
endif
set t=null
endfunction
function DestroyLightningN takes lightning light,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer ln=s__EffectsLib__DestroyLightningN_st__allocate()
set s__EffectsLib__DestroyLightningN_st_periodic[ln]=time/ 100.00
set s__EffectsLib__DestroyLightningN_st_light[ln]=light
call SaveInt(id,"DestroyLightningN | Structure",ln)
call TimerStart(t,s__EffectsLib__DestroyLightningN_st_periodic[ln],true,function DestroyLightningN_timer)
set t=null
endfunction
function s__EffectsLib__TimedRageEffectDestroy_st_Destroy takes integer this returns nothing
set s__EffectsLib__TimedRageEffectDestroy_st_target[this]=null
call s__EffectsLib__TimedRageEffectDestroy_st_deallocate(this)
endfunction
function s__EffectsLib__TimedRageEffect_st_Destroy takes integer this returns nothing
set s__EffectsLib__TimedRageEffect_st_percent[this]=0
set s__EffectsLib__TimedRageEffect_st_target[this]=null
call s__EffectsLib__TimedRageEffect_st_deallocate(this)
endfunction
function EffectsLib__TimedRageEffect_destroyTimer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer rj=LoadInt(id,"TimedRageEffect | Structure")
local integer color=0
local real percent
local real size
if s__EffectsLib__TimedRageEffect_st_percent[rj]<100 then
set s__EffectsLib__TimedRageEffect_st_percent[rj]=s__EffectsLib__TimedRageEffect_st_percent[rj]+1
set percent=0.5+(I2R(s__EffectsLib__TimedRageEffect_st_percent[rj])/ 100)/ 2
set size=1.00+(0.5-(I2R(s__EffectsLib__TimedRageEffect_st_percent[rj])/ 100)/ 2)
set color=PercentTo255(percent*100)
call SetUnitScale(s__EffectsLib__TimedRageEffect_st_target[rj],size,size,size)
call SetUnitVertexColor(s__EffectsLib__TimedRageEffect_st_target[rj],255,color,color,255)
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__EffectsLib__TimedRageEffect_st_Destroy(rj)
endif
set t=null
endfunction
function EffectsLib__TimedRageEffect_destroy takes nothing returns nothing
local timer t=GetExpiredTimer()
local timer changeTimer=CreateTimer()
local integer id=GetHandleId(changeTimer)
local integer rj=s__EffectsLib__TimedRageEffect_st__allocate()
local integer drj=LoadInt(GetHandleId(t),"TimedRageEffectDestroy | Structure")
set s__EffectsLib__TimedRageEffect_st_periodic[rj]=s__EffectsLib__TimedRageEffectDestroy_st_changeTime[drj]/ 100.00
set s__EffectsLib__TimedRageEffect_st_target[rj]=s__EffectsLib__TimedRageEffectDestroy_st_target[drj]
call SaveInt(id,"TimedRageEffect | Structure",rj)
call TimerStart(changeTimer,s__EffectsLib__TimedRageEffect_st_periodic[rj],true,function EffectsLib__TimedRageEffect_destroyTimer)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,GetHandleId(t))
call s__EffectsLib__TimedRageEffectDestroy_st_Destroy(drj)
set t=null
set changeTimer=null
endfunction
function EffectsLib__TimedRageEffect_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer rj=LoadInt(id,"TimedRageEffect | Structure")
local integer color=0
local real percent
local real size
if s__EffectsLib__TimedRageEffect_st_percent[rj]<100 then
set s__EffectsLib__TimedRageEffect_st_percent[rj]=s__EffectsLib__TimedRageEffect_st_percent[rj]+1
set percent=0.5+(1.00-(I2R(s__EffectsLib__TimedRageEffect_st_percent[rj])/ 100.00))/ 2
set size=1.00+((I2R(s__EffectsLib__TimedRageEffect_st_percent[rj])/ 100)/ 2)
set color=PercentTo255(percent*100)
call SetUnitScale(s__EffectsLib__TimedRageEffect_st_target[rj],size,size,size)
call SetUnitVertexColor(s__EffectsLib__TimedRageEffect_st_target[rj],255,color,color,255)
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__EffectsLib__TimedRageEffect_st_Destroy(rj)
endif
set t=null
endfunction
function TimedRageEffect takes unit target,real time,real changeTime returns nothing
local timer destroyTimer=CreateTimer()
local timer changeTimer=CreateTimer()
local integer rj=s__EffectsLib__TimedRageEffect_st__allocate()
local integer drj=s__EffectsLib__TimedRageEffectDestroy_st__allocate()
set s__EffectsLib__TimedRageEffect_st_periodic[rj]=changeTime/ 100.00
set s__EffectsLib__TimedRageEffect_st_target[rj]=target
call SaveInt(GetHandleId(changeTimer),"TimedRageEffect | Structure",rj)
call TimerStart(changeTimer,s__EffectsLib__TimedRageEffect_st_periodic[rj],true,function EffectsLib__TimedRageEffect_timer)
set s__EffectsLib__TimedRageEffectDestroy_st_time[drj]=time
set s__EffectsLib__TimedRageEffectDestroy_st_target[drj]=target
set s__EffectsLib__TimedRageEffectDestroy_st_changeTime[drj]=changeTime
call SaveInt(GetHandleId(destroyTimer),"TimedRageEffectDestroy | Structure",drj)
call TimerStart(destroyTimer,s__EffectsLib__TimedRageEffectDestroy_st_time[drj],false,function EffectsLib__TimedRageEffect_destroy)
set changeTimer=null
set destroyTimer=null
endfunction
function RangeEffect_start takes unit target,real x,real y,real range,real time returns nothing
local player owner=GetOwningPlayer(target)
local string effectPath=""
local effect eff
local real x1
local real y1
local integer count=GetCountOfPointsInCircle(range)
local real angle=360.00/ count
if GetLocalPlayer()==owner then
set effectPath="Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl"
endif
loop
exitwhen count==0
set x1=PolarPoints(x,y,range,angle*count,"x")
set y1=PolarPoints(x,y,range,angle*count,"y")
call TimedEffect(effectPath,x1,y1,time)
set count=count-1
endloop
set eff=null
endfunction
function CreatePentagram_circle takes nothing returns nothing
local timer pentaTimer=GetExpiredTimer()
local integer timerID=GetHandleId(pentaTimer)
local effect pentaEffect
local real array pentaX
local real array pentaY
local integer i=1
local integer count=LoadInteger(udg_Hash,timerID,StringHash("Pentagram | Circle | Count"))
local real range=LoadReal(udg_Hash,timerID,StringHash("Pentagram | Circle | Range"))
local real angle=LoadReal(udg_Hash,timerID,StringHash("Pentagram | Circle | Angle"))
local string model=LoadStr(udg_Hash,timerID,StringHash("Pentagram | Circle | Model"))
local integer pentaID=LoadInteger(udg_Hash,timerID,StringHash("Pentagram | ID"))
local integer index=LoadInteger(udg_Hash,pentaID,StringHash("Pentagram | Index"))
local real x=LoadReal(udg_Hash,timerID,StringHash("Pentagram | Circle | X"))
local real y=LoadReal(udg_Hash,timerID,StringHash("Pentagram | Circle | Y"))
if count>0 then
set x=PolarPoints(x,y,range,angle*index,"x")
set y=PolarPoints(x,y,range,angle*index,"y")
set pentaEffect=AddSpecialEffect(model,x,y)
call SaveEffectHandle(udg_Hash,pentaID,StringHash("Pentagram | Effect"+I2S(index)),pentaEffect)
call SaveInteger(udg_Hash,pentaID,StringHash("Pentagram | Index"),index+1)
call SaveInteger(udg_Hash,timerID,StringHash("Pentagram | Circle | Count"),count-1)
else
call DestroyTimer(pentaTimer)
call FlushChildHashtable(udg_Hash,timerID)
endif
set pentaTimer=null
set pentaEffect=null
endfunction
function CreatePentagram takes integer pentaID,real x,real y,real range,string model returns nothing
local timer pentaTimer=CreateTimer()
local integer timerID=GetHandleId(pentaTimer)
local integer effectIndex=1
local effect pentaEffect
local real array pentaX
local real array pentaY
local integer lines=0
local integer index=1
local integer line=0
local real effectX
local real effectY
local real pangle
local real x1
local real y1
local real pentaAngle=360/ el_PENTA_LINES
local real pentaFragDist=range/ el_PENTA_LINES/ 2
local integer pentaCircleCount=R2I(range/ el_PENTA_LINES*1.0)
local real pentaCirlcleAngle=360/ pentaCircleCount*1.15
loop
exitwhen index>5
set pentaX[index]=PolarPoints(x,y,range,pentaAngle*index,"x")
set pentaY[index]=PolarPoints(x,y,range,pentaAngle*index,"y")
set index=index+1
endloop
set index=1
loop
exitwhen index>5
set line=index+2
if line>5 then
set line=line-5
endif
set lines=R2I(PointsDistance(pentaX[index],pentaY[index],pentaX[line],pentaY[line])/ pentaFragDist)
set pangle=PointsAngle(pentaX[index],pentaY[index],pentaX[line],pentaY[line])
set x1=pentaX[index]
set y1=pentaY[index]
loop
exitwhen lines==0
set effectX=PolarPoints(x1,y1,pentaFragDist,pangle,"x")
set effectY=PolarPoints(x1,y1,pentaFragDist,pangle,"y")
set pentaEffect=AddSpecialEffect(model,effectX,effectY)
call SaveEffectHandle(udg_Hash,pentaID,StringHash("Pentagram | Effect"+I2S(effectIndex)),pentaEffect)
set effectIndex=effectIndex+1
set x1=effectX
set y1=effectY
set lines=lines-1
endloop
set index=index+1
endloop
call SaveInteger(udg_Hash,timerID,StringHash("Pentagram | Circle | Count"),pentaCircleCount+1)
call SaveInteger(udg_Hash,pentaID,StringHash("Pentagram | Index"),effectIndex+1)
call SaveReal(udg_Hash,timerID,StringHash("Pentagram | Circle | Range"),range)
call SaveReal(udg_Hash,timerID,StringHash("Pentagram | Circle | Angle"),pentaCirlcleAngle)
call SaveStr(udg_Hash,timerID,StringHash("Pentagram | Circle | Model"),model)
call SaveInteger(udg_Hash,timerID,StringHash("Pentagram | ID"),pentaID)
call SaveReal(udg_Hash,timerID,StringHash("Pentagram | Circle | X"),x)
call SaveReal(udg_Hash,timerID,StringHash("Pentagram | Circle | Y"),y)
call TimerStart(pentaTimer,0.04,true,function CreatePentagram_circle)
set pentaTimer=null
set pentaEffect=null
endfunction
function DestroyPentaBlock takes nothing returns nothing
local timer pentaTimer=GetExpiredTimer()
local integer id=LoadInteger(udg_Hash,GetHandleId(pentaTimer),StringHash("Pentagram | Id"))
local integer index=LoadInteger(udg_Hash,id,StringHash("Pentagram | Index"))
local effect pentaEffect=LoadEffectHandle(udg_Hash,id,StringHash("Pentagram | Effect"+I2S(index)))
if index>0 then
call DestroyEffect(pentaEffect)
call SaveInteger(udg_Hash,id,StringHash("Pentagram | Index"),index-1)
else
call DestroyTimer(pentaTimer)
call FlushChildHashtable(udg_Hash,GetHandleId(pentaTimer))
call FlushChildHashtable(udg_Hash,id)
endif
set pentaEffect=null
set pentaTimer=null
endfunction
function DestroyPentagram takes integer id returns nothing
local timer pentaTimer=CreateTimer()
call SaveInteger(udg_Hash,GetHandleId(pentaTimer),StringHash("Pentagram | ID"),id)
call TimerStart(pentaTimer,0.04,true,function DestroyPentaBlock)
set pentaTimer=null
endfunction
function s__KydesnikLib__Portals_st_Destroy takes integer this returns nothing
call KillUnit(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[this]])
call KillUnit(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[this]+1])
set s__KydesnikLib__Portals_st_caster[this]=null
set s__KydesnikLib__Portals_st_target[this]=null
set s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[this]]=null
set s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[this]+1]=null
call s__KydesnikLib__Portals_st_deallocate(this)
endfunction
function s__KydesnikLib__Summons_st_Destroy takes integer this returns nothing
local integer ndx=0
loop
exitwhen ndx>12
set s___KydesnikLib__Summons_st_unitID[s__KydesnikLib__Summons_st_unitID[this]+ndx]=0
set ndx=ndx+1
endloop
call s__KydesnikLib__Summons_st_deallocate(this)
endfunction
function KydesnikPortals_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer portals=LoadInt(id,"KydesnikPortals | Structure")
local integer index=0
local effect eff
local unit dummy
local real angle
local real x
local real y
if s__KydesnikLib__Portals_st_limit[portals]>s__KydesnikLib__Portals_st_index[portals]then
if s___KydesnikLib__Portals_st_unitID[s__KydesnikLib__Portals_st_unitID[portals]+s__KydesnikLib__Portals_st_index[portals]]==0 then
set s___KydesnikLib__Portals_st_unitID[s__KydesnikLib__Portals_st_unitID[portals]+s__KydesnikLib__Portals_st_index[portals]]='n02A'
endif
loop
exitwhen index==2
call SetUnitTimeScale(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]+index],1)
set x=GetUnitX(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]+index])
set y=GetUnitY(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]+index])
set angle=GetUnitFacing(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]+index])
set dummy=CreateUnit(GetOwningPlayer(s__KydesnikLib__Portals_st_caster[portals]),s___KydesnikLib__Portals_st_unitID[s__KydesnikLib__Portals_st_unitID[portals]+s__KydesnikLib__Portals_st_index[portals]],x,y,angle)
if s__KydesnikLib__Portals_st_target[portals]==null then
call IssuePointOrder(dummy,"attack",s__KydesnikLib__Portals_st_targetX[portals],s__KydesnikLib__Portals_st_targetY[portals])
else
call IssueTargetOrder(dummy,"attack",s__KydesnikLib__Portals_st_target[portals])
endif
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",dummy,"origin")
call DestroyEffect(eff)
set index=index+1
endloop
set s__KydesnikLib__Portals_st_index[portals]=s__KydesnikLib__Portals_st_index[portals]+1
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__KydesnikLib__Portals_st_Destroy(portals)
endif
set t=null
set eff=null
set dummy=null
endfunction
function KydesnikPortals_Actions takes nothing returns nothing
local real targetX=GetSpellTargetX()
local real targetY=GetSpellTargetY()
local unit target=GetSpellTargetUnit()
local unit caster=GetTriggerUnit()
local real unitX=GetUnitX(caster)
local real unitY=GetUnitY(caster)
local integer summons=LoadInt(GetHandleId(caster),"KydesnikSummons | Structure")
local integer lvl=GetUnitAbilityLevel(caster,'A0GN')
local integer portals=s__KydesnikLib__Portals_st__allocate()
local real facing=PointsAngle(unitX,unitY,targetX,targetY)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer index=0
local real angle
local real x
local real y
local real periodic=2-(0.25*(lvl-1))
local real portalsRange=200.00
local integer limit=2+(2*lvl)
if summons==0 then
set summons=s__KydesnikLib__Summons_st__allocate()
endif
if s__KydesnikLib__Summons_st_limit[summons]!=limit then
set s__KydesnikLib__Summons_st_limit[summons]=limit
endif
loop
exitwhen index>s__KydesnikLib__Summons_st_limit[summons]
set s___KydesnikLib__Portals_st_unitID[s__KydesnikLib__Portals_st_unitID[portals]+index]=s___KydesnikLib__Summons_st_unitID[s__KydesnikLib__Summons_st_unitID[summons]+index]
set index=index+1
endloop
set x=PolarPoints(unitX,unitY,portalsRange,facing+90,"x")
set y=PolarPoints(unitX,unitY,portalsRange,facing+90,"y")
set angle=PointsAngle(x,y,targetX,targetY)
set s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]]=CreateUnit(GetOwningPlayer(caster),'h03M',x,y,angle)
call SetUnitAnimation(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]],"birth")
call SetUnitTimeScale(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]],4)
set x=PolarPoints(unitX,unitY,portalsRange,facing-90,"x")
set y=PolarPoints(unitX,unitY,portalsRange,facing-90,"y")
set angle=PointsAngle(x,y,targetX,targetY)
set s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]+1]=CreateUnit(GetOwningPlayer(caster),'h03M',x,y,angle)
call SetUnitAnimation(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]+1],"birth")
call SetUnitTimeScale(s___KydesnikLib__Portals_st_portal[s__KydesnikLib__Portals_st_portal[portals]+1],4)
set s__KydesnikLib__Portals_st_caster[portals]=caster
set s__KydesnikLib__Portals_st_target[portals]=target
set s__KydesnikLib__Portals_st_limit[portals]=s__KydesnikLib__Summons_st_limit[summons]
set s__KydesnikLib__Portals_st_targetX[portals]=targetX
set s__KydesnikLib__Portals_st_targetY[portals]=targetY
set s__KydesnikLib__Portals_st_periodic[portals]=periodic
call SaveInt(id,"KydesnikPortals | Structure",portals)
call s__KydesnikLib__Summons_st_Destroy(summons)
call SaveInt(GetHandleId(caster),"KydesnikSummons | Structure",0)
call TimerStart(t,s__KydesnikLib__Portals_st_periodic[portals],true,function KydesnikPortals_timer)
set t=null
set target=null
set caster=null
endfunction
function KydesnikSummons_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetHandleId(caster)
local integer portalsLvl=GetUnitAbilityLevel(caster,'A0GN')
local integer summons=LoadInt(id,"KydesnikSummons | Structure")
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local integer abilID=GetSpellAbilityId()
local integer unitID=0
local string s
local integer limit=2+(2*portalsLvl)
if abilID=='A0GT' then
set unitID='n027'
call SetPlayerTechResearched(GetOwningPlayer(caster),'R04Y',lvl-1)
elseif abilID=='A0I8' then
set unitID='n029'
call SetPlayerTechResearched(GetOwningPlayer(caster),'R04Z',lvl-1)
elseif abilID=='A0I9' then
set unitID='n028'
call SetPlayerTechResearched(GetOwningPlayer(caster),'R050',lvl-1)
endif
if summons==0 then
set summons=s__KydesnikLib__Summons_st__allocate()
endif
if s__KydesnikLib__Summons_st_limit[summons]!=limit then
set s__KydesnikLib__Summons_st_limit[summons]=limit
endif
if s__KydesnikLib__Summons_st_limit[summons]>s__KydesnikLib__Summons_st_index[summons]then
set s___KydesnikLib__Summons_st_unitID[s__KydesnikLib__Summons_st_unitID[summons]+s__KydesnikLib__Summons_st_index[summons]]=unitID
set s__KydesnikLib__Summons_st_index[summons]=s__KydesnikLib__Summons_st_index[summons]+1
if GetLocalPlayer()==GetOwningPlayer(caster)then
set s=I2S(s__KydesnikLib__Summons_st_index[summons])+" / "+I2S(s__KydesnikLib__Summons_st_limit[summons])
call TextUp(s,caster,10,0,255,0,0,96.00,2.00)
endif
else
call DisplayTextToPlayer(GetOwningPlayer(caster),0,0,"|cffffcc90Подсказка:|r Лимит исчерпан!")
endif
call SaveInt(id,"KydesnikSummons | Structure",summons)
set caster=null
endfunction
function KydesnikPortals_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0GN'
endfunction
function KydesnikSummons_Conditions takes nothing returns boolean
local integer id=GetSpellAbilityId()
return id=='A0GT' or id=='A0I8' or id=='A0I9'
endfunction
function InitTriggers takes nothing returns nothing
local trigger portals=CreateTrigger()
local trigger summon=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(portals,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(portals,Condition(function KydesnikPortals_Conditions))
call TriggerAddAction(portals,function KydesnikPortals_Actions)
call TriggerRegisterAnyUnitEventBJ(summon,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(summon,Condition(function KydesnikSummons_Conditions))
call TriggerAddAction(summon,function KydesnikSummons_Actions)
endfunction
function isUnitEnemy takes unit caster,unit target returns boolean
return IsUnitEnemy(caster,GetOwningPlayer(target))
endfunction
function isUnitAlly takes unit caster,unit target returns boolean
return IsUnitAlly(caster,GetOwningPlayer(target))
endfunction
function isUnitAlive takes unit target returns boolean
return GetWidgetLife(target)>0.405
endfunction
function ClearDamage takes unit caster,unit target,real dmg returns nothing
call UnitDamageTarget(caster,target,dmg,true,true,ATTACK_TYPE_CHAOS,DAMAGE_TYPE_UNIVERSAL,null)
endfunction
function MagDamage takes unit caster,unit target,real dmg returns nothing
call UnitDamageTarget(caster,target,dmg,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,null)
endfunction
function Owner takes unit target returns player
return GetOwningPlayer(target)
endfunction
function OwnerId takes unit target returns integer
return GetPlayerId(Owner(target))
endfunction
function isUnitDummy takes unit caster returns boolean
return GetUnitAbilityLevel(caster,'A0DQ')>0
endfunction
function isUnitRange takes unit caster returns boolean
return GetUnitAttackRange1(caster)>=250.00 or GetUnitAttackRange2(caster)>=250.00
endfunction
function isUnitFlying takes unit caster returns boolean
return GetUnitMoveType(caster)==67108868
endfunction
function GetUnitMagicResistEx takes unit u,integer resistType returns real
local integer pData=ConvertHandle(u)
local integer pAbil=0
local integer pDefData=0
local integer baseid=0
local real r_temp=0.
local real runic_resist=0.
local real elune_resist=0.
local real total_resist=0.
if pData!=0 then
set pAbil=GetCAgentFromHashGroup(pData+0x1DC)
if pAbil!=0 then
loop
exitwhen pAbil==0
if pAbil!=0 then
set pData=ReadRealMemory(pAbil+0x54)
if pData!=0 then
set baseid=ReadRealMemory(pData+0x30)
if baseid=='AIdd' or baseid=='AIsr' then
set pDefData=GetAbilityBaseDefData(ReadRealMemory(pAbil+0x34),ReadRealMemory(pAbil+0x50))
if baseid=='AIdd' then
if elune_resist==0. then
set elune_resist=ReadRealFloat(pDefData+0x30)
else
set elune_resist=elune_resist*ReadRealFloat(pDefData+0x30)
endif
elseif baseid=='AIsr' then
set r_temp=ReadRealFloat(pDefData+0x24)
if r_temp>runic_resist then
set runic_resist=r_temp
endif
endif
endif
endif
endif
set pAbil=GetCAgentFromHashGroup(pAbil+0x24)
endloop
endif
endif
if elune_resist>0. then
if runic_resist>0. then
set total_resist=1.-(elune_resist)*(1.-runic_resist)
else
set total_resist=1.-elune_resist
endif
else
if runic_resist>0 then
set total_resist=runic_resist
endif
endif
if resistType==1 then
return runic_resist
elseif resistType==2 then
return 1.-elune_resist
endif
return total_resist
endfunction
function GetUnitMagicResist takes unit u returns real
return GetUnitMagicResistEx(u,0)
endfunction
function isUnitBack takes unit target,unit caster returns boolean
local real r1=bj_RADTODEG*Atan2(GetUnitY(target)-GetUnitY(caster),GetUnitX(target)-GetUnitX(caster))+360.00
local real r2=GetUnitFacing(target)+360.00
if GetUnitY(target)<GetUnitY(caster)then
set r1=r1+360.00
endif
return(r1<=(r2+45.00)and r1>=(r2-45.00))
endfunction
function CreateSummon takes player owner,integer unitid,real x,real y,real angle,real lifetime returns unit
set bj_lastCreatedUnit=CreateUnit(owner,unitid,x,y,angle)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',lifetime)
call SetUnitAnimation(bj_lastCreatedUnit,"birth")
return bj_lastCreatedUnit
endfunction
function UnitTag takes unit caster returns string
local integer id=GetUnitPointValue(caster)
local string s="Other"
if(id==1000)then
set s="undead"
elseif(id==1001)then
set s="wizard"
elseif(id==1002)then
set s="summon"
elseif id==1003 then
set s="mercenary"
elseif id==1011 then
set s="block_talants"
endif
set caster=null
return s
endfunction
function GetUnitItemCountById takes unit target,integer id returns integer
local integer index=0
local integer count=0
loop
exitwhen index>5
if GetItemTypeId(UnitItemInSlot(target,index))==id then
set count=count+1
endif
set index=index+1
endloop
return count
endfunction
function UnitRemoveItemById takes unit target,integer id returns nothing
local integer index=0
local integer count=0
local item itm
loop
exitwhen index>5
set itm=UnitItemInSlot(target,index)
if GetItemTypeId(itm)==id then
call RemoveItem(itm)
set itm=null
return
endif
set index=index+1
endloop
set itm=null
endfunction
function HealUnit takes unit target,real hp,boolean isPercent returns nothing
local real currentHealth=GetUnitHealth(target)
local real maxHealth=GetUnitMaxHealth(target)
local string s=""
local effect eff
if hp>0 and currentHealth!=maxHealth then
if isPercent then
set hp=hp*maxHealth
endif
set s="+"+R2SW(hp,0,2)+" hp"
if maxHealth<hp then
set hp=maxHealth
set currentHealth=0
endif
call SetUnitHealth(target,currentHealth+hp)
call TextUpRand(s,target,6,0,255,0,0,96.00,1.00)
call TimedEffectTarget("Abilities\\Spells\\Human\\Feedback\\SpellBreakerAttack.mdl",target,"origin",1.00)
endif
set eff=null
endfunction
function HP_RESTORE takes unit caster,real HP,string MESS_HP,real size,integer r,integer g,integer b,integer z,real speed,real time returns nothing
local real Hp=GetUnitState(caster,UNIT_STATE_LIFE)
local real MaxHp=GetUnitState(caster,UNIT_STATE_MAX_LIFE)
if(HP>0)then
if(MaxHp<HP)then
set HP=MaxHp
set Hp=0
endif
call SetUnitState(caster,UNIT_STATE_LIFE,Hp+HP)
endif
if(MESS_HP!=null)then
if(GetLocalPlayer()==GetOwningPlayer(caster))then
call TextUp(MESS_HP,caster,size,r,g,b,z,speed,time)
endif
endif
endfunction
function MP_RESTORE takes unit caster,real MP,string MESS_MP,real size,integer r,integer g,integer b,integer z,real speed,real time returns nothing
local real Mp=GetUnitState(caster,UNIT_STATE_MANA)
local real MaxMp=GetUnitState(caster,UNIT_STATE_MAX_MANA)
if(MP>0)then
if(MaxMp<MP)then
set MP=MaxMp
set Mp=0
endif
call SetUnitState(caster,UNIT_STATE_MANA,Mp+MP)
endif
if(MESS_MP!=null)then
if(GetLocalPlayer()==GetOwningPlayer(caster))then
call TextUp(MESS_MP,caster,size,r,g,b,z,speed,time)
endif
endif
endfunction
function s__UnitSpawner_st_Destroy takes integer this returns nothing
set s__UnitSpawner_st_caster[this]=null
call s__UnitSpawner_st_deallocate(this)
endfunction
function UnitSpawner_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer st=LoadInt(id,"UnitSpawner | Structure")
local real x=GetUnitX(s__UnitSpawner_st_caster[st])
local real y=GetUnitY(s__UnitSpawner_st_caster[st])
local real angle=GetUnitFacing(s__UnitSpawner_st_caster[st])
if s__UnitSpawner_st_caster[st]!=null then
if GetUnitState(s__UnitSpawner_st_caster[st],UNIT_STATE_LIFE)>0 then
call CreateUnit(GetOwningPlayer(s__UnitSpawner_st_caster[st]),s__UnitSpawner_st_unitID[st],x,y,angle)
endif
else
call s__UnitSpawner_st_Destroy(st)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
endif
set t=null
endfunction
function UnitSpawner_start takes unit caster,integer unitID,real periodic returns nothing
local integer st=s__UnitSpawner_st__allocate()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
set s__UnitSpawner_st_caster[st]=caster
set s__UnitSpawner_st_unitID[st]=unitID
call SaveInt(id,"UnitSpawner | Structure",st)
call TimerStart(t,periodic,true,function UnitSpawner_timer)
set t=null
endfunction
function s__UnitLib__TimedInvul_st_Destroy takes integer this returns nothing
call SetUnitInvulnerable(s__UnitLib__TimedInvul_st_target[this],false)
set s__UnitLib__TimedInvul_st_target[this]=null
call s__UnitLib__TimedInvul_st_deallocate(this)
endfunction
function TimedInvul_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer invul=LoadInt(id,"TimedInvul | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__UnitLib__TimedInvul_st_Destroy(invul)
set t=null
endfunction
function TimedInvul takes unit target,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer invul=s__UnitLib__TimedInvul_st__allocate()
set s__UnitLib__TimedInvul_st_target[invul]=target
call SetUnitInvulnerable(s__UnitLib__TimedInvul_st_target[invul],true)
call SaveInt(id,"TimedInvul | Structure",invul)
call TimerStart(t,time,false,function TimedInvul_remove)
set t=null
endfunction
function s__UnitLib__TimedMpRegen_st_Destroy takes integer this returns nothing
call AddUnitManaRegen(s__UnitLib__TimedMpRegen_st_target[this],-s__UnitLib__TimedMpRegen_st_regen[this])
set s__UnitLib__TimedMpRegen_st_target[this]=null
call s__UnitLib__TimedMpRegen_st_deallocate(this)
endfunction
function UnitLib__TimedMpRegen_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer mpr=LoadInt(id,"TimedMpRegen | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__UnitLib__TimedMpRegen_st_Destroy(mpr)
set t=null
endfunction
function TimedMpRegen takes unit target,real regen,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer mpr=s__UnitLib__TimedMpRegen_st__allocate()
set s__UnitLib__TimedMpRegen_st_target[mpr]=target
set s__UnitLib__TimedMpRegen_st_regen[mpr]=regen
call AddUnitManaRegen(s__UnitLib__TimedMpRegen_st_target[mpr],regen)
call SaveInt(id,"TimedMpRegen | Structure",mpr)
call TimerStart(t,time,false,function UnitLib__TimedMpRegen_remove)
set t=null
endfunction
function s__UnitLib__TimedHpRegen_st_Destroy takes integer this returns nothing
call AddUnitLifeRegen(s__UnitLib__TimedHpRegen_st_target[this],-s__UnitLib__TimedHpRegen_st_regen[this])
set s__UnitLib__TimedHpRegen_st_target[this]=null
call s__UnitLib__TimedHpRegen_st_deallocate(this)
endfunction
function UnitLib__TimedHpRegen_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer hpr=LoadInt(id,"TimedHpRegen | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__UnitLib__TimedHpRegen_st_Destroy(hpr)
set t=null
endfunction
function TimedHpRegen takes unit target,real regen,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer hpr=s__UnitLib__TimedHpRegen_st__allocate()
set s__UnitLib__TimedHpRegen_st_target[hpr]=target
set s__UnitLib__TimedHpRegen_st_regen[hpr]=regen
call AddUnitLifeRegen(s__UnitLib__TimedHpRegen_st_target[hpr],regen)
call SaveInt(id,"TimedHpRegen | Structure",hpr)
call TimerStart(t,time,false,function UnitLib__TimedHpRegen_remove)
set t=null
endfunction
function s__UnitLib__TimedArmor_st_Destroy takes integer this returns nothing
call AddUnitArmour(s__UnitLib__TimedArmor_st_target[this],-s__UnitLib__TimedArmor_st_armor[this])
set s__UnitLib__TimedArmor_st_target[this]=null
call s__UnitLib__TimedArmor_st_deallocate(this)
endfunction
function UnitLib__TimedArmor_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer arm=LoadInt(id,"TimedArmor | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__UnitLib__TimedArmor_st_Destroy(arm)
set t=null
endfunction
function TimedArmor takes unit target,real armor,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer arm=s__UnitLib__TimedArmor_st__allocate()
set s__UnitLib__TimedArmor_st_target[arm]=target
set s__UnitLib__TimedArmor_st_armor[arm]=armor
call AddUnitArmour(s__UnitLib__TimedArmor_st_target[arm],armor)
call SaveInt(id,"TimedArmor | Structure",arm)
call TimerStart(t,time,false,function UnitLib__TimedArmor_remove)
set t=null
endfunction
function s__UnitLib__TimedDamage_st_Destroy takes integer this returns nothing
call AddUnitBonusDamage(s__UnitLib__TimedDamage_st_target[this],-s__UnitLib__TimedDamage_st_damage[this])
set s__UnitLib__TimedDamage_st_damage[this]=0
set s__UnitLib__TimedDamage_st_target[this]=null
call s__UnitLib__TimedDamage_st_deallocate(this)
endfunction
function UnitLib__TimedDamage_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer dmg=LoadInt(id,"TimedDamage | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__UnitLib__TimedDamage_st_Destroy(dmg)
set t=null
endfunction
function TimedDamage takes unit target,integer l__damage,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer dmg=s__UnitLib__TimedDamage_st__allocate()
set s__UnitLib__TimedDamage_st_target[dmg]=target
set s__UnitLib__TimedDamage_st_damage[dmg]=l__damage
call AddUnitBonusDamage(target,l__damage)
call SaveInt(id,"TimedDamage | Structure",dmg)
call TimerStart(t,time,false,function UnitLib__TimedDamage_remove)
set t=null
endfunction
function s__UnitLib__TimedPause_st_Destroy takes integer this returns nothing
call PauseUnit(s__UnitLib__TimedPause_st_target[this],false)
set s__UnitLib__TimedPause_st_target[this]=null
call s__UnitLib__TimedPause_st_deallocate(this)
endfunction
function TimedPause_remove takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer pause=LoadInt(id,"TimedPause | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__UnitLib__TimedPause_st_Destroy(pause)
set t=null
endfunction
function TimedPause takes unit target,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer pause=s__UnitLib__TimedPause_st__allocate()
set s__UnitLib__TimedPause_st_target[pause]=target
call PauseUnit(s__UnitLib__TimedPause_st_target[pause],true)
call SaveInt(id,"TimedPause | Structure",pause)
call TimerStart(t,time,false,function TimedPause_remove)
set t=null
endfunction
function s__UnitLib__ReplaceAfterTime_st_Destroy takes integer this returns nothing
local real x=GetUnitX(s__UnitLib__ReplaceAfterTime_st_target[this])
local real y=GetUnitY(s__UnitLib__ReplaceAfterTime_st_target[this])
local real angle=GetUnitFacing(s__UnitLib__ReplaceAfterTime_st_target[this])
call RemoveUnit(s__UnitLib__ReplaceAfterTime_st_target[this])
call CreateUnit(GetOwningPlayer(s__UnitLib__ReplaceAfterTime_st_target[this]),s__UnitLib__ReplaceAfterTime_st_id[this],x,y,angle)
set s__UnitLib__ReplaceAfterTime_st_target[this]=null
call s__UnitLib__ReplaceAfterTime_st_deallocate(this)
endfunction
function ReplaceAfterTime_replace takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer replace=LoadInt(id,"ReplaceAfterTime | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__UnitLib__ReplaceAfterTime_st_Destroy(replace)
set t=null
endfunction
function ReplaceAfterTime takes unit target,integer unitID,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer replace=s__UnitLib__ReplaceAfterTime_st__allocate()
set s__UnitLib__ReplaceAfterTime_st_target[replace]=target
set s__UnitLib__ReplaceAfterTime_st_id[replace]=unitID
call SaveInt(id,"ReplaceAfterTime | Structure",replace)
call TimerStart(t,time,false,function ReplaceAfterTime_replace)
set t=null
endfunction
function s__UnitLib__OwnerAfterTime_st_Destroy takes integer this returns nothing
call SetUnitOwner(s__UnitLib__OwnerAfterTime_st_target[this],s__UnitLib__OwnerAfterTime_st_casterPlayer[this],true)
set s__UnitLib__OwnerAfterTime_st_target[this]=null
call s__UnitLib__OwnerAfterTime_st_deallocate(this)
endfunction
function OwnerAfterTime_own takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer owner=LoadInt(id,"OwnerAfterTime | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__UnitLib__OwnerAfterTime_st_Destroy(owner)
set t=null
endfunction
function OwnerAfterTime takes unit caster,unit target,real time returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer owner=s__UnitLib__OwnerAfterTime_st__allocate()
set s__UnitLib__OwnerAfterTime_st_target[owner]=target
set s__UnitLib__OwnerAfterTime_st_casterPlayer[owner]=GetOwningPlayer(caster)
call SaveInt(id,"OwnerAfterTime | Structure",owner)
call TimerStart(t,time,false,function OwnerAfterTime_own)
set t=null
endfunction
function isUnitSilenced takes unit target returns boolean
return GetUnitAbilityLevel(target,'BNsi')>0
endfunction
function GetUnitOwnerId takes unit target returns integer
return GetPlayerId(GetOwningPlayer(target))
endfunction
function PauseAllUnits takes nothing returns nothing
local group g=CreateGroup()
local unit dummy
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,null)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
call PauseUnit(dummy,true)
call GroupRemoveUnit(g,dummy)
endloop
call DestroyGroup(g)
set g=null
set dummy=null
endfunction
function UnpauseAllUnits takes nothing returns nothing
local group g=CreateGroup()
local unit dummy
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,null)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
call PauseUnit(dummy,false)
call GroupRemoveUnit(g,dummy)
endloop
call DestroyGroup(g)
set g=null
set dummy=null
endfunction
function HealAlliesAroundUnit_filter takes nothing returns boolean
return IsUnitAlly(bj_caster,GetOwningPlayer(GetFilterUnit()))and GetUnitHealth(GetFilterUnit())>0.00 and GetFilterUnit()!=bj_caster and not isUnitStruct(GetFilterUnit())
endfunction
function HealAlliesAroundUnit takes unit caster,real range,real heal returns nothing
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group ug=CreateGroup()
local boolexpr filter=null
local unit target=null
local effect eff=null
local string s
set bj_caster=caster
set filter=Condition(function HealAlliesAroundUnit_filter)
call GroupEnumUnitsInRange(ug,x,y,range,filter)
loop
set target=FirstOfGroup(ug)
exitwhen target==null
set s=("+"+I2S(R2I(heal))+" hp")
call TextUpRand(s,target,6,0,255,0,0,96.00,1.00)
call HP_RESTORE(target,heal,"",10.00,0,255,0,0,96.00,0.75)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\Feedback\\SpellBreakerAttack.mdl",target,"origin")
call DestroyEffect(eff)
call GroupRemoveUnit(ug,target)
endloop
call DestroyBoolExpr(filter)
call DestroyGroup(ug)
set ug=null
set eff=null
set filter=null
set target=null
set caster=null
endfunction
function VipLib___InitNames takes nothing returns nothing
set VIP_NAMES[1]="loliconshik3"
set VIP_NAMES[2]="Ram"
set VIP_NAMES[3]="Daniil1"
set VIP_NAMES[4]="ImNoobTarenas"
set VIP_NAMES[5]="ValeraVarulli"
set VIP_NAMES[6]="Fortnite2281338"
set VIP_NAMES[7]="ruswirex"
set VIP_NAMES[8]="i_luzer"
set VIP_NAMES[9]="sdlvt"
endfunction
function isPlayerHasVip takes player target returns boolean
return VIP_ACCESS[GetPlayerId(target)+1]
endfunction
function VipAccess takes nothing returns nothing
local integer index=0
local integer ndx=1
call VipLib___InitNames()
loop
exitwhen index>5
set PLAYER_NAMES[index+1]=GetPlayerName(Player(index))
set VIP_ACCESS[index+1]=false
set ndx=1
loop
exitwhen VIP_NAMES[ndx]=="" or VIP_NAMES[ndx]==null
if VIP_NAMES[ndx]==PLAYER_NAMES[index+1]then
set VIP_ACCESS[index+1]=true
call PlayerAddLumber(Player(index),990)
if PLAYER_NAMES[index+1]!="loliconshik3" then
call SetPlayerName(Player(index),"[VIP] "+PLAYER_NAMES[index+1])
endif
endif
set ndx=ndx+1
endloop
set index=index+1
endloop
endfunction
function EndLib___Victory takes player target returns nothing
call CustomVictoryBJ(target,true,true)
endfunction
function EndLib___Defeat takes player target returns nothing
call CustomDefeatBJ(target,"О нет, вы проиграли!")
endfunction
function EndLib___GetCastleCount takes nothing returns integer
local integer castleCount=0
local integer index=0
loop
exitwhen index>5
if isPlayerHasCastle(Player(index))then
set castleCount=castleCount+1
endif
set index=index+1
endloop
return castleCount
endfunction
function EndLib___GetFirstTeamCount takes nothing returns integer
local integer count=0
local integer i=0
loop
exitwhen i>2
if isPlayerHasCastle(Player(i))and isPlayerActiveUser(Player(i))then
set count=count+1
endif
set i=i+1
endloop
return count
endfunction
function EndLib___GetSecondTeamCount takes nothing returns integer
local integer count=0
local integer i=3
loop
exitwhen i>5
if isPlayerHasCastle(Player(i))and isPlayerActiveUser(Player(i))then
set count=count+1
endif
set i=i+1
endloop
return count
endfunction
function EndLib___DestroyPlayer takes unit target returns boolean
local group g=CreateGroup()
local player owner=GetOwningPlayer(target)
local integer id=GetPlayerId(owner)
local integer index=0
set g=GetUnitsOfPlayerMatching(owner,null)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call KillUnit(target)
call GroupRemoveUnit(g,target)
endloop
if REJIME=="ffa" and udg_Hero[id+1]==null then
call CreateFogModifierRectBJ(true,owner,FOG_OF_WAR_VISIBLE,bj_mapInitialPlayableArea)
endif
set udg_Castle[id+1]=null
call DestroyGroup(g)
set g=null
set target=null
return true
endfunction
function EndLib___GameEnd takes nothing returns nothing
local integer castleCount=EndLib___GetCastleCount()
local integer fteamCount=EndLib___GetFirstTeamCount()
local integer steamCount=EndLib___GetSecondTeamCount()
local integer index=0
if REJIME=="ffa" then
if castleCount==1 then
loop
exitwhen index>5
if isPlayerHasCastle(Player(index))then
call EndLib___Victory(Player(index))
else
call EndLib___Defeat(Player(index))
endif
set index=index+1
endloop
endif
elseif REJIME=="teams" then
if castleCount>0 then
if fteamCount==0 then
call EndLib___Victory(Player(3))
call EndLib___Victory(Player(4))
call EndLib___Victory(Player(5))
call EndLib___Defeat(Player(0))
call EndLib___Defeat(Player(1))
call EndLib___Defeat(Player(2))
elseif steamCount==0 then
call EndLib___Victory(Player(0))
call EndLib___Victory(Player(1))
call EndLib___Victory(Player(2))
call EndLib___Defeat(Player(3))
call EndLib___Defeat(Player(4))
call EndLib___Defeat(Player(5))
endif
endif
endif
endfunction
function EndLib___GameEnd_Dest takes nothing returns nothing
local boolean destroyed=EndLib___DestroyPlayer(GetTriggerUnit())
call EndLib___GameEnd()
endfunction
function EndLib___Leaver_Actions takes nothing returns nothing
local player leaver=GetTriggerPlayer()
local integer gold=GetPlayerState(leaver,PLAYER_STATE_RESOURCE_GOLD)
local integer ally_counter=0
local integer i=0
loop
exitwhen i>5
call DisplayTextToPlayer(Player(i),0,0,"|cffffcc00"+GetPlayerName(leaver)+"|r вышел из игры!")
if IsPlayerAlly(leaver,Player(i))==true then
call SetPlayerAllianceStateBJ(leaver,Player(i),bj_ALLIANCE_ALLIED_ADVUNITS)
call SetPlayerAllianceStateBJ(Player(i),leaver,bj_ALLIANCE_ALLIED_ADVUNITS)
set ally_counter=ally_counter+1
endif
set i=i+1
endloop
set i=0
call PlayerAddGold(leaver,-gold)
set gold=gold/ ally_counter
loop
exitwhen i>5
if IsPlayerAlly(leaver,Player(i))==true and leaver!=Player(i)then
call PlayerAddGold(Player(i),gold)
endif
set i=i+1
endloop
call TriggerSleepAction(1.00)
call EndLib___GameEnd()
set leaver=null
endfunction
function EndLib___GameEnd_Condition takes nothing returns boolean
local unit caster=GetTriggerUnit()
local integer id=OwnerId(GetTriggerUnit())+1
local boolean bool=caster==udg_Castle[id]or(isPlayerHasTitan(Owner(caster))and caster==udg_Hero[id])
set caster=null
return bool
endfunction
function EndLib___InitTrigs takes nothing returns nothing
local trigger end=CreateTrigger()
local integer i=0
local trigger t=CreateTrigger()
loop
exitwhen i>11
call TriggerRegisterPlayerEvent(t,Player(i),EVENT_PLAYER_LEAVE)
set i=i+1
endloop
call TriggerAddAction(t,function EndLib___Leaver_Actions)
set t=null
call TriggerAddCondition(end,Condition(function EndLib___GameEnd_Condition))
call TriggerRegisterAnyUnitEventBJ(end,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddAction(end,function EndLib___GameEnd_Dest)
endfunction
function s__HeroRespawnLib___HeroRespawn_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__HeroRespawnLib___HeroRespawn_st_t[this])
call FlushChildHashtable(udg_Hash,id)
call DestroyTimer(s__HeroRespawnLib___HeroRespawn_st_t[this])
call DestroyTimerDialog(s__HeroRespawnLib___HeroRespawn_st_td[this])
set s__HeroRespawnLib___HeroRespawn_st_caster[this]=null
set s__HeroRespawnLib___HeroRespawn_st_killer[this]=null
call s__HeroRespawnLib___HeroRespawn_st_deallocate(this)
endfunction
function HeroRespawnLib___HeroRes_Dalbaeb takes unit caster returns nothing
local player pp=GetOwningPlayer(caster)
local integer lvl=GetPlayerTechCount(pp,'R028',true)
local integer i=GetPlayerId(pp)+1
local integer gold=25
local string s
if lvl==1 then
call AdjustPlayerStateBJ(gold,pp,PLAYER_STATE_RESOURCE_GOLD)
if GetLocalPlayer()==pp then
set s="+"+I2S(gold)+" gold"
call TextUp(s,caster,11,0,255,0,60,96.00,2.00)
endif
endif
set udg_Dalbaeb[i]=udg_Dalbaeb[i]+1
if udg_Dalbaeb[i]>=10 and lvl==0 then
call AchievUnlocked(pp,6,'R028')
endif
endfunction
function HeroRespawnLib___HeroRes_Limit takes unit caster returns nothing
local player pp=GetOwningPlayer(caster)
local integer i=GetPlayerId(pp)+1
local string s
if udg_Castle[i]==null and HeroRes[i]<MaxHeroRes then
set HeroRes[i]=HeroRes[i]+1
if GetLocalPlayer()==pp then
set s=I2S(HeroRes[i])+"/"+I2S(MaxHeroRes)
call TextUp(s,caster,11,0,255,0,60,96.00,2.00)
endif
endif
endfunction
function HeroRespawnLib___HeroRes_Message takes unit caster,unit killer returns nothing
local string s
if isUnitHero(killer)then
set s=RandGoodMess()
call TextUp(s,killer,11,0,255,0,60,96.00,2.00)
set s=RandBadMess()
call TextUp(s,caster,11,0,255,0,60,96.00,2.00)
endif
endfunction
function HeroRespawnLib___HeroRespawn takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer hr=LoadInt(id,"HeroRespawn | Structure")
local player pp=Owner(s__HeroRespawnLib___HeroRespawn_st_caster[hr])
local integer heroizmCoef=1
call ReviveHero(s__HeroRespawnLib___HeroRespawn_st_caster[hr],s__HeroRespawnLib___HeroRespawn_st_x[hr],s__HeroRespawnLib___HeroRespawn_st_y[hr],true)
if GetPlayerTechCount(pp,'R00U',true)==1 and isUnitEnemy(s__HeroRespawnLib___HeroRespawn_st_caster[hr],s__HeroRespawnLib___HeroRespawn_st_killer[hr])then
call SetHeroStr(s__HeroRespawnLib___HeroRespawn_st_caster[hr],GetHeroStr(s__HeroRespawnLib___HeroRespawn_st_caster[hr],false)+heroizmCoef,true)
call SetHeroAgi(s__HeroRespawnLib___HeroRespawn_st_caster[hr],GetHeroAgi(s__HeroRespawnLib___HeroRespawn_st_caster[hr],false)+heroizmCoef,true)
call SetHeroInt(s__HeroRespawnLib___HeroRespawn_st_caster[hr],GetHeroInt(s__HeroRespawnLib___HeroRespawn_st_caster[hr],false)+heroizmCoef,true)
endif
call s__HeroRespawnLib___HeroRespawn_st_Destroy(hr)
set t=null
set pp=null
endfunction
function HeroRespawnLib___HeroRes_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit killer=GetKillingUnit()
local player pp=GetOwningPlayer(caster)
local integer i=GetPlayerId(pp)+1
local real x=GetStartLocationX(GetPlayerStartLocation(pp))
local real y=GetStartLocationY(GetPlayerStartLocation(pp))
local integer hr=s__HeroRespawnLib___HeroRespawn_st__allocate()
local string s
call HeroRespawnLib___HeroRes_Dalbaeb(caster)
call HeroRespawnLib___HeroRes_Limit(caster)
call HeroRespawnLib___HeroRes_Message(caster,killer)
if HeroRes[i]<MaxHeroRes then
set s__HeroRespawnLib___HeroRespawn_st_time[hr]=udg_HeroResTime[i]
set s__HeroRespawnLib___HeroRespawn_st_caster[hr]=caster
set s__HeroRespawnLib___HeroRespawn_st_killer[hr]=killer
set s__HeroRespawnLib___HeroRespawn_st_x[hr]=x
set s__HeroRespawnLib___HeroRespawn_st_y[hr]=y
call DisplayTextToPlayer(pp,0,0,"|cffffcc90Подсказка:|r Ваш герой воскреснет через |cffffcc00"+I2S(R2I(s__HeroRespawnLib___HeroRespawn_st_time[hr]))+"|r секунд.")
call TimerDialogSetTitle(s__HeroRespawnLib___HeroRespawn_st_td[hr],"Воскрешение:")
call TimerDialogDisplay(s__HeroRespawnLib___HeroRespawn_st_td[hr],false)
if GetLocalPlayer()==pp then
call TimerDialogDisplay(s__HeroRespawnLib___HeroRespawn_st_td[hr],true)
endif
call SaveInt(GetHandleId(s__HeroRespawnLib___HeroRespawn_st_t[hr]),"HeroRespawn | Structure",hr)
call TimerStart(s__HeroRespawnLib___HeroRespawn_st_t[hr],s__HeroRespawnLib___HeroRespawn_st_time[hr],false,function HeroRespawnLib___HeroRespawn)
else
call s__HeroRespawnLib___HeroRespawn_st_Destroy(hr)
if REJIME=="ffa" then
call CreateFogModifierRectBJ(true,pp,FOG_OF_WAR_VISIBLE,bj_mapInitialPlayableArea)
endif
call DisplayTextToPlayer(pp,0,0,"|cffffcc90Подсказка:|r Ваш герой ликвидирован.")
call RemoveUnit(caster)
endif
set pp=null
set caster=null
set killer=null
endfunction
function HeroRespawnLib___HeroRes_Conditions takes nothing returns boolean
return GetTriggerUnit()==udg_Hero[GetPlayerId(GetOwningPlayer(GetTriggerUnit()))+1]
endfunction
function HeroRespawnLib___Init takes nothing returns nothing
local trigger t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(t,Condition(function HeroRespawnLib___HeroRes_Conditions))
call TriggerAddAction(t,function HeroRespawnLib___HeroRes_Actions)
endfunction
function s__MagicWand__MagicWandProjectile_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__MagicWand__MagicWandProjectile_st_Timer[this])
call DestroyTimer(s__MagicWand__MagicWandProjectile_st_Timer[this])
call DestroyEffect(s__MagicWand__MagicWandProjectile_st_projectile[this])
call FlushChildHashtable(udg_Hash,id)
set s__MagicWand__MagicWandProjectile_st_Timer[this]=null
set s__MagicWand__MagicWandProjectile_st_caster[this]=null
set s__MagicWand__MagicWandProjectile_st_projectile[this]=null
call s__MagicWand__MagicWandProjectile_st_deallocate(this)
endfunction
function s__MagicWand__MagicWand_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__MagicWand__MagicWand_st_Timer[this])
set s__MagicWand__MagicWand_st_count[this]=0
call DestroyTimer(s__MagicWand__MagicWand_st_Timer[this])
call FlushChildHashtable(udg_Hash,id)
set s__MagicWand__MagicWand_st_wand[this]=null
set s__MagicWand__MagicWand_st_Timer[this]=null
set s__MagicWand__MagicWand_st_caster[this]=null
call s__MagicWand__MagicWand_st_deallocate(this)
endfunction
function MagicWand__CreateSkeletonIfUnitDead takes unit caster,unit target,boolean isNecro returns nothing
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real angle=GetUnitFacing(target)
if not isUnitAlive(target)and isNecro and not isUnitStruct(target)and not isUnitHero(target)and not isUnitSummon(target)then
call RemoveUnit(target)
set bj_lastCreatedUnit=CreateUnit(Owner(caster),'u00G',x,y,angle)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',30.00)
call SetUnitAnimation(bj_lastCreatedUnit,"birth")
endif
endfunction
function MagicWand__WandDealDamage takes unit caster,unit target,real l__damage,boolean isNecro returns nothing
call MagDamage(caster,target,l__damage)
call MagicWand__CreateSkeletonIfUnitDead(caster,target,isNecro)
endfunction
function MagicWand__MagicWandProjectile_filter takes nothing returns boolean
return not IsUnitInvisible(GetFilterUnit(),Owner(bj_caster))and isUnitEnemy(bj_caster,GetFilterUnit())and isUnitAlive(GetFilterUnit())and not isUnitStruct(GetFilterUnit())
endfunction
function MagicWand__MagicWandProjectile_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer mwp=LoadInt(id,"MagicWandProjectile | Structure")
local real eX=GetEffectX(s__MagicWand__MagicWandProjectile_st_projectile[mwp])
local real eY=GetEffectY(s__MagicWand__MagicWandProjectile_st_projectile[mwp])
local group g=CreateGroup()
local boolexpr filter
local unit target
local unit dummy
local effect eff
local real x
local real y
if s__MagicWand__MagicWandProjectile_st_distance[mwp]>0.00 then
set s__MagicWand__MagicWandProjectile_st_distance[mwp]=s__MagicWand__MagicWandProjectile_st_distance[mwp]-s__MagicWand__MagicWandProjectile_st_speed[mwp]
set x=PolarPoints(eX,eY,s__MagicWand__MagicWandProjectile_st_speed[mwp],s__MagicWand__MagicWandProjectile_st_angle[mwp],"x")
set y=PolarPoints(eX,eY,s__MagicWand__MagicWandProjectile_st_speed[mwp],s__MagicWand__MagicWandProjectile_st_angle[mwp],"y")
call SetEffectFacing(s__MagicWand__MagicWandProjectile_st_projectile[mwp],s__MagicWand__MagicWandProjectile_st_angle[mwp])
call SetEffectPosition(s__MagicWand__MagicWandProjectile_st_projectile[mwp],x,y,GetEffectZ(s__MagicWand__MagicWandProjectile_st_projectile[mwp]))
set bj_caster=s__MagicWand__MagicWandProjectile_st_caster[mwp]
set filter=Condition(function MagicWand__MagicWandProjectile_filter)
call GroupEnumUnitsInRange(g,x,y,s__MagicWand__MagicWandProjectile_st_checkRange[mwp],filter)
set target=FirstOfGroup(g)
if target!=null then
if s__MagicWand__MagicWandProjectile_st_dmgRange[mwp]!=0.00 then
set eff=AddSpecialEffect(MagicWand__FIRE_SPHERE_EFFECT_PATH,x,y)
call DestroyEffect(eff)
set dummy=target
call GroupClear(g)
set bj_caster=s__MagicWand__MagicWandProjectile_st_caster[mwp]
set filter=Condition(function MagicWand__MagicWandProjectile_filter)
call GroupEnumUnitsInRange(g,x,y,s__MagicWand__MagicWandProjectile_st_dmgRange[mwp],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
if target==dummy then
call MagicWand__WandDealDamage(s__MagicWand__MagicWandProjectile_st_caster[mwp],target,s__MagicWand__MagicWandProjectile_st_damage[mwp],s__MagicWand__MagicWandProjectile_st_isNecro[mwp])
else
call MagicWand__WandDealDamage(s__MagicWand__MagicWandProjectile_st_caster[mwp],target,s__MagicWand__MagicWandProjectile_st_damage[mwp]*0.5,s__MagicWand__MagicWandProjectile_st_isNecro[mwp])
endif
call GroupRemoveUnit(g,target)
endloop
call s__MagicWand__MagicWandProjectile_st_Destroy(mwp)
else
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl",target,"origin")
call DestroyEffect(eff)
call MagicWand__WandDealDamage(s__MagicWand__MagicWandProjectile_st_caster[mwp],target,s__MagicWand__MagicWandProjectile_st_damage[mwp],s__MagicWand__MagicWandProjectile_st_isNecro[mwp])
call s__MagicWand__MagicWandProjectile_st_Destroy(mwp)
endif
endif
else
if s__MagicWand__MagicWandProjectile_st_dmgRange[mwp]!=0.00 then
set eff=AddSpecialEffect(MagicWand__FIRE_SPHERE_EFFECT_PATH,eX,eY)
call DestroyEffect(eff)
call GroupClear(g)
set bj_caster=s__MagicWand__MagicWandProjectile_st_caster[mwp]
set filter=Condition(function MagicWand__MagicWandProjectile_filter)
call GroupEnumUnitsInRange(g,eX,eY,s__MagicWand__MagicWandProjectile_st_dmgRange[mwp],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagicWand__WandDealDamage(s__MagicWand__MagicWandProjectile_st_caster[mwp],target,s__MagicWand__MagicWandProjectile_st_damage[mwp]*0.5,s__MagicWand__MagicWandProjectile_st_isNecro[mwp])
call GroupRemoveUnit(g,target)
endloop
else
set eff=AddSpecialEffect("Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl",eX,eY)
call DestroyEffect(eff)
endif
call s__MagicWand__MagicWandProjectile_st_Destroy(mwp)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set t=null
set eff=null
set filter=null
set target=null
endfunction
function MagicWand__MagicWandProjectile_start takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer mw=LoadInt(id,"MagicWand | Structure")
local real x=GetUnitX(s__MagicWand__MagicWand_st_caster[mw])
local real y=GetUnitY(s__MagicWand__MagicWand_st_caster[mw])
local group g=CreateGroup()
local boolexpr filter=null
local unit target=null
local integer index=1
local integer mwp=0
local timer pt=null
local integer pid=0
local integer itemsCount=GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02E')
local boolean isCollected=GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],MagicWand__GREAT_WAND_ID)>0
if IsUnitInvisible(s__MagicWand__MagicWand_st_caster[mw],Player(11))or not isUnitAlive(s__MagicWand__MagicWand_st_caster[mw])or s__MagicWand__MagicWand_st_caster[mw]==null then
call TimerStart(t,s__MagicWand__MagicWand_st_periodic[mw],false,function MagicWand__MagicWandProjectile_start)
call DestroyGroup(g)
set g=null
set t=null
return
endif
set bj_caster=s__MagicWand__MagicWand_st_caster[mw]
set filter=Condition(function MagicWand__MagicWandProjectile_filter)
call GroupEnumUnitsInRange(g,x,y,s__MagicWand__MagicWand_st_range[mw],filter)
loop
exitwhen index>s__MagicWand__MagicWand_st_count[mw]
set target=FirstOfGroup(g)
if target!=null then
set mwp=s__MagicWand__MagicWandProjectile_st__allocate()
set pt=CreateTimer()
set pid=GetHandleId(pt)
set s__MagicWand__MagicWandProjectile_st_projectile[mwp]=AddSpecialEffect("Medium_ICM_Purple.mdx",x,y)
set s__MagicWand__MagicWandProjectile_st_caster[mwp]=s__MagicWand__MagicWand_st_caster[mw]
set s__MagicWand__MagicWandProjectile_st_Timer[mwp]=pt
set s__MagicWand__MagicWandProjectile_st_isNecro[mwp]=s__MagicWand__MagicWand_st_isNecro[mw]
set s__MagicWand__MagicWandProjectile_st_dmgRange[mwp]=s__MagicWand__MagicWand_st_dmgRange[mw]
set s__MagicWand__MagicWandProjectile_st_damage[mwp]=s__MagicWand__MagicWand_st_damage[mw]
set s__MagicWand__MagicWandProjectile_st_speed[mwp]=25.00
set s__MagicWand__MagicWandProjectile_st_checkRange[mwp]=75.00
set s__MagicWand__MagicWandProjectile_st_targetX[mwp]=GetUnitX(target)
set s__MagicWand__MagicWandProjectile_st_targetY[mwp]=GetUnitY(target)
set s__MagicWand__MagicWandProjectile_st_angle[mwp]=PointsAngle(x,y,s__MagicWand__MagicWandProjectile_st_targetX[mwp],s__MagicWand__MagicWandProjectile_st_targetY[mwp])
set s__MagicWand__MagicWandProjectile_st_distance[mwp]=PointsDistance(x,y,s__MagicWand__MagicWandProjectile_st_targetX[mwp],s__MagicWand__MagicWandProjectile_st_targetY[mwp])
if isCollected then
set s__MagicWand__MagicWand_st_periodic[mw]=0.75
set s__MagicWand__MagicWandProjectile_st_damage[mwp]=30.00
set s__MagicWand__MagicWandProjectile_st_dmgRange[mwp]=200.00
endif
call SetEffectZ(s__MagicWand__MagicWandProjectile_st_projectile[mwp],75.00)
call SaveInt(pid,"MagicWandProjectile | Structure",mwp)
call TimerStart(pt,0.04,true,function MagicWand__MagicWandProjectile_timer)
call GroupRemoveUnit(g,target)
endif
set index=index+1
endloop
set s__MagicWand__MagicWand_st_periodic[mw]=MagicWand__PERIODIC
set s__MagicWand__MagicWand_st_dmgRange[mw]=MagicWand__DMG_RANGE
set s__MagicWand__MagicWand_st_damage[mw]=MagicWand__DAMAGE
set s__MagicWand__MagicWand_st_range[mw]=MagicWand__RANGE
set s__MagicWand__MagicWand_st_isNecro[mw]=MagicWand__IS_NECRO
set s__MagicWand__MagicWand_st_count[mw]=MagicWand__COUNT
if GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I00T')>0 or s__MagicWand__MagicWand_st_isCollected[mw]then
set s__MagicWand__MagicWand_st_count[mw]=s__MagicWand__MagicWand_st_count[mw]+1
endif
if GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02F')>0 or s__MagicWand__MagicWand_st_isCollected[mw]then
set s__MagicWand__MagicWand_st_dmgRange[mw]=150.00
endif
if GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02G')>0 or s__MagicWand__MagicWand_st_isCollected[mw]then
set s__MagicWand__MagicWand_st_isNecro[mw]=true
endif
if GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02H')>0 or s__MagicWand__MagicWand_st_isCollected[mw]then
set s__MagicWand__MagicWand_st_periodic[mw]=0.75
endif
call TimerStart(t,s__MagicWand__MagicWand_st_periodic[mw],false,function MagicWand__MagicWandProjectile_start)
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set t=null
set pt=null
set filter=null
set target=null
endfunction
function MagicWand__TakeWand_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local item wand=GetManipulatedItem()
local integer wandID=GetItemTypeId(wand)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer mw=s__MagicWand__MagicWand_st__allocate()
local boolean isCollected=wandID==MagicWand__GREAT_WAND_ID
local integer count=0
set s__MagicWand__MagicWand_st_wand[mw]=wand
set s__MagicWand__MagicWand_st_caster[mw]=caster
set s__MagicWand__MagicWand_st_isCollected[mw]=isCollected
set s__MagicWand__MagicWand_st_Timer[mw]=t
set s__MagicWand__MagicWand_st_periodic[mw]=MagicWand__PERIODIC
set s__MagicWand__MagicWand_st_dmgRange[mw]=MagicWand__DMG_RANGE
set s__MagicWand__MagicWand_st_damage[mw]=MagicWand__DAMAGE
set s__MagicWand__MagicWand_st_range[mw]=MagicWand__RANGE
set s__MagicWand__MagicWand_st_isNecro[mw]=MagicWand__IS_NECRO
set s__MagicWand__MagicWand_st_count[mw]=MagicWand__COUNT
if GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I00T')>0 or isCollected then
set s__MagicWand__MagicWand_st_count[mw]=s__MagicWand__MagicWand_st_count[mw]+1
endif
if GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02F')>0 or isCollected then
set s__MagicWand__MagicWand_st_dmgRange[mw]=150.00
endif
if GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02G')>0 or isCollected then
set s__MagicWand__MagicWand_st_isNecro[mw]=true
endif
if GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02H')>0 or isCollected then
set s__MagicWand__MagicWand_st_periodic[mw]=1.
endif
if s__MagicWand__MagicWand_st_isCollected[mw]then
set s__MagicWand__MagicWand_st_periodic[mw]=0.75
set s__MagicWand__MagicWand_st_damage[mw]=30.00
set s__MagicWand__MagicWand_st_dmgRange[mw]=200.00
endif
call SaveInt(id,"MagicWand | Structure",mw)
call SaveInt(GetHandleId(wand),"MagicWand | Structure",mw)
call TimerStart(t,s__MagicWand__MagicWand_st_periodic[mw],false,function MagicWand__MagicWandProjectile_start)
set count=count+GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02E')
set count=count+GetUnitItemCountById(s__MagicWand__MagicWand_st_caster[mw],'I02I')
if count>1 then
call UnitRemoveItem(s__MagicWand__MagicWand_st_caster[mw],wand)
call Tooltip("Вы не можете носить более одного посоха!",Owner(s__MagicWand__MagicWand_st_caster[mw]))
endif
set t=null
set wand=null
set caster=null
endfunction
function MagicWand__DropWand_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local item wand=GetManipulatedItem()
local integer mw=LoadInt(GetHandleId(wand),"MagicWand | Structure")
call s__MagicWand__MagicWand_st_Destroy(mw)
set wand=null
set caster=null
endfunction
function MagicWand__TakeWand_Conditions takes nothing returns boolean
local integer id=GetItemTypeId(GetManipulatedItem())
return id=='I02E' or id==MagicWand__GREAT_WAND_ID and not IsUnitIllusion(GetTriggerUnit())
endfunction
function MagicWand__Init takes nothing returns nothing
local trigger dropWand=CreateTrigger()
local trigger getWand=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(getWand,EVENT_PLAYER_UNIT_PICKUP_ITEM)
call TriggerAddCondition(getWand,Condition(function MagicWand__TakeWand_Conditions))
call TriggerAddAction(getWand,function MagicWand__TakeWand_Actions)
call TriggerRegisterAnyUnitEventBJ(dropWand,EVENT_PLAYER_UNIT_DROP_ITEM)
call TriggerAddCondition(dropWand,Condition(function MagicWand__TakeWand_Conditions))
call TriggerAddAction(dropWand,function MagicWand__DropWand_Actions)
set getWand=null
set dropWand=null
endfunction
function RemoveMercenaryLimits takes player p returns nothing
call SetPlayerTechMaxAllowed(p,'e005',100)
call SetPlayerTechMaxAllowed(p,'h01I',100)
call SetPlayerTechMaxAllowed(p,'n00W',100)
call SetPlayerTechMaxAllowed(p,'n017',100)
call SetPlayerTechMaxAllowed(p,'n00M',100)
call SetPlayerTechMaxAllowed(p,'n00O',100)
call SetPlayerTechMaxAllowed(p,'n016',100)
call SetPlayerTechMaxAllowed(p,'n00X',100)
call SetPlayerTechMaxAllowed(p,'h01J',100)
call SetPlayerTechMaxAllowed(p,'n00P',100)
call SetPlayerTechMaxAllowed(p,'o008',100)
call SetPlayerTechMaxAllowed(p,'u00Q',100)
call SetPlayerTechMaxAllowed(p,'o009',100)
call SetPlayerTechMaxAllowed(p,'u00P',100)
call SetPlayerTechMaxAllowed(p,'h01K',100)
call SetPlayerTechMaxAllowed(p,'n00Q',100)
endfunction
function SetMercenaryLimits takes nothing returns nothing
local integer index=0
loop
exitwhen index>5
call SetPlayerTechMaxAllowed(Player(index),'e005',15)
call SetPlayerTechMaxAllowed(Player(index),'h01I',15)
call SetPlayerTechMaxAllowed(Player(index),'n00W',15)
call SetPlayerTechMaxAllowed(Player(index),'n017',15)
call SetPlayerTechMaxAllowed(Player(index),'n00M',12)
call SetPlayerTechMaxAllowed(Player(index),'n00O',12)
call SetPlayerTechMaxAllowed(Player(index),'n016',12)
call SetPlayerTechMaxAllowed(Player(index),'n00X',12)
call SetPlayerTechMaxAllowed(Player(index),'h01J',8)
call SetPlayerTechMaxAllowed(Player(index),'n00P',8)
call SetPlayerTechMaxAllowed(Player(index),'o008',8)
call SetPlayerTechMaxAllowed(Player(index),'u00Q',8)
call SetPlayerTechMaxAllowed(Player(index),'o009',5)
call SetPlayerTechMaxAllowed(Player(index),'u00P',5)
call SetPlayerTechMaxAllowed(Player(index),'h01K',5)
call SetPlayerTechMaxAllowed(Player(index),'n00Q',5)
set index=index+1
endloop
endfunction
function MercenaryLib___TrainMercenary takes nothing returns nothing
local integer cost=GetUnitGoldCost(GetUnitTypeId(GetTrainedUnit()))
local integer cashback=R2I(cost*0.25)
call PlayerAddGold(GetOwningPlayer(GetTrainedUnit()),cashback)
endfunction
function MercenaryLib___TrainMercenary_conditons takes nothing returns boolean
return GetPlayerTechCount(GetOwningPlayer(GetTrainedUnit()),'R00V',true)>0 and UnitTag(GetTrainedUnit())=="mercenary"
endfunction
function MercenaryLib___InitTriggers takes nothing returns nothing
local trigger train=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(train,EVENT_PLAYER_UNIT_TRAIN_FINISH)
call TriggerAddCondition(train,Condition(function MercenaryLib___TrainMercenary_conditons))
call TriggerAddAction(train,function MercenaryLib___TrainMercenary)
call SetMercenaryLimits()
endfunction
function Pentagram_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(bj_caster,GetOwningPlayer(GetFilterUnit()))==true
endfunction
function Pentagram_timer takes nothing returns nothing
local timer spellTimer=GetExpiredTimer()
local integer timerID=GetHandleId(spellTimer)
local unit caster=LoadUnitHandle(udg_Hash,timerID,StringHash("Pentagram | Caster"))
local integer count=LoadInteger(udg_Hash,timerID,StringHash("Pentagram | Count"))
local real targetX=LoadReal(udg_Hash,timerID,StringHash("Pentagram | TargetX"))
local real targetY=LoadReal(udg_Hash,timerID,StringHash("Pentagram | TargetY"))
local group spellGroup=CreateGroup()
local effect spellEffect
local integer index=0
local boolexpr filter
local unit dummy
local real l__damage=PENTA_DAMAGE
local real range=PENTA_RANGE+25
if count>0 then
call SaveInteger(udg_Hash,timerID,StringHash("Pentagram | Count"),count-1)
set bj_caster=caster
set filter=Condition(function Pentagram_filter)
call GroupEnumUnitsInRange(spellGroup,targetX,targetY,range,filter)
loop
set dummy=FirstOfGroup(spellGroup)
exitwhen dummy==null
set spellEffect=AddSpecialEffectTarget("Environment\\NightElfBuildingFire\\ElfSmallBuildingFire2.mdl",dummy,"origin")
call DestroyEffect(spellEffect)
call MagDamage(caster,dummy,l__damage)
call GroupRemoveUnit(spellGroup,dummy)
endloop
else
call DestroyTimer(spellTimer)
call DestroyPentagram(timerID-12345)
call FlushChildHashtable(udg_Hash,timerID)
endif
call DestroyGroup(spellGroup)
call DestroyBoolExpr(filter)
set dummy=null
set caster=null
set filter=null
set spellGroup=null
set spellEffect=null
endfunction
function Pentagram_start takes unit caster,real targetX,real targetY returns nothing
local timer spellTimer=CreateTimer()
local integer timerID=GetHandleId(spellTimer)
call CreatePentagram(timerID-12345,targetX,targetY,PENTA_RANGE,"Environment\\NightElfBuildingFire\\ElfSmallBuildingFire2.mdl")
call SaveReal(udg_Hash,timerID,StringHash("Pentagram | TargetX"),targetX)
call SaveReal(udg_Hash,timerID,StringHash("Pentagram | TargetY"),targetY)
call SaveUnitHandle(udg_Hash,timerID,StringHash("Pentagram | Caster"),caster)
call SaveInteger(udg_Hash,timerID,StringHash("Pentagram | Count"),PENTA_DMG_COUNT)
call TimerStart(spellTimer,PENTA_DMG_PERIODIC,true,function Pentagram_timer)
set caster=null
set spellTimer=null
endfunction
function s__RecipesLib__Recipe_st_Destroy takes integer this returns nothing
local integer index=1
loop
exitwhen index>6
set s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[this]+index]=0
set index=index+1
endloop
set s__RecipesLib__Recipe_st_collectedItem[this]=0
call s__RecipesLib__Recipe_st_deallocate(this)
endfunction
function RecipesLib__TakeItem_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer collectedItems=0
local boolean array hasItem
local integer items=0
local integer index=1
local integer rp=0
local integer ind=1
loop
exitwhen RecipesLib__RECIPES_LIST[index]==0
set ind=1
set items=0
set collectedItems=0
set rp=RecipesLib__RECIPES_LIST[index]
loop
exitwhen ind>6
if s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+ind]!=0 then
set items=items+1
if GetUnitItemCountById(caster,s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+ind])>0 then
set collectedItems=collectedItems+1
endif
endif
set ind=ind+1
endloop
if items==collectedItems and s__RecipesLib__Recipe_st_collectedItem[rp]!=0 then
set ind=1
loop
exitwhen ind>6
if s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+ind]!=0 then
call UnitRemoveItemById(caster,s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+ind])
endif
set ind=ind+1
endloop
call UnitAddItemById(caster,s__RecipesLib__Recipe_st_collectedItem[rp])
endif
set index=index+1
endloop
set caster=null
endfunction
function RecipesLib__InitRecipes takes nothing returns nothing
local integer index=0
local integer rp=0
set index=index+1
set rp=s__RecipesLib__Recipe_st__allocate()
set RecipesLib__RECIPES_LIST[index]=rp
set s__RecipesLib__Recipe_st_collectedItem[rp]='I02I'
set s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+1]='I02E'
set s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+2]='I00T'
set s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+3]='I02F'
set s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+4]='I02G'
set s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+5]='I02H'
set s___RecipesLib__Recipe_st_items[s__RecipesLib__Recipe_st_items[rp]+6]=0
endfunction
function RecipesLib__Init takes nothing returns nothing
local trigger takeItem=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(takeItem,EVENT_PLAYER_UNIT_PICKUP_ITEM)
call TriggerAddAction(takeItem,function RecipesLib__TakeItem_Actions)
call RecipesLib__InitRecipes()
set takeItem=null
endfunction
function s__SpellsLib__DamageWave_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__SpellsLib__DamageWave_st_t[this])
call DestroyTimer(s__SpellsLib__DamageWave_st_t[this])
call DestroyEffect(s__SpellsLib__DamageWave_st_wave[this])
call DestroyGroup(s__SpellsLib__DamageWave_st_damagedGroup[this])
call FlushChildHashtable(udg_Hash,id)
set s__SpellsLib__DamageWave_st_t[this]=null
set s__SpellsLib__DamageWave_st_wave[this]=null
set s__SpellsLib__DamageWave_st_caster[this]=null
set s__SpellsLib__DamageWave_st_damagedGroup[this]=null
call s__SpellsLib__DamageWave_st_deallocate(this)
endfunction
function SpellsLib__DamageWave_filter takes nothing returns boolean
return isUnitEnemy(bj_caster,GetFilterUnit())and isUnitAlive(GetFilterUnit())and not IsUnitInGroup(GetFilterUnit(),bj_group)
endfunction
function SpellsLib__DamageWave_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer dw=LoadInt(id,"DamageWave | Structure")
local real x=GetEffectX(s__SpellsLib__DamageWave_st_wave[dw])
local real y=GetEffectY(s__SpellsLib__DamageWave_st_wave[dw])
local group g=CreateGroup()
local boolexpr filter
local unit target
local real x1
local real y1
if s__SpellsLib__DamageWave_st_distance[dw]>0.00 then
set s__SpellsLib__DamageWave_st_distance[dw]=s__SpellsLib__DamageWave_st_distance[dw]-s__SpellsLib__DamageWave_st_speed[dw]
set x1=PolarPoints(x,y,s__SpellsLib__DamageWave_st_speed[dw],s__SpellsLib__DamageWave_st_angle[dw],"x")
set y1=PolarPoints(x,y,s__SpellsLib__DamageWave_st_speed[dw],s__SpellsLib__DamageWave_st_angle[dw],"y")
call SetEffectPosition(s__SpellsLib__DamageWave_st_wave[dw],x1,y1,GetEffectZ(s__SpellsLib__DamageWave_st_wave[dw]))
call SetEffectFacing(s__SpellsLib__DamageWave_st_wave[dw],s__SpellsLib__DamageWave_st_angle[dw])
set bj_caster=s__SpellsLib__DamageWave_st_caster[dw]
set bj_group=s__SpellsLib__DamageWave_st_damagedGroup[dw]
set filter=Condition(function SpellsLib__DamageWave_filter)
call GroupEnumUnitsInRange(g,x,y,s__SpellsLib__DamageWave_st_range[dw],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(s__SpellsLib__DamageWave_st_caster[dw],target,s__SpellsLib__DamageWave_st_damage[dw])
call GroupAddUnit(s__SpellsLib__DamageWave_st_damagedGroup[dw],target)
call GroupRemoveUnit(g,target)
endloop
else
call s__SpellsLib__DamageWave_st_Destroy(dw)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set target=null
set filter=null
endfunction
function DamageWave takes unit caster,real l__damage,real range,real speed,real distance,real angle,string path returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer dw=s__SpellsLib__DamageWave_st__allocate()
local real periodic=0.04
set s__SpellsLib__DamageWave_st_t[dw]=t
set s__SpellsLib__DamageWave_st_caster[dw]=caster
set s__SpellsLib__DamageWave_st_damage[dw]=l__damage
set s__SpellsLib__DamageWave_st_range[dw]=range
set s__SpellsLib__DamageWave_st_speed[dw]=speed
set s__SpellsLib__DamageWave_st_angle[dw]=angle
set s__SpellsLib__DamageWave_st_distance[dw]=distance
set s__SpellsLib__DamageWave_st_wave[dw]=AddSpecialEffect(path,GetUnitX(caster),GetUnitY(caster))
call SaveInt(id,"DamageWave | Structure",dw)
call TimerStart(t,periodic,true,function SpellsLib__DamageWave_timer)
set t=null
endfunction
function s__Stun___Stun_st_Destroy takes integer this returns nothing
call UnitSetStunFlag(s__Stun___Stun_st_target[this],false)
call DestroyEffect(s__Stun___Stun_st_eff[this])
set s__Stun___Stun_st_eff[this]=null
set s__Stun___Stun_st_target[this]=null
set s__Stun___Stun_st_caster[this]=null
call s__Stun___Stun_st_deallocate(this)
endfunction
function Stun___Timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local unit target=LoadUnitHandle(udg_Hash,id,StringHash("Stun|Target"))
local effect eff=LoadEffectHandle(udg_Hash,id,StringHash("Stun|Effect"))
local real time=LoadReal(udg_Hash,id,StringHash("Stun|Time"))
if time>0.00 and target!=null and GetUnitState(target,UNIT_STATE_LIFE)>0.5 then
call SaveReal(udg_Hash,id,StringHash("Stun|Time"),time-0.04)
else
call DestroyTimer(t)
call DestroyEffect(eff)
call UnitSetStunFlag(target,false)
call FlushChildHashtable(udg_Hash,id)
call SaveTimerHandle(udg_Hash,GetHandleId(target),StringHash("Stun|Timer"),null)
endif
set t=null
set eff=null
set target=null
endfunction
function Stun_Start takes unit target,real time returns nothing
local integer id=GetHandleId(target)
local timer t=LoadTimerHandle(udg_Hash,id,StringHash("Stun|Timer"))
local effect eff
set id=GetHandleId(t)
if id==0 then
set t=CreateTimer()
set id=GetHandleId(t)
call UnitSetStunFlag(target,true)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\Thunderclap\\ThunderclapTarget.mdl",target,"overhead")
call SaveTimerHandle(udg_Hash,GetHandleId(target),StringHash("Stun|Timer"),t)
call SaveUnitHandle(udg_Hash,id,StringHash("Stun|Target"),target)
call SaveEffectHandle(udg_Hash,id,StringHash("Stun|Effect"),eff)
call SaveReal(udg_Hash,id,StringHash("Stun|Time"),time)
call TimerStart(t,0.04,true,function Stun___Timer)
else
set id=GetHandleId(t)
call SaveReal(udg_Hash,id,StringHash("Stun|Time"),time)
endif
set t=null
set eff=null
set target=null
endfunction
function s__Stun___Frost_st_Destroy takes integer this returns nothing
call UnitSetStunFlag(s__Stun___Frost_st_target[this],false)
call DestroyEffect(s__Stun___Frost_st_eff[this])
set s__Stun___Frost_st_eff[this]=null
set s__Stun___Frost_st_target[this]=null
call s__Stun___Frost_st_deallocate(this)
endfunction
function isUnitFrosted takes unit target returns boolean
return LoadTimer(GetHandleId(target),"Frost | Timer")!=null
endfunction
function Frost_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer fs=LoadInt(id,"Frost | Structure")
if fs!=0 then
call s__Stun___Frost_st_Destroy(fs)
endif
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
set t=null
endfunction
function Frost_Start takes unit target,real time returns nothing
local timer t=LoadTimer(GetHandleId(target),"Frost | Timer")
local integer id=GetHandleId(t)
local integer fs=LoadInt(id,"Frost | Structure")
local real resist=GetUnitMagicResist(target)
set time=time-(time*resist)
if t==null then
set fs=s__Stun___Frost_st__allocate()
set t=CreateTimer()
set id=GetHandleId(t)
set s__Stun___Frost_st_target[fs]=target
set s__Stun___Frost_st_eff[fs]=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\FreezingBreath\\FreezingBreathTargetArt.mdl",target,"origin")
call UnitSetStunFlag(target,true)
call SaveTimer(GetHandleId(target),"Frost | Timer",t)
call SaveInt(id,"Frost | Structure",fs)
call TimerStart(t,time,false,function Frost_timer)
else
call DestroyTimer(t)
set t=CreateTimer()
set id=GetHandleId(t)
call SaveTimer(GetHandleId(target),"Frost | Timer",t)
call SaveInt(id,"Frost | Structure",fs)
call TimerStart(t,time,false,function Frost_timer)
endif
set t=null
endfunction
function s__Stun___Roots_st_Destroy takes integer this returns nothing
call UnitSetStunFlag(s__Stun___Roots_st_target[this],false)
call DestroyEffect(s__Stun___Roots_st_eff[this])
set s__Stun___Roots_st_eff[this]=null
set s__Stun___Roots_st_target[this]=null
set s__Stun___Roots_st_caster[this]=null
call s__Stun___Roots_st_deallocate(this)
endfunction
function isUnitRooted takes unit target returns boolean
return LoadTimer(GetHandleId(target),"Roots | Timer")!=null
endfunction
function DispelRoots takes unit target returns nothing
local timer t=LoadTimer(GetHandleId(target),"Roots | Timer")
local integer id=GetHandleId(t)
local integer rs=LoadInt(id,"Roots | Structure")
if rs!=0 then
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__Stun___Roots_st_Destroy(rs)
endif
set t=null
endfunction
function Roots_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer rs=LoadInt(id,"Roots | Structure")
if s__Stun___Roots_st_time[rs]>0.00 and GetUnitHealth(s__Stun___Roots_st_target[rs])>0.00 then
set s__Stun___Roots_st_time[rs]=s__Stun___Roots_st_time[rs]-s__Stun___Roots_st_periodic[rs]
call MagDamage(s__Stun___Roots_st_caster[rs],s__Stun___Roots_st_target[rs],s__Stun___Roots_st_damage[rs])
else
call DispelRoots(s__Stun___Roots_st_target[rs])
endif
set t=null
endfunction
function Roots_Start takes unit caster,unit target,real l__damage,real periodic,real time returns nothing
local timer t=LoadTimer(GetHandleId(target),"Roots | Timer")
local integer id=GetHandleId(t)
local integer rs=LoadInt(id,"Roots | Structure")
local real resist=GetUnitMagicResist(target)
set time=time-(time*resist)
if t==null then
set rs=s__Stun___Roots_st__allocate()
set t=CreateTimer()
set id=GetHandleId(t)
set s__Stun___Roots_st_caster[rs]=caster
set s__Stun___Roots_st_target[rs]=target
set s__Stun___Roots_st_damage[rs]=l__damage
set s__Stun___Roots_st_periodic[rs]=periodic
set s__Stun___Roots_st_time[rs]=time
set s__Stun___Roots_st_eff[rs]=AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl",target,"origin")
call UnitSetStunFlag(target,true)
call SaveTimer(GetHandleId(target),"Roots | Timer",t)
call SaveInt(id,"Roots | Structure",rs)
call TimerStart(t,s__Stun___Roots_st_periodic[rs],true,function Roots_timer)
else
set s__Stun___Roots_st_caster[rs]=caster
set s__Stun___Roots_st_damage[rs]=l__damage
set s__Stun___Roots_st_periodic[rs]=periodic
set s__Stun___Roots_st_time[rs]=time
endif
set t=null
endfunction
function s__Stun___Parasites_st_Destroy takes integer this returns nothing
call UnitSetStunFlag(s__Stun___Parasites_st_target[this],false)
call DestroyEffect(s__Stun___Parasites_st_eff[this])
set s__Stun___Parasites_st_eff[this]=null
set s__Stun___Parasites_st_target[this]=null
set s__Stun___Parasites_st_caster[this]=null
call s__Stun___Parasites_st_deallocate(this)
endfunction
function isUnitParasited takes unit target returns boolean
return LoadTimer(GetHandleId(target),"Parasites | Timer")!=null
endfunction
function DispelParasites takes unit target returns nothing
local timer t=LoadTimer(GetHandleId(target),"Parasites | Timer")
local integer id=GetHandleId(t)
local integer rs=LoadInt(id,"Parasites | Structure")
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__Stun___Parasites_st_Destroy(rs)
set t=null
endfunction
function Parasites_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer rs=LoadInt(id,"Parasites | Structure")
if s__Stun___Parasites_st_time[rs]>0.00 and GetUnitHealth(s__Stun___Parasites_st_target[rs])>0.00 then
set s__Stun___Parasites_st_time[rs]=s__Stun___Parasites_st_time[rs]-s__Stun___Parasites_st_periodic[rs]
call MagDamage(s__Stun___Parasites_st_caster[rs],s__Stun___Parasites_st_target[rs],s__Stun___Parasites_st_damage[rs])
else
call DispelParasites(s__Stun___Parasites_st_target[rs])
endif
set t=null
endfunction
function Parasites_Start takes unit caster,unit target,real l__damage,real periodic,real time returns nothing
local timer t=LoadTimer(GetHandleId(target),"Parasites | Timer")
local integer id=GetHandleId(t)
local integer rs=LoadInt(id,"Parasites | Structure")
if t==null then
set rs=s__Stun___Parasites_st__allocate()
set t=CreateTimer()
set id=GetHandleId(t)
set s__Stun___Parasites_st_caster[rs]=caster
set s__Stun___Parasites_st_target[rs]=target
set s__Stun___Parasites_st_damage[rs]=l__damage
set s__Stun___Parasites_st_periodic[rs]=periodic
set s__Stun___Parasites_st_time[rs]=time
set s__Stun___Parasites_st_eff[rs]=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Parasite\\ParasiteTarget.mdl",target,"overhead")
call UnitSetStunFlag(target,true)
call SaveTimer(GetHandleId(target),"Parasites | Timer",t)
call SaveInt(id,"Parasites | Structure",rs)
call TimerStart(t,s__Stun___Parasites_st_periodic[rs],true,function Parasites_timer)
else
set s__Stun___Parasites_st_caster[rs]=caster
set s__Stun___Parasites_st_time[rs]=time
set s__Stun___Parasites_st_damage[rs]=l__damage
set s__Stun___Parasites_st_periodic[rs]=periodic
set s__Stun___Parasites_st_time[rs]=time
endif
set t=null
endfunction
function UnitTypeLib___Attack_Act takes nothing returns nothing
local integer id=GetSpellAbilityId()
local unit caster=GetTriggerUnit()
local integer damageType=-1
if id=='A0JX' then
set damageType=1
elseif id=='A0JY' then
set damageType=2
elseif id=='A0JZ' then
set damageType=4
endif
set bj_unitDamageType[OwnerId(caster)+1]=damageType
set caster=null
endfunction
function UnitTypeLib___Armor_Act takes nothing returns nothing
local integer id=GetSpellAbilityId()
local unit caster=GetTriggerUnit()
local integer armorType=-1
if id=='A0K0' then
set armorType=7
elseif id=='A0K1' then
set armorType=0
elseif id=='A0K2' then
set armorType=1
elseif id=='A0K3' then
set armorType=2
endif
set bj_unitArmourType[OwnerId(caster)+1]=armorType
set caster=null
endfunction
function UnitTypeLib___Attack_Cond takes nothing returns boolean
local integer id=GetSpellAbilityId()
return id=='A0JX' or id=='A0JY' or id=='A0JZ'
endfunction
function UnitTypeLib___Armor_Cond takes nothing returns boolean
local integer id=GetSpellAbilityId()
return id=='A0K0' or id=='A0K1' or id=='A0K2' or id=='A0K3'
endfunction
function UnitTypeLib___Init takes nothing returns nothing
local trigger attack=CreateTrigger()
local trigger armor=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(attack,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(attack,Condition(function UnitTypeLib___Attack_Cond))
call TriggerAddAction(attack,function UnitTypeLib___Attack_Act)
call TriggerRegisterAnyUnitEventBJ(armor,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(armor,Condition(function UnitTypeLib___Armor_Cond))
call TriggerAddAction(armor,function UnitTypeLib___Armor_Act)
endfunction
function WillOfNature___WillOfNature_filter takes nothing returns boolean
return not isUnitDummy(GetFilterUnit())and IsUnitAlly(GetFilterUnit(),GetOwningPlayer(bj_caster))and not isUnitStruct(GetFilterUnit())and GetUnitHealth(GetFilterUnit())<=0.00 and not isUnitHero(GetFilterUnit())
endfunction
function WillOfNature___WillOfNature_efilter takes nothing returns boolean
return isUnitEnemy(bj_caster,GetFilterUnit())and not isUnitStruct(GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0.00 and GetUnitAbilityLevel(GetFilterUnit(),'A0IQ')>0
endfunction
function s__WillOfNature_st_Destroy takes integer this returns nothing
set s__WillOfNature_st_count[this]=0
set s__WillOfNature_st_caster[this]=null
call s__WillOfNature_st_deallocate(this)
endfunction
function s__WillOfNatureProjectile_st_Destroy takes integer this returns nothing
call RemoveUnit(s__WillOfNatureProjectile_st_dummy[this])
call DestroyGroup(s__WillOfNatureProjectile_st_picker[this])
set s__WillOfNatureProjectile_st_dummy[this]=null
set s__WillOfNatureProjectile_st_picker[this]=null
set s__WillOfNatureProjectile_st_caster[this]=null
call s__WillOfNatureProjectile_st_deallocate(this)
endfunction
function WillOfNature___WillOfNature_timer takes nothing returns nothing
local timer spellTimer=GetExpiredTimer()
local integer timerID=GetHandleId(spellTimer)
local integer prj=LoadInt(timerID,"WillOfNatureProjectile | Structure")
local real height=GetUnitFlyHeight(s__WillOfNatureProjectile_st_dummy[prj])
local real angle=GetUnitFacing(s__WillOfNatureProjectile_st_dummy[prj])
local real dummyX=GetUnitX(s__WillOfNatureProjectile_st_dummy[prj])
local real dummyY=GetUnitY(s__WillOfNatureProjectile_st_dummy[prj])
local integer targetLevel=0
local unit target=null
local unit spirit=null
local real targetHeight
local boolexpr filter
local real totalX
local real totalY
if height>=s__WillOfNatureProjectile_st_flySpeed[prj]then
set totalX=PolarPoints(dummyX,dummyY,s__WillOfNatureProjectile_st_speed[prj],angle,"x")
set totalY=PolarPoints(dummyX,dummyY,s__WillOfNatureProjectile_st_speed[prj],angle,"y")
call SetUnitPosition(s__WillOfNatureProjectile_st_dummy[prj],totalX,totalY)
set s__WillOfNatureProjectile_st_distance[prj]=s__WillOfNatureProjectile_st_distance[prj]+s__WillOfNatureProjectile_st_speed[prj]
call SetUnitHeightByDistance(s__WillOfNatureProjectile_st_dummy[prj],s__WillOfNatureProjectile_st_distance[prj],s__WillOfNatureProjectile_st_maxDistance[prj],s__WillOfNatureProjectile_st_flySpeed[prj],s__WillOfNatureProjectile_st_flySpeed[prj]/ 0.03)
if s__WillOfNatureProjectile_st_distance[prj]>=s__WillOfNatureProjectile_st_maxDistance[prj]/ 2 then
if s__WillOfNatureProjectile_st_angle[prj]!=0.00 then
set angle=angle-s__WillOfNatureProjectile_st_angle[prj]
call SetUnitFacing(s__WillOfNatureProjectile_st_dummy[prj],angle)
set s__WillOfNatureProjectile_st_angle[prj]=0.00
endif
elseif s__WillOfNatureProjectile_st_distance[prj]>=s__WillOfNatureProjectile_st_maxDistance[prj]/ 4 then
if s__WillOfNatureProjectile_st_angle[prj]!=s__WillOfNatureProjectile_st_stAngle[prj]/ 2 then
set angle=angle-s__WillOfNatureProjectile_st_angle[prj]
call SetUnitFacing(s__WillOfNatureProjectile_st_dummy[prj],angle)
set s__WillOfNatureProjectile_st_angle[prj]=s__WillOfNatureProjectile_st_angle[prj]/ 2
endif
endif
else
call DestroyTimer(spellTimer)
call FlushChildHashtable(udg_Hash,timerID)
call TimedEffect("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkZapTarget.mdl",dummyX,dummyY,1.00)
call HealAlliesAroundUnit(s__WillOfNatureProjectile_st_dummy[prj],s__WillOfNatureProjectile_st_healRange[prj],s__WillOfNatureProjectile_st_heal[prj])
call GroupClear(s__WillOfNatureProjectile_st_picker[prj])
set bj_caster=s__WillOfNatureProjectile_st_caster[prj]
set filter=Condition(function WillOfNature___WillOfNature_filter)
call GroupEnumUnitsInRange(s__WillOfNatureProjectile_st_picker[prj],dummyX,dummyY,s__WillOfNatureProjectile_st_healRange[prj],filter)
loop
set target=FirstOfGroup(s__WillOfNatureProjectile_st_picker[prj])
exitwhen target==null
if Chance(s__WillOfNatureProjectile_st_caster[prj],s__WillOfNatureProjectile_st_spiritChance[prj])then
call TimedEffect("Abilities\\Spells\\Orc\\AncestralSpirit\\AncestralSpiritCaster.mdl",dummyX,dummyY,1.00)
set spirit=CreateUnit(GetOwningPlayer(s__WillOfNatureProjectile_st_caster[prj]),s__WillOfNatureProjectile_st_spiritID[prj],dummyX,dummyY,angle)
call UnitApplyTimedLife(spirit,'BTLF',45.00)
call RemoveUnit(target)
endif
call GroupRemoveUnit(s__WillOfNatureProjectile_st_picker[prj],target)
endloop
call GroupClear(s__WillOfNatureProjectile_st_picker[prj])
set bj_caster=s__WillOfNatureProjectile_st_caster[prj]
set filter=Condition(function WillOfNature___WillOfNature_efilter)
call GroupEnumUnitsInRange(s__WillOfNatureProjectile_st_picker[prj],dummyX,dummyY,s__WillOfNatureProjectile_st_healRange[prj],filter)
loop
set target=FirstOfGroup(s__WillOfNatureProjectile_st_picker[prj])
exitwhen target==null
set targetLevel=GetUnitAbilityLevel(target,'A0IQ')
call TimedEffect("Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl",dummyX,dummyY,1.00)
call MagDamage(s__WillOfNatureProjectile_st_caster[prj],target,s__WillOfNatureProjectile_st_heal[prj]*(targetLevel*0.2))
call GroupRemoveUnit(s__WillOfNatureProjectile_st_picker[prj],target)
endloop
call s__WillOfNatureProjectile_st_Destroy(prj)
endif
call DestroyBoolExpr(filter)
set spirit=null
set target=null
set filter=null
set spellTimer=null
endfunction
function WillOfNature___WillOfNature_launch takes nothing returns nothing
local timer expTimer=GetExpiredTimer()
local integer id=GetHandleId(expTimer)
local integer rain=LoadInt(id,"WillOfNature | Structure")
local integer level=GetUnitAbilityLevel(s__WillOfNature_st_caster[rain],'A0IN')
local real casterX=GetUnitX(s__WillOfNature_st_caster[rain])
local real casterY=GetUnitY(s__WillOfNature_st_caster[rain])
local integer prj=0
local integer timerID=0
local timer spellTimer
local real changeAngle
local real totalAngle
local real totalFly
local unit dummy
local real range=250.00
local real randX=GetRandomPointInRange(s__WillOfNature_st_x[rain],s__WillOfNature_st_y[rain],range,"x")
local real randY=GetRandomPointInRange(s__WillOfNature_st_x[rain],s__WillOfNature_st_y[rain],range,"y")
local real distance=PointsDistance(casterX,casterY,s__WillOfNature_st_x[rain],s__WillOfNature_st_y[rain])
local integer spiritID='o000'
local real spiritChance=10.00*level
local integer unitID='h03S'
local real periodic=0.03
local real heal=6.00*level
local real angle=PointsAngle(casterX,casterY,s__WillOfNature_st_x[rain],s__WillOfNature_st_y[rain])
local real angleRange=50.00
local real speed=20.00
local real flyMin=speed*0.20
local real flyMax=speed*0.50
if GetPlayerTechCount(GetOwningPlayer(s__WillOfNature_st_caster[rain]),'R02A',true)>0 then
set spiritID='o00K'
endif
if s__WillOfNature_st_count[rain]>0 and GetUnitCurrentOrder(s__WillOfNature_st_caster[rain])==OrderId("chainlightning")then
set s__WillOfNature_st_count[rain]=s__WillOfNature_st_count[rain]-1
set randX=GetRandomPointInRange(s__WillOfNature_st_x[rain],s__WillOfNature_st_y[rain],range,"x")
set randY=GetRandomPointInRange(s__WillOfNature_st_x[rain],s__WillOfNature_st_y[rain],range,"y")
set distance=PointsDistance(casterX,casterY,randX,randY)
set angle=PointsAngle(casterX,casterY,randX,randY)
set spellTimer=CreateTimer()
set timerID=GetHandleId(spellTimer)
set totalFly=GetRandomReal(flyMin,flyMax)
set changeAngle=GetRandomReal(-angleRange,angleRange)
set totalAngle=angle+changeAngle
set prj=s__WillOfNatureProjectile_st__allocate()
set s__WillOfNatureProjectile_st_caster[prj]=s__WillOfNature_st_caster[rain]
set s__WillOfNatureProjectile_st_distance[prj]=0.00
set s__WillOfNatureProjectile_st_speed[prj]=speed
set s__WillOfNatureProjectile_st_heal[prj]=heal
set s__WillOfNatureProjectile_st_flySpeed[prj]=totalFly
set s__WillOfNatureProjectile_st_angle[prj]=changeAngle
set s__WillOfNatureProjectile_st_stAngle[prj]=changeAngle
set s__WillOfNatureProjectile_st_healRange[prj]=150.00
set s__WillOfNatureProjectile_st_healCheckRange[prj]=75.00
set s__WillOfNatureProjectile_st_maxDistance[prj]=distance
set s__WillOfNatureProjectile_st_spiritChance[prj]=spiritChance
set s__WillOfNatureProjectile_st_spiritID[prj]=spiritID
set s__WillOfNatureProjectile_st_dummy[prj]=CreateUnit(GetOwningPlayer(s__WillOfNatureProjectile_st_caster[prj]),unitID,casterX,casterY,totalAngle)
call SaveInt(timerID,"WillOfNatureProjectile | Structure",prj)
call TimerStart(spellTimer,periodic,true,function WillOfNature___WillOfNature_timer)
else
call s__WillOfNature_st_Destroy(rain)
call DestroyTimer(expTimer)
call FlushChildHashtable(udg_Hash,id)
endif
set expTimer=null
set spellTimer=null
endfunction
function WillOfNature___WillOfNature_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local timer spellTimer=CreateTimer()
local integer id=GetHandleId(spellTimer)
local integer rain=s__WillOfNature_st__allocate()
set s__WillOfNature_st_caster[rain]=caster
set s__WillOfNature_st_periodic[rain]=0.05
set s__WillOfNature_st_count[rain]=20
set s__WillOfNature_st_x[rain]=x
set s__WillOfNature_st_y[rain]=y
call SaveInt(id,"WillOfNature | Structure",rain)
call TimerStart(spellTimer,s__WillOfNature_st_periodic[rain],true,function WillOfNature___WillOfNature_launch)
set caster=null
set spellTimer=null
endfunction
function WillOfNature___WillOfNature_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0IN'
endfunction
function WillOfNature___WillOfNature_init takes nothing returns nothing
local trigger trig=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(trig,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(trig,Condition(function WillOfNature___WillOfNature_Conditions))
call TriggerAddAction(trig,function WillOfNature___WillOfNature_Actions)
set trig=null
endfunction
function Dispel takes unit target returns nothing
call DispelControl(target)
call DispelPeriodicDamage(target)
call DispelRoots(target)
endfunction
function DispelLib_Actions takes nothing returns nothing
local integer id=GetSpellAbilityId()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local unit target=null
local real range=DISPEL_RANGE
if id==WIZARD_RING_ID then
set range=WIZARD_RING_RANGE
elseif id==DETONATE_ID then
set range=DETONATE_RANGE
endif
call GroupEnumUnitsInRange(g,x,y,range,null)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call Dispel(target)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
set g=null
set target=null
endfunction
function DispelLib_Conditions takes nothing returns boolean
local integer id=GetSpellAbilityId()
return id=='AIds' or id==WIZARD_RING_ID or id==DETONATE_ID
endfunction
function InitTrig_DispelLib takes nothing returns nothing
set gg_trg_DispelLib=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DispelLib,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_DispelLib,Condition(function DispelLib_Conditions))
call TriggerAddAction(gg_trg_DispelLib,function DispelLib_Actions)
endfunction
function s__Frostmorne_stpj_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__Frostmorne_stpj_t[this])
set s__Frostmorne_stpj_lvl[this]=0
set s__Frostmorne_stpj_isLaunched[this]=false
call DestroyEffect(s__Frostmorne_stpj_eff[this])
call DestroyTimer(s__Frostmorne_stpj_t[this])
call FlushChildHashtable(udg_Hash,id)
set s__Frostmorne_stpj_t[this]=null
set s__Frostmorne_stpj_eff[this]=null
set s__Frostmorne_stpj_caster[this]=null
set s__Frostmorne_stpj_target[this]=null
call s__Frostmorne_stpj_deallocate(this)
endfunction
function s__Frostmorne_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__Frostmorne_st_t[this])
local integer i=0
set s__Frostmorne_st_lvl[this]=0
set s__Frostmorne_st_count[this]=0
loop
exitwhen s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[this]+i]==0
call s__Frostmorne_stpj_Destroy(s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[this]+i])
set s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[this]+i]=0
set i=i+1
endloop
call DestroyTimer(s__Frostmorne_st_t[this])
call DestroyGroup(s__Frostmorne_st_g[this])
call FlushChildHashtable(udg_Hash,id)
set s__Frostmorne_st_t[this]=null
set s__Frostmorne_st_g[this]=null
set s__Frostmorne_st_caster[this]=null
call s__Frostmorne_st_deallocate(this)
endfunction
function s__Frostmorne_strl_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__Frostmorne_strl_t[this])
set s__Frostmorne_strl_fm[this]=0
set s__Frostmorne_strl_index[this]=0
call DestroyTimer(s__Frostmorne_strl_t[this])
call FlushChildHashtable(udg_Hash,id)
set s__Frostmorne_strl_t[this]=null
call s__Frostmorne_strl_deallocate(this)
endfunction
function Frostmorne___isUnitCurrentTarget takes unit target returns boolean
return LoadBool(GetHandleId(target),"Frostmorne | Target")
endfunction
function Frostmorne___setUnitCurrentTarget takes unit target,boolean arg returns nothing
call SaveBool(GetHandleId(target),"Frostmorne | Target",arg)
endfunction
function Frostmorne___Frostmorne_filter takes nothing returns boolean
return isUnitEnemy(bj_caster,GetFilterUnit())and GetWidgetLife(GetFilterUnit())>0.405 and not isUnitStruct(GetFilterUnit())and IsUnitVisible(GetFilterUnit(),Owner(bj_caster))
endfunction
function Frostmorne___Frostmorne_timerpj takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer pj=LoadInt(id,"Frostmorne | Projectile | Structure")
local integer power=GetUnitUserData(s__Frostmorne_stpj_caster[pj])/ 2
local real x=GetEffectX(s__Frostmorne_stpj_eff[pj])
local real y=GetEffectY(s__Frostmorne_stpj_eff[pj])
local real x1=GetUnitX(s__Frostmorne_stpj_target[pj])
local real y1=GetUnitY(s__Frostmorne_stpj_target[pj])
local real x2
local real y2
local real distance=PointsDistance(x,y,x1,y1)
local real angle=PointsAngle(x,y,x1,y1)
if distance>s__Frostmorne_stpj_speed[pj]and isUnitAlive(s__Frostmorne_stpj_target[pj])then
set x2=PolarPoints(x,y,s__Frostmorne_stpj_speed[pj],angle,"x")
set y2=PolarPoints(x,y,s__Frostmorne_stpj_speed[pj],angle,"y")
call SetEffectFacing(s__Frostmorne_stpj_eff[pj],angle)
call SetEffectX(s__Frostmorne_stpj_eff[pj],x2)
call SetEffectY(s__Frostmorne_stpj_eff[pj],y2)
else
set s__Frostmorne_stpj_damage[pj]=s__Frostmorne_stpj_damage[pj]*(1+0.005*power)
set s__Frostmorne_stpj_frostTime[pj]=s__Frostmorne_stpj_frostTime[pj]+(0.01*power)
call MagDamage(s__Frostmorne_stpj_caster[pj],s__Frostmorne_stpj_target[pj],s__Frostmorne_stpj_damage[pj])
if isUnitHero(s__Frostmorne_stpj_target[pj])then
set s__Frostmorne_stpj_frostTime[pj]=s__Frostmorne_stpj_frostTime[pj]/ 4
endif
call Frost_Start(s__Frostmorne_stpj_target[pj],s__Frostmorne_stpj_frostTime[pj])
call Frostmorne___setUnitCurrentTarget(s__Frostmorne_stpj_target[pj],false)
call s__Frostmorne_stpj_Destroy(pj)
endif
set t=null
endfunction
function Frostmorne___GetFirstProjectileIndex takes integer fm returns integer
local integer i=0
loop
exitwhen s__Frostmorne_st_count[fm]==i
if s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]!=0 and not s__Frostmorne_stpj_isLaunched[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]]then
return i
endif
set i=i+1
endloop
return 0
endfunction
function Frostmorne___ReloadProjectile_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer rl=LoadInt(id,"Frostmorne | Reload | Structure")
local real x=GetUnitX(s__Frostmorne_st_caster[s__Frostmorne_strl_fm[rl]])
local real y=GetUnitY(s__Frostmorne_st_caster[s__Frostmorne_strl_fm[rl]])
local integer i=0
local real x1
local real y1
local real angle=360.00/ I2R(s__Frostmorne_st_count[s__Frostmorne_strl_fm[rl]])
if s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[s__Frostmorne_strl_fm[rl]]+s__Frostmorne_strl_index[rl]]==0 then
set s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[s__Frostmorne_strl_fm[rl]]+s__Frostmorne_strl_index[rl]]=s__Frostmorne_stpj__allocate()
call SetEffectScale(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[s__Frostmorne_strl_fm[rl]]+s__Frostmorne_strl_index[rl]]],0.75)
call SetEffectZ(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[s__Frostmorne_strl_fm[rl]]+s__Frostmorne_strl_index[rl]]],100.00)
endif
loop
exitwhen i==s__Frostmorne_st_count[s__Frostmorne_strl_fm[rl]]
set x1=PolarPoints(x,y,s__Frostmorne_st_offset[s__Frostmorne_strl_fm[rl]],angle*i,"x")
set y1=PolarPoints(x,y,s__Frostmorne_st_offset[s__Frostmorne_strl_fm[rl]],angle*i,"y")
set s__Frostmorne_stpj_angle[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[s__Frostmorne_strl_fm[rl]]+i]]=angle*i
call SetEffectX(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[s__Frostmorne_strl_fm[rl]]+i]],x1)
call SetEffectY(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[s__Frostmorne_strl_fm[rl]]+i]],y1)
set i=i+1
endloop
call s__Frostmorne_strl_Destroy(rl)
set t=null
endfunction
function Frostmorne___ReloadProjectile takes integer fm,integer index returns nothing
local integer rl=s__Frostmorne_strl__allocate()
set s__Frostmorne_strl_fm[rl]=fm
set s__Frostmorne_strl_index[rl]=index
set s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+index]=0
call SaveInt(GetHandleId(s__Frostmorne_strl_t[rl]),"Frostmorne | Reload | Structure",rl)
call TimerStart(s__Frostmorne_strl_t[rl],s__Frostmorne_strl_time[rl],false,function Frostmorne___ReloadProjectile_timer)
endfunction
function Frostmorne___Frostmorne_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer fm=LoadInt(id,"Frostmorne | Structure")
local real x=GetUnitX(s__Frostmorne_st_caster[fm])
local real y=GetUnitY(s__Frostmorne_st_caster[fm])
local integer proj=0
local boolexpr filter
local integer i=0
local unit target
local real x1
local real y1
loop
exitwhen i==s__Frostmorne_st_count[fm]
if s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]!=0 and not s__Frostmorne_stpj_isLaunched[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]]and isUnitAlive(s__Frostmorne_st_caster[fm])then
if IsEffectHidden(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]])then
call ShowEffect(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],true)
endif
set s__Frostmorne_stpj_angle[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]]=s__Frostmorne_stpj_angle[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]]+s__Frostmorne_st_speed[fm]
set x1=PolarPoints(x,y,s__Frostmorne_st_offset[fm],s__Frostmorne_stpj_angle[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],"x")
set y1=PolarPoints(x,y,s__Frostmorne_st_offset[fm],s__Frostmorne_stpj_angle[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],"y")
call SetEffectFacing(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],s__Frostmorne_stpj_angle[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]]+90)
call SetEffectX(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],x1)
call SetEffectY(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],y1)
endif
set i=i+1
endloop
if isUnitAlive(s__Frostmorne_st_caster[fm])then
set bj_caster=s__Frostmorne_st_caster[fm]
set filter=Condition(function Frostmorne___Frostmorne_filter)
call GroupClear(s__Frostmorne_st_g[fm])
call GroupEnumUnitsInRange(s__Frostmorne_st_g[fm],x,y,s__Frostmorne_st_range[fm],filter)
set target=FirstOfGroup(s__Frostmorne_st_g[fm])
set i=Frostmorne___GetFirstProjectileIndex(fm)
set proj=s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]
if target!=null and proj!=0 and not Frostmorne___isUnitCurrentTarget(target)then
set s__Frostmorne_stpj_caster[proj]=s__Frostmorne_st_caster[fm]
set s__Frostmorne_stpj_target[proj]=target
set s__Frostmorne_stpj_isLaunched[proj]=true
set s__Frostmorne_stpj_damage[proj]=s__Frostmorne_st_lvl[fm]*Frostmorne___DAMAGE_PER_LVL
set s__Frostmorne_stpj_frostTime[proj]=s__Frostmorne_st_lvl[fm]*Frostmorne___FROST_TIME_PER_LVL
call Frostmorne___ReloadProjectile(fm,i)
call Frostmorne___setUnitCurrentTarget(target,true)
call SaveInt(GetHandleId(s__Frostmorne_stpj_t[proj]),"Frostmorne | Projectile | Structure",proj)
call TimerStart(s__Frostmorne_stpj_t[proj],s__Frostmorne_stpj_periodic[proj],true,function Frostmorne___Frostmorne_timerpj)
endif
else
set i=0
loop
exitwhen i==s__Frostmorne_st_count[fm]
if not IsEffectHidden(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]])then
call ShowEffect(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],false)
endif
set i=i+1
endloop
endif
set t=null
set target=null
set filter=null
endfunction
function Frostmorne___Frostmorne_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetHandleId(caster)
local integer lvl=GetUnitAbilityLevel(caster,GetLearnedSkill())
local integer fm=LoadInt(id,"Frostmorne | Structure")
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=0
local real x1
local real y1
local integer count=2+lvl
local real angle=360.00/ I2R(count)
if fm==0 then
set fm=s__Frostmorne_st__allocate()
set s__Frostmorne_st_caster[fm]=caster
call SaveInt(GetHandleId(s__Frostmorne_st_t[fm]),"Frostmorne | Structure",fm)
call TimerStart(s__Frostmorne_st_t[fm],s__Frostmorne_st_periodic[fm],true,function Frostmorne___Frostmorne_timer)
endif
set s__Frostmorne_st_lvl[fm]=lvl
set s__Frostmorne_st_count[fm]=count
loop
exitwhen count==0
if s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]==0 then
set s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]=s__Frostmorne_stpj__allocate()
call SetEffectScale(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],0.75)
call SetEffectZ(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],100.00)
endif
set x1=PolarPoints(x,y,s__Frostmorne_st_offset[fm],angle*i,"x")
set y1=PolarPoints(x,y,s__Frostmorne_st_offset[fm],angle*i,"y")
set s__Frostmorne_stpj_angle[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]]=angle*i
call SetEffectX(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],x1)
call SetEffectY(s__Frostmorne_stpj_eff[s___Frostmorne_st_projectiles[s__Frostmorne_st_projectiles[fm]+i]],y1)
set i=i+1
set count=count-1
endloop
call SaveInt(id,"Frostmorne | Structure",fm)
set caster=null
endfunction
function Frostmorne___Frostmorne_Conditions takes nothing returns boolean
return GetLearnedSkill()=='A0FR'
endfunction
function Frostmorne___Init takes nothing returns nothing
local trigger trig=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(trig,EVENT_PLAYER_HERO_SKILL)
call TriggerAddCondition(trig,Condition(function Frostmorne___Frostmorne_Conditions))
call TriggerAddAction(trig,function Frostmorne___Frostmorne_Actions)
set trig=null
endfunction
function Move___MoveUnit_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local real speed=LoadReal(udg_Hash,id,StringHash("MoveUnit|Speed"))
local real angle=LoadReal(udg_Hash,id,StringHash("MoveUnit|Angle"))
local real dist=LoadReal(udg_Hash,id,StringHash("MoveUnit|Distance"))
local real max_dist=LoadReal(udg_Hash,id,StringHash("MoveUnit|MaxDistance"))
local real fly_speed=LoadReal(udg_Hash,id,StringHash("MoveUnit|FlySpeed"))
local boolean pause=LoadBoolean(udg_Hash,id,StringHash("MoveUnit|Pause"))
local unit target=LoadUnitHandle(udg_Hash,id,StringHash("MoveUnit|Target"))
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real x1
local real y1
if(dist>0)then
set dist=dist-speed
call SaveReal(udg_Hash,id,StringHash("MoveUnit|Distance"),dist)
set x1=x+speed*Cos(angle*bj_DEGTORAD)
set y1=y+speed*Sin(angle*bj_DEGTORAD)
if(fly_speed>0.00)then
if(dist>max_dist*0.5)then
call SetUnitFlyHeight(target,GetUnitFlyHeight(target)+fly_speed,0.00)
else
call SetUnitFlyHeight(target,GetUnitFlyHeight(target)-fly_speed,0.00)
endif
endif
call SetUnitPosition(target,x1,y1)
else
if(pause==true)then
call PauseUnit(target,false)
endif
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
endif
set t=null
set target=null
endfunction
function Move_MoveUnit takes unit target,real periodic,real speed,real distance,real angle,boolean pause,boolean fly returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
if(IsUnitPaused(target)==false)then
if(pause==true)then
call PauseUnit(target,true)
endif
else
set pause=false
endif
if(IsUnitType(target,UNIT_TYPE_STRUCTURE)==false)then
call SaveReal(udg_Hash,id,StringHash("MoveUnit|Speed"),speed)
call SaveReal(udg_Hash,id,StringHash("MoveUnit|Angle"),angle)
call SaveBoolean(udg_Hash,id,StringHash("MoveUnit|Pause"),pause)
call SaveReal(udg_Hash,id,StringHash("MoveUnit|Distance"),distance)
call SaveReal(udg_Hash,id,StringHash("MoveUnit|MaxDistance"),distance)
call SaveUnitHandle(udg_Hash,id,StringHash("MoveUnit|Target"),target)
if fly==true then
call UnitAddAbility(target,'Arav')
call UnitRemoveAbility(target,'Arav')
call SaveReal(udg_Hash,id,StringHash("MoveUnit|FlySpeed"),speed*0.75)
endif
call TimerStart(t,periodic,true,function Move___MoveUnit_timer)
endif
set t=null
set target=null
endfunction
function s__Move___Jump_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__Move___Jump_Timer[this])
call DestroyTimer(s__Move___Jump_Timer[this])
call FlushChildHashtable(udg_Hash,id)
set s__Move___Jump_Timer[this]=null
set s__Move___Jump_target[this]=null
call s__Move___Jump_deallocate(this)
endfunction
function Move___Jump_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer jump=LoadInteger(udg_Hash,id,StringHash("Jump | Struct"))
local real flyHeight=GetUnitFlyHeight(s__Move___Jump_target[jump])
if s__Move___Jump_totalCount[jump]>0 then
set s__Move___Jump_totalCount[jump]=s__Move___Jump_totalCount[jump]-s__Move___Jump_speed[jump]
if s__Move___Jump_totalCount[jump]>s__Move___Jump_height[jump]then
call SetUnitFlyHeight(s__Move___Jump_target[jump],flyHeight+s__Move___Jump_speed[jump],0.00)
else
call SetUnitFlyHeight(s__Move___Jump_target[jump],flyHeight-s__Move___Jump_speed[jump],0.00)
endif
else
if s__Move___Jump_stunTime[jump]>0 then
call Stun_Start(s__Move___Jump_target[jump],s__Move___Jump_stunTime[jump])
endif
if s__Move___Jump_isPaused[jump]then
call PauseUnit(s__Move___Jump_target[jump],false)
endif
call s__Move___Jump_Destroy(jump)
endif
set t=null
endfunction
function Move_Jump_start takes unit target,real height,real speed,boolean isPaused,real stunTime returns real
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer jump=s__Move___Jump__allocate()
if IsUnitPaused(target)==false then
if(isPaused==true)then
call PauseUnit(target,true)
endif
else
set isPaused=false
endif
set s__Move___Jump_Timer[jump]=t
set s__Move___Jump_target[jump]=target
set s__Move___Jump_height[jump]=height
set s__Move___Jump_speed[jump]=speed
set s__Move___Jump_isPaused[jump]=isPaused
set s__Move___Jump_periodic[jump]=0.03
set s__Move___Jump_totalCount[jump]=height*2
set s__Move___Jump_stunTime[jump]=stunTime
call UnitAddAbility(target,'Arav')
call UnitRemoveAbility(target,'Arav')
call SaveInteger(udg_Hash,id,StringHash("Jump | Struct"),jump)
call TimerStart(t,s__Move___Jump_periodic[jump],true,function Move___Jump_timer)
set t=null
return s__Move___Jump_totalCount[jump]/ s__Move___Jump_speed[jump]*s__Move___Jump_periodic[jump]
endfunction
function isPlayerHasCommunism takes player p returns boolean
return GetPlayerTechCount(p,'R054',true)>0
endfunction
function isPlayerHasGreedy takes player p returns boolean
return GetPlayerTechCount(p,'R055',true)>0
endfunction
function isPlayerHasBasterds takes player p returns boolean
return GetPlayerTechCount(p,'R00V',true)>0
endfunction
function isPlayerHasSoloHero takes player p returns boolean
return GetPlayerTechCount(p,'R02A',true)>0
endfunction
function isPlayerHasTranquility takes player p returns boolean
return GetPlayerTechCount(p,'R057',true)>0
endfunction
function isPlayerHasCursedGold takes player p returns boolean
return GetPlayerTechCount(p,'R02L',true)>0
endfunction
function isPlayerHasLegion takes player p returns boolean
return GetPlayerTechCount(p,'R058',true)>0
endfunction
function isPlayerHasHolodomor takes player p returns boolean
return GetPlayerTechCount(p,'R059',true)>0
endfunction
function isPlayerHasUnits takes player p returns boolean
return GetPlayerTechCount(p,'R052',true)==0
endfunction
function GetTalantIndex takes integer id returns integer
local integer index=TALANTS_LIST_MIN
loop
exitwhen index>TALANTS_LIST_MAX
if TALANTS_LIST[index]==id then
return index
endif
set index=index+1
endloop
return-1
endfunction
function RemoveTalantFromList takes integer id returns nothing
local integer index=GetTalantIndex(id)
if index==-1 then
return
endif
set TALANTS_LIST[index]=TALANTS_LIST[TALANTS_LIST_MAX]
set TALANTS_LIST[TALANTS_LIST_MAX]=0
set TALANTS_LIST_MAX=TALANTS_LIST_MAX-1
endfunction
function InitRandomTalants takes nothing returns nothing
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01N'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01O'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01P'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01Q'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01R'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R00F'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01S'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R00V'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01T'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01U'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R01V'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R029'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R02A'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R02J'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R02K'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R02L'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R02O'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R02Q'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R034'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R035'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R036'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R02R'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R037'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R03Q'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R03S'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R047'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04B'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04D'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04E'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04J'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04K'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04T'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04U'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04V'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04W'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R04X'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R054'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R055'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R057'
set TALANTS_LIST_MAX=TALANTS_LIST_MAX+1
set TALANTS_LIST[TALANTS_LIST_MAX]='R059'
endfunction
function GetRandomTalant takes nothing returns integer
local integer talant=0
local integer index=0
call SetRandomSeed(GetRandomInt(-1000000,1000000))
set index=GetRandomInt(TALANTS_LIST_MIN,TALANTS_LIST_MAX)
set talant=TALANTS_LIST[index]
set TALANTS_LIST[index]=TALANTS_LIST[TALANTS_LIST_MAX]
set TALANTS_LIST[TALANTS_LIST_MAX]=0
set TALANTS_LIST_MAX=TALANTS_LIST_MAX-1
return talant
endfunction
function GlyxOborona takes nothing returns nothing
local unit target=GetEnumUnit()
local integer i=GetPlayerId(GetOwningPlayer(target))
local real x=GetUnitX(target)
local real y=GetUnitY(target)
call RemoveUnit(target)
set target=CreateUnit(Player(i),'n002',x,y,bj_UNIT_FACING)
if(i!=1 and i!=4)then
call UnitAddAbility(target,'A022')
call SetPlayerTechResearched(Player(i),'Rhgb',1)
endif
set target=null
endfunction
function Talants_Give takes unit caster,integer id returns nothing
local integer i=GetPlayerId(GetOwningPlayer(caster))
local multiboarditem mbitem
local boolean isTalantReplaceArmy=false
local boolean isTalantRemoveArmy=false
local boolean isTalantRemoveHero=false
local boolean replace=false
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local string Icon
local integer gold
local integer q
local unit dami
local real x1
local real y1
local integer damiID='h000'
if(id=='R01N')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNFarSight.blp"
set udg_SpawnTime[i+1]=(udg_SpawnTime[i+1]-3.25)
endif
if(id=='R01O')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNDalaranGuardTower.blp"
set bj_groupEnumTypeId='h004'
call GroupEnumUnitsOfPlayer(g,Player(i),filterGetUnitsOfPlayerAndTypeId)
call ForGroup(g,function GlyxOborona)
call DestroyGroup(g)
set hasDefense[i+1]=true
endif
if(id=='R01P')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNSorceress.blp"
set x1=x+500*Cos(60*bj_DEGTORAD)
set y1=y+500*Sin(60*bj_DEGTORAD)
if(GetPlayerTechCount(Player(i),'R03V',true)==1)then
call CreateUnit(Player(i),'h02J',x1,y1,bj_UNIT_FACING)
else
call CreateUnit(Player(i),'h009',x1,y1,bj_UNIT_FACING)
endif
endif
if(id=='R01Q')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp"
call SetPlayerHandicap(Player(i),(GetPlayerHandicap(Player(i))+0.40))
endif
if(id=='R01R')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNGrunt.blp"
endif
if(id=='R00F')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNGoblinLandMine.blp"
set q=1
loop
exitwhen q>30
set x1=GetRandomReal(x-(1100/ 2),x+(1100/ 2))
set y1=GetRandomReal(y-(1100/ 2),y+(1100/ 2))
call CreateUnit(Player(i),'nglm',x1,y1,bj_UNIT_FACING)
set q=q+1
endloop
set hasDefense[i+1]=true
endif
if(id=='R01S')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNChestOfGold.blp"
set gold=400
call SetPlayerState(Player(i),PLAYER_STATE_RESOURCE_GOLD,GetPlayerState(Player(i),PLAYER_STATE_RESOURCE_GOLD)+gold)
endif
if(id=='R00V')then
set replace=true
set isTalantRemoveArmy=true
set isTalantReplaceArmy=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNBandit.blp"
call SetPlayerState(Player(i),PLAYER_STATE_RESOURCE_FOOD_CAP,20)
call RemoveMercenaryLimits(Player(i))
endif
if(id=='R01T')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNSpellSteal.blp"
call SetPlayerTechResearched(Player(i),'R04L',1)
set hasDefense[i+1]=true
endif
if(id=='R01U')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNSpinyCrab.blp"
endif
if(id=='R01V')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNPeasant.blp"
set x1=x+500*Cos(60*bj_DEGTORAD)
set y1=y+500*Sin(60*bj_DEGTORAD)
call CreateUnit(Player(i),'h01O',x1,y1,bj_UNIT_FACING)
set hasDefense[i+1]=true
endif
if(id=='R029')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNTomeOfRetraining.blp"
endif
if(id=='R02A')then
set replace=true
set isTalantRemoveArmy=true
set isTalantReplaceArmy=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNReincarnation.blp"
call SetPlayerState(Player(i),PLAYER_STATE_FOOD_CAP_CEILING,SOLO_HERO_FOOD)
call SetPlayerTechResearched(Player(i),'R04C',1)
set udg_HeroResTime[i+1]=(udg_HeroResTime[i+1]-20.00)
endif
if(id=='R02J')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNMirrorImage.blp"
endif
if(id=='R02K')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNSell.blp"
endif
if(id=='R02L')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNDarkGold.blp"
endif
if(id=='R02O')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNPackBeast.blp"
endif
if(id=='R02Q')then
set replace=true
set isTalantRemoveHero=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNTemp.blp"
set udg_SpawnTime[i+1]=(udg_SpawnTime[i+1]-2.00)
endif
if(id=='R034')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNDwarvenLongRifle.blp"
set hasDefense[i+1]=true
endif
if(id=='R035')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNControlMagic.blp"
endif
if(id=='R036')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNMagicVault.blp"
endif
if(id=='R02R')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNGreenHydra.blp"
endif
if(id=='R037')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNGarithos.blp"
endif
if(id=='R03Q')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNRifleman.blp"
endif
if(id=='R03S')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNMilitia.blp"
set hasDefense[i+1]=true
endif
if(id=='R047')then
set replace=true
set isTalantRemoveArmy=true
set isTalantReplaceArmy=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNHydralisk.blp"
call SetPlayerState(Player(i),PLAYER_STATE_FOOD_CAP_CEILING,0)
endif
if(id=='R04B')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNMedivh.blp"
endif
if(id=='R04D')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNSleep.blp"
endif
if(id=='R04E')then
set replace=true
set isTalantRemoveArmy=true
set isTalantReplaceArmy=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNAcolyte.blp"
call SetPlayerState(Player(i),PLAYER_STATE_FOOD_CAP_CEILING,0)
endif
if(id=='R04I')then
set replace=true
set isTalantRemoveArmy=true
set isTalantReplaceArmy=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNRockGolem.blp"
call SetPlayerState(Player(i),PLAYER_STATE_FOOD_CAP_CEILING,0)
set damiID='h02N'
endif
if(id=='R04J')then
set replace=true
set isTalantReplaceArmy=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNZombie.blp"
endif
if(id=='R04K')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNDizzy.blp"
set hasDefense[i+1]=true
endif
if(id=='R04T')then
set replace=true
set isTalantRemoveArmy=true
set isTalantReplaceArmy=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNHeroBloodElfPrince.blp"
call SetPlayerState(Player(i),PLAYER_STATE_FOOD_CAP_CEILING,0)
endif
if id=='R04U' then
set replace=true
set isTalantRemoveHero=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNShadeTrueSight.blp"
set udg_SpawnTime[i+1]=(udg_SpawnTime[i+1]-2.00)
endif
if id=='R04V' then
set replace=true
set isTalantRemoveHero=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNCommand.blp"
set udg_SpawnTime[i+1]=(udg_SpawnTime[i+1]-2.75)
call DictatorshipOfProletariat(Player(i))
endif
if(id=='R04W')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNSpiritLink.blp"
endif
if(id=='R04X')then
set replace=true
set isTalantRemoveArmy=true
set isTalantReplaceArmy=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNBlackWizard.blp"
call SetPlayerState(Player(i),PLAYER_STATE_FOOD_CAP_CEILING,0)
endif
if(id=='R054')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNHumanCaptureFlag.blp"
endif
if(id=='R055')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNDustOfAppearance.blp"
endif
if(id=='R057')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNTranquility.blp"
endif
if(id=='R058')then
set replace=true
set Icon="ReplaceableTextures\\CommandButtons\\BTNAnimateDead.blp"
endif
if id=='R059' then
set replace=true
set bj_unitLimit[i+1]=24
call SetPlayerState(Player(i),PLAYER_STATE_FOOD_CAP_CEILING,0)
set Icon="ReplaceableTextures\\CommandButtons\\BTNMonsterLure.blp"
endif
if(replace==true)then
if not isTalantReplaceArmy then
call SetPlayerTechResearched(Player(i),'R051',1)
endif
if not isTalantRemoveArmy then
call SetPlayerTechResearched(Player(i),'R052',1)
endif
if not isTalantRemoveHero then
call SetPlayerTechResearched(Player(i),'R053',1)
endif
call RemoveUnit(caster)
set dami=CreateUnit(Player(i),damiID,x,y,bj_UNIT_FACING)
set udg_TalantPicker[i+1]=dami
call MultiboardIconForAllies(Player(i),Icon,i+1,3)
call SelectUnitForPlayerSingle(dami,Player(i))
endif
call DestroyGroup(g)
set g=null
set dami=null
set caster=null
set mbitem=null
endfunction
function Talants_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
call Talants_Give(caster,GetResearched())
set caster=null
endfunction
function TalantsLib__Talants_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())!='n021'
endfunction
function TalantsLib__InitTriggers takes nothing returns nothing
local trigger t=CreateTrigger()
local integer i=0
loop
call TriggerRegisterPlayerUnitEvent(t,Player(i),EVENT_PLAYER_UNIT_RESEARCH_FINISH,null)
set i=i+1
exitwhen i==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(t,function Talants_Actions)
call TriggerAddCondition(t,Condition(function TalantsLib__Talants_Conditions))
call InitRandomTalants()
set t=null
endfunction
function s__BadWave__BadWave_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__BadWave__BadWave_st_Timer[this])
call DestroyTimer(s__BadWave__BadWave_st_Timer[this])
call DestroyGroup(s__BadWave__BadWave_st_damagedGroup[this])
call DestroyLightningN(s__BadWave__BadWave_st_wave[this],1.00)
call FlushChildHashtable(udg_Hash,id)
set s__BadWave__BadWave_st_count[this]=0
set s__BadWave__BadWave_st_wave[this]=null
set s__BadWave__BadWave_st_Timer[this]=null
set s__BadWave__BadWave_st_target[this]=null
set s__BadWave__BadWave_st_caster[this]=null
set s__BadWave__BadWave_st_damagedGroup[this]=null
call s__BadWave__BadWave_st_deallocate(this)
endfunction
function BadWave__BadWave_filterHero takes nothing returns boolean
return isUnitHero(GetFilterUnit())and not IsUnitInGroup(GetFilterUnit(),bj_group)and not isUnitStruct(GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0.00 and isUnitEnemy(bj_caster,GetFilterUnit())
endfunction
function BadWave__BadWave_filter takes nothing returns boolean
return not IsUnitInGroup(GetFilterUnit(),bj_group)and not isUnitStruct(GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0.00 and isUnitEnemy(bj_caster,GetFilterUnit())
endfunction
function BadWave__BadWave_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer bw=LoadInt(id,"BadWave | Structure")
local group g=CreateGroup()
local real x=GetUnitX(s__BadWave__BadWave_st_target[bw])
local real y=GetUnitY(s__BadWave__BadWave_st_target[bw])
local boolexpr filter
local unit target
local real height=75.00
if s__BadWave__BadWave_st_count[bw]>0 then
set s__BadWave__BadWave_st_count[bw]=s__BadWave__BadWave_st_count[bw]-1
if s__BadWave__BadWave_st_isFirst[bw]then
set s__BadWave__BadWave_st_isFirst[bw]=false
if isPlayerHasSoloHero(Owner(s__BadWave__BadWave_st_caster[bw]))and isUnitHero(s__BadWave__BadWave_st_target[bw])then
call MagDamage(s__BadWave__BadWave_st_caster[bw],s__BadWave__BadWave_st_target[bw],s__BadWave__BadWave_st_damage[bw]*1.25)
else
call MagDamage(s__BadWave__BadWave_st_caster[bw],s__BadWave__BadWave_st_target[bw],s__BadWave__BadWave_st_damage[bw])
endif
call TimedEffectTarget(BadWave__DAMAGE_FX,s__BadWave__BadWave_st_target[bw],"origin",1.00)
set s__BadWave__BadWave_st_damage[bw]=s__BadWave__BadWave_st_damage[bw]-(s__BadWave__BadWave_st_damage[bw]*s__BadWave__BadWave_st_damageDebuff[bw])
endif
set bj_caster=s__BadWave__BadWave_st_caster[bw]
set bj_group=s__BadWave__BadWave_st_damagedGroup[bw]
set filter=Condition(function BadWave__BadWave_filter)
call GroupEnumUnitsInRange(g,x,y,s__BadWave__BadWave_st_range[bw],filter)
set target=FirstOfGroup(g)
if target==s__BadWave__BadWave_st_target[bw]then
call GroupRemoveUnit(g,target)
set target=FirstOfGroup(g)
endif
if isPlayerHasSoloHero(Owner(s__BadWave__BadWave_st_caster[bw]))and(s__BadWave__BadWave_st_count[bw]==0 or target==null)then
set bj_caster=s__BadWave__BadWave_st_caster[bw]
set bj_group=s__BadWave__BadWave_st_damagedGroup[bw]
set filter=Condition(function BadWave__BadWave_filterHero)
call GroupEnumUnitsInRange(g,x,y,1000.00,filter)
set target=FirstOfGroup(g)
if target==s__BadWave__BadWave_st_target[bw]then
call GroupRemoveUnit(g,target)
set target=FirstOfGroup(g)
endif
endif
if target!=null then
call DestroyLightningN(s__BadWave__BadWave_st_wave[bw],BadWave__WAVE_DESTROY_TIME)
set s__BadWave__BadWave_st_wave[bw]=AddLightningEx(BadWave__WAVE_FX,true,x,y,height,GetUnitX(target),GetUnitY(target),height)
call TimedEffectTarget(BadWave__DAMAGE_FX,target,"origin",1.00)
if isPlayerHasSoloHero(Owner(s__BadWave__BadWave_st_caster[bw]))and isUnitHero(target)then
call MagDamage(s__BadWave__BadWave_st_caster[bw],target,s__BadWave__BadWave_st_damage[bw]*1.25)
else
call MagDamage(s__BadWave__BadWave_st_caster[bw],target,s__BadWave__BadWave_st_damage[bw])
endif
call GroupAddUnit(s__BadWave__BadWave_st_damagedGroup[bw],target)
set s__BadWave__BadWave_st_target[bw]=target
set s__BadWave__BadWave_st_damage[bw]=s__BadWave__BadWave_st_damage[bw]-(s__BadWave__BadWave_st_damage[bw]*s__BadWave__BadWave_st_damageDebuff[bw])
else
call s__BadWave__BadWave_st_Destroy(bw)
endif
else
call s__BadWave__BadWave_st_Destroy(bw)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set t=null
set target=null
set filter=null
endfunction
function BadWave__BadWave_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local unit target=GetSpellTargetUnit()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer bw=s__BadWave__BadWave_st__allocate()
local real x1=GetUnitX(caster)
local real y1=GetUnitY(caster)
local real x2=GetUnitX(target)
local real y2=GetUnitY(target)
local real height=75.00
local real periodic=0.10
set s__BadWave__BadWave_st_Timer[bw]=t
set s__BadWave__BadWave_st_isFirst[bw]=true
set s__BadWave__BadWave_st_caster[bw]=caster
set s__BadWave__BadWave_st_target[bw]=target
set s__BadWave__BadWave_st_count[bw]=2+(2*lvl)
set s__BadWave__BadWave_st_range[bw]=500.00
set s__BadWave__BadWave_st_damage[bw]=45.00*lvl
set s__BadWave__BadWave_st_damageDebuff[bw]=0.11-(0.01*lvl)
set s__BadWave__BadWave_st_wave[bw]=AddLightningEx(BadWave__WAVE_FX,true,x1,y1,height,x2,y2,height)
if isPlayerHasSoloHero(Owner(caster))then
set s__BadWave__BadWave_st_count[bw]=s__BadWave__BadWave_st_count[bw]+1
endif
call SaveInt(id,"BadWave | Structure",bw)
call TimerStart(t,periodic,true,function BadWave__BadWave_timer)
set t=null
set caster=null
set target=null
endfunction
function BadWave__BadWave_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0BP'
endfunction
function BadWave__Init takes nothing returns nothing
local trigger wave=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(wave,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(wave,Condition(function BadWave__BadWave_Conditions))
call TriggerAddAction(wave,function BadWave__BadWave_Actions)
set wave=null
endfunction
function Clap___Clap_filter takes nothing returns boolean
return isUnitAlive(GetFilterUnit())and isUnitEnemy(GetFilterUnit(),bj_caster)and not isUnitStruct(GetFilterUnit())
endfunction
function Clap___Clap_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
local real range=250.00
local real time=5.00
local real l__damage=20.00*lvl
local string effPath="Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl"
local string debuffEffPath="Abilities\\Spells\\Orc\\StasisTrap\\StasisTotemTarget.mdl"
local integer moveDebuffAbil='A0JP'
local real dtime=0.00
set eff=AddSpecialEffect(effPath,x,y)
call DestroyEffect(eff)
set bj_caster=caster
set filter=Condition(function Clap___Clap_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set dtime=time
if isUnitHero(target)then
set dtime=dtime/ 2
endif
call MagDamage(caster,target,l__damage)
call TimedAbility(target,moveDebuffAbil,dtime)
call TimedEffectTarget(debuffEffPath,target,"overhead",dtime)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set target=null
set caster=null
set filter=null
endfunction
function Clap___Clap_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0JO'
endfunction
function Clap___InitTrig takes nothing returns nothing
local trigger clap=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(clap,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(clap,Condition(function Clap___Clap_Conditions))
call TriggerAddAction(clap,function Clap___Clap_Actions)
set clap=null
endfunction
function CursedPrince___DeathCoil_filter takes nothing returns boolean
return isUnitEnemy(bj_caster,GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0.00 and not isUnitStruct(GetFilterUnit())
endfunction
function CursedPrince___DeathCoil_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0J6')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
local integer count=0
local real time=10.00
local real l__damage=0.00
local real range=275.00
local real damagePerUnit=4.00*lvl
if isPlayerHasSoloHero(Owner(caster))then
set range=range+125.00
endif
set bj_caster=caster
set filter=Condition(function CursedPrince___DeathCoil_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
set count=CountUnitsInGroup(g)
set l__damage=damagePerUnit*count
loop
set target=FirstOfGroup(g)
exitwhen target==null
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilSpecialArt.mdl",target,"chest")
call DestroyEffect(eff)
call MagDamage(caster,target,l__damage)
call TimedAbility(target,'A09S',time)
call SaveUnit(GetHandleId(target),"Crused Prince | Death Coil | Caster",caster)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set filter=null
set target=null
set caster=null
endfunction
function CursedPrince___CallOfDarkness_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0J8')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local boolexpr filter
local unit target
local real angle
local effect eff
local unit dummy
local real healthPercent=0.35+(0.05*lvl)
local integer dummyID='h00S'
local real range=275.00
local boolean soloHeroFilter=false
local boolean standartFilter=false
if isPlayerHasSoloHero(Owner(caster))then
set range=range+125.00
endif
set bj_caster=caster
set filter=Condition(function CursedPrince___DeathCoil_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set soloHeroFilter=isPlayerHasSoloHero(Owner(caster))and GetUnitHealthPercent(target)<=0.25 and not isUnitHero(target)
set standartFilter=GetUnitAbilityLevel(target,'A0J7')>0 and GetUnitHealthPercent(target)<=healthPercent and not isUnitHero(target)
if soloHeroFilter or standartFilter then
set x=GetUnitX(target)
set y=GetUnitY(target)
set angle=GetUnitFacing(target)
call RemoveUnit(target)
set eff=AddSpecialEffect("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",x,y)
call DestroyEffect(eff)
set dummy=CreateUnit(Owner(caster),dummyID,x,y,angle)
call UnitApplyTimedLife(dummy,'BTLF',30.00)
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set dummy=null
set filter=null
set target=null
set caster=null
endfunction
function CursedPrince___DeathAuraHero_filter takes nothing returns boolean
return GetUnitHealth(GetFilterUnit())>0.00 and GetUnitAbilityLevel(GetFilterUnit(),'A01H')>0
endfunction
function CursedPrince___DeathAura_filter takes nothing returns boolean
local unit caster=LoadUnit(GetHandleId(GetFilterUnit()),"Crused Prince | Death Coil | Caster")
local boolean isCaster=caster==bj_caster
set caster=null
return GetWidgetLife(GetFilterUnit())>0.00 and GetUnitAbilityLevel(GetFilterUnit(),'A0J7')>0 and isCaster
endfunction
function CursedPrince___DeathAura_Actions takes nothing returns nothing
local group g=CreateGroup()
local integer lvl=0
local boolexpr filter
local unit target
local unit dummy
local effect eff
local group gg
local real l__damage=3*lvl
local real range=600.00
set filter=Condition(function CursedPrince___DeathAuraHero_filter)
call GroupEnumUnitsInRange(g,0,0,999999999,filter)
call DestroyBoolExpr(filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set lvl=GetUnitAbilityLevel(target,'A01H')
set l__damage=3*lvl
set gg=CreateGroup()
set bj_caster=target
set filter=Condition(function CursedPrince___DeathAura_filter)
call GroupEnumUnitsInRange(gg,GetUnitX(target),GetUnitY(target),range,filter)
loop
set dummy=FirstOfGroup(gg)
exitwhen dummy==null
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Cleave\\CleaveDamageTarget.mdl",dummy,"chest")
call DestroyEffect(eff)
call MagDamage(target,dummy,l__damage)
call GroupRemoveUnit(gg,dummy)
endloop
call DestroyGroup(gg)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyGroup(gg)
call DestroyBoolExpr(filter)
set g=null
set gg=null
set eff=null
set dummy=null
set filter=null
set target=null
endfunction
function CursedPrince___DeathCoil_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0J6'
endfunction
function CursedPrince___CallOfDarkness_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0J8'
endfunction
function CursedPrince___InitTriggers takes nothing returns nothing
local trigger callOfDarkness=CreateTrigger()
local trigger deathAura=CreateTrigger()
local trigger deathCoil=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(callOfDarkness,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(callOfDarkness,Condition(function CursedPrince___CallOfDarkness_Conditions))
call TriggerAddAction(callOfDarkness,function CursedPrince___CallOfDarkness_Actions)
call TriggerRegisterAnyUnitEventBJ(deathCoil,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(deathCoil,Condition(function CursedPrince___DeathCoil_Conditions))
call TriggerAddAction(deathCoil,function CursedPrince___DeathCoil_Actions)
call TriggerRegisterTimerEventPeriodic(deathAura,1.00)
call TriggerAddAction(deathAura,function CursedPrince___DeathAura_Actions)
set deathCoil=null
set deathAura=null
set callOfDarkness=null
endfunction
function GetSkeletonIdByLvl takes unit caster returns integer
local integer lvl=GetUnitAbilityLevel(caster,'A071')
local integer array skeleton
set skeleton[0]=0
set skeleton[1]='u00J'
set skeleton[2]='u00K'
set skeleton[3]='u00L'
set skeleton[4]='u00M'
set skeleton[5]='u00N'
if isPlayerHasSoloHero(Owner(caster))then
set skeleton[5]='u002'
endif
return skeleton[lvl]
endfunction
function DarkRevenge__DarkRevenge_filter takes nothing returns boolean
return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))and GetUnitHealth(GetFilterUnit())>0
endfunction
function s__DarkRevenge_st_Destroy takes integer this returns nothing
set s__DarkRevenge_st_count[this]=0
set s__DarkRevenge_st_caster[this]=null
call s__DarkRevenge_st_deallocate(this)
endfunction
function s__DarkRevengeProjectile_st_Destroy takes integer this returns nothing
call RemoveUnit(s__DarkRevengeProjectile_st_dummy[this])
call DestroyGroup(s__DarkRevengeProjectile_st_picker[this])
set s__DarkRevengeProjectile_st_dummy[this]=null
set s__DarkRevengeProjectile_st_picker[this]=null
set s__DarkRevengeProjectile_st_caster[this]=null
call s__DarkRevengeProjectile_st_deallocate(this)
endfunction
function DarkRevenge__DarkRevenge_timer takes nothing returns nothing
local timer spellTimer=GetExpiredTimer()
local integer timerID=GetHandleId(spellTimer)
local integer prj=LoadInt(timerID,"DarkRevengeProjectile | Structure")
local integer skelLevel=GetUnitAbilityLevel(s__DarkRevengeProjectile_st_caster[prj],'A071')
local integer skelId=GetSkeletonIdByLvl(s__DarkRevengeProjectile_st_caster[prj])
local real height=GetUnitFlyHeight(s__DarkRevengeProjectile_st_dummy[prj])
local real angle=GetUnitFacing(s__DarkRevengeProjectile_st_dummy[prj])
local real dummyX=GetUnitX(s__DarkRevengeProjectile_st_dummy[prj])
local real dummyY=GetUnitY(s__DarkRevengeProjectile_st_dummy[prj])
local unit target=null
local effect spellEffect
local real targetHeight
local boolexpr filter
local unit skel=null
local real totalX
local real totalY
if height>=s__DarkRevengeProjectile_st_flySpeed[prj]then
set totalX=PolarPoints(dummyX,dummyY,s__DarkRevengeProjectile_st_speed[prj],angle,"x")
set totalY=PolarPoints(dummyX,dummyY,s__DarkRevengeProjectile_st_speed[prj],angle,"y")
call SetUnitPosition(s__DarkRevengeProjectile_st_dummy[prj],totalX,totalY)
set s__DarkRevengeProjectile_st_distance[prj]=s__DarkRevengeProjectile_st_distance[prj]+s__DarkRevengeProjectile_st_speed[prj]
call SetUnitHeightByDistance(s__DarkRevengeProjectile_st_dummy[prj],s__DarkRevengeProjectile_st_distance[prj],s__DarkRevengeProjectile_st_maxDistance[prj],s__DarkRevengeProjectile_st_flySpeed[prj],s__DarkRevengeProjectile_st_flySpeed[prj]/ 0.03)
if s__DarkRevengeProjectile_st_distance[prj]>=s__DarkRevengeProjectile_st_maxDistance[prj]/ 2 then
if s__DarkRevengeProjectile_st_angle[prj]!=0.00 then
set angle=angle-s__DarkRevengeProjectile_st_angle[prj]
call SetUnitFacing(s__DarkRevengeProjectile_st_dummy[prj],angle)
set s__DarkRevengeProjectile_st_angle[prj]=0.00
endif
elseif s__DarkRevengeProjectile_st_distance[prj]>=s__DarkRevengeProjectile_st_maxDistance[prj]/ 4 then
if s__DarkRevengeProjectile_st_angle[prj]!=s__DarkRevengeProjectile_st_stAngle[prj]/ 2 then
set angle=angle-s__DarkRevengeProjectile_st_angle[prj]
call SetUnitFacing(s__DarkRevengeProjectile_st_dummy[prj],angle)
set s__DarkRevengeProjectile_st_angle[prj]=s__DarkRevengeProjectile_st_angle[prj]/ 2
endif
endif
set bj_caster=s__DarkRevengeProjectile_st_caster[prj]
set filter=Condition(function DarkRevenge__DarkRevenge_filter)
call GroupEnumUnitsInRange(s__DarkRevengeProjectile_st_picker[prj],totalX,totalY,s__DarkRevengeProjectile_st_dmgCheckRange[prj],filter)
set target=FirstOfGroup(s__DarkRevengeProjectile_st_picker[prj])
if target!=null then
call DestroyTimer(spellTimer)
call FlushChildHashtable(udg_Hash,timerID)
set spellEffect=AddSpecialEffect("Abilities\\Spells\\Undead\\DeathandDecay\\DeathandDecayTarget.mdl",GetUnitX(target),GetUnitY(target))
call DestroyEffect(spellEffect)
call MagDamage(s__DarkRevengeProjectile_st_caster[prj],target,s__DarkRevengeProjectile_st_damage[prj])
call s__DarkRevengeProjectile_st_Destroy(prj)
endif
else
call DestroyTimer(spellTimer)
call FlushChildHashtable(udg_Hash,timerID)
if skelId!=0 then
set spellEffect=AddSpecialEffect("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",dummyX,dummyY)
call DestroyEffect(spellEffect)
set skel=CreateUnit(GetOwningPlayer(s__DarkRevengeProjectile_st_caster[prj]),skelId,dummyX,dummyY,angle)
call UnitApplyTimedLife(skel,'BTLF',45.00)
if(GetPlayerTechCount(GetOwningPlayer(s__DarkRevengeProjectile_st_caster[prj]),'R02A',true)>0)then
call UnitAddAbility(skel,'A074')
endif
else
set spellEffect=AddSpecialEffect("Abilities\\Spells\\Undead\\DeathandDecay\\DeathandDecayTarget.mdl",dummyX,dummyY)
call DestroyEffect(spellEffect)
endif
call s__DarkRevengeProjectile_st_Destroy(prj)
endif
call DestroyBoolExpr(filter)
call DestroyEffect(spellEffect)
set skel=null
set target=null
set filter=null
set spellTimer=null
set spellEffect=null
endfunction
function DarkRevenge__DarkRevenge_launch takes nothing returns nothing
local timer expTimer=GetExpiredTimer()
local integer id=GetHandleId(expTimer)
local integer rain=LoadInt(id,"DarkRevenge | Structure")
local integer level=GetUnitAbilityLevel(s__DarkRevenge_st_caster[rain],'A0IM')
local real casterX=GetUnitX(s__DarkRevenge_st_caster[rain])
local real casterY=GetUnitY(s__DarkRevenge_st_caster[rain])
local integer prj=0
local integer timerID=0
local timer spellTimer
local real changeAngle
local real totalAngle
local real totalFly
local unit dummy
local real range=250.00
local real randX=GetRandomPointInRange(s__DarkRevenge_st_x[rain],s__DarkRevenge_st_y[rain],range,"x")
local real randY=GetRandomPointInRange(s__DarkRevenge_st_x[rain],s__DarkRevenge_st_y[rain],range,"y")
local real distance=PointsDistance(casterX,casterY,s__DarkRevenge_st_x[rain],s__DarkRevenge_st_y[rain])
local integer unitID='h03R'
local real periodic=0.03
local real l__damage=20.00*level
local real angle=PointsAngle(casterX,casterY,s__DarkRevenge_st_x[rain],s__DarkRevenge_st_y[rain])
local real angleRange=50.00
local real speed=20.00
local real flyMin=speed*0.20
local real flyMax=speed*0.50
if s__DarkRevenge_st_count[rain]>0 and GetUnitCurrentOrder(s__DarkRevenge_st_caster[rain])==OrderId("chainlightning")then
set s__DarkRevenge_st_count[rain]=s__DarkRevenge_st_count[rain]-1
set randX=GetRandomPointInRange(s__DarkRevenge_st_x[rain],s__DarkRevenge_st_y[rain],range,"x")
set randY=GetRandomPointInRange(s__DarkRevenge_st_x[rain],s__DarkRevenge_st_y[rain],range,"y")
set distance=PointsDistance(casterX,casterY,randX,randY)
set angle=PointsAngle(casterX,casterY,randX,randY)
set spellTimer=CreateTimer()
set timerID=GetHandleId(spellTimer)
set totalFly=GetRandomReal(flyMin,flyMax)
set changeAngle=GetRandomReal(-angleRange,angleRange)
set totalAngle=angle+changeAngle
set prj=s__DarkRevengeProjectile_st__allocate()
set s__DarkRevengeProjectile_st_caster[prj]=s__DarkRevenge_st_caster[rain]
set s__DarkRevengeProjectile_st_distance[prj]=0.00
set s__DarkRevengeProjectile_st_speed[prj]=speed
set s__DarkRevengeProjectile_st_damage[prj]=l__damage
set s__DarkRevengeProjectile_st_flySpeed[prj]=totalFly
set s__DarkRevengeProjectile_st_angle[prj]=changeAngle
set s__DarkRevengeProjectile_st_stAngle[prj]=changeAngle
set s__DarkRevengeProjectile_st_dmgCheckRange[prj]=75.00
set s__DarkRevengeProjectile_st_maxDistance[prj]=distance
set s__DarkRevengeProjectile_st_dummy[prj]=CreateUnit(GetOwningPlayer(s__DarkRevengeProjectile_st_caster[prj]),unitID,casterX,casterY,totalAngle)
call SaveInt(timerID,"DarkRevengeProjectile | Structure",prj)
call TimerStart(spellTimer,periodic,true,function DarkRevenge__DarkRevenge_timer)
else
call s__DarkRevenge_st_Destroy(rain)
call DestroyTimer(expTimer)
call FlushChildHashtable(udg_Hash,id)
endif
set expTimer=null
set spellTimer=null
endfunction
function DarkRevenge__DarkRevenge_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local timer spellTimer=CreateTimer()
local integer id=GetHandleId(spellTimer)
local integer rain=s__DarkRevenge_st__allocate()
set s__DarkRevenge_st_caster[rain]=caster
set s__DarkRevenge_st_periodic[rain]=0.05
set s__DarkRevenge_st_count[rain]=10
set s__DarkRevenge_st_x[rain]=x
set s__DarkRevenge_st_y[rain]=y
call SaveInt(id,"DarkRevenge | Structure",rain)
call TimerStart(spellTimer,s__DarkRevenge_st_periodic[rain],true,function DarkRevenge__DarkRevenge_launch)
set caster=null
set spellTimer=null
endfunction
function DarkRevenge__DarkRevenge_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0IM'
endfunction
function DarkRevenge__DarkRevenge_init takes nothing returns nothing
local trigger trig=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(trig,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(trig,Condition(function DarkRevenge__DarkRevenge_Conditions))
call TriggerAddAction(trig,function DarkRevenge__DarkRevenge_Actions)
set trig=null
endfunction
function FireRain__MagicDamage takes unit caster,unit target,real dmg returns nothing
call UnitDamageTarget(caster,target,dmg,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_NORMAL,null)
endfunction
function FireRain__FireRain_filter takes nothing returns boolean
return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))and GetUnitHealth(GetFilterUnit())>0
endfunction
function s__FireRain_st_Destroy takes integer this returns nothing
set s__FireRain_st_count[this]=0
set s__FireRain_st_caster[this]=null
call s__FireRain_st_deallocate(this)
endfunction
function s__FireRainProjectile_st_Destroy takes integer this returns nothing
call RemoveUnit(s__FireRainProjectile_st_dummy[this])
call DestroyGroup(s__FireRainProjectile_st_picker[this])
set s__FireRainProjectile_st_dummy[this]=null
set s__FireRainProjectile_st_picker[this]=null
set s__FireRainProjectile_st_caster[this]=null
call s__FireRainProjectile_st_deallocate(this)
endfunction
function FireRain__FireRain_timer takes nothing returns nothing
local timer spellTimer=GetExpiredTimer()
local integer timerID=GetHandleId(spellTimer)
local integer prj=LoadInt(timerID,"FireRainProjectile | Structure")
local real height=GetUnitFlyHeight(s__FireRainProjectile_st_dummy[prj])
local real angle=GetUnitFacing(s__FireRainProjectile_st_dummy[prj])
local real dummyX=GetUnitX(s__FireRainProjectile_st_dummy[prj])
local real dummyY=GetUnitY(s__FireRainProjectile_st_dummy[prj])
local unit target=null
local effect spellEffect
local real targetHeight
local boolexpr filter
local real totalX
local real totalY
if height>=s__FireRainProjectile_st_flySpeed[prj]then
set totalX=PolarPoints(dummyX,dummyY,s__FireRainProjectile_st_speed[prj],angle,"x")
set totalY=PolarPoints(dummyX,dummyY,s__FireRainProjectile_st_speed[prj],angle,"y")
call SetUnitPosition(s__FireRainProjectile_st_dummy[prj],totalX,totalY)
set s__FireRainProjectile_st_distance[prj]=s__FireRainProjectile_st_distance[prj]+s__FireRainProjectile_st_speed[prj]
call SetUnitHeightByDistance(s__FireRainProjectile_st_dummy[prj],s__FireRainProjectile_st_distance[prj],s__FireRainProjectile_st_maxDistance[prj],s__FireRainProjectile_st_flySpeed[prj],s__FireRainProjectile_st_flySpeed[prj]/ 0.03)
if s__FireRainProjectile_st_distance[prj]>=s__FireRainProjectile_st_maxDistance[prj]/ 2 then
if s__FireRainProjectile_st_angle[prj]!=0.00 then
set angle=angle-s__FireRainProjectile_st_angle[prj]
call SetUnitFacing(s__FireRainProjectile_st_dummy[prj],angle)
set s__FireRainProjectile_st_angle[prj]=0.00
endif
elseif s__FireRainProjectile_st_distance[prj]>=s__FireRainProjectile_st_maxDistance[prj]/ 4 then
if s__FireRainProjectile_st_angle[prj]!=s__FireRainProjectile_st_stAngle[prj]/ 2 then
set angle=angle-s__FireRainProjectile_st_angle[prj]
call SetUnitFacing(s__FireRainProjectile_st_dummy[prj],angle)
set s__FireRainProjectile_st_angle[prj]=s__FireRainProjectile_st_angle[prj]/ 2
endif
endif
else
call DestroyTimer(spellTimer)
call FlushChildHashtable(udg_Hash,timerID)
set spellEffect=AddSpecialEffect("Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl",dummyX,dummyY)
call DestroyEffect(spellEffect)
call GroupClear(s__FireRainProjectile_st_picker[prj])
set bj_caster=s__FireRainProjectile_st_caster[prj]
set filter=Condition(function FireRain__FireRain_filter)
call GroupEnumUnitsInRange(s__FireRainProjectile_st_picker[prj],dummyX,dummyY,s__FireRainProjectile_st_dmgRange[prj],filter)
set target=FirstOfGroup(s__FireRainProjectile_st_picker[prj])
if target!=null then
loop
set target=FirstOfGroup(s__FireRainProjectile_st_picker[prj])
exitwhen target==null
call FireRain__MagicDamage(s__FireRainProjectile_st_caster[prj],target,s__FireRainProjectile_st_damage[prj])
call GroupRemoveUnit(s__FireRainProjectile_st_picker[prj],target)
endloop
endif
call s__FireRainProjectile_st_Destroy(prj)
endif
call DestroyBoolExpr(filter)
call DestroyEffect(spellEffect)
set target=null
set filter=null
set spellTimer=null
set spellEffect=null
endfunction
function FireRain__FireRain_launch takes nothing returns nothing
local timer expTimer=GetExpiredTimer()
local integer id=GetHandleId(expTimer)
local integer rain=LoadInt(id,"FireRain | Structure")
local integer level=GetUnitAbilityLevel(s__FireRain_st_caster[rain],'A01X')
local real casterX=GetUnitX(s__FireRain_st_caster[rain])
local real casterY=GetUnitY(s__FireRain_st_caster[rain])
local integer prj=0
local integer timerID=0
local timer spellTimer
local real changeAngle
local real totalAngle
local real totalFly
local unit dummy
local real range=250.00
local real randX=GetRandomPointInRange(s__FireRain_st_x[rain],s__FireRain_st_y[rain],range,"x")
local real randY=GetRandomPointInRange(s__FireRain_st_x[rain],s__FireRain_st_y[rain],range,"y")
local real distance=PointsDistance(casterX,casterY,s__FireRain_st_x[rain],s__FireRain_st_y[rain])
local integer unitID='h03Q'
local real periodic=0.03
local real l__damage=5.00+(5.00*level)
local real angle=PointsAngle(casterX,casterY,s__FireRain_st_x[rain],s__FireRain_st_y[rain])
local real angleRange=50.00
local real speed=20.00
local real flyMin=speed*0.20
local real flyMax=speed*0.50
if s__FireRain_st_count[rain]>0 and GetUnitCurrentOrder(s__FireRain_st_caster[rain])==OrderId("charm")then
set s__FireRain_st_count[rain]=s__FireRain_st_count[rain]-1
set randX=GetRandomPointInRange(s__FireRain_st_x[rain],s__FireRain_st_y[rain],range,"x")
set randY=GetRandomPointInRange(s__FireRain_st_x[rain],s__FireRain_st_y[rain],range,"y")
set distance=PointsDistance(casterX,casterY,randX,randY)
set angle=PointsAngle(casterX,casterY,randX,randY)
set spellTimer=CreateTimer()
set timerID=GetHandleId(spellTimer)
set totalFly=GetRandomReal(flyMin,flyMax)
set changeAngle=GetRandomReal(-angleRange,angleRange)
set totalAngle=angle+changeAngle
set prj=s__FireRainProjectile_st__allocate()
set s__FireRainProjectile_st_caster[prj]=s__FireRain_st_caster[rain]
set s__FireRainProjectile_st_distance[prj]=0.00
set s__FireRainProjectile_st_speed[prj]=speed
set s__FireRainProjectile_st_damage[prj]=l__damage
set s__FireRainProjectile_st_dmgRange[prj]=150.00
set s__FireRainProjectile_st_flySpeed[prj]=totalFly
set s__FireRainProjectile_st_angle[prj]=changeAngle
set s__FireRainProjectile_st_stAngle[prj]=changeAngle
set s__FireRainProjectile_st_dmgCheckRange[prj]=100.00
set s__FireRainProjectile_st_maxDistance[prj]=distance
set s__FireRainProjectile_st_dummy[prj]=CreateUnit(GetOwningPlayer(s__FireRainProjectile_st_caster[prj]),unitID,casterX,casterY,totalAngle)
if isPlayerHasSoloHero(Owner(s__FireRainProjectile_st_caster[prj]))then
set s__FireRainProjectile_st_damage[prj]=s__FireRainProjectile_st_damage[prj]*1.25
set s__FireRainProjectile_st_dmgRange[prj]=s__FireRainProjectile_st_dmgRange[prj]*1.25
endif
call SaveInt(timerID,"FireRainProjectile | Structure",prj)
call TimerStart(spellTimer,periodic,true,function FireRain__FireRain_timer)
else
call s__FireRain_st_Destroy(rain)
call DestroyTimer(expTimer)
call FlushChildHashtable(udg_Hash,id)
endif
set expTimer=null
set spellTimer=null
endfunction
function FireRain__FireRain_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local timer spellTimer=CreateTimer()
local integer id=GetHandleId(spellTimer)
local integer rain=s__FireRain_st__allocate()
set s__FireRain_st_caster[rain]=caster
set s__FireRain_st_periodic[rain]=0.05
set s__FireRain_st_count[rain]=25
set s__FireRain_st_x[rain]=x
set s__FireRain_st_y[rain]=y
call SaveInt(id,"FireRain | Structure",rain)
call TimerStart(spellTimer,s__FireRain_st_periodic[rain],true,function FireRain__FireRain_launch)
set caster=null
set spellTimer=null
endfunction
function FireRain__FireRain_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A01X'
endfunction
function FireRain__FireRain_init takes nothing returns nothing
local trigger trig=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(trig,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(trig,Condition(function FireRain__FireRain_Conditions))
call TriggerAddAction(trig,function FireRain__FireRain_Actions)
set trig=null
endfunction
function s__HealWave__HealWave_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__HealWave__HealWave_st_Timer[this])
call DestroyTimer(s__HealWave__HealWave_st_Timer[this])
call DestroyGroup(s__HealWave__HealWave_st_healedGroup[this])
call DestroyLightningN(s__HealWave__HealWave_st_wave[this],2.00)
call FlushChildHashtable(udg_Hash,id)
set s__HealWave__HealWave_st_count[this]=0
set s__HealWave__HealWave_st_wave[this]=null
set s__HealWave__HealWave_st_Timer[this]=null
set s__HealWave__HealWave_st_target[this]=null
set s__HealWave__HealWave_st_caster[this]=null
set s__HealWave__HealWave_st_healedGroup[this]=null
call s__HealWave__HealWave_st_deallocate(this)
endfunction
function HealWave__HealWave_filter takes nothing returns boolean
local real hpPercent=GetUnitHealthPercent(GetFilterUnit())
return not IsUnitInGroup(GetFilterUnit(),bj_group)and not isUnitStruct(GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0.00 and hpPercent<1.00 and isUnitAlly(bj_caster,GetFilterUnit())
endfunction
function HealWave__HealWave_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer hw=LoadInt(id,"HealWave | Structure")
local group g=CreateGroup()
local real x=GetUnitX(s__HealWave__HealWave_st_target[hw])
local real y=GetUnitY(s__HealWave__HealWave_st_target[hw])
local boolexpr filter
local unit target
local real height=75.00
if s__HealWave__HealWave_st_count[hw]>0 then
set s__HealWave__HealWave_st_count[hw]=s__HealWave__HealWave_st_count[hw]-1
if s__HealWave__HealWave_st_isFirst[hw]then
set s__HealWave__HealWave_st_isFirst[hw]=false
if isPlayerHasSoloHero(Owner(s__HealWave__HealWave_st_caster[hw]))and isUnitHero(s__HealWave__HealWave_st_target[hw])then
call HealUnit(s__HealWave__HealWave_st_target[hw],s__HealWave__HealWave_st_heal[hw]*1.25,false)
else
call HealUnit(s__HealWave__HealWave_st_target[hw],s__HealWave__HealWave_st_heal[hw],false)
endif
call TimedEffectTarget(HealWave__HEAL_EFFECT_PATH,s__HealWave__HealWave_st_target[hw],"origin",1.00)
set s__HealWave__HealWave_st_heal[hw]=s__HealWave__HealWave_st_heal[hw]-(s__HealWave__HealWave_st_heal[hw]*s__HealWave__HealWave_st_healDebuff[hw])
endif
set bj_caster=s__HealWave__HealWave_st_caster[hw]
set bj_group=s__HealWave__HealWave_st_healedGroup[hw]
set filter=Condition(function HealWave__HealWave_filter)
call GroupEnumUnitsInRange(g,x,y,s__HealWave__HealWave_st_range[hw],filter)
set target=FirstOfGroup(g)
if target==s__HealWave__HealWave_st_target[hw]then
call GroupRemoveUnit(g,target)
set target=FirstOfGroup(g)
endif
if isPlayerHasSoloHero(Owner(s__HealWave__HealWave_st_caster[hw]))and(s__HealWave__HealWave_st_count[hw]==0 or target==null)then
set target=s__HealWave__HealWave_st_caster[hw]
endif
if target!=null then
call DestroyLightningN(s__HealWave__HealWave_st_wave[hw],2.00)
set s__HealWave__HealWave_st_wave[hw]=AddLightningEx("HWSB",true,x,y,height,GetUnitX(target),GetUnitY(target),height)
call TimedEffectTarget(HealWave__HEAL_EFFECT_PATH,target,"origin",1.00)
if isPlayerHasSoloHero(Owner(s__HealWave__HealWave_st_caster[hw]))and isUnitHero(target)then
call HealUnit(target,s__HealWave__HealWave_st_heal[hw]*1.25,false)
else
call HealUnit(target,s__HealWave__HealWave_st_heal[hw],false)
endif
call GroupAddUnit(s__HealWave__HealWave_st_healedGroup[hw],target)
set s__HealWave__HealWave_st_target[hw]=target
set s__HealWave__HealWave_st_heal[hw]=s__HealWave__HealWave_st_heal[hw]-(s__HealWave__HealWave_st_heal[hw]*s__HealWave__HealWave_st_healDebuff[hw])
else
call s__HealWave__HealWave_st_Destroy(hw)
endif
else
call s__HealWave__HealWave_st_Destroy(hw)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set t=null
set target=null
set filter=null
endfunction
function HealWave__HealWave_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local unit target=GetSpellTargetUnit()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer hw=s__HealWave__HealWave_st__allocate()
local real x1=GetUnitX(caster)
local real y1=GetUnitY(caster)
local real x2=GetUnitX(target)
local real y2=GetUnitY(target)
local real height=75.00
local real periodic=0.10
set s__HealWave__HealWave_st_Timer[hw]=t
set s__HealWave__HealWave_st_isFirst[hw]=true
set s__HealWave__HealWave_st_caster[hw]=caster
set s__HealWave__HealWave_st_target[hw]=target
set s__HealWave__HealWave_st_count[hw]=2+(2*lvl)
set s__HealWave__HealWave_st_range[hw]=500.00
set s__HealWave__HealWave_st_heal[hw]=75.00*lvl
set s__HealWave__HealWave_st_healDebuff[hw]=0.11+(-0.01*lvl)
set s__HealWave__HealWave_st_wave[hw]=AddLightningEx("HWPB",true,x1,y1,height,x2,y2,height)
if isPlayerHasSoloHero(Owner(caster))then
set s__HealWave__HealWave_st_count[hw]=s__HealWave__HealWave_st_count[hw]+1
endif
call SaveInt(id,"HealWave | Structure",hw)
call TimerStart(t,periodic,true,function HealWave__HealWave_timer)
set t=null
set caster=null
set target=null
endfunction
function HealWave__HealWave_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0CJ'
endfunction
function HealWave__Init takes nothing returns nothing
local trigger wave=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(wave,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(wave,Condition(function HealWave__HealWave_Conditions))
call TriggerAddAction(wave,function HealWave__HealWave_Actions)
set wave=null
endfunction
function HolyLight__HolyLight_allyfilter takes nothing returns boolean
return not isUnitEnemy(bj_caster,GetFilterUnit())and GetWidgetLife(GetFilterUnit())>0.00 and not isUnitStruct(GetFilterUnit())
endfunction
function HolyLight__HolyLight_enemyfilter takes nothing returns boolean
return isUnitEnemy(bj_caster,GetFilterUnit())and GetWidgetLife(GetFilterUnit())>0.00 and not isUnitStruct(GetFilterUnit())
endfunction
function HolyLight__HolyLight_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local unit target=GetSpellTargetUnit()
local real x1=GetUnitX(target)
local real y1=GetUnitY(target)
local group g=CreateGroup()
local boolexpr filter
local unit dummy
local real range=200.00
local real heal=120*lvl
local real l__damage=60*lvl
local real undeadBuff=0.25
local real nearBuff=0.50
local real dmg
local real hl
if isPlayerHasSoloHero(Owner(caster))then
set range=range+125.00
set l__damage=l__damage*1.25
set heal=heal*1.25
endif
set bj_caster=caster
if isUnitEnemy(caster,target)then
set filter=Condition(function HolyLight__HolyLight_enemyfilter)
else
set filter=Condition(function HolyLight__HolyLight_allyfilter)
endif
call GroupEnumUnitsInRange(g,x1,y1,range,filter)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
set dmg=l__damage
set hl=heal
if isUnitUndead(dummy)then
set dmg=dmg+dmg*undeadBuff
set hl=hl-hl*undeadBuff
endif
if target==dummy then
set bj_lastCreatedEffect=AddSpecialEffectTarget("Holy Light.mdx",target,"origin")
call DestroyEffect(bj_lastCreatedEffect)
else
set bj_lastCreatedEffect=AddSpecialEffectTarget("Heal.mdx",dummy,"origin")
call DestroyEffect(bj_lastCreatedEffect)
set dmg=dmg*nearBuff
set hl=hl*nearBuff
endif
if isUnitEnemy(caster,dummy)then
call MagDamage(caster,dummy,dmg)
else
call HealUnit(dummy,hl,false)
endif
call GroupRemoveUnit(g,dummy)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set dummy=null
set filter=null
set caster=null
set target=null
endfunction
function HolyLight__HolyLight_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A06E'
endfunction
function HolyLight__Init takes nothing returns nothing
local trigger t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(t,Condition(function HolyLight__HolyLight_Conditions))
call TriggerAddAction(t,function HolyLight__HolyLight_Actions)
set t=null
endfunction
function s__Illusions___Illusions_st_Destroy takes integer this returns nothing
call DestroyGroup(s__Illusions___Illusions_st_illusions[this])
set s__Illusions___Illusions_st_caster[this]=null
set s__Illusions___Illusions_st_illusions[this]=null
call s__Illusions___Illusions_st_deallocate(this)
endfunction
function Illusions___IllusionsDie_Actions takes nothing returns nothing
local unit caster=GetDyingUnit()
local integer id=GetHandleId(caster)
local integer il=LoadInt(id,"Illusions | Structure")
call GroupRemoveUnit(s__Illusions___Illusions_st_illusions[il],caster)
if Group_Count(s__Illusions___Illusions_st_illusions[il])<=0 then
call s__Illusions___Illusions_st_Destroy(il)
endif
set caster=null
endfunction
function Illusions___IllusionsKill_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local unit target=GetDyingUnit()
local integer id=GetHandleId(caster)
local integer il=LoadInt(id,"Illusions | Structure")
local group g=CreateGroup()
local unit dummy=null
local real healPower=50.00
call HealUnit(s__Illusions___Illusions_st_caster[il],healPower,false)
call Group_Copy(s__Illusions___Illusions_st_illusions[il],g)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
call HealUnit(dummy,healPower,false)
call GroupRemoveUnit(g,dummy)
endloop
call DestroyGroup(g)
set g=null
set dummy=null
set caster=null
set target=null
endfunction
function Illusions___Illusions_Actions takes nothing returns nothing
local unit caster=GetSummoningUnit()
local unit target=GetSummonedUnit()
local integer id=GetHandleId(caster)
local integer il=LoadInt(id,"Illusions | Structure")
if il==0 then
set il=s__Illusions___Illusions_st__allocate()
set s__Illusions___Illusions_st_caster[il]=caster
call SaveInt(id,"Illusions | Structure",il)
endif
if isPlayerHasSoloHero(Owner(caster))then
call AddUnitBonusDamage(target,25)
endif
call SaveInt(GetHandleId(target),"Illusions | Structure",il)
call GroupAddUnit(s__Illusions___Illusions_st_illusions[il],target)
set caster=null
set target=null
endfunction
function Illusions___Illusions_Conditions takes nothing returns boolean
return IsUnitIllusion(GetSummonedUnit())and isUnitHero(GetSummoningUnit())and GetUnitAbilityLevel(GetSummoningUnit(),'A0JM')>0
endfunction
function Illusions___IllusionsKill_Conditions takes nothing returns boolean
local integer il=LoadInt(GetHandleId(GetKillingUnit()),"Illusions | Structure")
return IsUnitIllusion(GetKillingUnit())and IsUnitInGroup(GetKillingUnit(),s__Illusions___Illusions_st_illusions[il])
endfunction
function Illusions___IllusionsDie_Conditions takes nothing returns boolean
local integer il=LoadInt(GetHandleId(GetDyingUnit()),"Illusions | Structure")
return IsUnitIllusion(GetDyingUnit())and IsUnitInGroup(GetDyingUnit(),s__Illusions___Illusions_st_illusions[il])
endfunction
function Illusions___Init takes nothing returns nothing
local trigger create=CreateTrigger()
local trigger kill=CreateTrigger()
local trigger die=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(create,EVENT_PLAYER_UNIT_SUMMON)
call TriggerAddCondition(create,Condition(function Illusions___Illusions_Conditions))
call TriggerAddAction(create,function Illusions___Illusions_Actions)
call TriggerRegisterAnyUnitEventBJ(kill,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(kill,Condition(function Illusions___IllusionsKill_Conditions))
call TriggerAddAction(kill,function Illusions___IllusionsKill_Actions)
call TriggerRegisterAnyUnitEventBJ(die,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(die,Condition(function Illusions___IllusionsDie_Conditions))
call TriggerAddAction(die,function Illusions___IllusionsDie_Actions)
set die=null
set kill=null
set create=null
endfunction
function Income_timer takes nothing returns nothing
local integer index=0
local integer income=INIT_INCOME
local integer defenseIncomeBuff=1
loop
exitwhen index>5
set income=INIT_INCOME
if isPlayerHasCastle(Player(index))then
if hasDefense[index+1]then
set income=income+defenseIncomeBuff
endif
call PlayerAddGold(Player(index),income)
endif
set index=index+1
endloop
endfunction
function GoldMine_timer takes nothing returns nothing
local group g=CreateGroup()
local integer totalGold=0
local integer array mine
local integer array gold
local integer index=1
local integer i=0
local player owner
local unit dummy
local string s
local integer moleman=2
set mine[1]='n01K'
set gold[1]=1
set mine[2]='n01N'
set gold[2]=2
set mine[3]='n01O'
set gold[3]=3
set mine[4]='n01P'
set gold[4]=4
set mine[5]='n01Q'
set gold[5]=5
loop
exitwhen mine[index]==0 or mine[index]==null
set bj_groupEnumTypeId=mine[index]
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,filterGetUnitsOfPlayerAndTypeId)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
set totalGold=gold[index]
set owner=GetOwningPlayer(dummy)
call PlayerAddGold(owner,totalGold)
if GetLocalPlayer()==owner then
set s="+"+I2S(totalGold)+" gold"
call TextUp(s,dummy,11,0,255,0,60,96.00,2.00)
endif
if(GetPlayerTechCount(owner,'R04D',true)>0)then
call AddHeroXP(udg_Hero[GetUnitOwnerId(dummy)+1],moleman*index,false)
if GetLocalPlayer()==owner then
set s="+"+I2S(moleman*index)+" xp"
call TextUp(s,dummy,11,0,51,255,0,96.00,2.00)
endif
endif
if isPlayerHasCommunism(owner)then
set i=0
loop
exitwhen i>5
if IsPlayerAlly(Player(i),owner)and owner!=Player(15)and Player(i)!=owner then
call PlayerAddGold(Player(i),totalGold)
if GetLocalPlayer()==Player(i)then
set s="+"+I2S(totalGold)+" gold"
call TextUp(s,dummy,11,0,255,0,60,96.00,2.00)
endif
endif
set i=i+1
endloop
endif
call GroupRemoveUnit(g,dummy)
endloop
set index=index+1
endloop
set bj_groupEnumTypeId='nfoh'
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,filterGetUnitsOfPlayerAndTypeId)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
set totalGold=1
set owner=GetOwningPlayer(dummy)
set index=0
loop
exitwhen index>5
if IsPlayerAlly(Player(index),owner)and owner!=Player(15)then
call PlayerAddGold(Player(index),totalGold)
if GetLocalPlayer()==Player(index)then
set s="+"+I2S(totalGold)+" gold"
call TextUp(s,dummy,11,0,255,0,60,96.00,2.00)
endif
if(GetPlayerTechCount(owner,'R04D',true)>0)then
call AddHeroXP(udg_Hero[index+1],moleman,false)
if GetLocalPlayer()==Player(index)then
set s="+"+I2S(moleman)+" xp"
call TextUp(s,dummy,11,0,51,255,0,96.00,2.00)
endif
endif
endif
set index=index+1
endloop
call GroupRemoveUnit(g,dummy)
endloop
call DestroyGroup(g)
set g=null
set owner=null
endfunction
function IncomeLib__InitMinePlayer takes nothing returns nothing
local integer i=1
local integer mn=0
local integer array mine
local group g=CreateGroup()
local unit dummy
local integer owner=PLAYER_NEUTRAL_AGGRESSIVE
set mine[1]='n01K'
set mine[2]='nfoh'
loop
set mn=mine[i]
exitwhen mn==0
set bj_groupEnumTypeId=mn
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,filterGetUnitsOfPlayerAndTypeId)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
call SetUnitOwner(dummy,Player(owner),true)
call GroupRemoveUnit(g,dummy)
endloop
set i=i+1
endloop
call DestroyGroup(g)
set g=null
set dummy=null
endfunction
function Income_trig takes nothing returns nothing
local trigger incomeTrig=CreateTrigger()
local trigger mineTrig=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(mineTrig,INCOME_PERIODIC)
call TriggerAddAction(mineTrig,function GoldMine_timer)
call TriggerRegisterTimerEventPeriodic(incomeTrig,INCOME_PERIODIC)
call TriggerAddAction(incomeTrig,function Income_timer)
endfunction
function s__PowerWave__PowerWave_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__PowerWave__PowerWave_st_t[this])
call DestroyTimer(s__PowerWave__PowerWave_st_t[this])
call DestroyEffect(s__PowerWave__PowerWave_st_wave[this])
call DestroyGroup(s__PowerWave__PowerWave_st_damagedGroup[this])
call FlushChildHashtable(udg_Hash,id)
set s__PowerWave__PowerWave_st_t[this]=null
set s__PowerWave__PowerWave_st_wave[this]=null
set s__PowerWave__PowerWave_st_caster[this]=null
set s__PowerWave__PowerWave_st_damagedGroup[this]=null
call s__PowerWave__PowerWave_st_deallocate(this)
endfunction
function PowerWave__PowerWave_filter takes nothing returns boolean
return isUnitAlive(GetFilterUnit())and not IsUnitInGroup(GetFilterUnit(),bj_group)
endfunction
function PowerWave__PowerWave_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer dw=LoadInt(id,"PowerWave | Structure")
local real x=GetEffectX(s__PowerWave__PowerWave_st_wave[dw])
local real y=GetEffectY(s__PowerWave__PowerWave_st_wave[dw])
local group g=CreateGroup()
local boolexpr filter
local unit target
local real x1
local real y1
if s__PowerWave__PowerWave_st_distance[dw]>0.00 then
set s__PowerWave__PowerWave_st_distance[dw]=s__PowerWave__PowerWave_st_distance[dw]-s__PowerWave__PowerWave_st_speed[dw]
set x1=PolarPoints(x,y,s__PowerWave__PowerWave_st_speed[dw],s__PowerWave__PowerWave_st_angle[dw],"x")
set y1=PolarPoints(x,y,s__PowerWave__PowerWave_st_speed[dw],s__PowerWave__PowerWave_st_angle[dw],"y")
call SetEffectPosition(s__PowerWave__PowerWave_st_wave[dw],x1,y1,GetEffectZ(s__PowerWave__PowerWave_st_wave[dw]))
call SetEffectFacing(s__PowerWave__PowerWave_st_wave[dw],s__PowerWave__PowerWave_st_angle[dw])
set bj_caster=s__PowerWave__PowerWave_st_caster[dw]
set bj_group=s__PowerWave__PowerWave_st_damagedGroup[dw]
set filter=Condition(function PowerWave__PowerWave_filter)
call GroupEnumUnitsInRange(g,x,y,s__PowerWave__PowerWave_st_range[dw],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
if isUnitEnemy(s__PowerWave__PowerWave_st_caster[dw],target)then
call MagDamage(s__PowerWave__PowerWave_st_caster[dw],target,s__PowerWave__PowerWave_st_damage[dw])
else
if isPlayerHasSoloHero(Owner(s__PowerWave__PowerWave_st_caster[dw]))then
call HealUnit(target,s__PowerWave__PowerWave_st_damage[dw],false)
else
call HealUnit(target,s__PowerWave__PowerWave_st_damage[dw]*0.5,false)
endif
endif
call GroupAddUnit(s__PowerWave__PowerWave_st_damagedGroup[dw],target)
call GroupRemoveUnit(g,target)
endloop
else
call s__PowerWave__PowerWave_st_Destroy(dw)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set target=null
set filter=null
endfunction
function PowerWave takes unit caster,real l__damage,real range,real speed,real distance,real angle,string path returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer dw=s__PowerWave__PowerWave_st__allocate()
local real periodic=0.04
set s__PowerWave__PowerWave_st_t[dw]=t
set s__PowerWave__PowerWave_st_caster[dw]=caster
set s__PowerWave__PowerWave_st_damage[dw]=l__damage
set s__PowerWave__PowerWave_st_range[dw]=range
set s__PowerWave__PowerWave_st_speed[dw]=speed
set s__PowerWave__PowerWave_st_angle[dw]=angle
set s__PowerWave__PowerWave_st_distance[dw]=distance
set s__PowerWave__PowerWave_st_wave[dw]=AddSpecialEffect(path,GetUnitX(caster),GetUnitY(caster))
call SaveInt(id,"PowerWave | Structure",dw)
call TimerStart(t,periodic,true,function PowerWave__PowerWave_timer)
set t=null
endfunction
function PowerWave_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real x1=GetSpellTargetX()
local real y1=GetSpellTargetY()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real angle=PointsAngle(x,y,x1,y1)
local real l__damage=35.00*lvl
local real range=125.00
local real speed=30.00
local real distance=800.00
local string path="Abilities\\Spells\\Orc\\Shockwave\\ShockwaveMissile.mdl"
if isPlayerHasSoloHero(Owner(caster))then
set distance=distance*1.50
endif
call PowerWave(caster,l__damage,range,speed,distance,angle,path)
set caster=null
endfunction
function PowerWave__PowerWave_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A00U'
endfunction
function PowerWave__Init takes nothing returns nothing
set gg_trg_PowerWave=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_PowerWave,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_PowerWave,Condition(function PowerWave__PowerWave_Conditions))
call TriggerAddAction(gg_trg_PowerWave,function PowerWave_Actions)
endfunction
function PrisonOnWheelsMove_filter takes nothing returns boolean
return GetUnitTypeId(GetFilterUnit())=='eilw'
endfunction
function PrisonOnWheelsMove_Actions takes nothing returns nothing
local group g=CreateGroup()
local boolexpr filter
local unit target
local unit dummy
set filter=Condition(function PrisonOnWheelsMove_filter)
call GroupEnumUnitsInRange(g,0,0,99999999999,filter)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
set target=LoadUnit(GetHandleId(dummy),"PrisonOnWheels | Target")
call SetUnitPosition(target,GetUnitX(dummy),GetUnitY(dummy))
call GroupRemoveUnit(g,dummy)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set dummy=null
set target=null
set filter=null
endfunction
function PrisonOnWheelsDie_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=LoadUnit(GetHandleId(caster),"PrisonOnWheels | Target")
call SetUnitPosition(target,GetUnitX(caster),GetUnitY(caster))
call ShowUnit(target,true)
set target=null
set caster=null
endfunction
function PrisonOnWheels_filter takes nothing returns boolean
return isUnitEnemy(bj_caster,GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0 and not isUnitStruct(GetFilterUnit())
endfunction
function PrisonOnWheels_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local group g=CreateGroup()
local boolexpr filter
local unit dummy
local effect eff
local real range=350.00
local real time=10.00+(5*(lvl-1))
local real hp=100.00*lvl
set bj_caster=caster
set filter=Condition(function PrisonOnWheels_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set eff=AddSpecialEffect("Abilities\\Spells\\NightElf\\Starfall\\StarfallTarget.mdl",GetUnitX(target),GetUnitY(target))
call DestroyEffect(eff)
call ShowUnit(target,false)
set dummy=CreateUnit(Owner(caster),'eilw',GetUnitX(target),GetUnitY(target),GetUnitFacing(target))
if isPlayerHasSoloHero(Owner(caster))then
call AddUnitBonusMovespeed(dummy,75)
if isUnitHero(target)then
call AddUnitBonusMovespeed(dummy,50)
endif
call IssuePointOrder(dummy,"move",GetUnitX(udg_Castle[OwnerId(dummy)+1]),GetUnitY(udg_Castle[OwnerId(dummy)+1]))
endif
call SaveUnit(GetHandleId(dummy),"PrisonOnWheels | Target",target)
call UnitApplyTimedLife(dummy,'BTLF',time)
call SetUnitMaxLife(dummy,hp)
call SetUnitHealth(dummy,hp)
if isUnitHero(target)then
call SetUnitMaxLife(dummy,hp*1.50)
call SetUnitHealth(dummy,hp*1.50)
call SetUnitVertexColor(dummy,255,150,150,255)
call SetUnitScale(dummy,1.5,1.5,1.5)
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set dummy=null
set filter=null
set target=null
set caster=null
endfunction
function PrisonOnWheels_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0JD'
endfunction
function PrisonOnWheelsDie_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())=='eilw'
endfunction
function PrisonOnWheels__InitTriggers takes nothing returns nothing
local trigger prisonMove=CreateTrigger()
local trigger prisonDie=CreateTrigger()
local trigger prison=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(prison,EVENT_PLAYER_UNIT_SPELL_ENDCAST)
call TriggerAddCondition(prison,Condition(function PrisonOnWheels_Conditions))
call TriggerAddAction(prison,function PrisonOnWheels_Actions)
call TriggerRegisterAnyUnitEventBJ(prisonDie,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(prisonDie,Condition(function PrisonOnWheelsDie_Conditions))
call TriggerAddAction(prisonDie,function PrisonOnWheelsDie_Actions)
call TriggerRegisterTimerEventPeriodic(prisonMove,0.04)
call TriggerAddAction(prisonMove,function PrisonOnWheelsMove_Actions)
set prison=null
set prisonDie=null
endfunction
function RewardLib___GetXpReward takes unit target,unit killer returns integer
local player killerPlayer=GetOwningPlayer(killer)
local player targetPlayer=GetOwningPlayer(target)
local integer killerPlayerId=GetPlayerId(killerPlayer)+1
local integer lvl=0
local integer xp=0
set lvl=GetUnitLevel(target)
if lvl==0 then
set lvl=1
endif
set xp=RewardLib___LVL_XP*lvl
set lvl=GetPlayerTechCount(killerPlayer,'R029',true)
if lvl>0 then
set xp=R2I(xp*RewardLib___BOOK_WORM_XP)
endif
set lvl=GetPlayerTechCount(killerPlayer,'R02A',true)
if lvl>0 then
set xp=R2I(xp*RewardLib___SOLO_HERO_XP)
endif
set lvl=GetPlayerTechCount(targetPlayer,'R02A',true)
if lvl>0 and isUnitHero(target)then
set xp=R2I(xp*RewardLib___SOLO_HERO_DIE_XP)
endif
if isUnitHero(target)then
set xp=R2I(xp*RewardLib___JUST_HERO_XP)
endif
if isUnitStruct(target)then
set xp=R2I(xp*RewardLib___STRUCTURE_XP)
endif
if isUnitStruct(killer)then
set xp=R2I(xp*RewardLib___STRUCTURE_KILLER_XP)
endif
set lvl=GetPlayerTechCount(targetPlayer,'R04I',true)
if lvl>0 then
set xp=R2I(xp*RewardLib___ATTACK_ON_TITAN_XP)
endif
if isUnitSummon(target)then
set xp=RewardLib___SUMMON_XP
endif
if isPlayerHasGreedy(targetPlayer)then
set xp=R2I(xp*RewardLib___GREEDY_XP)
endif
return xp
endfunction
function RewardLib___GetGoldReward takes unit target,unit killer returns integer
local player killerPlayer=GetOwningPlayer(killer)
local player targetPlayer=GetOwningPlayer(target)
local integer killerPlayerId=GetPlayerId(killerPlayer)+1
local integer gold=0
local integer lvl=0
set lvl=GetUnitLevel(target)
if lvl==0 then
set lvl=1
endif
set gold=RewardLib___LVL_GOLD*lvl
set lvl=GetPlayerTechCount(killerPlayer,'R000',true)
if lvl>0 then
set gold=R2I(gold*(1+(RewardLib___GOLD_DIGGER*lvl)))
endif
if lvl>0 then
set gold=R2I(gold*(1.+udg_KillBonus[killerPlayerId]))
endif
set lvl=GetPlayerTechCount(killerPlayer,'R02A',true)
if lvl>0 then
set gold=R2I(gold*RewardLib___SOLO_HERO_GOLD)
endif
set lvl=GetPlayerTechCount(targetPlayer,'R02A',true)
if lvl>0 and isUnitHero(target)then
set gold=R2I(gold*RewardLib___SOLO_HERO_DIE_GOLD)
endif
if isUnitHero(target)then
set gold=R2I(gold*RewardLib___JUST_HERO_GOLD)
endif
if isUnitStruct(target)then
set gold=R2I(gold*RewardLib___STRUCTURE_GOLD)
endif
if isUnitStruct(killer)then
set gold=R2I(gold*RewardLib___STRUCTURE_KILLER_GOLD)
else
if killer!=null then
set udg_KillBonus[killerPlayerId]=udg_KillBonus[killerPlayerId]+RewardLib___KILL_BONUS
endif
endif
set lvl=GetPlayerTechCount(killerPlayer,'R04J',true)
if lvl>0 then
set gold=R2I(gold*RewardLib___ZOMBIE_GOLD)
endif
set lvl=GetPlayerTechCount(killerPlayer,'R047',true)
if lvl>0 then
set gold=R2I(gold*RewardLib___SWARM_QUEEN_GOLD)
endif
set lvl=GetPlayerTechCount(killerPlayer,'R04E',true)
if lvl>0 then
set gold=R2I(gold*RewardLib___RAT_KING_GOLD)
endif
set lvl=GetPlayerTechCount(killerPlayer,'R04I',true)
if lvl>0 then
set gold=R2I(gold*RewardLib___ATTACK_ON_TITAN_GOLD)
endif
if isUnitSummon(target)then
set gold=RewardLib___SUMMON_GOLD
endif
if isPlayerHasGreedy(targetPlayer)then
set gold=R2I(gold*RewardLib___GREEDY_GOLD)
endif
return gold
endfunction
function RewardLib___RewardGold takes unit target,unit killer returns nothing
local player killerOwner=GetOwningPlayer(killer)
local player targetOwner=GetOwningPlayer(target)
local integer killerOwnerID=GetPlayerId(killerOwner)+1
local integer targetOwnerID=GetPlayerId(targetOwner)+1
local integer index=0
local integer otherGold=0
local string ttStr
local integer gold=RewardLib___GetGoldReward(target,killer)
local integer cursedGold=2
call PlayerAddGold(killerOwner,gold)
if GetLocalPlayer()==killerOwner then
set ttStr="+"+I2S(gold)
call TextUp(ttStr,target,10,0,255,0,0,96.00,2.00)
endif
if GetPlayerTechCount(targetOwner,'R02K',true)>0 then
set otherGold=R2I(gold*RewardLib___SHARING_GOLD)
call PlayerAddGold(targetOwner,gold)
if GetLocalPlayer()==targetOwner then
set ttStr="+"+I2S(otherGold)
call TextUp(ttStr,target,10,0,255,0,0,96.00,2.00)
endif
endif
loop
exitwhen index>6
if isPlayerHasCursedGold(Player(index))and IsPlayerEnemy(killerOwner,Player(index))and not isUnitSummon(target)then
call PlayerAddGold(Player(index),cursedGold)
if GetLocalPlayer()==Player(index)then
set ttStr="+"+I2S(cursedGold)
call TextUp(ttStr,target,10,0,200,0,0,96.00,2.00)
endif
endif
set index=index+1
endloop
endfunction
function RewardLib___AllyXp_filter takes nothing returns boolean
local integer filterOwnerID=GetUnitOwnerId(GetFilterUnit())+1
local integer casterOwnerID=GetUnitOwnerId(bj_caster)+1
return GetFilterUnit()!=udg_Hero[casterOwnerID]and GetFilterUnit()==udg_Hero[filterOwnerID]and GetUnitHealth(GetFilterUnit())>0 and not isUnitEnemy(GetFilterUnit(),bj_caster)and IsUnitIllusion(GetTriggerUnit())==false
endfunction
function RewardLib___RewardXp takes unit target,unit killer returns nothing
local player killerOwner=GetOwningPlayer(killer)
local player targetOwner=GetOwningPlayer(target)
local integer killerOwnerID=GetPlayerId(killerOwner)+1
local integer targetOwnerID=GetPlayerId(targetOwner)+1
local real targetX=GetUnitX(target)
local real targetY=GetUnitY(target)
local group xpGroup=CreateGroup()
local unit xpTextTarget=killer
local boolexpr filter=null
local integer index=0
local integer otherXP=0
local unit groupTarget
local string ttStr
local integer xp=RewardLib___GetXpReward(target,killer)
local integer rightOfKelDaray=6
local real allyXpRange=2500.00
local real allyXpPercent=0.35
if GetPlayerTechCount(killerOwner,'R04W',true)>0 then
set allyXpRange=999999999.0
set allyXpPercent=0.80
endif
if xpTextTarget!=udg_Hero[killerOwnerID]then
set xpTextTarget=udg_Hero[killerOwnerID]
endif
if GetUnitHealth(xpTextTarget)<=0 or xpTextTarget==null then
set xpTextTarget=killer
endif
call AddHeroXP(udg_Hero[killerOwnerID],xp,false)
if GetLocalPlayer()==killerOwner then
set ttStr="+"+I2S(xp)+" xp"
call TextUp(ttStr,xpTextTarget,10,0,51,255,0,96.00,2.00)
endif
set otherXP=R2I(xp*allyXpPercent)
set bj_caster=killer
set filter=Condition(function RewardLib___AllyXp_filter)
call GroupEnumUnitsInRange(xpGroup,targetX,targetY,allyXpRange,filter)
loop
set groupTarget=FirstOfGroup(xpGroup)
exitwhen groupTarget==null
call AddHeroXP(groupTarget,otherXP,false)
if GetLocalPlayer()==GetOwningPlayer(groupTarget)then
set ttStr="+"+I2S(otherXP)+" xp"
call TextUp(ttStr,groupTarget,9,0,51,255,0,96.00,1.00)
endif
call GroupRemoveUnit(xpGroup,groupTarget)
endloop
if GetPlayerTechCount(targetOwner,'R02K',true)>0 then
set otherXP=R2I(xp*RewardLib___SHARING_XP)
call AddHeroXP(udg_Hero[targetOwnerID],xp,false)
if GetLocalPlayer()==targetOwner then
set ttStr="+"+I2S(otherXP)+" xp"
call TextUp(ttStr,xpTextTarget,10,0,51,255,0,96.00,2.00)
endif
endif
loop
exitwhen index>6
if GetPlayerTechCount(Player(index),'R035',true)>0 and IsPlayerEnemy(killerOwner,Player(index))and not isUnitSummon(target)then
call AddHeroXP(udg_Hero[index+1],rightOfKelDaray,false)
if GetLocalPlayer()==Player(index)then
set ttStr="+"+I2S(rightOfKelDaray)+" xp"
call TextUp(ttStr,xpTextTarget,10,0,51,200,0,96.00,2.00)
endif
endif
set index=index+1
endloop
call DestroyGroup(xpGroup)
call DestroyBoolExpr(filter)
set filter=null
set xpGroup=null
set groupTarget=null
set xpTextTarget=null
endfunction
function RewardLib___Reward takes nothing returns nothing
local unit target=GetTriggerUnit()
local unit killer=GetKillingUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local effect eff
set eff=AddSpecialEffect("UI\\Feedback\\GoldCredit\\GoldCredit.mdl",x,y)
call DestroyEffect(eff)
call RewardLib___RewardGold(target,killer)
call RewardLib___RewardXp(target,killer)
set eff=null
set killer=null
set target=null
endfunction
function RewardLib___Reward_Conditions takes nothing returns boolean
return isUnitEnemy(GetTriggerUnit(),GetKillingUnit())and not IsUnitIllusion(GetTriggerUnit())and GetKillingUnit()!=null
endfunction
function RewardLib___Init takes nothing returns nothing
local trigger reward=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(reward,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(reward,Condition(function RewardLib___Reward_Conditions))
call TriggerAddAction(reward,function RewardLib___Reward)
endfunction
function GetUnitRuneShieldIndex takes unit caster returns integer
local integer max=udg_MS_num
local integer index=1
loop
exitwhen index>max
if(caster==udg_MS_units[index])then
return index
endif
set index=index+1
endloop
return-1
endfunction
function GetUnitRuneShieldPower takes unit caster returns real
local integer index=GetUnitRuneShieldIndex(caster)
if index!=-1 then
return udg_MS_power[index]
endif
return 0.00
endfunction
function DestroyRuneShieldForUnit takes unit caster returns nothing
local integer index=GetUnitRuneShieldIndex(caster)
local integer max=udg_MS_num
if index==-1 then
return
endif
call DestroyEffect(udg_MS_effects[index])
set udg_MS_power[index]=0
set udg_MS_effects[index]=null
call DestroyTrigger(udg_MS_trigs[index])
set udg_MS_trigs[index]=udg_MS_trigs[max]
set udg_MS_units[index]=udg_MS_units[max]
set udg_MS_power[index]=udg_MS_power[max]
set udg_MS_num=udg_MS_num-1
endfunction
function Adv_RuneShield_Actions takes nothing returns nothing
local unit u=GetTriggerUnit()
local real takedDamage=GetEventDamage()
local unit damager=GetEventDamageSource()
local integer ultLvl=GetUnitAbilityLevel(u,'A0IK')
local effect e
local integer i=0
local integer j=0
local integer k=0
local real r
local real up
local real blockChance=0.00
local real mountainPowerHealPower=5.00
local real mountainPowerHealRange=450.00
local real mountainPowerReturnedDamage=takedDamage*0.50
if ultLvl>1 then
call MagDamage(u,damager,mountainPowerReturnedDamage)
endif
if ultLvl>2 then
call HealAlliesAroundUnit(u,mountainPowerHealRange,mountainPowerHealPower)
endif
if GetUnitAbilityLevel(u,'A0J4')>0 then
set blockChance=20.00
endif
set i=udg_MS_num
set j=1
set up=GetUnitStatePercent(u,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)
loop
exitwhen j>i
if(u==udg_MS_units[j])then
set k=j
endif
set j=j+1
endloop
if(udg_MS_power[k]-GetEventDamage()>=0.00)then
if Chance(u,blockChance)then
set e=AddSpecialEffectTarget("Abilities\\Spells\\Human\\Feedback\\SpellBreakerAttack.mdl",u,"origin")
else
set e=AddSpecialEffectTarget("Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl",u,"origin")
set udg_MS_power[k]=udg_MS_power[k]-GetEventDamage()
endif
call DestroyEffect(e)
set r=GetEventDamage()
if(up==100)then
call TriggerSleepAction(0.01)
endif
call SetUnitLifeBJ(u,(GetWidgetLife(u)+r))
else
call DestroyEffect(udg_MS_effects[k])
set r=udg_MS_power[k]
set udg_MS_power[k]=0
set udg_MS_effects[k]=null
call DestroyTrigger(udg_MS_trigs[k])
set udg_MS_trigs[k]=udg_MS_trigs[i]
set udg_MS_units[k]=udg_MS_units[i]
set udg_MS_power[k]=udg_MS_power[i]
set udg_MS_num=udg_MS_num-1
call SetUnitLifeBJ(u,(GetWidgetLife(u)+r))
endif
set u=null
set damager=null
endfunction
function RuneShield_Cast takes unit caster,real power returns nothing
local effect e
local integer i
local integer j
local integer k=0
set i=udg_MS_num
set j=1
loop
exitwhen j>i
if(caster==udg_MS_units[j])then
set k=j
endif
set j=j+1
endloop
if(k==0)then
set i=i+1
set udg_MS_num=i
set udg_MS_units[i]=caster
else
set i=k
endif
set udg_MS_power[i]=power
call DestroyEffect(udg_MS_effects[i])
set udg_MS_effects[i]=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\Voodoo\\VoodooAuraTarget.mdl",caster,"overhead")
call DestroyTrigger(udg_MS_trigs[i])
set udg_MS_trigs[i]=CreateTrigger()
call TriggerRegisterUnitEvent(udg_MS_trigs[i],caster,EVENT_UNIT_DAMAGED)
call TriggerAddAction(udg_MS_trigs[i],function Adv_RuneShield_Actions)
set caster=null
endfunction
function RuneShield_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0GS')
local integer ultLvl=GetUnitAbilityLevel(caster,'A0IK')
local real power=100*lvl
local real mountainPowerShieldBuff=1.75
if ultLvl>0 then
set power=power*mountainPowerShieldBuff
endif
call RuneShield_Cast(caster,power)
set caster=null
endfunction
function RuneShield_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0GS'
endfunction
function InitTrig_RuneShield takes nothing returns nothing
set gg_trg_RuneShield=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_RuneShield,EVENT_PLAYER_UNIT_SPELL_FINISH)
call TriggerAddCondition(gg_trg_RuneShield,Condition(function RuneShield_Conditions))
call TriggerAddAction(gg_trg_RuneShield,function RuneShield_Actions)
endfunction
function s__SpawnLib__Spawn_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__SpawnLib__Spawn_st_t[this])
call FlushChildHashtable(udg_Hash,id)
call DestroyTimer(s__SpawnLib__Spawn_st_t[this])
call DestroyTextTag(s__SpawnLib__Spawn_st_tt[this])
set s__SpawnLib__Spawn_st_t[this]=null
set s__SpawnLib__Spawn_st_tt[this]=null
set s__SpawnLib__Spawn_st_index[this]=0
set s__SpawnLib__Spawn_st_castle[this]=null
call s__SpawnLib__Spawn_st_deallocate(this)
endfunction
function UnitSpawn takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer spawn=LoadInt(id,"Spawn | Structure")
local real x1=LoadRealn(GetHandleId(s__SpawnLib__Spawn_st_castle[spawn]),"Flag|X")
local real y1=LoadRealn(GetHandleId(s__SpawnLib__Spawn_st_castle[spawn]),"Flag|Y")
local string s=R2SW(s__SpawnLib__Spawn_st_time[spawn],0,1)
local unit dummy
if isPlayerHasCastle(Player(s__SpawnLib__Spawn_st_index[spawn]))then
if s__SpawnLib__Spawn_st_time[spawn]>0.00 then
set s__SpawnLib__Spawn_st_time[spawn]=s__SpawnLib__Spawn_st_time[spawn]-s__SpawnLib__Spawn_st_periodic[spawn]
call SetTextTagText(s__SpawnLib__Spawn_st_tt[spawn],s,(12.00*0.023)/ 10)
else
set s__SpawnLib__Spawn_st_time[spawn]=udg_SpawnTime[s__SpawnLib__Spawn_st_index[spawn]+1]
call SetTextTagText(s__SpawnLib__Spawn_st_tt[spawn],"0.0",(12.00*0.023)/ 10)
if Units[s__SpawnLib__Spawn_st_index[spawn]+1]<bj_unitLimit[s__SpawnLib__Spawn_st_index[spawn]+1]then
set dummy=CreateUnit(Player(s__SpawnLib__Spawn_st_index[spawn]),udg_Unit[s__SpawnLib__Spawn_st_index[spawn]+1],s__SpawnLib__Spawn_st_x[spawn],s__SpawnLib__Spawn_st_y[spawn],bj_UNIT_FACING)
call SetUnitMana(dummy,GetUnitMaxMana(dummy))
if bj_unitDamageType[s__SpawnLib__Spawn_st_index[spawn]+1]==-1 then
set bj_unitDamageType[s__SpawnLib__Spawn_st_index[spawn]+1]=GetUnitAttackType1(dummy)
set bj_unitArmourType[s__SpawnLib__Spawn_st_index[spawn]+1]=GetUnitArmourType(dummy)
endif
call SetUnitAttackType1(dummy,bj_unitDamageType[s__SpawnLib__Spawn_st_index[spawn]+1])
call SetUnitArmourType(dummy,bj_unitArmourType[s__SpawnLib__Spawn_st_index[spawn]+1])
if isPlayerHasHolodomor(Player(s__SpawnLib__Spawn_st_index[spawn]))then
call UnitAddAbility(dummy,'A0JU')
endif
if(x1!=0.00 and y1!=0.00)then
call IssuePointOrder(dummy,"attack",x1,y1)
endif
endif
endif
else
call s__SpawnLib__Spawn_st_Destroy(spawn)
endif
set dummy=null
endfunction
function StartSpawn takes integer playerId returns nothing
local integer spawn=s__SpawnLib__Spawn_st__allocate()
local string s=R2SW(udg_SpawnTime[playerId+1],0,1)
set s__SpawnLib__Spawn_st_castle[spawn]=udg_Castle[playerId+1]
set s__SpawnLib__Spawn_st_index[spawn]=playerId
set s__SpawnLib__Spawn_st_x[spawn]=GetUnitX(s__SpawnLib__Spawn_st_castle[spawn])
set s__SpawnLib__Spawn_st_y[spawn]=GetUnitY(s__SpawnLib__Spawn_st_castle[spawn])
set bj_unitDamageType[s__SpawnLib__Spawn_st_index[spawn]+1]=-1
set bj_unitArmourType[s__SpawnLib__Spawn_st_index[spawn]+1]=-1
call SetTextTagText(s__SpawnLib__Spawn_st_tt[spawn],s,(12*0.023)/ 10)
call SetTextTagPosUnit(s__SpawnLib__Spawn_st_tt[spawn],s__SpawnLib__Spawn_st_castle[spawn],0)
call SetTextTagColor(s__SpawnLib__Spawn_st_tt[spawn],51,255,51,0)
call SetTextTagPermanent(s__SpawnLib__Spawn_st_tt[spawn],true)
call SetTextTagFadepoint(s__SpawnLib__Spawn_st_tt[spawn],0)
if UNIT_TYPES_CHANGE then
call SetUnitAbilityLevel(s__SpawnLib__Spawn_st_castle[spawn],'A02D',2)
call UnitAddItemById(s__SpawnLib__Spawn_st_castle[spawn],'I01F')
call UnitAddItemById(s__SpawnLib__Spawn_st_castle[spawn],'I01G')
endif
call SaveInt(GetHandleId(s__SpawnLib__Spawn_st_t[spawn]),"Spawn | Structure",spawn)
call TimerStart(s__SpawnLib__Spawn_st_t[spawn],s__SpawnLib__Spawn_st_periodic[spawn],true,function UnitSpawn)
endfunction
function s__StompLib__StompFly_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__StompLib__StompFly_st_Timer[this])
call DestroyTimer(s__StompLib__StompFly_st_Timer[this])
call FlushChildHashtable(udg_Hash,id)
set s__StompLib__StompFly_st_Timer[this]=null
set s__StompLib__StompFly_st_target[this]=null
set s__StompLib__StompFly_st_caster[this]=null
call s__StompLib__StompFly_st_deallocate(this)
endfunction
function StompLib__Stomp_filter takes nothing returns boolean
return not isUnitStruct(GetFilterUnit())and isUnitEnemy(bj_caster,GetFilterUnit())and GetWidgetLife(GetFilterUnit())>0 and not isUnitFlying(GetFilterUnit())
endfunction
function StompLib__StompFly_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer stomp=LoadInteger(udg_Hash,id,StringHash("StompFly | Struct"))
local real flyHeight=GetUnitFlyHeight(s__StompLib__StompFly_st_target[stomp])
local real x=GetUnitX(s__StompLib__StompFly_st_target[stomp])
local real y=GetUnitY(s__StompLib__StompFly_st_target[stomp])
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
local real x1
local real y1
local real upSpeed=s__StompLib__StompFly_st_speed[stomp]/ 2.00
local real rate=upSpeed/ 0.03
if flyHeight>upSpeed or s__StompLib__StompFly_st_distance[stomp]<s__StompLib__StompFly_st_maxDistance[stomp]then
call SetUnitHeightByDistance(s__StompLib__StompFly_st_target[stomp],s__StompLib__StompFly_st_distance[stomp],s__StompLib__StompFly_st_maxDistance[stomp],upSpeed,rate)
set x1=PolarPoints(x,y,s__StompLib__StompFly_st_speed[stomp],s__StompLib__StompFly_st_angle[stomp],"x")
set y1=PolarPoints(x,y,s__StompLib__StompFly_st_speed[stomp],s__StompLib__StompFly_st_angle[stomp],"y")
call SetUnitPosition(s__StompLib__StompFly_st_target[stomp],x1,y1)
set s__StompLib__StompFly_st_distance[stomp]=s__StompLib__StompFly_st_distance[stomp]+s__StompLib__StompFly_st_speed[stomp]
else
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",x,y)
call DestroyEffect(eff)
call MagDamage(s__StompLib__StompFly_st_caster[stomp],s__StompLib__StompFly_st_target[stomp],s__StompLib__StompFly_st_damage[stomp])
if s__StompLib__StompFly_st_stunTime[stomp]>0 then
call Stun_Start(s__StompLib__StompFly_st_target[stomp],s__StompLib__StompFly_st_stunTime[stomp])
endif
if s__StompLib__StompFly_st_isPaused[stomp]then
call PauseUnit(s__StompLib__StompFly_st_target[stomp],false)
endif
if isPlayerHasSoloHero(Owner(s__StompLib__StompFly_st_caster[stomp]))then
set bj_caster=s__StompLib__StompFly_st_caster[stomp]
set filter=Condition(function StompLib__Stomp_filter)
call GroupEnumUnitsInRange(g,x,y,200.00,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(s__StompLib__StompFly_st_caster[stomp],target,s__StompLib__StompFly_st_damage[stomp]*0.2)
call GroupRemoveUnit(g,target)
endloop
endif
call s__StompLib__StompFly_st_Destroy(stomp)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set t=null
set eff=null
set filter=null
set target=null
endfunction
function StompLib__StompFly_start takes unit caster,unit target,integer lvl returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local boolean isPaused=true
local integer stomp=s__StompLib__StompFly_st__allocate()
if IsUnitPaused(target)==false then
if(isPaused==true)then
call PauseUnit(target,true)
endif
else
set isPaused=false
endif
set s__StompLib__StompFly_st_Timer[stomp]=t
set s__StompLib__StompFly_st_caster[stomp]=caster
set s__StompLib__StompFly_st_target[stomp]=target
set s__StompLib__StompFly_st_distance[stomp]=0.00
set s__StompLib__StompFly_st_maxDistance[stomp]=400.00
set s__StompLib__StompFly_st_speed[stomp]=25.00
set s__StompLib__StompFly_st_isPaused[stomp]=isPaused
set s__StompLib__StompFly_st_periodic[stomp]=0.03
set s__StompLib__StompFly_st_damage[stomp]=25.00*lvl
set s__StompLib__StompFly_st_stunTime[stomp]=1.00*lvl
set s__StompLib__StompFly_st_angle[stomp]=AngleBetweenUnits(caster,target)
call UnitAddAbility(target,'Arav')
call UnitRemoveAbility(target,'Arav')
call SaveInt(id,"StompFly | Struct",stomp)
call TimerStart(t,s__StompLib__StompFly_st_periodic[stomp],true,function StompLib__StompFly_timer)
set t=null
endfunction
function StompLib__Stomp_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local group g=CreateGroup()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local boolexpr filter
local unit target
local effect eff
local real range=275.00
set eff=AddSpecialEffect("Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl",x,y)
call DestroyEffect(eff)
set bj_caster=caster
set filter=Condition(function StompLib__Stomp_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call StompLib__StompFly_start(caster,target,lvl)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set target=null
set caster=null
set filter=null
endfunction
function StompLib__Stomp_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0JI'
endfunction
function StompLib__InitTriggers takes nothing returns nothing
local trigger stomp=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(stomp,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(stomp,Condition(function StompLib__Stomp_Conditions))
call TriggerAddAction(stomp,function StompLib__Stomp_Actions)
set stomp=null
endfunction
function SupremeShaman___Zap_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))and not IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)
endfunction
function SupremeShaman___Zap_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
local real range=250.00
local real time=6.00
local real l__damage=6.00*lvl
local string Type="Electro"
local string dmgEffPath="Abilities\\Spells\\Orc\\Purge\\PurgeBuffTarget.mdl"
local integer moveDebuffAbil='A0IO'
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",x,y)
call DestroyEffect(eff)
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl",x,y)
call DestroyEffect(eff)
set bj_caster=caster
set filter=Condition(function SupremeShaman___Zap_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
if isPlayerHasSoloHero(Owner(caster))then
call UnitRemoveBuffs(target,true,false)
call Dispel(target)
call UnitRestoreMana(target,-75.00)
if isUnitSummon(target)then
call MagDamage(caster,target,50.00)
endif
endif
call PeriodicDamage_Start(Type,dmgEffPath,caster,target,l__damage,time,moveDebuffAbil)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set target=null
set caster=null
set filter=null
endfunction
function SupremeShaman___ThunderStrike_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local boolexpr filter=null
local unit target=null
local effect eff=null
local real time
local real zapBuff=2.00
local real range=200.00
local real stunTime=lvl*0.25
local real heroDebuff=0.50
local integer zapID='A0IO'
set bj_caster=caster
set filter=Condition(function SupremeShaman___Zap_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set time=stunTime
if GetUnitAbilityLevel(target,zapID)>0 then
set time=time*zapBuff
endif
if isUnitHero(target)and not isPlayerHasSoloHero(Owner(caster))then
set time=time*heroDebuff
endif
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl",GetUnitX(target),GetUnitY(target))
call DestroyEffect(eff)
call Stun_Start(target,stunTime)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set filter=null
set target=null
set caster=null
endfunction
function SupremeShaman___Shtorm_Damage takes nothing returns nothing
local unit caster=bj_caster
local unit target=GetEnumUnit()
local real dmg=25.00
local real HousePercent=1.50
if isPlayerHasSoloHero(Owner(caster))then
set dmg=dmg*1.25
endif
if isUnitStruct(target)then
set dmg=dmg*HousePercent
endif
if isUnitEnemy(caster,target)then
call MagDamage(caster,target,dmg)
endif
set caster=null
set target=null
endfunction
function SupremeShaman___Shtorm_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local integer i=1
local effect eff
local group g
local real x1
local real y1
local integer max=16*lvl
local real time=0.75
local real range=300.00
local real ZapRange=175.00
loop
exitwhen i>max
set x1=GetRandomReal(x-(range/ 2),x+(range/ 2))
set y1=GetRandomReal(y-(range/ 2),y+(range/ 2))
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl",x1,y1)
set bj_caster=caster
set g=CreateGroup()
call GroupEnumUnitsInRange(g,x1,y1,ZapRange,null)
call ForGroup(g,function SupremeShaman___Shtorm_Damage)
call DestroyGroup(g)
call DestroyEffect(eff)
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\ThunderClap\\ThunderClapCaster.mdl",x1,y1)
call DestroyEffect(eff)
call TriggerSleepAction(time)
set time=time*0.85
set i=i+1
endloop
set eff=null
set g=null
set caster=null
endfunction
function SupremeShaman___Zap_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0D0'
endfunction
function SupremeShaman___ThunderStrike_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0JA'
endfunction
function SupremeShaman___Shtorm_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0A0'
endfunction
function SupremeShaman___InitTriggers takes nothing returns nothing
local trigger thunderStrike=CreateTrigger()
local trigger shtorm=CreateTrigger()
local trigger zap=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(zap,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(zap,Condition(function SupremeShaman___Zap_Conditions))
call TriggerAddAction(zap,function SupremeShaman___Zap_Actions)
call TriggerRegisterAnyUnitEventBJ(thunderStrike,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(thunderStrike,Condition(function SupremeShaman___ThunderStrike_Conditions))
call TriggerAddAction(thunderStrike,function SupremeShaman___ThunderStrike_Actions)
call TriggerRegisterAnyUnitEventBJ(shtorm,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(shtorm,Condition(function SupremeShaman___Shtorm_Conditions))
call TriggerAddAction(shtorm,function SupremeShaman___Shtorm_Actions)
set zap=null
set shtorm=null
set thunderStrike=null
endfunction
function TranquilityLib__Tranquility_fitler takes nothing returns boolean
return isPlayerHasTranquility(Owner(GetFilterUnit()))and isUnitAlive(GetFilterUnit())and not isUnitStruct(GetFilterUnit())
endfunction
function TranquilityLib__Tranquility_timer takes nothing returns nothing
local boolexpr filter=Condition(function TranquilityLib__Tranquility_fitler)
local group g=CreateGroup()
local unit target=null
local effect eff=null
local real time=0.00
local integer id=0
call GroupEnumUnitsInRange(g,0,0,999999999,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set id=GetHandleId(target)
set eff=LoadEffect(id,TranquilityLib__EFFECT_STRING)
set time=LoadRealn(id,TranquilityLib__TIME_STRING)
if time<TranquilityLib__MAX_TIME then
call SaveRealn(id,TranquilityLib__TIME_STRING,time+TranquilityLib__PERIODIC)
else
if eff==null then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\Rejuvenation\\RejuvenationTarget.mdl",target,"chest")
call SaveEffect(id,TranquilityLib__EFFECT_STRING,eff)
endif
call HealUnit(target,TranquilityLib__POWER,true)
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set filter=null
set target=null
endfunction
function TranquilityLib__Tranquility_attack takes nothing returns nothing
local unit target=GetTriggerUnit()
local integer id=GetHandleId(target)
local effect eff=null
set eff=LoadEffect(id,TranquilityLib__EFFECT_STRING)
if eff!=null then
call DestroyEffect(eff)
call SaveEffect(id,TranquilityLib__EFFECT_STRING,null)
endif
call SaveRealn(id,TranquilityLib__TIME_STRING,0.00)
set eff=null
set target=null
endfunction
function TranquilityLib__AddAttackEventToUnit takes nothing returns nothing
call TriggerRegisterUnitEvent(TranquilityLib__DAMAGE_EVENT_TRIGGER,GetTriggerUnit(),EVENT_UNIT_DAMAGED)
endfunction
function TranquilityLib__Tranquility_conditions takes nothing returns boolean
return isPlayerHasTranquility(Owner(GetTriggerUnit()))and not isUnitStruct(GetTriggerUnit())and LoadRealn(GetHandleId(GetTriggerUnit()),"Tranquility | Time")>0.00
endfunction
function TranquilityLib__InitTriggers takes nothing returns nothing
local trigger time=CreateTrigger()
local trigger addAttack=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(time,TranquilityLib__PERIODIC)
call TriggerAddAction(time,function TranquilityLib__Tranquility_timer)
call TriggerAddCondition(TranquilityLib__DAMAGE_EVENT_TRIGGER,Condition(function TranquilityLib__Tranquility_conditions))
call TriggerAddAction(TranquilityLib__DAMAGE_EVENT_TRIGGER,function TranquilityLib__Tranquility_attack)
call TriggerRegisterEnterRectSimple(addAttack,bj_mapInitialPlayableArea)
call TriggerAddAction(addAttack,function TranquilityLib__AddAttackEventToUnit)
set time=null
set addAttack=null
endfunction
function s__WonderfulFlow__WonderfulFlow_st_Destroy takes integer this returns nothing
set s__WonderfulFlow__WonderfulFlow_st_eff[this]=null
set s__WonderfulFlow__WonderfulFlow_st_caster[this]=null
call s__WonderfulFlow__WonderfulFlow_st_deallocate(this)
endfunction
function WonderfulFlow__WonderfulFlow_filter takes nothing returns boolean
return isUnitEnemy(bj_caster,GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0
endfunction
function WonderfulFlow__WonderfulFlow_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer wf=LoadInt(id,"WonderfulFlow | Structure")
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
call ShowEffect(s__WonderfulFlow__WonderfulFlow_st_eff[wf],false)
set eff=AddSpecialEffect("Flamestrike Mystic II.mdx",s__WonderfulFlow__WonderfulFlow_st_x[wf],s__WonderfulFlow__WonderfulFlow_st_y[wf])
call SetEffectScale(eff,s__WonderfulFlow__WonderfulFlow_st_scale[wf])
call DestroyEffect(eff)
set bj_caster=s__WonderfulFlow__WonderfulFlow_st_caster[wf]
set filter=Condition(function WonderfulFlow__WonderfulFlow_filter)
call GroupEnumUnitsInRange(g,s__WonderfulFlow__WonderfulFlow_st_x[wf],s__WonderfulFlow__WonderfulFlow_st_y[wf],s__WonderfulFlow__WonderfulFlow_st_range[wf],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
if isUnitSummon(target)then
call MagDamage(s__WonderfulFlow__WonderfulFlow_st_caster[wf],target,s__WonderfulFlow__WonderfulFlow_st_damage[wf]*WonderfulFlow__SUMMON_DAMAGE)
else
call MagDamage(s__WonderfulFlow__WonderfulFlow_st_caster[wf],target,s__WonderfulFlow__WonderfulFlow_st_damage[wf])
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__WonderfulFlow__WonderfulFlow_st_Destroy(wf)
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set t=null
set g=null
set eff=null
set filter=null
set target=null
endfunction
function WonderfulFlow__WonderfulFlow_start takes nothing returns nothing
local unit caster=GetAttacker()
local integer cid=GetHandleId(caster)
local integer count=LoadInt(cid,"WonderfulFlow | Count")
local integer wf=s__WonderfulFlow__WonderfulFlow_st__allocate()
local integer lvl=GetUnitAbilityLevel(caster,'A05H')
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local effect eff
set s__WonderfulFlow__WonderfulFlow_st_damage[wf]=lvl*WonderfulFlow__LVL_DAMAGE
set s__WonderfulFlow__WonderfulFlow_st_caster[wf]=caster
set s__WonderfulFlow__WonderfulFlow_st_x[wf]=GetUnitX(GetTriggerUnit())
set s__WonderfulFlow__WonderfulFlow_st_y[wf]=GetUnitY(GetTriggerUnit())
set s__WonderfulFlow__WonderfulFlow_st_range[wf]=WonderfulFlow__RANGE
set s__WonderfulFlow__WonderfulFlow_st_scale[wf]=1.00
set s__WonderfulFlow__WonderfulFlow_st_eff[wf]=TimedEffect("Abilities\\Spells\\Human\\Brilliance\\Brilliance.mdl",s__WonderfulFlow__WonderfulFlow_st_x[wf],s__WonderfulFlow__WonderfulFlow_st_y[wf],WonderfulFlow__WAIT_TIME)
call SetEffectScale(s__WonderfulFlow__WonderfulFlow_st_eff[wf],2.00)
if isPlayerHasSoloHero(Owner(caster))then
if count==WonderfulFlow__BUFF_USE_COUNT-1 then
set s__WonderfulFlow__WonderfulFlow_st_scale[wf]=2.00
set s__WonderfulFlow__WonderfulFlow_st_range[wf]=s__WonderfulFlow__WonderfulFlow_st_range[wf]*s__WonderfulFlow__WonderfulFlow_st_scale[wf]
call SetEffectScale(s__WonderfulFlow__WonderfulFlow_st_eff[wf],4.00)
call SaveInt(cid,"WonderfulFlow | Count",0)
else
call SaveInt(cid,"WonderfulFlow | Count",count+1)
endif
endif
call SaveInt(id,"WonderfulFlow | Structure",wf)
call SaveBool(GetHandleId(s__WonderfulFlow__WonderfulFlow_st_caster[wf]),"WonderfulFlow | Charged",false)
set eff=LoadEffect(GetHandleId(s__WonderfulFlow__WonderfulFlow_st_caster[wf]),"WonderfulFlow | Effect")
call DestroyEffect(eff)
call TimerStart(t,WonderfulFlow__WAIT_TIME,false,function WonderfulFlow__WonderfulFlow_timer)
set t=null
set eff=null
set caster=null
endfunction
function WonderfulFlow__WonderfulFlow_timerFilter takes nothing returns boolean
return GetUnitAbilityLevel(GetFilterUnit(),'A05H')>0 and not LoadBool(GetHandleId(GetFilterUnit()),"WonderfulFlow | Charged")
endfunction
function WonderfulFlow__WonderfulFlow_Charged takes nothing returns nothing
local boolexpr filter=Condition(function WonderfulFlow__WonderfulFlow_timerFilter)
local group g=CreateGroup()
local unit target
local effect eff
call GroupEnumUnitsInRange(g,0,0,99999999,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",target,"weapon")
call SaveBool(GetHandleId(target),"WonderfulFlow | Charged",true)
call SaveEffect(GetHandleId(target),"WonderfulFlow | Effect",eff)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set target=null
set filter=null
endfunction
function WonderfulFlow__WonderfulFlow_conditions takes nothing returns boolean
return LoadBool(GetHandleId(GetAttacker()),"WonderfulFlow | Charged")
endfunction
function WonderfulFlow__InitTriggers takes nothing returns nothing
local trigger cast=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(cast,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(cast,Condition(function WonderfulFlow__WonderfulFlow_conditions))
call TriggerAddAction(cast,function WonderfulFlow__WonderfulFlow_start)
set gg_trg_WonderfulFlow=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_WonderfulFlow,WonderfulFlow__PERIODIC)
call TriggerAddAction(gg_trg_WonderfulFlow,function WonderfulFlow__WonderfulFlow_Charged)
endfunction
function s__cursedAI___UnitAI_Destroy takes integer this returns nothing
set s__cursedAI___UnitAI_isWaitForHp[this]=false
set s__cursedAI___UnitAI_isDefended[this]=false
set s__cursedAI___UnitAI_isDefend[this]=false
set s__cursedAI___UnitAI_target[this]=null
call s__cursedAI___UnitAI_deallocate(this)
endfunction
function cursedAI___InitUnitStruct takes unit target returns nothing
local integer unit_st=s__cursedAI___UnitAI__allocate()
call SaveInt(GetHandleId(target),"UnitAI | Structure",unit_st)
endfunction
function cursedAI___GetUnitStruct takes unit target returns integer
return LoadInt(GetHandleId(target),"UnitAI | Structure")
endfunction
function cursedAI___isPlayerBot takes player target returns boolean
return IsPlayerSlotState(target,PLAYER_SLOT_STATE_PLAYING)and GetPlayerController(target)==MAP_CONTROL_COMPUTER
endfunction
function cursedAI___isUnitStay takes unit target returns boolean
local integer unitOrder=GetUnitCurrentOrder(target)
return unitOrder==0 or(OrderId("move")!=unitOrder and OrderId("attack")!=unitOrder and OrderId("smart")!=unitOrder)
endfunction
function cursedAI___UnitsCountFilter takes nothing returns boolean
return GetWidgetLife(GetFilterUnit())>0.00 and GetOwningPlayer(GetFilterUnit())==cursedAI___bj_player and not isUnitStruct(GetFilterUnit())
endfunction
function cursedAI___GetUnitsCount takes player caster returns integer
local integer count=0
local boolexpr filter
local unit target
call GroupClear(cursedAI___unitsCountGroup)
set cursedAI___bj_player=caster
set filter=Condition(function cursedAI___UnitsCountFilter)
call GroupEnumUnitsInRect(cursedAI___unitsCountGroup,bj_mapInitialPlayableArea,filter)
loop
set target=FirstOfGroup(cursedAI___unitsCountGroup)
exitwhen target==null
set count=count+1
call GroupRemoveUnit(cursedAI___unitsCountGroup,target)
endloop
call DestroyBoolExpr(filter)
set filter=null
set target=null
return count
endfunction
function cursedAI___GetMostWeaknesEnemyId takes player caster returns integer
local integer index=0
local integer power=0
local integer pw=0
local integer id=0
loop
exitwhen index>5
set pw=PlayerPower[index+1]
if(pw<power or power==0)and IsPlayerEnemy(caster,Player(index))and isPlayerHasCastle(Player(index))then
set power=pw
set id=index+1
endif
set index=index+1
endloop
if cursedAI___IS_LOGGER_ENABLED then
call Log("Player("+I2S(GetPlayerId(caster))+") found Enemy("+I2S(id)+") with "+I2S(power)+" power")
endif
return id
endfunction
function cursedAI___UseUltimate takes player target returns nothing
local unit castle=udg_Castle[GetPlayerId(target)+1]
call IssueImmediateOrder(castle,"roar")
call TriggerSleepAction(0.1)
call IssueImmediateOrder(castle,"channel")
call TriggerSleepAction(0.1)
call IssueImmediateOrder(castle,"starfall")
set castle=null
endfunction
function cursedAI___AttackEnemy takes player attacker,player enemy returns nothing
local boolexpr filter
local unit target
local unit enemyCastle=udg_Castle[GetPlayerId(enemy)+1]
local real castleX=GetUnitX(enemyCastle)
local real castleY=GetUnitY(enemyCastle)
local integer unit_st=0
call PingMinimapForForce(GetPlayersAllies(attacker),castleX,castleY,1.00)
call GroupClear(cursedAI___attackGroup)
set cursedAI___bj_player=attacker
set filter=Condition(function cursedAI___UnitsCountFilter)
call GroupEnumUnitsInRect(cursedAI___attackGroup,bj_mapInitialPlayableArea,filter)
loop
set target=FirstOfGroup(cursedAI___attackGroup)
exitwhen target==null
set unit_st=cursedAI___GetUnitStruct(target)
if cursedAI___isUnitStay(target)and not s__cursedAI___UnitAI_isWaitForHp[unit_st]and not s__cursedAI___UnitAI_isDefend[unit_st]then
call IssuePointOrder(target,"attack",castleX,castleY)
endif
call GroupRemoveUnit(cursedAI___attackGroup,target)
endloop
call DestroyBoolExpr(filter)
set filter=null
set target=null
endfunction
function cursedAI___Periodic_Act takes nothing returns nothing
local integer index=0
local integer botIndex=0
local integer unitsCount=0
local integer weaknesEnemy=0
local unit castle=null
loop
set botIndex=cursedAI___BOTS[index]
exitwhen botIndex==0
set unitsCount=cursedAI___GetUnitsCount(Player(botIndex-1))
if cursedAI___IS_LOGGER_ENABLED then
call Log("Player("+I2S(botIndex-1)+") has "+I2S(unitsCount)+" units")
endif
if unitsCount>=cursedAI___MIN_ATTACK_GROUP_SIZE or isPlayerHasSoloHero(Player(botIndex-1))then
set weaknesEnemy=cursedAI___GetMostWeaknesEnemyId(Player(botIndex-1))
if weaknesEnemy>0 then
call cursedAI___AttackEnemy(Player(botIndex-1),Player(weaknesEnemy-1))
endif
endif
set index=index+1
endloop
set castle=null
endfunction
function cursedAI___WaitForHp_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local unit target=LoadUnit(id,"WaitForHp | Target")
local integer unit_st=cursedAI___GetUnitStruct(target)
if GetUnitHealthPercent(target)>=cursedAI___WAIT_FOR_HP_PERCENT then
if cursedAI___IS_LOGGER_ENABLED then
call Log("Unit of Player("+I2S(OwnerId(target))+") stoped wait for hp regeneration")
endif
set s__cursedAI___UnitAI_isWaitForHp[unit_st]=false
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
endif
set t=null
set target=null
endfunction
function cursedAI___WaitForHp takes unit target returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer unit_st=cursedAI___GetUnitStruct(target)
set s__cursedAI___UnitAI_isWaitForHp[unit_st]=true
call SaveUnit(id,"WaitForHp | Target",target)
call TimerStart(t,cursedAI___WAIT_FOR_HP_PERIODIC,true,function cursedAI___WaitForHp_timer)
set t=null
endfunction
function cursedAI___WaitForDefend_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local unit target=LoadUnit(id,"WaitForDefend | Target")
local integer unit_st=cursedAI___GetUnitStruct(target)
if cursedAI___IS_LOGGER_ENABLED then
call Log("Unit of Player("+I2S(OwnerId(target))+") stoped wait for defend")
endif
set s__cursedAI___UnitAI_isDefended[unit_st]=false
set s__cursedAI___UnitAI_isDefend[unit_st]=false
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
set t=null
set target=null
endfunction
function cursedAI___WaitForDefend takes unit target returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer unit_st=cursedAI___GetUnitStruct(target)
set s__cursedAI___UnitAI_isDefended[unit_st]=true
set s__cursedAI___UnitAI_isDefend[unit_st]=true
call SaveUnit(id,"WaitForDefend | Target",target)
call TimerStart(t,cursedAI___DEFEND_TIME,true,function cursedAI___WaitForDefend_timer)
set t=null
endfunction
function cursedAI___IssueNearbyUnitsDefendUnit takes unit target,player owner returns nothing
local group g=CreateGroup()
local boolexpr filter
local unit tgt
local real targetX=GetUnitX(target)
local real targetY=GetUnitY(target)
set cursedAI___bj_player=owner
set filter=Condition(function cursedAI___UnitsCountFilter)
call GroupEnumUnitsInRangeCounted(g,targetX,targetY,99999999999.00,filter,cursedAI___DEFEND_GROUP_SIZE)
loop
set tgt=FirstOfGroup(g)
exitwhen tgt==null
call cursedAI___WaitForDefend(tgt)
call IssuePointOrder(tgt,"attack",targetX,targetY)
call GroupRemoveUnit(g,tgt)
endloop
call DestroyGroup(g)
set g=null
set tgt=null
set filter=null
endfunction
function cursedAI___IssueAllyBotsDefendUnit takes unit target returns nothing
local integer i=0
local integer botIndex
loop
set botIndex=cursedAI___BOTS[i]
exitwhen botIndex==0
if IsUnitAlly(target,Player(botIndex))then
call PingMinimapForForce(GetPlayersAllies(Owner(target)),GetUnitX(target),GetUnitY(target),1.00)
call cursedAI___IssueNearbyUnitsDefendUnit(target,Player(botIndex))
endif
set i=i+1
endloop
endfunction
function cursedAI___UnitTakeDamage_Act takes nothing returns nothing
local unit target=GetTriggerUnit()
local unit damager=GetEventDamageSource()
local unit castle=udg_Castle[OwnerId(target)+1]
local real castleX=GetUnitX(castle)
local real castleY=GetUnitY(castle)
local integer unit_st=cursedAI___GetUnitStruct(target)
local integer index=0
if cursedAI___isPlayerBot(Owner(target))then
call TriggerSleepAction(0.1)
if GetUnitHealthPercent(target)<=cursedAI___RUN_AWAY_HP_PERCENT and not s__cursedAI___UnitAI_isWaitForHp[unit_st]then
if cursedAI___IS_LOGGER_ENABLED then
call Log("Unit of Player("+I2S(OwnerId(target))+") run away")
endif
call cursedAI___WaitForHp(target)
call IssuePointOrder(target,"move",castleX,castleY)
endif
if GetUnitHealthPercent(target)<=cursedAI___ULTIMATE_HP_PERCENT and castle==target then
call cursedAI___UseUltimate(Owner(target))
endif
endif
if isUnitStruct(target)and not s__cursedAI___UnitAI_isDefended[unit_st]then
if cursedAI___IS_LOGGER_ENABLED then
call Log("Player("+I2S(OwnerId(target))+") request for defend")
endif
call cursedAI___WaitForDefend(target)
call cursedAI___IssueAllyBotsDefendUnit(target)
endif
set target=null
set damager=null
endfunction
function cursedAI___UnitsEnterMap_Act takes nothing returns nothing
local unit caster=GetTriggerUnit()
if cursedAI___isPlayerBot(Owner(caster))then
call cursedAI___InitUnitStruct(caster)
endif
call TriggerRegisterUnitEvent(cursedAI___takeDamage,caster,EVENT_UNIT_DAMAGED)
set caster=null
endfunction
function cursedAI___UnitDie_Act takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer unit_st=cursedAI___GetUnitStruct(caster)
if cursedAI___IS_LOGGER_ENABLED then
call Log("Unit of Player("+I2S(OwnerId(caster))+") die")
endif
if unit_st!=0 then
call s__cursedAI___UnitAI_Destroy(unit_st)
endif
set caster=null
endfunction
function cursedAI___UnitDie_Cond takes nothing returns boolean
return cursedAI___isPlayerBot(Owner(GetTriggerUnit()))and not isUnitHero(GetTriggerUnit())
endfunction
function cursedAI___InitBots takes nothing returns nothing
local integer index=0
local integer bind=0
loop
exitwhen index>5
if cursedAI___isPlayerBot(Player(index))then
set cursedAI___BOTS[bind]=index+1
set bind=bind+1
endif
set index=index+1
endloop
endfunction
function cursedAI___Init takes nothing returns nothing
local trigger periodic=CreateTrigger()
local trigger enterMap=CreateTrigger()
local trigger unitDie=CreateTrigger()
call cursedAI___InitBots()
call TriggerRegisterTimerEventPeriodic(periodic,cursedAI___PERIODIC_TIME)
call TriggerAddAction(periodic,function cursedAI___Periodic_Act)
call TriggerRegisterEnterRectSimple(enterMap,bj_mapInitialPlayableArea)
call TriggerAddAction(enterMap,function cursedAI___UnitsEnterMap_Act)
call TriggerRegisterAnyUnitEventBJ(unitDie,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(unitDie,Condition(function cursedAI___UnitDie_Cond))
call TriggerAddAction(unitDie,function cursedAI___UnitDie_Act)
call TriggerAddAction(cursedAI___takeDamage,function cursedAI___UnitTakeDamage_Act)
set enterMap=null
set periodic=null
endfunction
function GetRaceIndex takes integer id returns integer
local integer index=RACE_LIST_MIN
loop
exitwhen index>RACE_LIST_MAX
if RACE_LIST[index]==id then
return index
endif
set index=index+1
endloop
return-1
endfunction
function RemoveRaceFromList takes integer id returns nothing
local integer index=GetRaceIndex(id)
if index==-1 or not RACE_LIMIT then
return
endif
set RACE_LIST[index]=RACE_LIST[RACE_LIST_MAX]
set RACE_LIST[RACE_LIST_MAX]=0
set RACE_LIST_MAX=RACE_LIST_MAX-1
endfunction
function InitRandomRaces takes nothing returns nothing
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A001'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A00I'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A01B'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A01S'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A0AN'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A0GQ'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A02G'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A02S'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A03A'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A03N'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A06R'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A07D'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A082'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A08M'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A09N'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A0BS'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A0BR'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A0CQ'
set RACE_LIST_MAX=RACE_LIST_MAX+1
set RACE_LIST[RACE_LIST_MAX]='A0DT'
endfunction
function GetRandomRace takes nothing returns integer
local integer index=0
local integer Race=0
call SetRandomSeed(GetRandomInt(-1000000,1000000))
set index=GetRandomInt(RACE_LIST_MIN,RACE_LIST_MAX)
set Race=RACE_LIST[index]
if RACE_LIMIT then
set RACE_LIST[index]=RACE_LIST[RACE_LIST_MAX]
set RACE_LIST[RACE_LIST_MAX]=0
set RACE_LIST_MAX=RACE_LIST_MAX-1
endif
return Race
endfunction
function Race_Remove takes unit dami,integer id returns unit
local player p=GetOwningPlayer(dami)
local real x=GetUnitX(dami)
local real y=GetUnitY(dami)
call RemoveUnit(dami)
set dami=CreateUnit(p,id,x,y,bj_UNIT_FACING)
set p=null
return dami
endfunction
function Race_Group takes nothing returns nothing
local unit target=GetEnumUnit()
local integer id=bj_num
local unit dami
set dami=Race_Remove(target,id)
if(GetPlayerId(GetOwningPlayer(dami))!=1 and GetPlayerId(GetOwningPlayer(dami))!=4)then
call UnitAddAbility(dami,'A022')
call SetPlayerTechResearched(GetOwningPlayer(dami),'Rhgb',1)
endif
set target=null
set dami=null
endfunction
function Race_RandomItem takes nothing returns integer
local integer min=1
local integer max=3
local integer i=GetRandomInt(min,max)
local integer array RandomItem
set RandomItem[1]='I010'
set RandomItem[2]='I015'
set RandomItem[3]='I02D'
return RandomItem[i]
endfunction
function isRacePicked takes integer playerRace returns boolean
local integer index=0
loop
exitwhen index>5
if bj_playerRace[index]==playerRace then
return true
endif
set index=index+1
endloop
return false
endfunction
function pickRace takes integer playerRace,integer playerID returns nothing
if RACE_LIMIT then
set bj_playerRace[playerID]=playerRace
endif
endfunction
function Race_Give takes unit caster,integer id returns nothing
local integer casterID=GetUnitTypeId(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local player p=GetOwningPlayer(caster)
local integer pid=GetPlayerId(p)+1
local boolean remove=false
local integer Castle=0
local integer Tower=0
local integer Hero=0
local integer Item=0
local integer l__Unit=0
local integer Shop=0
local integer Guards=0
local integer l__Abil=0
local string Icon=""
local integer num=0
local integer max=0
local integer i=0
local string text
local unit dami
local group g
if(id=='A001')then
set remove=true
set l__Abil='A040'
set Castle='h002'
set Tower='h003'
set Hero='H008'
set Item='I003'
set l__Unit='h005'
set Shop='n00S'
set Guards='n00L'
set Icon="ReplaceableTextures\\CommandButtons\\BTNHeroPaladin.blp"
endif
if(id=='A00I')then
set remove=true
set l__Abil='A04A'
set Castle='h007'
set Tower='h00A'
set Hero='H00B'
set Item='I004'
set l__Unit='h00H'
set Shop='n00S'
set Guards='n00L'
set Icon="ReplaceableTextures\\CommandButtons\\BTNJaina.blp"
endif
if(id=='A01B')then
set remove=true
set l__Abil='A045'
set Castle='h00N'
set Tower='h003'
set Hero='H00O'
set Item='I005'
set l__Unit='h00M'
set Shop='n00S'
set Guards='n00L'
set Icon="ReplaceableTextures\\CommandButtons\\BTNProudmoore.blp"
endif
if(id=='A01S')then
set remove=true
set l__Abil='A04F'
set Castle='h00Q'
set Tower='h003'
set Hero='H00R'
set Item='I006'
set l__Unit='h00P'
set Shop='n00S'
set Guards='n00L'
set Icon="ReplaceableTextures\\CommandButtons\\BTNArthas.blp"
endif
if(id=='A0AN')then
set remove=true
set l__Abil='A0AO'
set Castle='h024'
set Tower='h00A'
set Hero='H025'
set Item='I01B'
set l__Unit='h023'
set Shop='n00S'
set Guards='n00L'
set Icon="ReplaceableTextures\\CommandButtons\\BTNBloodMage2.blp"
endif
if(id=='A0GQ')then
set remove=true
set l__Abil='A0GP'
set Castle='h03D'
set Tower='h03E'
set Hero='H017'
set Item='I029'
set l__Unit='h03F'
set Shop='n00S'
set Guards='n00L'
set Icon="ReplaceableTextures\\CommandButtons\\BTNHeroMountainKing.blp"
endif
if(id=='A02G')then
set remove=true
set l__Abil='A04P'
set Castle='h00U'
set Tower='h00V'
set Hero='E002'
set Item='I009'
set l__Unit='e000'
set Shop='n00T'
set Guards='n00N'
set Icon="ReplaceableTextures\\CommandButtons\\BTNKeeperOfTheGrove.blp"
endif
if(id=='A02S')then
set remove=true
set l__Abil='A04K'
set Castle='h013'
set Tower='h00V'
set Hero='H016'
set Item='I00A'
set l__Unit='h011'
set Shop='n00T'
set Guards='n00N'
set Icon="ReplaceableTextures\\CommandButtons\\BTNTreant.blp"
endif
if(id=='A03A')then
set remove=true
set l__Abil='A04U'
set Castle='h01C'
set Tower='h01E'
set Hero='E001'
set Item='I00B'
set l__Unit='h01B'
set Shop='n00T'
set Guards='n00N'
set Icon="ReplaceableTextures\\CommandButtons\\BTNFurion.blp"
endif
if(id=='A03N')then
set remove=true
set l__Abil='A04Z'
set Castle='h01G'
set Tower='h00V'
set Hero='E004'
set Item='I00D'
set l__Unit='h01F'
set Shop='n00T'
set Guards='n00N'
set Icon="ReplaceableTextures\\CommandButtons\\BTNAssassin.blp"
endif
if(id=='A06R')then
set remove=true
set l__Abil='A06S'
set Castle='u00F'
set Tower='h01P'
set Hero='U00E'
set Item='I00L'
set l__Unit='h01Q'
set Shop='n00U'
set Guards='n00V'
set Icon="ReplaceableTextures\\CommandButtons\\BTNBanshee.blp"
endif
if(id=='A07D')then
set remove=true
set l__Abil='A07E'
set Castle='u00U'
set Tower='h01P'
set Hero='U00T'
set Item='I00Q'
set l__Unit='h01R'
set Shop='n00U'
set Guards='n00V'
set Icon="ReplaceableTextures\\CommandButtons\\BTNNecromancer.blp"
endif
if(id=='A082')then
set remove=true
set l__Abil='A083'
set Castle='u011'
set Tower='h01T'
set Hero='U012'
set Item='I00U'
set l__Unit='h01U'
set Shop='n00U'
set Guards='n00V'
set Icon="ReplaceableTextures\\CommandButtons\\BTNGhoul.blp"
endif
if(id=='A08M')then
set remove=true
set l__Abil='A08N'
set Castle='u015'
set Tower='h01T'
set Hero='U017'
set Item='I00W'
set l__Unit='h01V'
set Shop='n00U'
set Guards='n00V'
set Icon="ReplaceableTextures\\CommandButtons\\BTNCarrionScarabs.blp"
endif
if(id=='A09N')then
set remove=true
set l__Abil='A09M'
set Castle='u01A'
set Tower='h022'
set Hero='O001'
set Item='I016'
set l__Unit='h020'
set Shop='n015'
set Guards='n014'
set Icon="ReplaceableTextures\\CommandButtons\\BTNThrall.blp"
endif
if(id=='A0BS')then
set remove=true
set l__Abil='A0BT'
set Castle='u01C'
set Tower='h02F'
set Hero='O007'
set Item='I01J'
set l__Unit='h02E'
set Shop='n015'
set Guards='n014'
set Icon="ReplaceableTextures\\CommandButtons\\BTNHeroBlademaster.blp"
endif
if(id=='A0BR')then
set remove=true
set l__Abil='A0CE'
set Castle='u01E'
set Tower='h02F'
set Hero='O00C'
set Item='I01L'
set l__Unit='h02I'
set Shop='n015'
set Guards='n014'
set Icon="ReplaceableTextures\\CommandButtons\\BTNHeroTaurenChieftain.blp"
endif
if(id=='A0CQ')then
set remove=true
set l__Abil='A0CR'
set Castle='u01F'
set Tower='h02F'
set Hero='O00D'
set Item='I01M'
set l__Unit='e006'
set Shop='n015'
set Guards='n014'
set Icon="ReplaceableTextures\\CommandButtons\\BTNShadowHunter.blp"
endif
if(id=='A0DT')then
set remove=true
set l__Abil='A0DZ'
set Castle='h02W'
set Tower='h02Z'
set Hero='H02Y'
set Item='I01S'
set l__Unit='h02X'
set Shop='n01T'
set Guards='n01U'
set Icon="ReplaceableTextures\\CommandButtons\\BTNForgottenOne.blp"
endif
if remove==true then
call ForceUICancelBJ(p)
call ForceUICancelBJ(p)
call ForceUICancelBJ(p)
call ForceUICancelBJ(p)
call ForceUICancelBJ(p)
if casterID=='h03N' then
set BANNED_RACES=BANNED_RACES-1
if BANNED_RACES>=0 then
set text=SetTextColor("Подсказка:","hint")+" Забанена раса "+GetObjectName(l__Abil)+" ["+I2S(BANNED_RACES)+"]"
set i=0
loop
exitwhen i>11
call SetPlayerAbilityAvailable(Player(i),l__Abil,false)
call DisplayTextToPlayer(Player(i),0,0,text)
set i=i+1
endloop
if CHOICE_REJIME=="rand" then
call RemoveRaceFromList(id)
endif
endif
if BANNED_RACES==0 then
call RemoveUnit(caster)
set caster=CreateUnit(p,'h001',x,y,bj_UNIT_FACING)
call SelectUnitForPlayerSingle(caster,p)
set udg_TalantPicker[GetPlayerId(p)+1]=caster
call MessageToAll(SetTextColor("Подсказка:","hint")+" Игра началась!")
call UnpauseAllUnits()
if CHOICE_REJIME=="rand" then
set i=0
loop
exitwhen i>5
if isPlayerActive(Player(i))then
set num=GetRandomTalant()
call SetPlayerTechResearched(Player(i),num,1)
call Talants_Give(udg_TalantPicker[i+1],num)
set num=GetRandomRace()
call Race_Give(udg_TalantPicker[i+1],num)
endif
set i=i+1
endloop
endif
endif
return
endif
if(GetLocalPlayer()==p)then
call ClearSelection()
endif
if isRacePicked(id)and bj_playerRace[pid-1]==0 then
call DisplayTextToPlayer(p,0,0,SetTextColor("Подсказка:","hint")+" Данная раса уже выбрана!")
return
else
call pickRace(id,pid-1)
endif
if RACE_LIMIT then
set i=0
loop
exitwhen i>11
call SetPlayerAbilityAvailable(Player(i),l__Abil,false)
set i=i+1
endloop
endif
call MultiboardIconForAllies(p,Icon,pid,4)
call ShowUnit(udg_Visualisator[pid],false)
call RemoveUnit(caster)
set udg_Castle[pid]=CreateUnit(p,Castle,x,y,bj_UNIT_FACING)
if(GetPlayerTechCount(p,'R04K',true)==1)then
call Pentagram_start(udg_Castle[pid],GetUnitX(udg_Castle[pid]),GetUnitY(udg_Castle[pid]))
endif
set g=CreateGroup()
set bj_groupEnumTypeId='n001'
call GroupEnumUnitsOfPlayer(g,p,filterGetUnitsOfPlayerAndTypeId)
set dami=FirstOfGroup(g)
call Race_Remove(dami,Guards)
call GroupClear(g)
set bj_groupEnumTypeId='n000'
call GroupEnumUnitsOfPlayer(g,p,filterGetUnitsOfPlayerAndTypeId)
set dami=FirstOfGroup(g)
call Race_Remove(dami,Shop)
call GroupClear(g)
set bj_groupEnumTypeId='h004'
call GroupEnumUnitsOfPlayer(g,p,filterGetUnitsOfPlayerAndTypeId)
set bj_num=Tower
call ForGroup(g,function Race_Group)
call GroupClear(g)
set bj_groupEnumTypeId='h006'
call GroupEnumUnitsOfPlayer(g,p,filterGetUnitsOfPlayerAndTypeId)
set dami=FirstOfGroup(g)
if(GetPlayerTechCount(p,'R01U',true)==1)then
set Hero='H01L'
endif
if(GetPlayerTechCount(p,'R02R',true)==1)then
set Hero='H01Z'
endif
if(GetPlayerTechCount(p,'R03Q',true)==1)then
set Hero='H02R'
endif
if(GetPlayerTechCount(p,'R047',true)==1)then
set Hero='U01H'
endif
if(GetPlayerTechCount(p,'R04B',true)==1)then
set Hero='H034'
endif
if(GetPlayerTechCount(p,'R04E',true)==1)then
set Hero='U01N'
endif
if(GetPlayerTechCount(p,'R04J',true)==1)then
set Hero='H03A'
endif
if(GetPlayerTechCount(p,'R04T',true)==1)then
set Hero='H03K'
endif
if(GetPlayerTechCount(p,'R04X',true)==1)then
set Hero='H03L'
endif
if(GetPlayerTechCount(p,'R03L',true)==1 and Hero=='H00R')then
set Hero='H02L'
endif
if(GetPlayerTechCount(p,'R03N',true)==1 and Hero=='H00B')then
set Hero='H02K'
endif
if(GetPlayerTechCount(p,'R03O',true)==1 and Hero=='H008')then
set Hero='H02O'
endif
if(GetPlayerTechCount(p,'R03W',true)==1 and Hero=='O007')then
set Hero='O00J'
endif
if(GetPlayerTechCount(p,'R049',true)==1 and Hero=='H02Y')then
set Hero='H032'
set l__Unit='h033'
endif
set caster=Race_Remove(dami,Hero)
set udg_Hero[pid]=caster
call UnitAddItemById(caster,Item)
call SelectUnitForPlayerSingle(udg_Hero[pid],p)
set i=Race_RandomItem()
if(GetPlayerTechCount(p,'R036',true)==1)then
call UnitAddItemById(caster,i)
endif
if isPlayerHasLegion(p)then
call UnitAddItemById(caster,'I01E')
endif
if(GetPlayerTechCount(p,'R04J',true)==1)then
set l__Unit='n024'
endif
set udg_Unit[pid]=l__Unit
if(not isPlayerHasBasterds(p)and GetPlayerTechCount(p,'R04T',true)!=1 and GetPlayerTechCount(p,'R02A',true)!=1 and GetPlayerTechCount(p,'R047',true)!=1 and GetPlayerTechCount(p,'R04E',true)!=1 and GetPlayerTechCount(p,'R04X',true)!=1)then
call StartSpawn(pid-1)
endif
if(GetPlayerTechCount(p,'R02Q',true)==1 or GetPlayerTechCount(p,'R04U',true)==1 or GetPlayerTechCount(p,'R04V',true)==1)then
call RemoveUnit(udg_Hero[pid])
set udg_Hero[pid]=null
endif
endif
call DestroyGroup(g)
set g=null
set p=null
set dami=null
set caster=null
endfunction
function Race_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
call Race_Give(caster,GetSpellAbilityId())
set caster=null
endfunction
function RaceLib___InitTriggers takes nothing returns nothing
local trigger rac=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(rac,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddAction(rac,function Race_Actions)
call InitRandomRaces()
set rac=null
endfunction
function StartGameLib__ChoicePlayer takes nothing returns string
local string name=""
local string array players
local integer index=0
set players[0]="|c00FF0303"+GetPlayerName(Player(0))+"|r"
set players[1]="|c000042FF"+GetPlayerName(Player(1))+"|r"
set players[2]="|c001CE6B9"+GetPlayerName(Player(2))+"|r"
set players[3]="|c00540081"+GetPlayerName(Player(3))+"|r"
set players[4]="|c00FFFC01"+GetPlayerName(Player(4))+"|r"
set players[5]="|c00fEBA0E"+GetPlayerName(Player(5))+"|r"
loop
exitwhen index>5
set name=GetPlayerName(Player(index))
if name=="loliconshik3" or name=="sdlvt" or name=="ImNoobTarenas" then
set bj_PlayerChoice=Player(index)
return players[index]
endif
set index=index+1
endloop
set index=0
loop
exitwhen index>5
if(players[index]!=null and players[index]!="" and GetPlayerSlotState(Player(index))==PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(index))==MAP_CONTROL_USER)then
set bj_PlayerChoice=Player(index)
return players[index]
endif
set index=index+1
endloop
return""
endfunction
function StartGameLib__DisplaySettings takes nothing returns nothing
local string array stringArray
local integer arrayIndex=1
local integer i=0
local string ss
local string s
call ClearTextMessages()
set stringArray[1]="|cffffcc00Настройки|r"
set stringArray[2]="Может вводить лишь "+bj_ChoicePlayer+"."
set stringArray[3]="Для ввода используйте символ - , например: -ip 25."
set stringArray[4]="    |cffffcc00-ip 1, 99|r - Периодичность инкома (сек) (тек: "+I2S(R2I(INCOME_PERIODIC))+")."
set stringArray[5]="    |cffffcc00-sg 0, 9999|r - Стандартное кол-во золота (тек: "+I2S(INIT_GOLD_COUNT)+")."
set stringArray[6]="    |cffffcc00-si 0, 99|r - Стандартный инком (тек: "+I2S(INIT_INCOME)+")."
set stringArray[7]="    |cffffcc00-rj ffa, teams|r - Режим игры (тек: "+REJIME+")."
set stringArray[8]="    |cffffcc00-bt 0, 10|r - Лимит забаненных талантов (тек: "+I2S(BANNED_TALANTS)+")."
set stringArray[9]="    |cffffcc00-br 0, 10|r - Лимит забаненных рас (тек: "+I2S(BANNED_RACES)+")."
set stringArray[10]="    |cffffcc00-cr std, rand|r - Режим выбора талантов и рас (тек: "+CHOICE_REJIME+")."
set stringArray[11]="    |cffffcc00-tc false, true|r - Смена типа атаки и брони юнитов (тек: "+mB2S(UNIT_TYPES_CHANGE)+")."
set stringArray[12]="    |cffffcc00-rl false, true|r - Запрет брать одинаковые расы (тек: "+mB2S(RACE_LIMIT)+")."
set stringArray[13]="Для старта игры напишите |cffffcc00-start|r."
loop
exitwhen i>11
set arrayIndex=1
loop
exitwhen stringArray[arrayIndex]=="" or stringArray[arrayIndex]==null
call DisplayTimedTextToPlayer(Player(i),0,0,999999999,stringArray[arrayIndex])
set arrayIndex=arrayIndex+1
endloop
set i=i+1
endloop
endfunction
function StartGameLib__InputSettings takes nothing returns nothing
local string s=GetEventPlayerChatString()
local string sub=SubString(s,1,3)
local string argument5=SubString(s,4,9)
local string argument4=SubString(s,4,8)
local string argument3=SubString(s,4,7)
local integer arg=S2I(argument5)
if s=="-start" then
return
endif
if(sub=="ip")then
if(arg>=1 and arg<=99)then
set INCOME_PERIODIC=arg
endif
elseif(sub=="sg")then
if(arg>=0 and arg<=9999)then
set INIT_GOLD_COUNT=arg
endif
elseif(sub=="si")then
if(arg>=1 and arg<=99)then
set INIT_INCOME=arg
endif
elseif(sub=="bt")then
if(arg>=0 and arg<=10)then
set BANNED_TALANTS=arg
endif
elseif(sub=="br")then
if(arg>=0 and arg<=10)then
set BANNED_RACES=arg
endif
elseif sub=="rj" then
if argument5=="teams" then
set REJIME=argument5
elseif argument3=="ffa" then
set REJIME=argument3
endif
elseif sub=="cr" then
if argument3=="std" then
set CHOICE_REJIME=argument3
elseif argument4=="rand" then
set CHOICE_REJIME=argument4
endif
elseif sub=="tc" then
if argument5=="false" then
set UNIT_TYPES_CHANGE=mS2B(argument5)
elseif argument4=="true" then
set UNIT_TYPES_CHANGE=mS2B(argument4)
endif
elseif sub=="rl" then
if argument5=="false" then
set RACE_LIMIT=mS2B(argument5)
elseif argument4=="true" then
set RACE_LIMIT=mS2B(argument4)
endif
endif
call StartGameLib__DisplaySettings()
endfunction
function StartGameLib__StartGame takes nothing returns nothing
local integer index=0
local integer num=0
local integer i=0
local real x
local real y
call DisableTrigger(sgl_settingsTrigger)
call DisableTrigger(sgl_startGameTrigger)
call DisableTrigger(sgl_setSettingsTrigger)
call ClearTextMessages()
set index=0
call Income_trig()
loop
exitwhen index>5
call PlayerAddGold(Player(index),INIT_GOLD_COUNT)
if REJIME=="teams" then
call SetForceAllianceStateBJ(udg_PlayerGroup[1],udg_PlayerGroup[1],bj_ALLIANCE_ALLIED_VISION)
call SetForceAllianceStateBJ(udg_PlayerGroup[2],udg_PlayerGroup[2],bj_ALLIANCE_ALLIED_VISION)
endif
set index=index+1
endloop
if BANNED_RACES!=0 or BANNED_TALANTS!=0 then
if BANNED_TALANTS>0 then
call MessageToAll(SetTextColor("Подсказка:","hint")+" Теперь "+bj_ChoicePlayer+" должен забанить "+I2S(BANNED_TALANTS)+" талантов.")
set x=GetUnitX(udg_TalantPicker[GetPlayerId(bj_PlayerChoice)+1])
set y=GetUnitY(udg_TalantPicker[GetPlayerId(bj_PlayerChoice)+1])
call RemoveUnit(udg_TalantPicker[GetPlayerId(bj_PlayerChoice)+1])
set bj_lastCreatedUnit=CreateUnit(bj_PlayerChoice,'h01S',x,y,bj_UNIT_FACING)
call SelectUnitForPlayerSingle(bj_lastCreatedUnit,bj_PlayerChoice)
elseif BANNED_RACES>0 then
call MessageToAll(SetTextColor("Подсказка:","hint")+" Теперь "+bj_ChoicePlayer+" должен забанить "+I2S(BANNED_RACES)+" рас.")
set x=GetUnitX(udg_TalantPicker[GetPlayerId(bj_PlayerChoice)+1])
set y=GetUnitY(udg_TalantPicker[GetPlayerId(bj_PlayerChoice)+1])
call RemoveUnit(udg_TalantPicker[GetPlayerId(bj_PlayerChoice)+1])
set bj_lastCreatedUnit=CreateUnit(bj_PlayerChoice,'h03N',x,y,bj_UNIT_FACING)
call SelectUnitForPlayerSingle(bj_lastCreatedUnit,bj_PlayerChoice)
endif
else
call UnpauseAllUnits()
if CHOICE_REJIME=="rand" then
set i=0
loop
exitwhen i>5
if isPlayerActive(Player(i))then
set num=GetRandomTalant()
call SetPlayerTechResearched(Player(i),num,1)
call Talants_Give(udg_TalantPicker[i+1],num)
set num=GetRandomRace()
call Race_Give(udg_TalantPicker[i+1],num)
endif
set i=i+1
endloop
endif
endif
endfunction
function StartGameLib__startGameTrigger takes nothing returns nothing
set bj_ChoicePlayer=StartGameLib__ChoicePlayer()
call PauseAllUnits()
call TriggerRegisterTimerEventSingle(sgl_settingsTrigger,0.01)
call TriggerAddAction(sgl_settingsTrigger,function StartGameLib__DisplaySettings)
call TriggerRegisterPlayerChatEvent(sgl_startGameTrigger,bj_PlayerChoice,"-start",true)
call TriggerAddAction(sgl_startGameTrigger,function StartGameLib__StartGame)
call TriggerRegisterPlayerChatEvent(sgl_setSettingsTrigger,bj_PlayerChoice,"-",false)
call TriggerAddAction(sgl_setSettingsTrigger,function StartGameLib__InputSettings)
endfunction
function InitGlobals takes nothing returns nothing
local integer i=0
set i=0
loop
exitwhen(i>8)
set udg_SpawnTime[i]=10.00
set i=i+1
endloop
set i=0
loop
exitwhen(i>8)
set udg_Castle[i]=null
set i=i+1
endloop
set i=0
loop
exitwhen(i>8)
set udg_UnitSpawnTrigg[i]=CreateTrigger()
set i=i+1
endloop
set i=0
loop
exitwhen(i>8)
set udg_HeroResTime[i]=60.00
set i=i+1
endloop
set i=0
loop
exitwhen(i>8)
set udg_KillBonus[i]=0
set i=i+1
endloop
set udg_DIALOG=DialogCreate()
set i=0
loop
exitwhen(i>2)
set udg_PlayerGroup[i]=CreateForce()
set i=i+1
endloop
set udg_PlayerNum=0
set i=0
loop
exitwhen(i>8)
set udg_BossDamage[i]=0
set i=i+1
endloop
set udg_Round=1
set udg_Timer=CreateTimer()
set udg_PvE_Timer=CreateTimer()
set i=0
loop
exitwhen(i>10)
set udg_BuilderPower[i]=0
set i=i+1
endloop
set udg_TimeSecond=0
set udg_TimeMinute=0
set udg_TimeHours=0
set i=0
loop
exitwhen(i>8)
set udg_Bandos[i]=0
set i=i+1
endloop
set i=0
loop
exitwhen(i>8)
set udg_Necronomicon[i]=0
set i=i+1
endloop
set i=0
loop
exitwhen(i>8)
set udg_Dalbaeb[i]=0
set i=i+1
endloop
set udg_MultiBoard=CreateMultiboard()
set udg_VlastDyxov=0
set udg_TimeMiniSecond=0
set udg_HeroCount=0
endfunction
function InitSounds takes nothing returns nothing
set gg_snd_HumanCallToArmsWhat1=CreateSound("Abilities\\Spells\\Human\\CallToArms\\HumanCallToArmsWhat1.wav",false,true,true,10,10,"SpellsEAX")
call SetSoundParamsFromLabel(gg_snd_HumanCallToArmsWhat1,"TownHallCallToArms")
call SetSoundDuration(gg_snd_HumanCallToArmsWhat1,3971)
endfunction
function CreateBuildingsForPlayer0 takes nothing returns nothing
local player p=Player(0)
local unit u
local integer unitID
local trigger t
local real life
set u=CreateUnit(p,'h004',-3008.0,1856.0,270.000)
set u=CreateUnit(p,'h004',-2112.0,2752.0,270.000)
set u=CreateUnit(p,'h004',-3008.0,2752.0,270.000)
set gg_unit_h001_0017=CreateUnit(p,'h001',-2560.0,2304.0,270.000)
set u=CreateUnit(p,'h006',-2304.0,2048.0,270.000)
set u=CreateUnit(p,'n000',-2688.0,2688.0,270.000)
set u=CreateUnit(p,'n021',-2816.0,2560.0,270.000)
set u=CreateUnit(p,'n001',-2944.0,2432.0,270.000)
call SetUnitColor(u,ConvertPlayerColor(0))
set gg_unit_h02V_0065=CreateUnit(p,'h02V',-2368.0,2112.0,270.000)
endfunction
function CreateBuildingsForPlayer1 takes nothing returns nothing
local player p=Player(1)
local unit u
local integer unitID
local trigger t
local real life
set u=CreateUnit(p,'h004',-3008.0,192.0,270.000)
set gg_unit_h001_0018=CreateUnit(p,'h001',-2560.0,-256.0,270.000)
set u=CreateUnit(p,'h004',-3008.0,-704.0,270.000)
set u=CreateUnit(p,'h004',-2112.0,192.0,270.000)
set u=CreateUnit(p,'h004',-2112.0,-704.0,270.000)
set u=CreateUnit(p,'h006',-2176.0,-256.0,270.000)
set u=CreateUnit(p,'n000',-2944.0,-128.0,270.000)
set u=CreateUnit(p,'n001',-2944.0,-384.0,270.000)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=CreateUnit(p,'n021',-2944.0,-256.0,270.000)
set gg_unit_h02V_0066=CreateUnit(p,'h02V',-2240.0,-256.0,270.000)
endfunction
function CreateBuildingsForPlayer2 takes nothing returns nothing
local player p=Player(2)
local unit u
local integer unitID
local trigger t
local real life
set u=CreateUnit(p,'h004',-3008.0,-2368.0,270.000)
set u=CreateUnit(p,'h004',-3008.0,-3264.0,270.000)
set u=CreateUnit(p,'h004',-2112.0,-3264.0,270.000)
set gg_unit_h001_0019=CreateUnit(p,'h001',-2560.0,-2816.0,270.000)
set u=CreateUnit(p,'h006',-2304.0,-2560.0,270.000)
set u=CreateUnit(p,'n000',-2944.0,-2944.0,270.000)
set u=CreateUnit(p,'n001',-2688.0,-3200.0,270.000)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=CreateUnit(p,'n021',-2816.0,-3072.0,270.000)
set gg_unit_h02V_0072=CreateUnit(p,'h02V',-2368.0,-2624.0,270.000)
endfunction
function CreateBuildingsForPlayer3 takes nothing returns nothing
local player p=Player(3)
local unit u
local integer unitID
local trigger t
local real life
set gg_unit_h001_0020=CreateUnit(p,'h001',2560.0,2304.0,270.000)
set u=CreateUnit(p,'n000',2944.0,2432.0,270.000)
set u=CreateUnit(p,'n021',2816.0,2560.0,270.000)
set u=CreateUnit(p,'n001',2688.0,2688.0,270.000)
call SetUnitColor(u,ConvertPlayerColor(0))
set u=CreateUnit(p,'h006',2304.0,2048.0,270.000)
set u=CreateUnit(p,'h004',3008.0,2752.0,270.000)
set u=CreateUnit(p,'h004',2112.0,2752.0,270.000)
set u=CreateUnit(p,'h004',3008.0,1856.0,270.000)
set gg_unit_h02V_0074=CreateUnit(p,'h02V',2368.0,2112.0,270.000)
endfunction
function CreateBuildingsForPlayer4 takes nothing returns nothing
local player p=Player(4)
local unit u
local integer unitID
local trigger t
local real life
set u=CreateUnit(p,'h004',3008.0,-704.0,270.000)
set u=CreateUnit(p,'n021',2944.0,-256.0,270.000)
set gg_unit_h001_0041=CreateUnit(p,'h001',2560.0,-256.0,270.000)
set u=CreateUnit(p,'h004',2112.0,192.0,270.000)
set u=CreateUnit(p,'h004',2112.0,-704.0,270.000)
set u=CreateUnit(p,'h004',3008.0,192.0,270.000)
set u=CreateUnit(p,'h006',2176.0,-256.0,270.000)
set u=CreateUnit(p,'n000',2944.0,-384.0,270.000)
set u=CreateUnit(p,'n001',2944.0,-128.0,270.000)
call SetUnitColor(u,ConvertPlayerColor(0))
set gg_unit_h02V_0075=CreateUnit(p,'h02V',2240.0,-256.0,270.000)
endfunction
function CreateBuildingsForPlayer5 takes nothing returns nothing
local player p=Player(5)
local unit u
local integer unitID
local trigger t
local real life
set u=CreateUnit(p,'n021',2816.0,-3072.0,270.000)
set u=CreateUnit(p,'h004',3008.0,-2368.0,270.000)
set gg_unit_h001_0056=CreateUnit(p,'h001',2560.0,-2816.0,270.000)
set u=CreateUnit(p,'h006',2304.0,-2560.0,270.000)
set u=CreateUnit(p,'h004',2112.0,-3264.0,270.000)
set u=CreateUnit(p,'h004',3008.0,-3264.0,270.000)
set u=CreateUnit(p,'n000',2688.0,-3200.0,270.000)
set u=CreateUnit(p,'n001',2944.0,-2944.0,270.000)
call SetUnitColor(u,ConvertPlayerColor(0))
set gg_unit_h02V_0073=CreateUnit(p,'h02V',2368.0,-2624.0,270.000)
endfunction
function CreateBuildingsForPlayer11 takes nothing returns nothing
local player p=Player(11)
local unit u
local integer unitID
local trigger t
local real life
set u=CreateUnit(p,'n01D',-1088.0,192.0,270.000)
set u=CreateUnit(p,'n01D',-448.0,832.0,270.000)
set u=CreateUnit(p,'n01D',448.0,832.0,270.000)
set u=CreateUnit(p,'n01D',1088.0,192.0,270.000)
set u=CreateUnit(p,'n01D',1088.0,-704.0,270.000)
set u=CreateUnit(p,'n01D',448.0,-1344.0,270.000)
set u=CreateUnit(p,'n01D',-448.0,-1344.0,270.000)
set u=CreateUnit(p,'n01D',-1088.0,-704.0,270.000)
endfunction
function CreateNeutralPassiveBuildings takes nothing returns nothing
local player p=Player(PLAYER_NEUTRAL_PASSIVE)
local unit u
local integer unitID
local trigger t
local real life
set u=CreateUnit(p,'nfoh',0.0,-256.0,270.000)
set gg_unit_n01K_0012=CreateUnit(p,'n01K',0.0,-2816.0,270.000)
set gg_unit_n01K_0013=CreateUnit(p,'n01K',0.0,2304.0,270.000)
endfunction
function CreateNeutralPassive takes nothing returns nothing
local player p=Player(PLAYER_NEUTRAL_PASSIVE)
local unit u
local integer unitID
local trigger t
local real life
set u=CreateUnit(p,'n01L',-431.6,-260.7,0.000)
call SetUnitColor(u,ConvertPlayerColor(4))
set u=CreateUnit(p,'n01M',436.5,-259.1,180.000)
call SetUnitColor(u,ConvertPlayerColor(4))
endfunction
function CreatePlayerBuildings takes nothing returns nothing
call CreateBuildingsForPlayer0()
call CreateBuildingsForPlayer1()
call CreateBuildingsForPlayer2()
call CreateBuildingsForPlayer3()
call CreateBuildingsForPlayer4()
call CreateBuildingsForPlayer5()
call CreateBuildingsForPlayer11()
endfunction
function CreatePlayerUnits takes nothing returns nothing
endfunction
function CreateAllUnits takes nothing returns nothing
call CreateNeutralPassiveBuildings()
call CreatePlayerBuildings()
call CreateNeutralPassive()
call CreatePlayerUnits()
endfunction
function CreateRegions takes nothing returns nothing
local weathereffect we
set gg_rct_Blue=Rect(-3264.0,-1536.0,-1312.0,1056.0)
set gg_rct_Orange=Rect(1280.0,-3552.0,3264.0,-1536.0)
set gg_rct_LightGreen=Rect(-3264.0,-3552.0,-1280.0,-1536.0)
set gg_rct_Yellow=Rect(1312.0,-1536.0,3264.0,1056.0)
set gg_rct_MID=Rect(-1312.0,-1568.0,1312.0,1088.0)
set gg_rct_Red=Rect(-3264.0,1056.0,-1280.0,3040.0)
set gg_rct_Purple=Rect(1280.0,1056.0,3264.0,3040.0)
set gg_rct_PvE=Rect(-800.0,-1024.0,768.0,544.0)
set gg_rct________________010=Rect(-768.0,-576.0,-544.0,64.0)
set gg_rct________________011=Rect(416.0,-608.0,736.0,-32.0)
set gg_rct_CreepsUp=Rect(-480.0,1824.0,480.0,2784.0)
set gg_rct_CreepsDown=Rect(-480.0,-3296.0,480.0,-2336.0)
set gg_rct_UpMiniTower1=Rect(192.0,2496.0,320.0,2624.0)
set gg_rct_UpMiniTower4=Rect(192.0,1984.0,320.0,2112.0)
set gg_rct_UpMiniTower3=Rect(-320.0,1984.0,-192.0,2112.0)
set gg_rct_UpMiniTower2=Rect(-320.0,2496.0,-192.0,2624.0)
set gg_rct_DownMiniTower1=Rect(192.0,-2624.0,320.0,-2496.0)
set gg_rct_DownMiniTower2=Rect(-320.0,-2624.0,-192.0,-2496.0)
set gg_rct_DownMiniTower3=Rect(-320.0,-3136.0,-192.0,-3008.0)
set gg_rct_DownMiniTower4=Rect(192.0,-3136.0,320.0,-3008.0)
endfunction
function ItemCheck takes unit caster,integer item_id returns integer
local integer num=0
local integer i=0
local item Item
loop
exitwhen i>5
set Item=UnitItemInSlot(caster,i)
if(GetItemTypeId(Item)==item_id)then
set num=num+1
endif
set i=i+1
endloop
set Item=null
return num
endfunction
function GetItemCooldown takes integer item_id returns real
local real array item_cooldown
local integer array items
local integer i=1
local integer min
local integer max
set items[1]='I024'
set item_cooldown[1]=25.00
set min=1
set max=1
loop
exitwhen i>max
if(item_id==items[i])then
return item_cooldown[i]
endif
set i=i+1
endloop
return 0.00
endfunction
function ItemCooldown takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer timer_id=GetHandleId(t)
local integer item_id=LoadInteger(udg_Hash,timer_id,StringHash("ItemCooldown|ItemId"))
local unit caster=LoadUnitHandle(udg_Hash,timer_id,StringHash("ItemCooldown|Caster"))
local item Item
local integer id=0
local real cooldown=0
local integer p=0
local real time=0
local integer index=LoadInteger(udg_Hash,timer_id,StringHash("ItemCooldown|Index"))
local boolean destr=false
local boolean tick_tack=false
local timer p_t
local integer p_index=0
local integer p_timer_id=0
local real p_time=0
local integer num=0
local integer i=0
local integer w=0
local timer c_t
local real q=0
local item ITEM
loop
exitwhen i>5
set ITEM=UnitItemInSlot(caster,i)
if(GetItemTypeId(ITEM)==item_id and GetItemCharges(ITEM)==0)then
set index=index+1
call SaveItemHandle(udg_Hash,timer_id,StringHash("ItemCooldown|Item")+index,ITEM)
call SaveInteger(udg_Hash,timer_id,StringHash("ItemCooldown|Index"),index)
endif
set i=i+1
endloop
set w=StringHash("ItemCooldown|Item")+1
set i=StringHash("ItemCooldown|Item")+index
loop
exitwhen w>i
set Item=LoadItemHandle(udg_Hash,timer_id,w)
set id=GetHandleId(Item)
if(id!=0)then
set cooldown=LoadReal(udg_Hash,id,StringHash("ItemCooldown|Cooldown"))
set p=LoadInteger(udg_Hash,id,StringHash("ItemCooldown|Player"))
set time=LoadReal(udg_Hash,item_id,StringHash("ItemCooldown|Time")+p)
set num=GetPlayerId(GetItemPlayer(Item))+1
set c_t=LoadTimerHandle(udg_Hash,id,StringHash("ItemCooldown|Timer"))
if(cooldown==0)then
set cooldown=GetItemCooldown(item_id)
call SaveReal(udg_Hash,id,StringHash("ItemCooldown|Cooldown"),cooldown)
endif
if(p==0)then
set p=num
call SaveInteger(udg_Hash,id,StringHash("ItemCooldown|Player"),p)
set time=LoadReal(udg_Hash,item_id,StringHash("ItemCooldown|Time")+p)
endif
if(p!=num)then
call SaveItemHandle(udg_Hash,timer_id,w,null)
set p_t=LoadTimerHandle(udg_Hash,id,StringHash("ItemCooldown|Timer"))
if(p_t==null)then
set p_t=CreateTimer()
set p_timer_id=GetHandleId(p_t)
set p_index=LoadInteger(udg_Hash,p_timer_id,StringHash("ItemCooldown|Index"))+1
call SaveUnitHandle(udg_Hash,p_timer_id,StringHash("ItemCooldown|Caster"),udg_Hero[num])
call SaveInteger(udg_Hash,p_timer_id,StringHash("ItemCooldown|ItemId"),item_id)
call SaveItemHandle(udg_Hash,p_timer_id,StringHash("ItemCooldown|Item")+p_index,Item)
call SaveInteger(udg_Hash,p_timer_id,StringHash("ItemCooldown|Index"),p_index)
call SaveInteger(udg_Hash,id,StringHash("ItemCooldown|Player"),num)
call SaveReal(udg_Hash,id,StringHash("ItemCooldown|Cooldown"),cooldown)
call SaveTimerHandle(udg_Hash,id,StringHash("ItemCooldown|Timer"),p_t)
set p_time=cooldown
call SaveReal(udg_Hash,item_id,StringHash("ItemCooldown|Time")+num,p_time)
call TimerStart(p_t,0.05,true,function ItemCooldown)
else
call BJDebugMsg("Иначе")
set p_timer_id=GetHandleId(p_t)
set p_index=LoadInteger(udg_Hash,p_timer_id,StringHash("ItemCooldown|Index"))+1
call SaveItemHandle(udg_Hash,p_timer_id,StringHash("ItemCooldown|Item")+p_index,Item)
call SaveInteger(udg_Hash,p_timer_id,StringHash("ItemCooldown|Index"),p_index)
call SaveInteger(udg_Hash,id,StringHash("ItemCooldown|Player"),num)
set p_time=LoadReal(udg_Hash,item_id,StringHash("ItemCooldown|Time")+num)
endif
call SetItemCharges(Item,R2I(p_time))
else
if(time>0.05)then
if(time<1.00)then
call SetItemCharges(Item,1)
else
call SetItemCharges(Item,R2I(time))
endif
set tick_tack=true
else
call SetItemCharges(Item,0)
set destr=true
endif
endif
endif
set w=w+1
endloop
if(tick_tack==true)then
set time=time-0.05
call SaveReal(udg_Hash,item_id,StringHash("ItemCooldown|Time")+p,time)
endif
if(destr==true)then
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call FlushChildHashtable(udg_Hash,item_id)
call FlushChildHashtable(udg_Hash,timer_id)
endif
set t=null
set c_t=null
set p_t=null
set ITEM=null
set Item=null
set caster=null
endfunction
function ItemCooldown_timer takes unit caster,item Item,real time returns nothing
local timer t=CreateTimer()
local integer num=GetPlayerId(GetItemPlayer(Item))+1
local integer item_id=GetItemTypeId(Item)
local integer timer_id=GetHandleId(t)
local integer id=GetHandleId(Item)
local integer index=1
call SaveUnitHandle(udg_Hash,timer_id,StringHash("ItemCooldown|Caster"),caster)
call SaveInteger(udg_Hash,timer_id,StringHash("ItemCooldown|ItemId"),item_id)
call SaveItemHandle(udg_Hash,timer_id,StringHash("ItemCooldown|Item")+index,Item)
call SaveInteger(udg_Hash,timer_id,StringHash("ItemCooldown|Index"),index)
call SaveTimerHandle(udg_Hash,id,StringHash("ItemCooldown|Timer"),t)
call SaveInteger(udg_Hash,id,StringHash("ItemCooldown|Player"),num)
call SaveReal(udg_Hash,id,StringHash("ItemCooldown|Cooldown"),time)
call SaveReal(udg_Hash,item_id,StringHash("ItemCooldown|Time")+num,time)
call SetItemCharges(Item,R2I(time))
call TimerStart(t,0.05,true,function ItemCooldown)
set t=null
set Item=null
set caster=null
endfunction
function HandleCounter_Update takes nothing returns nothing
local integer i=0
local integer id
local location array P
local real result=0
loop
exitwhen i>=50
set i=i+1
set P[i]=Location(0,0)
set id=GetHandleId(P[i])
set result=result+(id-0x100000)
endloop
set result=result/ i-i/ 2
loop
call RemoveLocation(P[i])
set P[i]=null
exitwhen i<=1
set i=i-1
endloop
call LeaderboardSetItemValue(udg_HandleBoard,0,R2I(result))
endfunction
function HandleCounter_Actions takes nothing returns nothing
set udg_HandleBoard=CreateLeaderboard()
call LeaderboardSetLabel(udg_HandleBoard,"Handle Counter")
call PlayerSetLeaderboard(GetLocalPlayer(),udg_HandleBoard)
call LeaderboardDisplay(udg_HandleBoard,true)
call LeaderboardAddItem(udg_HandleBoard,"Handles",0,Player(0))
call LeaderboardSetSizeByItemCount(udg_HandleBoard,1)
call HandleCounter_Update()
call TimerStart(GetExpiredTimer(),0.05,true,function HandleCounter_Update)
endfunction
function InitTrig_HandleCounter takes nothing returns nothing
call TimerStart(CreateTimer(),0,false,function HandleCounter_Actions)
endfunction
function AddPlayerState takes player p,playerstate first_res,playerstate sec_res,integer res returns nothing
call SetPlayerState(p,first_res,GetPlayerState(p,sec_res)+res)
endfunction
function Timer_Text takes unit target,real time returns texttag
local string s
set s=R2SW(time,0,1)
set bj_lastCreatedTextTag=CreateTextTag()
call SetTextTagText(bj_lastCreatedTextTag,s,(12*0.023)/ 10)
call SetTextTagPosUnit(bj_lastCreatedTextTag,target,0)
call SetTextTagColor(bj_lastCreatedTextTag,51,255,51,0)
call SetTextTagPermanent(bj_lastCreatedTextTag,true)
call SetTextTagFadepoint(bj_lastCreatedTextTag,0)
return bj_lastCreatedTextTag
endfunction
function Angle takes real x1,real y1,real x2,real y2 returns real
return bj_RADTODEG*Atan2(y2-y1,x2-x1)
endfunction
function GodArmor_Actions takes unit caster returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A007')
local effect eff
local real time=4.00+(2*lvl)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\Voodoo\\VoodooAuraTarget.mdl",caster,"overhead")
call UnitAddAbility(caster,'A008')
call TriggerSleepAction(time)
call UnitRemoveAbility(caster,'A008')
call DestroyEffect(eff)
set eff=null
set caster=null
endfunction
function AltarCreate_Actions takes unit caster,real x,real y returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A08Y')
local unit dami
local real time=20.00*lvl
set dami=CreateUnit(GetOwningPlayer(caster),'u01D',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(dami,'BTLF',time)
set dami=null
set caster=null
endfunction
function ManaExp_Filter takes nothing returns boolean
return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))==true and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0
endfunction
function ManaExp_Actions takes unit caster returns nothing
local boolexpr filter=Condition(function ManaExp_Filter)
local integer lvl=GetUnitAbilityLevel(caster,'A00L')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local integer array sumtype
local unit target
local unit dummy
local effect eff
local real dmg=35.00*lvl
local real range=500.00
set sumtype[1]='h00C'
set sumtype[2]='h00F'
set sumtype[3]='h00G'
set sumtype[4]='h00E'
set sumtype[5]='h00D'
set bj_caster=caster
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl",target,"origin")
call DestroyEffect(eff)
call MagDamage(caster,target,dmg)
if GetUnitHealth(target)<=0.00 then
set dummy=CreateUnit(GetOwningPlayer(caster),sumtype[GetRandomInt(1,5)],GetUnitX(target),GetUnitY(target),bj_UNIT_FACING)
call UnitApplyTimedLife(dummy,'BTLF',60)
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set dummy=null
set caster=null
set target=null
set filter=null
endfunction
function GreatSummon_Actions takes unit caster returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A00M')
local player p=GetOwningPlayer(caster)
local integer array sumtype
local real r=360/ lvl
local integer q=1
local integer i
local unit dami
local real x
local real y
set sumtype[1]='h00C'
set sumtype[2]='h00F'
set sumtype[3]='h00G'
set sumtype[4]='h00E'
set sumtype[5]='h00D'
if isPlayerHasSoloHero(Owner(caster))then
set lvl=lvl+4
set r=360/ lvl
endif
loop
exitwhen q>lvl
set x=GetUnitX(caster)+200.00*Cos((r*q)*bj_DEGTORAD)
set y=GetUnitY(caster)+200.00*Sin((r*q)*bj_DEGTORAD)
set i=sumtype[GetRandomInt(1,5)]
set dami=CreateUnit(p,i,x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(dami,'BTLF',60)
set q=q+1
endloop
set p=null
set dami=null
set caster=null
endfunction
function MagicDospex_Actions takes unit caster returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A00N')
local effect eff
local real time=20.00
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdl",caster,"chest")
call UnitAddAbility(caster,'A00P')
call SetUnitAbilityLevel(caster,'A00Q',lvl)
call SetUnitAbilityLevel(caster,'A00O',lvl)
call TriggerSleepAction(time)
call UnitRemoveAbility(caster,'A00P')
call DestroyEffect(eff)
set eff=null
set caster=null
endfunction
function DalaranPortal_Actions takes unit caster returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A00A')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer array units
local integer i=1
local unit portal
local integer id
local effect eff
local unit dami
local real x1
local real y1
local real time=20.00*lvl
local real periodic=2.00
local real lifetime=45.00
set units[1]='h00C'
set units[2]='h00F'
set units[3]='h00G'
set units[4]='h00E'
set units[5]='h00D'
set x1=x+250.00*Cos((GetUnitFacing(caster)+180)*bj_DEGTORAD)
set y1=y+250.00*Sin((GetUnitFacing(caster)+180)*bj_DEGTORAD)
set portal=CreateUnit(GetOwningPlayer(caster),'hprt',x1,y1,GetUnitFacing(caster))
call SetUnitTimeScale(portal,1.50)
call SetUnitAnimation(portal,"birth")
set x=GetUnitX(portal)
set y=GetUnitY(portal)
call TriggerSleepAction(5.00)
loop
exitwhen i>R2I(time/ periodic)
if GetWidgetLife(portal)<=0.405 then
set i=10000
endif
set id=GetRandomInt(1,5)
set dami=CreateUnit(GetOwningPlayer(caster),units[id],x,y,270)
call UnitApplyTimedLife(dami,'BTLF',lifetime)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",dami,"origin")
call DestroyEffect(eff)
call TriggerSleepAction(periodic)
set i=i+1
endloop
call KillUnit(portal)
set eff=null
set dami=null
set portal=null
set caster=null
endfunction
function Korsars_Actions takes unit caster returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A01H')+1
local real r=360/ lvl
local integer q=1
local unit dummy
local real x
local real y
if(GetPlayerTechCount(GetOwningPlayer(caster),'R02A',true)>0)then
set lvl=lvl+2
set r=360/ lvl
endif
loop
exitwhen q>lvl
set x=GetUnitX(caster)+200.00*Cos((r*q)*bj_DEGTORAD)
set y=GetUnitY(caster)+200.00*Sin((r*q)*bj_DEGTORAD)
set dummy=CreateUnit(GetOwningPlayer(caster),'h00M',x,y,bj_UNIT_FACING)
call SetUnitState(dummy,UNIT_STATE_MANA,GetUnitState(dummy,UNIT_STATE_MAX_MANA))
set q=q+1
endloop
set dummy=null
set caster=null
endfunction
function GnevMorey_Actions takes unit caster returns nothing
local integer i=1
local real x
local real y
loop
exitwhen i>12
set x=GetUnitX(caster)+300.00*Cos((30*i)*bj_DEGTORAD)
set y=GetUnitY(caster)+300.00*Sin((30*i)*bj_DEGTORAD)
set bj_lastCreatedEffect=AddSpecialEffect("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl",x,y)
call DestroyEffect(bj_lastCreatedEffect)
set i=i+1
endloop
set caster=null
endfunction
function SheepKaptain_Actions takes unit caster returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A0DV')
local real angle=GetUnitFacing(caster)+180
local real targetx=GetSpellTargetX()
local real targety=GetSpellTargetY()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local unit dami
local real x1
local real y1
local real time=30.00
set x1=x+200*Cos(angle*bj_DEGTORAD)
set y1=y+200*Sin(angle*bj_DEGTORAD)
set dami=CreateUnit(GetOwningPlayer(caster),'h02M',x1,y1,angle-180)
call SetUnitVertexColor(dami,255,255,255,100)
call UnitApplyTimedLife(dami,'BTLF',time)
call IssuePointOrder(dami,"attackground",targetx,targety)
call SaveInteger(udg_Hash,GetHandleId(dami),StringHash("Praudmur|SheepCaptain|LVL"),lvl)
call SaveReal(udg_Hash,GetHandleId(dami),StringHash("Praudmur|SheepCaptain|DMG"),0)
set eff=AddSpecialEffect("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl",x,y)
call DestroyEffect(eff)
set eff=null
set dami=null
set caster=null
endfunction
function InitTrig_APIBasicUtils takes nothing returns nothing
endfunction
function InitTrig_APITypecast takes nothing returns nothing
endfunction
function InitTrig_APIMemory takes nothing returns nothing
endfunction
function InitTrig_APIMemoryCalls takes nothing returns nothing
endfunction
function InitTrig_APIMemoryBitwise takes nothing returns nothing
endfunction
function InitTrig_APIMemoryString takes nothing returns nothing
endfunction
function InitTrig_APIMemoryKernel takes nothing returns nothing
endfunction
function InitTrig_APIMemoryRestorer takes nothing returns nothing
endfunction
function InitTrig_APIMemoryStormDLL takes nothing returns nothing
endfunction
function InitTrig_APIMemoryMPQ takes nothing returns nothing
endfunction
function InitTrig_APIMemoryFrameData takes nothing returns nothing
endfunction
function InitTrig_APIMemoryGameData takes nothing returns nothing
endfunction
function InitTrig_APIMemoryGameUI takes nothing returns nothing
endfunction
function InitTrig_APIMemoryGameUIButton takes nothing returns nothing
endfunction
function InitTrig_APIMemoryGameWindow takes nothing returns nothing
endfunction
function InitTrig_APIMemoryUtilityLibraryAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackConstantsAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCLayerAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCLayoutFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCBackDropFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCEditBoxAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCModelFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleButtonAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleFontAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleGlueAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleConsoleAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSpriteFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleMessageFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSliderAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCTextAreaAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCTextFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleStatusBarAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCStatusBarAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleTextureAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSimpleRegionAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackFrameAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackUIAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSpriteBaseAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSpriteMiniAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCSpriteUberAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCObjectAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackPlayerAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackAbilityAddressAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackAbilityBaseAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackAbilityNormalAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackAbilityUnitAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackCastAbility takes nothing returns nothing
endfunction
function InitTrig_MemHackWidgetBaseAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackWidgetNormalAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackEffectAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackTrackableAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackItemBaseAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackItemNormalAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackUnitBaseAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackUnitNormalAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackGroupAPI takes nothing returns nothing
endfunction
function InitTrig_MemHackMouseAPI takes nothing returns nothing
endfunction
function Init_MemoryHack takes nothing returns nothing
if PatchVersion!="" then
call Init_APITypecast()
call Init_APIMemory()
call Init_APIMemoryCalls()
call Init_APIMemoryBitwise()
call Init_APIMemoryKernel()
call Init_APIMemoryMPQ()
call Init_APIMemoryString()
call Init_APIMemoryStormDLL()
call Init_APIMemoryFrameData()
call Init_APIMemoryGameData()
call Init_APIMemoryObjectData()
call Init_APIMemoryGameUI()
call Init_APIMemoryGameUIButton()
call Init_APIMemoryGameWindow()
call Init_MemHackConstantsAPI()
call Init_MemHackCFrameAPI()
call Init_MemHackCLayerAPI()
call Init_MemHackCBackDropFrameAPI()
call Init_MemHackCEditBoxAPI()
call Init_MemHackCLayoutFrameAPI()
call Init_MemHackCModelFrameAPI()
call Init_MemHackCSimpleButtonAPI()
call Init_MemHackCSimpleFontAPI()
call Init_MemHackCSimpleGlueAPI()
call Init_MemHackCSimpleFrameAPI()
call Init_MemHackCSimpleConsoleAPI()
call Init_MemHackCSimpleMessageFrameAPI()
call Init_MemHackCSliderAPI()
call Init_MemHackCSpriteFrameAPI()
call Init_MemHackCTextAreaAPI()
call Init_MemHackCTextFrameAPI()
call Init_MemHackCSimpleStatusBarAPI()
call Init_MemHackCStatusBarAPI()
call Init_MemHackCSimpleTextureAPI()
call Init_MemHackCSimpleRegionAPI()
call Init_MemHackFrameAPI()
call Init_MemHackUIAPI()
call Init_MemHackPlayerAPI()
call Init_MemHackAbilityAddressAPI()
call Init_MemHackAbilityBaseAPI()
call Init_MemHackAbilityNormalAPI()
call Init_MemHackAbilityUnitAPI()
call Init_MemHackCWidgetBaseAPI()
call Init_MemHackCWidgetNormalAPI()
call Init_MemHackItemBaseAPI()
call Init_MemHackItemNormalAPI()
call Init_MemHackUnitBaseAPI()
call Init_MemHackUnitNormalAPI()
call Init_MemHackGroupAPI()
call Init_MemHackCSpriteBaseAPI()
call Init_MemHackCSpriteMiniAPI()
call Init_MemHackCSpriteUberAPI()
call Init_MemHackEffectAPI()
call Init_MemHackTrackableAPI()
call Init_MemHackCastAbility()
call Init_MemHackMouseAPI()
call Init_APIMemoryRestorer()
call Init_MemHackDamageEventHook()
else
call DisplayTextToPlayer(GetLocalPlayer(),0,0,"Unsupported patch version!")
endif
call DestroyTimer(GetExpiredTimer())
endfunction
function InitTrig_InitMemoryHack takes nothing returns nothing
set bj_FORCE_PLAYER[0]=CreateForce()
call ForceAddPlayer(bj_FORCE_PLAYER[0],Player(0))
call ForForce(bj_FORCE_PLAYER[0],I2C(C2I(function UnlockMemory)+0x8))
call TimerStart(CreateTimer(),.05,false,function Init_MemoryHack)
endfunction
function InitTrig_MemHackDamageHook takes nothing returns nothing
endfunction
function BandaDodikov_Conditions takes nothing returns boolean
return GetResearched()=='R03R'
endfunction
function BandaDodikov_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local integer lvl=GetPlayerTechCount(p,'R03R',true)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer array naem
local integer i=1
local integer min
local integer max
local integer q
local integer count=5+(1*lvl)
set naem[1]='e005'
set naem[2]='h01J'
set naem[3]='h01K'
set naem[4]='h01I'
set naem[5]='o009'
set naem[6]='o008'
set naem[7]='u00P'
set naem[8]='u00Q'
set naem[9]='n00W'
set naem[10]='n00X'
set naem[11]='n00M'
set naem[12]='n01W'
set naem[13]='n016'
set naem[14]='n00Q'
set naem[15]='n00P'
set naem[16]='n017'
set naem[17]='n01V'
set naem[18]='n00O'
set naem[19]='n01X'
set naem[20]='n01Y'
set min=1
set max=20
loop
exitwhen i>count
set q=naem[GetRandomInt(min,max)]
call CreateUnit(p,q,x,y,GetRandomReal(0.00,360.00))
set i=i+1
endloop
set p=null
set caster=null
endfunction
function InitTrig_BandaDodikov takes nothing returns nothing
set gg_trg_BandaDodikov=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BandaDodikov,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_BandaDodikov,Condition(function BandaDodikov_Conditions))
call TriggerAddAction(gg_trg_BandaDodikov,function BandaDodikov_Actions)
endfunction
function Trig_SetupAchiv_Actions takes nothing returns nothing
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"Рабочая сила"," ","ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
call QuestSetCompleted(GetLastCreatedQuestBJ(),true)
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Нужно:|r Построить |cffffcc0010|r башен.")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Награда:|r Постройка башни приносит |cffffcc00100|r ед. золота.")
call QuestSetEnabledBJ(false,GetLastCreatedQuestBJ())
set udg_Achievement[1]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_UNDISCOVERED,"Рабочая сила"," ","ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
set udg_Fake_Achievement[1]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"Бандос"," ","ReplaceableTextures\\CommandButtons\\BTNBandit.blp")
call QuestSetCompleted(GetLastCreatedQuestBJ(),true)
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Нужно:|r Нанять наёмиков на |cffffcc00500|r ед. золота.")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Награда:|r Здоровье наёмников повышено на |cffffcc0020%|r.")
call QuestSetEnabledBJ(false,GetLastCreatedQuestBJ())
set udg_Achievement[2]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_UNDISCOVERED,"Бандос"," ","ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
set udg_Fake_Achievement[2]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"Приступная шайка"," ","ReplaceableTextures\\CommandButtons\\BTNFootman.blp")
call QuestSetCompleted(GetLastCreatedQuestBJ(),true)
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Нужно:|r Нанять наёмиков на |cffffcc001000|r ед. золота.")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Награда:|r Регенерация хп наёмников повышена на |cffffcc005|r ед.")
call QuestSetEnabledBJ(false,GetLastCreatedQuestBJ())
set udg_Achievement[3]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_UNDISCOVERED,"Приступная шайка"," ","ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
set udg_Fake_Achievement[3]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"Власть Проклятых"," ","ReplaceableTextures\\CommandButtons\\BTNNecromancer.blp")
call QuestSetCompleted(GetLastCreatedQuestBJ(),true)
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Нужно:|r Использовать некрономикон |cffffcc0025|r раз.")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Награда:|r Призываемые скелеты значительно усилены.")
call QuestSetEnabledBJ(false,GetLastCreatedQuestBJ())
set udg_Achievement[4]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_UNDISCOVERED,"Власть Проклятых"," ","ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
set udg_Fake_Achievement[4]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"Мощь Проклятых"," ","ReplaceableTextures\\CommandButtons\\BTNLichVersion2.blp")
call QuestSetCompleted(GetLastCreatedQuestBJ(),true)
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Нужно:|r Использовать некрономикон |cffffcc0050|r раз.")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Награда:|r Некрономикон призывает сразу |cffffcc002|r скелета.")
call QuestSetEnabledBJ(false,GetLastCreatedQuestBJ())
set udg_Achievement[5]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_UNDISCOVERED,"Мощь Проклятых"," ","ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
set udg_Fake_Achievement[5]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"Далбаёб"," ","ReplaceableTextures\\CommandButtons\\BTNTemp.blp")
call QuestSetCompleted(GetLastCreatedQuestBJ(),true)
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Нужно:|r Погибнуть героем |cffffcc0010|r раз.")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"|cffffcc90Награда:|r Смерть героя приносит |cffffcc0025|r ед. золота.")
call QuestSetEnabledBJ(false,GetLastCreatedQuestBJ())
set udg_Achievement[6]=GetLastCreatedQuestBJ()
call CreateQuestBJ(bj_QUESTTYPE_OPT_UNDISCOVERED,"Мощь Проклятых"," ","ReplaceableTextures\\CommandButtons\\BTNPeasant.blp")
set udg_Fake_Achievement[6]=GetLastCreatedQuestBJ()
endfunction
function InitTrig_SetupAchiv takes nothing returns nothing
set gg_trg_SetupAchiv=CreateTrigger()
call TriggerAddAction(gg_trg_SetupAchiv,function Trig_SetupAchiv_Actions)
endfunction
function BuilderPower_Conditions takes nothing returns boolean
if((GetUnitTypeId(GetConstructedStructure())=='h01P'))then
return true
endif
if((GetUnitTypeId(GetConstructedStructure())=='h00A'))then
return true
endif
if((GetUnitTypeId(GetConstructedStructure())=='h01E'))then
return true
endif
if((GetUnitTypeId(GetConstructedStructure())=='h003'))then
return true
endif
if((GetUnitTypeId(GetConstructedStructure())=='h00V'))then
return true
endif
if((GetUnitTypeId(GetConstructedStructure())=='n002'))then
return true
endif
return false
endfunction
function BuilderPower_Actions takes nothing returns nothing
local player pp=GetOwningPlayer(GetConstructedStructure())
local integer i=GetConvertedPlayerId(pp)
set udg_BuilderPower[i]=(udg_BuilderPower[i]+1)
if(GetPlayerTechCountSimple('R01Z',pp)==1)then
call AdjustPlayerStateBJ(100,pp,PLAYER_STATE_RESOURCE_GOLD)
if(GetLocalPlayer()==pp)then
call TextUp("+100",GetConstructedStructure(),10,0,255,0,0,96.00,2.00)
endif
endif
if(udg_BuilderPower[i]==10)then
if(GetPlayerTechCount(pp,'R01Z',true)==0)then
call AchievUnlocked(pp,1,'R01Z')
endif
else
endif
set pp=null
endfunction
function InitTrig_BuilderPower takes nothing returns nothing
set gg_trg_BuilderPower=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BuilderPower,EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
call TriggerAddCondition(gg_trg_BuilderPower,Condition(function BuilderPower_Conditions))
call TriggerAddAction(gg_trg_BuilderPower,function BuilderPower_Actions)
endfunction
function Bandos_Conditions takes nothing returns boolean
return UnitTag(GetTrainedUnit())=="mercenary"
endfunction
function Bandos_Actions takes nothing returns nothing
local player pp=GetOwningPlayer(GetTriggerUnit())
local integer i=GetConvertedPlayerId(pp)
set udg_Bandos[i]=(udg_Bandos[i]+GetUnitGoldCost(GetUnitTypeId(GetTrainedUnit())))
if(udg_Bandos[i]>=500)then
if(GetPlayerTechCount(pp,'R020',true)==0)then
call AchievUnlocked(pp,2,'R020')
endif
endif
if(udg_Bandos[i]>=1000)then
if(GetPlayerTechCount(pp,'R021',true)==0)then
call AchievUnlocked(pp,3,'R021')
endif
endif
set pp=null
endfunction
function InitTrig_Bandos takes nothing returns nothing
set gg_trg_Bandos=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Bandos,EVENT_PLAYER_UNIT_TRAIN_FINISH)
call TriggerAddCondition(gg_trg_Bandos,Condition(function Bandos_Conditions))
call TriggerAddAction(gg_trg_Bandos,function Bandos_Actions)
endfunction
function Trig_xp_Conditions takes nothing returns boolean
local integer id=GetPlayerId(GetTriggerPlayer())+1
return PLAYER_NAMES[id]=="loliconshik3" or PLAYER_NAMES[id]=="WorldEdit" or PLAYER_NAMES[id]=="sdlvt"
endfunction
function Trig_xp_Actions takes nothing returns nothing
call AddHeroXPSwapped(S2I(SubStringBJ(GetEventPlayerChatString(),7,11)),udg_Hero[S2I(SubStringBJ(GetEventPlayerChatString(),5,5))],false)
endfunction
function InitTrig_xp takes nothing returns nothing
set gg_trg_xp=CreateTrigger()
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(0),"-xp",false)
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(1),"-xp",false)
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(2),"-xp",false)
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(3),"-xp",false)
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(4),"-xp",false)
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(5),"-xp",false)
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(6),"-xp",false)
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(7),"-xp",false)
call TriggerRegisterPlayerChatEvent(gg_trg_xp,Player(11),"-xp",false)
call TriggerAddCondition(gg_trg_xp,Condition(function Trig_xp_Conditions))
call TriggerAddAction(gg_trg_xp,function Trig_xp_Actions)
endfunction
function Trig_Kick_Conditions takes nothing returns boolean
local integer id=GetPlayerId(GetTriggerPlayer())+1
return PLAYER_NAMES[id]=="loliconshik3" or PLAYER_NAMES[id]=="WorldEdit" or PLAYER_NAMES[id]=="sdlvt"
endfunction
function Trig_Kick_Actions takes nothing returns nothing
call CustomDefeatBJ(ConvertedPlayer(S2I(SubStringBJ(GetEventPlayerChatString(),7,8))),"Вы изгнаны!")
endfunction
function InitTrig_Kick takes nothing returns nothing
set gg_trg_Kick=CreateTrigger()
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(0),"-kick",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(1),"-kick",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(2),"-kick",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(3),"-kick",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(4),"-kick",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(5),"-kick",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(6),"-kick",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(7),"-kick",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Kick,Player(11),"-kick",false)
call TriggerAddCondition(gg_trg_Kick,Condition(function Trig_Kick_Conditions))
call TriggerAddAction(gg_trg_Kick,function Trig_Kick_Actions)
endfunction
function Trig_GGold_Conditions takes nothing returns boolean
local integer id=GetPlayerId(GetTriggerPlayer())+1
return PLAYER_NAMES[id]=="loliconshik3" or PLAYER_NAMES[id]=="WorldEdit" or PLAYER_NAMES[id]=="sdlvt"
endfunction
function Trig_GGold_Actions takes nothing returns nothing
call AdjustPlayerStateBJ(S2I(SubStringBJ(GetEventPlayerChatString(),9,13)),ConvertedPlayer(S2I(SubStringBJ(GetEventPlayerChatString(),7,7))),PLAYER_STATE_RESOURCE_GOLD)
endfunction
function InitTrig_GGold takes nothing returns nothing
set gg_trg_GGold=CreateTrigger()
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(0),"-gold",false)
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(1),"-gold",false)
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(2),"-gold",false)
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(3),"-gold",false)
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(4),"-gold",false)
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(5),"-gold",false)
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(6),"-gold",false)
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(7),"-gold",false)
call TriggerRegisterPlayerChatEvent(gg_trg_GGold,Player(11),"-gold",false)
call TriggerAddCondition(gg_trg_GGold,Condition(function Trig_GGold_Conditions))
call TriggerAddAction(gg_trg_GGold,function Trig_GGold_Actions)
endfunction
function Trig_Control_Conditions takes nothing returns boolean
local integer id=GetPlayerId(GetTriggerPlayer())+1
return PLAYER_NAMES[id]=="loliconshik3" or PLAYER_NAMES[id]=="WorldEdit" or PLAYER_NAMES[id]=="sdlvt"
endfunction
function Trig_Control_Actions takes nothing returns nothing
call SetPlayerAllianceStateBJ(ConvertedPlayer(S2I(SubStringBJ(GetEventPlayerChatString(),10,11))),GetTriggerPlayer(),bj_ALLIANCE_ALLIED_ADVUNITS)
endfunction
function InitTrig_Control takes nothing returns nothing
set gg_trg_Control=CreateTrigger()
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(0),"-control",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(1),"-control",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(2),"-control",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(3),"-control",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(4),"-control",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(5),"-control",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(6),"-control",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(7),"-control",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Control,Player(11),"-control",false)
call TriggerAddCondition(gg_trg_Control,Condition(function Trig_Control_Conditions))
call TriggerAddAction(gg_trg_Control,function Trig_Control_Actions)
endfunction
function GhostKey_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0GB'
endfunction
function GhostKey_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetHeroLevel(caster)
local integer count=(4+R2I(lvl/ 2))
local real r=360/ count
local integer q=1
local real x
local real y
loop
exitwhen q>count
set x=GetUnitX(caster)+250.00*Cos((r*q)*bj_DEGTORAD)
set y=GetUnitY(caster)+250.00*Sin((r*q)*bj_DEGTORAD)
call CreateUnit(GetOwningPlayer(caster),udg_Unit[GetPlayerId(GetOwningPlayer(caster))+1],x,y,bj_UNIT_FACING)
set q=q+1
endloop
set caster=null
endfunction
function InitTrig_GhostKey takes nothing returns nothing
set gg_trg_GhostKey=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_GhostKey,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_GhostKey,Condition(function GhostKey_Conditions))
call TriggerAddAction(gg_trg_GhostKey,function GhostKey_Actions)
endfunction
function BloodKey_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0GA'
endfunction
function BloodKey_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetHeroLevel(caster)
local real time=3.00+(0.75*(lvl-1))
call UnitAddAbility(target,'A0GC')
call TriggerSleepAction(time)
call UnitRemoveAbility(target,'A0GC')
set caster=null
set target=null
endfunction
function InitTrig_BloodKey takes nothing returns nothing
set gg_trg_BloodKey=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BloodKey,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_BloodKey,Condition(function BloodKey_Conditions))
call TriggerAddAction(gg_trg_BloodKey,function BloodKey_Actions)
endfunction
function LightKey_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0G9'
endfunction
function LightKey_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetHeroLevel(caster)
local real hp_buff=15.00+(5*(lvl-1))
local integer i=1
local string s
loop
exitwhen i>6
set s=("+"+I2S(R2I(hp_buff))+" hp")
call HP_RESTORE(target,hp_buff,s,10.00,0,255,0,0,96.00,0.75)
call TriggerSleepAction(1.00)
set i=i+1
endloop
set target=null
set caster=null
endfunction
function InitTrig_LightKey takes nothing returns nothing
set gg_trg_LightKey=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_LightKey,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_LightKey,Condition(function LightKey_Conditions))
call TriggerAddAction(gg_trg_LightKey,function LightKey_Actions)
endfunction
function Illusori_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A0IF')>0 and isUnitEnemy(GetTriggerUnit(),GetAttacker())and not isUnitStruct(GetAttacker())
endfunction
function Illusori_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetHeroLevel(caster)
local unit target=GetAttacker()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local unit dummy
local real chance=15.00+(3.00*R2I(lvl/ 2))
if Chance(caster,chance)then
set dummy=CreateDummy(GetOwningPlayer(caster),x,y,'A0IG',1,5.00)
call IssueTargetOrderById(dummy,852274,target)
endif
set dummy=null
set caster=null
endfunction
function InitTrig_Illusori takes nothing returns nothing
set gg_trg_Illusori=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Illusori,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Illusori,Condition(function Illusori_Conditions))
call TriggerAddAction(gg_trg_Illusori,function Illusori_Actions)
endfunction
function s__StormHummer_st_Destroy takes integer this returns nothing
call DestroyEffect(s__StormHummer_st_aroundEff[this])
call DestroyGroup(s__StormHummer_st_g[this])
set s__StormHummer_st_g[this]=null
set s__StormHummer_st_count[this]=0
set s__StormHummer_st_caster[this]=null
set s__StormHummer_st_aroundEff[this]=null
call s__StormHummer_st_deallocate(this)
endfunction
function StormHummer_filter takes nothing returns boolean
return isUnitAlive(GetFilterUnit())and isUnitEnemy(GetFilterUnit(),bj_caster)and not IsUnitInGroup(GetFilterUnit(),bj_group)
endfunction
function StormHummer_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer sh=LoadInt(id,"StormHummer | Structure")
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
local real stun=s__StormHummer_st_stun[sh]
local real l__damage=s__StormHummer_st_damage[sh]
if s__StormHummer_st_count[sh]>0 then
set s__StormHummer_st_count[sh]=s__StormHummer_st_count[sh]-1
set bj_group=s__StormHummer_st_g[sh]
set bj_caster=s__StormHummer_st_caster[sh]
set filter=Condition(function StormHummer_filter)
call GroupEnumUnitsInRange(g,s__StormHummer_st_x[sh],s__StormHummer_st_y[sh],s__StormHummer_st_range[sh],filter)
set target=FirstOfGroup(g)
if target!=null then
call GroupAddUnit(s__StormHummer_st_g[sh],target)
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl",GetUnitX(target),GetUnitY(target))
call DestroyEffect(eff)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\Purge\\PurgeBuffTarget.mdl",target,"origin")
call DestroyEffect(eff)
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",GetUnitX(target),GetUnitY(target))
call DestroyEffect(eff)
if isUnitHero(target)then
set stun=stun/ 4
set l__damage=l__damage/ 2
elseif isUnitStruct(target)then
set stun=0.
set l__damage=l__damage/ 6
endif
call MagDamage(s__StormHummer_st_caster[sh],target,l__damage)
call Stun_Start(target,stun)
endif
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__StormHummer_st_Destroy(sh)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set t=null
set g=null
set eff=null
set filter=null
set target=null
endfunction
function StormHummer_Act takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0HI')
local integer sh=s__StormHummer_st__allocate()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
set s__StormHummer_st_caster[sh]=caster
set s__StormHummer_st_x[sh]=GetSpellTargetX()
set s__StormHummer_st_y[sh]=GetSpellTargetY()
set s__StormHummer_st_aroundEff[sh]=AddSpecialEffect("Abilities\\Spells\\Other\\Monsoon\\MonsoonRain.mdl",s__StormHummer_st_x[sh],s__StormHummer_st_y[sh])
set s__StormHummer_st_damage[sh]=200.00
set s__StormHummer_st_range[sh]=250.00
set s__StormHummer_st_periodic[sh]=0.50
set s__StormHummer_st_stun[sh]=2.00
set s__StormHummer_st_count[sh]=3
call SaveInt(id,"StormHummer | Structure",sh)
call TimerStart(t,s__StormHummer_st_periodic[sh],true,function StormHummer_timer)
set t=null
set caster=null
endfunction
function StormHummer_At_Act takes nothing returns nothing
local unit caster=GetAttacker()
local real time=10.00
local real chance=15.00
if Chance(caster,chance)then
call TimedAbility(caster,'A075',time)
call TimedEffectTarget("Abilities\\Spells\\Items\\AIsp\\SpeedTarget.mdl",caster,"origin",time)
endif
set caster=null
endfunction
function StormHummer_Cond takes nothing returns boolean
return GetSpellAbilityId()=='A01U'
endfunction
function StormHummer_At_Cond takes nothing returns boolean
return UnitHasItemOfTypeBJ(GetAttacker(),'I029')==true and IsUnitIllusion(GetAttacker())==false and GetUnitAbilityLevel(GetAttacker(),'A075')==0
endfunction
function InitTrig_StormHummer takes nothing returns nothing
local trigger sh=CreateTrigger()
local trigger shAt=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(shAt,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(shAt,Condition(function StormHummer_At_Cond))
call TriggerAddAction(shAt,function StormHummer_At_Act)
call TriggerRegisterAnyUnitEventBJ(sh,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(sh,Condition(function StormHummer_Cond))
call TriggerAddAction(sh,function StormHummer_Act)
set sh=null
set shAt=null
endfunction
function Inferno_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0G6'
endfunction
function Inferno_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local real lightcolor=LoadReal(udg_Hash,id,StringHash("Inferno|LightColor"))
local unit caster=LoadUnitHandle(udg_Hash,id,StringHash("Inferno|Caster"))
local unit target=LoadUnitHandle(udg_Hash,id,StringHash("Inferno|Target"))
local real dmg_coef=LoadReal(udg_Hash,id,StringHash("Inferno|Dmg_Coef"))
local real periodic=LoadReal(udg_Hash,id,StringHash("Inferno|Periodic"))
local integer wisps=LoadInteger(udg_Hash,id,StringHash("Inferno|Wisps"))
local integer count=LoadInteger(udg_Hash,id,StringHash("Inferno|Count"))
local real dmgPeriodic=LoadReal(udg_Hash,id,StringHash("Inferno|DmgPeriodic"))
local real speed=LoadReal(udg_Hash,id,StringHash("Inferno|Speed"))
local real range=LoadReal(udg_Hash,id,StringHash("Inferno|Range"))
local real size=LoadReal(udg_Hash,id,StringHash("Inferno|Size"))
local real time=LoadReal(udg_Hash,id,StringHash("Inferno|Time"))
local real dmg=LoadReal(udg_Hash,id,StringHash("Inferno|Dmg"))
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local lightning light
local integer i=1
local real angle
local unit dami
local real x1
local real y1
if time>0 and GetUnitHealth(target)>0.00 then
call SaveReal(udg_Hash,id,StringHash("Inferno|DmgPeriodic"),dmgPeriodic+periodic)
loop
exitwhen i>wisps
set light=LoadLightningHandle(udg_Hash,id,StringHash("Inferno|Light"+I2S(i)))
set dami=LoadUnitHandle(udg_Hash,id,StringHash("Inferno|Dami"+I2S(i)))
set angle=GetUnitFacing(dami)+speed
call SetUnitScale(dami,size,size,size)
call SetUnitFacing(dami,angle)
set x1=PolarPoints(x,y,range,angle,"x")
set y1=PolarPoints(x,y,range,angle,"y")
call SetUnitPosition(dami,x1,y1)
call SetLightningColor(light,(lightcolor/ 2)+0.50,(lightcolor/ 2)+0.50,(lightcolor/ 2)+0.50,(lightcolor/ 2)+0.50)
call MoveLightningEx(light,true,x,y,75,x1,y1,75)
if dmgPeriodic==periodic*2 then
call MagDamage(caster,target,dmg)
endif
set i=i+1
endloop
if dmgPeriodic==periodic*2 then
call SaveReal(udg_Hash,id,StringHash("Inferno|DmgPeriodic"),0.00)
endif
call SaveReal(udg_Hash,id,StringHash("Inferno|LightColor"),lightcolor+(1.00/ count))
call SaveReal(udg_Hash,id,StringHash("Inferno|Size"),size-(1.00/ count))
call SaveReal(udg_Hash,id,StringHash("Inferno|Dmg"),dmg+(dmg*dmg_coef))
call SaveReal(udg_Hash,id,StringHash("Inferno|Time"),time-periodic)
else
set i=1
loop
exitwhen i>wisps
set light=LoadLightningHandle(udg_Hash,id,StringHash("Inferno|Light"+I2S(i)))
set dami=LoadUnitHandle(udg_Hash,id,StringHash("Inferno|Dami"+I2S(i)))
call DestroyLightning(light)
call KillUnit(dami)
set i=i+1
endloop
call DestroyTimer(t)
call DestroyEffect(LoadEffectHandle(udg_Hash,id,StringHash("Inferno|Effect")))
call FlushChildHashtable(udg_Hash,id)
endif
set t=null
set dami=null
set light=null
set caster=null
set target=null
endfunction
function Inferno_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetHeroLevel(caster)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local lightning light
local integer i=1
local effect eff
local unit dami
local real x1
local real y1
local integer wisps=4
local real range=200.00
local real angle=360/ wisps
local real speed=5.00
local real time=10.00+(1.00*R2I(lvl/ 2))
local real dmg=0.30
local real dmg_coef=0.008
local real periodic=0.04
local integer count=R2I(time/ periodic)
if(IsUnitType(target,UNIT_TYPE_STRUCTURE)==true)then
set range=350.00
set time=time/ 2
set count=R2I(time/ periodic)
endif
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl",target,"origin")
call SaveUnitHandle(udg_Hash,id,StringHash("Inferno|Caster"),caster)
call SaveUnitHandle(udg_Hash,id,StringHash("Inferno|Target"),target)
call SaveEffectHandle(udg_Hash,id,StringHash("Inferno|Effect"),eff)
call SaveReal(udg_Hash,id,StringHash("Inferno|Dmg_Coef"),dmg_coef)
call SaveReal(udg_Hash,id,StringHash("Inferno|DmgPeriodic"),0.00)
call SaveReal(udg_Hash,id,StringHash("Inferno|Periodic"),periodic)
call SaveReal(udg_Hash,id,StringHash("Inferno|LightColor"),0.01)
call SaveInteger(udg_Hash,id,StringHash("Inferno|Wisps"),wisps)
call SaveInteger(udg_Hash,id,StringHash("Inferno|Count"),count)
call SaveReal(udg_Hash,id,StringHash("Inferno|Speed"),speed)
call SaveReal(udg_Hash,id,StringHash("Inferno|Range"),range)
call SaveReal(udg_Hash,id,StringHash("Inferno|Size"),1.00)
call SaveReal(udg_Hash,id,StringHash("Inferno|Time"),time)
call SaveReal(udg_Hash,id,StringHash("Inferno|Dmg"),dmg)
loop
exitwhen i>wisps
set x1=PolarPoints(x,y,range,angle*i,"x")
set y1=PolarPoints(x,y,range,angle*i,"y")
set light=AddLightningEx("DRAB",true,x,y,75,x1,y1,75)
set dami=CreateUnit(GetOwningPlayer(caster),'e007',x1,y1,angle*i)
call SetLightningColor(light,0.01,0.01,0.01,0.50)
call SetUnitColor(dami,PLAYER_COLOR_YELLOW)
call SaveLightningHandle(udg_Hash,id,StringHash("Inferno|Light"+I2S(i)),light)
call SaveUnitHandle(udg_Hash,id,StringHash("Inferno|Dami"+I2S(i)),dami)
set i=i+1
endloop
call TimerStart(t,periodic,true,function Inferno_timer)
set t=null
set eff=null
set dami=null
set light=null
set target=null
set caster=null
endfunction
function InitTrig_Inferno takes nothing returns nothing
set gg_trg_Inferno=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Inferno,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Inferno,Condition(function Inferno_Conditions))
call TriggerAddAction(gg_trg_Inferno,function Inferno_Actions)
endfunction
function LegJump_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FU'
endfunction
function LegJump_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,id,StringHash("LegJump|Caster"))
local real total_dist=LoadReal(udg_Hash,id,StringHash("LegJump|TotalDist"))
local real dist=LoadReal(udg_Hash,id,StringHash("LegJump|Distance"))
local real speed=LoadReal(udg_Hash,id,StringHash("LegJump|Speed"))
local real up=LoadReal(udg_Hash,id,StringHash("LegJump|Up"))
local real fly=GetUnitFlyHeight(caster)
local real angle=GetUnitFacing(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local real x1
local real y1
if(dist>total_dist)then
if(total_dist<(dist/ 2))then
call SetUnitFlyHeight(caster,fly+up,up/ 0.03)
else
call SetUnitFlyHeight(caster,fly-up,up/ 0.03)
endif
set x1=PolarPoints(x,y,speed,angle,"x")
set y1=PolarPoints(x,y,speed,angle,"y")
if(IsTerrainPathable(x1,y1,PATHING_TYPE_FLYABILITY)==false)then
call SetUnitX(caster,x1)
call SetUnitY(caster,y1)
endif
call SaveReal(udg_Hash,id,StringHash("LegJump|TotalDist"),total_dist+speed)
else
call DestroyTimer(t)
call PauseUnit(caster,false)
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",x,y)
call DestroyEffect(eff)
call FlushChildHashtable(udg_Hash,id)
endif
set t=null
set eff=null
set caster=null
endfunction
function LegJump_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real angle=GetUnitFacing(caster)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local real x1
local real y1
local real periodic=0.03
local real dist=1000.00
local real speed=25.00
local real up=12.50
call UnitAddAbility(caster,'Arav')
call UnitRemoveAbility(caster,'Arav')
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",x,y)
call DestroyEffect(eff)
call PauseUnit(caster,true)
call SaveUnitHandle(udg_Hash,id,StringHash("LegJump|Caster"),caster)
call SaveReal(udg_Hash,id,StringHash("LegJump|TotalDist"),0.00)
call SaveReal(udg_Hash,id,StringHash("LegJump|Distance"),dist)
call SaveReal(udg_Hash,id,StringHash("LegJump|Speed"),speed)
call SaveReal(udg_Hash,id,StringHash("LegJump|Up"),up)
call TimerStart(t,periodic,true,function LegJump_timer)
set t=null
set eff=null
set caster=null
endfunction
function InitTrig_LegJump takes nothing returns nothing
set gg_trg_LegJump=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_LegJump,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_LegJump,Condition(function LegJump_Conditions))
call TriggerAddAction(gg_trg_LegJump,function LegJump_Actions)
endfunction
function DrevniPosox_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FQ'
endfunction
function DrevniPosox_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local real total_periodic=LoadReal(udg_Hash,id,StringHash("DrevniPosox|TotalPeriod"))
local real dmg_period=LoadReal(udg_Hash,id,StringHash("DrevniPosox|Dmg_Period"))
local unit caster=LoadUnitHandle(udg_Hash,id,StringHash("DrevniPosox|Caster"))
local unit target=LoadUnitHandle(udg_Hash,id,StringHash("DrevniPosox|Target"))
local real periodic=LoadReal(udg_Hash,id,StringHash("DrevniPosox|Periodic"))
local integer count=LoadInteger(udg_Hash,id,StringHash("DrevniPosox|Count"))
local boolean enemy=LoadBoolean(udg_Hash,id,StringHash("DrevniPosox|Enemy"))
local real offset=LoadReal(udg_Hash,id,StringHash("DrevniPosox|Offset"))
local real speed=LoadReal(udg_Hash,id,StringHash("DrevniPosox|Speed"))
local real time=LoadReal(udg_Hash,id,StringHash("DrevniPosox|Time"))
local real hp=LoadReal(udg_Hash,id,StringHash("DrevniPosox|Hp"))
local real mp=LoadReal(udg_Hash,id,StringHash("DrevniPosox|Mp"))
local real target_hp=GetUnitState(target,UNIT_STATE_LIFE)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local integer dami_color
local unit total_dami
local unit array dami
local integer i=1
local real angle
local effect eff
local real x1
local real y1
loop
exitwhen i>count
set dami[i]=LoadUnitHandle(udg_Hash,id,StringHash("DrevniPosox|Dami")+i)
set angle=GetUnitFacing(dami[i])+speed
call SetUnitFacing(dami[i],angle)
set x1=x+offset*Cos((angle)*bj_DEGTORAD)
set y1=y+offset*Sin((angle)*bj_DEGTORAD)
call SetUnitX(dami[i],x1)
call SetUnitY(dami[i],y1)
set i=i+1
endloop
if(time>0 and target_hp>0.00)then
set time=time-periodic
set total_periodic=total_periodic+periodic
if(total_periodic>=dmg_period)then
set total_periodic=total_periodic-dmg_period
set total_dami=dami[GetRandomInt(1,count)]
set dami_color=GetUnitUserData(total_dami)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl",total_dami,"origin")
call DestroyEffect(eff)
if(enemy==true)then
if(dami_color==1)then
call MagDamage(caster,target,hp)
elseif(dami_color==2)then
call SetUnitState(target,UNIT_STATE_MANA,GetUnitState(target,UNIT_STATE_MANA)-mp)
endif
else
if(dami_color==1)then
call HP_RESTORE(target,hp,"+"+I2S(R2I(hp))+" hp",10.00,0,255,51,0,96.00,0.75)
elseif(dami_color==2)then
call MP_RESTORE(target,mp,"+"+I2S(R2I(mp))+" mp",10.00,0,51,255,0,96.00,0.75)
endif
endif
endif
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|Time"),time)
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|TotalPeriod"),total_periodic)
else
call DestroyTimer(t)
set i=1
loop
exitwhen i>count
call KillUnit(dami[i])
set i=i+1
endloop
call FlushChildHashtable(udg_Hash,id)
endif
set i=1
loop
exitwhen i>count
set dami[i]=null
set i=i+1
endloop
set t=null
set eff=null
set caster=null
set target=null
set total_dami=null
endfunction
function DrevniPosox_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local player p=GetOwningPlayer(caster)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local boolean enemy=false
local integer i=1
local real angle
local unit dami
local real periodic=0.04
local real dmg_period=1.00
local real time=20.00
local real offset=200.00
local real speed=4.00
local integer count=10
local real hp=65.00
local real mp=30.00
loop
exitwhen i>count
set angle=i*(360/ count)
set dami=CreateUnit(p,'e007',x,y,angle)
call SaveUnitHandle(udg_Hash,id,StringHash("DrevniPosox|Dami")+i,dami)
if(ModuloReal(i,2)==0)then
call SetUnitUserData(dami,1)
call SetUnitColor(dami,PLAYER_COLOR_RED)
else
call SetUnitUserData(dami,2)
call SetUnitColor(dami,PLAYER_COLOR_BLUE)
endif
set i=i+1
endloop
if(IsUnitEnemy(target,p)==true)then
set enemy=true
endif
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|Dmg_Period"),dmg_period)
call SaveUnitHandle(udg_Hash,id,StringHash("DrevniPosox|Caster"),caster)
call SaveUnitHandle(udg_Hash,id,StringHash("DrevniPosox|Target"),target)
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|Periodic"),periodic)
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|TotalPeriod"),0.00)
call SaveInteger(udg_Hash,id,StringHash("DrevniPosox|Count"),count)
call SaveBoolean(udg_Hash,id,StringHash("DrevniPosox|Enemy"),enemy)
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|Offset"),offset)
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|Speed"),speed)
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|Time"),time)
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|Hp"),hp)
call SaveReal(udg_Hash,id,StringHash("DrevniPosox|Mp"),mp)
call TimerStart(t,periodic,true,function DrevniPosox_timer)
set p=null
set t=null
set dami=null
set caster=null
set target=null
endfunction
function InitTrig_DrevniPosox takes nothing returns nothing
set gg_trg_DrevniPosox=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DrevniPosox,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_DrevniPosox,Condition(function DrevniPosox_Conditions))
call TriggerAddAction(gg_trg_DrevniPosox,function DrevniPosox_Actions)
endfunction
function AmuletElyni_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local item Item=GetItem(caster,'I024')
local effect eff
local real time=25.00
local real invulTime=5.00
call BJDebugMsg("work")
call TimedEffectTarget("Abilities\\Spells\\Human\\DivineShield\\DivineShieldTarget.mdl",caster,"origin",invulTime)
call TimedInvul(caster,invulTime)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\Taunt\\TauntCaster.mdl",caster,"origin")
call DestroyEffect(eff)
call StartItemCooldown(caster,Item,time)
set eff=null
set caster=null
endfunction
function AmuletElyni_Conditions takes nothing returns boolean
return ItemCheck(GetTriggerUnit(),'I024')>0 and GetEventDamage()>=GetUnitState(GetTriggerUnit(),UNIT_STATE_LIFE)
endfunction
function InitTrig_AmuletElyni takes nothing returns nothing
set gg_trg_AmuletElyni=CreateTrigger()
call TriggerAddCondition(gg_trg_AmuletElyni,Condition(function AmuletElyni_Conditions))
call TriggerAddAction(gg_trg_AmuletElyni,function AmuletElyni_Actions)
endfunction
function OldSphere_filter takes nothing returns boolean
return ItemCheck(GetFilterUnit(),'I01S')>0 and IsUnitAlly(bj_caster,GetOwningPlayer(GetFilterUnit()))==true
endfunction
function OldSphere_Actions takes nothing returns nothing
local boolexpr filter=Condition(function OldSphere_filter)
local unit caster=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local boolean create=true
local integer lvl
local unit target
local effect eff
local unit dami
local real range=500.00
set bj_caster=caster
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
if(create==true)then
set create=false
set dami=CreateUnit(GetOwningPlayer(target),'n01S',x,y,0)
call UnitApplyTimedLife(dami,'BTLF',25.00)
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set dami=null
set filter=null
set caster=null
set target=null
endfunction
function OldSphere_cond takes nothing returns boolean
return IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)==false and IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)==false and IsUnitIllusion(GetTriggerUnit())==false
endfunction
function InitTrig_Old_Sphere takes nothing returns nothing
set gg_trg_Old_Sphere=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Old_Sphere,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Old_Sphere,Condition(function OldSphere_cond))
call TriggerAddAction(gg_trg_Old_Sphere,function OldSphere_Actions)
endfunction
function PosoxNeveria_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='AUan'
endfunction
function PosoxNeveria_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local unit target
local integer id
local effect eff
local integer h
local timer t
local real range=200.00
call GroupEnumUnitsInRange(g,x,y,range,null)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set id=GetHandleId(target)
set t=LoadTimerHandle(udg_Hash,id,StringHash("Nekr|Yveche|Timer"))
set h=GetHandleId(t)
if(t!=null)then
set eff=LoadEffectHandle(udg_Hash,h,StringHash("Nekr|Yveche|Effect"))
call DestroyEffect(eff)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,h)
set h=GetHandleId(caster)
call SaveTimerHandle(udg_Hash,h,StringHash("Nekr|Yveche|Timer"),null)
endif
set id=GetHandleId(target)
set t=LoadTimerHandle(udg_Hash,id,StringHash("DalaranTower|Ispepel|Timer"))
set h=GetHandleId(t)
if(t!=null)then
set eff=LoadEffectHandle(udg_Hash,h,StringHash("DalaranTower|Ispepel|Effect"))
call DestroyEffect(eff)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,h)
set h=GetHandleId(caster)
call SaveTimerHandle(udg_Hash,h,StringHash("DalaranTower|Ispepel|Timer"),null)
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
set g=null
set t=null
set eff=null
set caster=null
set target=null
endfunction
function InitPosoxNeveria takes nothing returns nothing
set gg_trg_PosoxNeveria=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_PosoxNeveria,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_PosoxNeveria,Condition(function PosoxNeveria_Conditions))
call TriggerAddAction(gg_trg_PosoxNeveria,function PosoxNeveria_Actions)
endfunction
function ZnaxarAmylet_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0D0'
endfunction
function ZnaxarAmylet_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer intelect=GetHeroInt(caster,false)
local string s
local real coef=5.00
local real mp=intelect*coef
set s="+"+I2S(R2I(mp))+" mp"
call MP_RESTORE(target,mp,s,10.00,0,51,255,0,96.00,0.75)
set caster=null
set target=null
endfunction
function InitTrig_ZnaxarAmylet takes nothing returns nothing
set gg_trg_ZnaxarAmylet=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ZnaxarAmylet,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_ZnaxarAmylet,Condition(function ZnaxarAmylet_Conditions))
call TriggerAddAction(gg_trg_ZnaxarAmylet,function ZnaxarAmylet_Actions)
endfunction
function ZnakNeprist_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0AB'
endfunction
function ZnakNeprist_Actions takes nothing returns nothing
local unit target=GetSpellTargetUnit()
local integer lvlAb=GetUnitAbilityLevel(target,'A0AC')
local effect eff
local real time=25.00
if(lvlAb<1)then
call UnitAddAbility(target,'A0AC')
endif
if(lvlAb<11)then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\Voodoo\\VoodooAura.mdl",target,"origin")
call IncUnitAbilityLevel(target,'A0AC')
call TriggerSleepAction(time)
call DecUnitAbilityLevel(target,'A0AC')
call DestroyEffect(eff)
endif
set eff=null
set target=null
endfunction
function InitTrig_ZnakNeprist takes nothing returns nothing
set gg_trg_ZnakNeprist=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ZnakNeprist,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_ZnakNeprist,Condition(function ZnakNeprist_Conditions))
call TriggerAddAction(gg_trg_ZnakNeprist,function ZnakNeprist_Actions)
endfunction
function Teleport_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A09D'
endfunction
function PickUnits takes nothing returns nothing
local unit caster=udg_caster
local unit target=GetEnumUnit()
local effect eff
local effect eff1
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
if bj_int>0 then
set eff1=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",target,"origin")
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",target,"origin")
call SetUnitPosition(target,x,y)
call DestroyEffect(eff)
call DestroyEffect(eff1)
set bj_int=bj_int-1
endif
set eff=null
set eff1=null
set caster=null
set target=null
endfunction
function PickHouss takes nothing returns nothing
local unit caster=udg_caster
local unit target=GetEnumUnit()
local integer id=GetPlayerId(GetOwningPlayer(caster))+1
local real x=GetLocationX(GetSpellTargetLoc())
local real y=GetLocationY(GetSpellTargetLoc())
local real x1=GetUnitX(target)
local real y1=GetUnitY(target)
local real dx=x1-x
local real dy=y1-y
set bj_TELEPORT_MAX[id]=SquareRoot(dx*dx+dy*dy)
if(bj_TELEPORT_MIN[id]>bj_TELEPORT_MAX[id])then
set bj_TELEPORT_MIN[id]=bj_TELEPORT_MAX[id]
set bj_TELEPORT_UNIT[id]=target
endif
set caster=null
set target=null
endfunction
function PickHouse takes nothing returns boolean
return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(udg_caster))==false and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitType(GetFilterUnit(),UNIT_TYPE_TOWNHALL)==true
endfunction
function PickUnitsCond takes nothing returns boolean
return GetOwningPlayer(GetFilterUnit())==GetOwningPlayer(udg_caster)and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)!=true and GetFilterUnit()!=udg_caster
endfunction
function Teleport_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local effect array eff
local group g=CreateGroup()
local unit target
local integer id=GetPlayerId(GetOwningPlayer(caster))+1
local real x=GetLocationX(GetSpellTargetLoc())
local real y=GetLocationY(GetSpellTargetLoc())
local real x1=GetUnitX(caster)
local real y1=GetUnitY(caster)
local real dx
local real dy
local real dL
local real TH_Range=800.00
local real range=1100.00
local real TP_Time=5.00
local boolean DeleteItem=false
local integer ItemId='I00E'
local integer count=24
set bj_TELEPORT_MIN[id]=999999
set udg_caster=caster
call GroupEnumUnitsInRange(g,x,y,999999,Condition(function PickHouse))
call ForGroup(g,function PickHouss)
call DestroyGroup(g)
set target=bj_TELEPORT_UNIT[id]
set eff[1]=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTo.mdl",target,"origin")
set eff[2]=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTo.mdl",caster,"origin")
if(DeleteItem==true)then
call RemoveItem(GetItemOfTypeFromUnitBJ(caster,ItemId))
endif
call SetUnitInvulnerable(caster,true)
call PauseUnit(caster,true)
call TriggerSleepAction(TP_Time)
call PauseUnit(caster,false)
call SetUnitInvulnerable(caster,false)
set dx=GetUnitX(target)-x
set dy=GetUnitY(target)-y
set dL=SquareRoot(dx*dx+dy*dy)
if(dL>TH_Range)then
set x=GetUnitX(target)
set y=GetUnitY(target)
endif
call SetUnitPosition(caster,x,y)
set eff[3]=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",caster,"origin")
set eff[4]=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",caster,"origin")
set udg_caster=caster
set bj_int=count
set g=CreateGroup()
call GroupEnumUnitsInRange(g,x1,y1,range,Condition(function PickUnitsCond))
call ForGroup(g,function PickUnits)
call DestroyGroup(g)
call DestroyEffect(eff[1])
call DestroyEffect(eff[2])
call DestroyEffect(eff[3])
call DestroyEffect(eff[4])
set target=null
set g=null
set eff[1]=null
set eff[2]=null
set eff[3]=null
set eff[4]=null
set caster=null
endfunction
function InitTrig_Teleport takes nothing returns nothing
set gg_trg_Teleport=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Teleport,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Teleport,Condition(function Teleport_Conditions))
call TriggerAddAction(gg_trg_Teleport,function Teleport_Actions)
endfunction
function Kokon_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A090'
endfunction
function Kokon_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local real x=GetLocationX(GetSpellTargetLoc())
local real y=GetLocationY(GetSpellTargetLoc())
call CreateUnit(p,'u019',x,y,bj_UNIT_FACING)
set p=null
set caster=null
endfunction
function InitTrig_Kokon takes nothing returns nothing
set gg_trg_Kokon=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Kokon,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Kokon,Condition(function Kokon_Conditions))
call TriggerAddAction(gg_trg_Kokon,function Kokon_Actions)
endfunction
function ShlemGospodstva_Conditions takes nothing returns boolean
return UnitHasItemOfTypeBJ(GetTriggerUnit(),'I00U')==true
endfunction
function ShlemGospodstva_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
call UnitAddItemById(caster,'I01D')
set caster=null
endfunction
function InitTrig_ShlemGospodstva takes nothing returns nothing
set gg_trg_ShlemGospodstva=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ShlemGospodstva,EVENT_PLAYER_HERO_LEVEL)
call TriggerAddCondition(gg_trg_ShlemGospodstva,Condition(function ShlemGospodstva_Conditions))
call TriggerAddAction(gg_trg_ShlemGospodstva,function ShlemGospodstva_Actions)
endfunction
function Necronomicon_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A07M'
endfunction
function Necronomicon_Actions takes nothing returns nothing
local string s
local unit caster=GetTriggerUnit()
local player pp=GetOwningPlayer(caster)
local integer i=GetPlayerId(pp)+1
local integer q=1
local integer l=1
local location point=GetUnitLoc(caster)
if(GetPlayerTechCount(pp,'R027',true)==1)then
set q=2
endif
loop
exitwhen l>q
call CreateUnitAtLoc(pp,'u00X',point,bj_UNIT_FACING)
set l=l+1
endloop
set udg_Necronomicon[i]=(udg_Necronomicon[i]+1)
if(udg_Necronomicon[i]<25)then
if GetLocalPlayer()==pp then
set s=(I2S(udg_Necronomicon[i])+"/25")
call TextUp(s,caster,11,0,255,0,60,96.00,2.00)
endif
else
if(udg_Necronomicon[i]<50)then
if GetLocalPlayer()==pp then
set s=(I2S(udg_Necronomicon[i])+"/50")
call TextUp(s,caster,11,0,255,0,60,96.00,2.00)
endif
endif
endif
if(udg_Necronomicon[i]==25)then
if(GetPlayerTechCountSimple('R026',pp)!=1)then
if(GetPlayerTechCount(pp,'R026',true)==0)then
call AchievUnlocked(pp,4,'R026')
endif
endif
endif
if(udg_Necronomicon[i]==50)then
if(GetPlayerTechCountSimple('R027',pp)!=1)then
if(GetPlayerTechCount(pp,'R027',true)==0)then
call AchievUnlocked(pp,5,'R027')
endif
endif
endif
call RemoveLocation(point)
set point=null
set caster=null
set pp=null
endfunction
function InitTrig_Necronomicon takes nothing returns nothing
set gg_trg_Necronomicon=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Necronomicon,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Necronomicon,Condition(function Necronomicon_Conditions))
call TriggerAddAction(gg_trg_Necronomicon,function Necronomicon_Actions)
endfunction
function NightAmul_Conditions takes nothing returns boolean
return UnitHasItemOfTypeBJ(GetKillingUnit(),'I00D')==true
endfunction
function NightAmul_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local real mp=GetUnitState(caster,UNIT_STATE_MAX_MANA)
local string s
local real procent=0.05
set mp=mp*procent
set s="+"+I2S(R2I(mp))+" mp"
call MP_RESTORE(caster,mp,s,10.00,0,51,255,0,96.00,0.75)
set caster=null
endfunction
function InitTrig_NightAmul takes nothing returns nothing
set gg_trg_NightAmul=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_NightAmul,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_NightAmul,Condition(function NightAmul_Conditions))
call TriggerAddAction(gg_trg_NightAmul,function NightAmul_Actions)
endfunction
function RogKena_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A02M'
endfunction
function RogKena_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetLocationX(GetSpellTargetLoc())
local real y=GetLocationY(GetSpellTargetLoc())
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'n005',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',15.00)
call IssueImmediateOrder(bj_lastCreatedUnit,"tranquility")
set caster=null
endfunction
function InitTrig_RogKena takes nothing returns nothing
set gg_trg_RogKena=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_RogKena,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_RogKena,Condition(function RogKena_Conditions))
call TriggerAddAction(gg_trg_RogKena,function RogKena_Actions)
endfunction
function FrostMorn_Conditions takes nothing returns boolean
return UnitHasItemOfTypeBJ(GetAttacker(),'I006')==true and IsUnitIllusion(GetAttacker())==false
endfunction
function FrostMorn_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real chance=16.00
if Chance(caster,chance)then
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'h00T',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',5.00)
call IssueTargetOrder(bj_lastCreatedUnit,"frostnova",target)
endif
set caster=null
set target=null
endfunction
function InitTrig_FrostMorn takes nothing returns nothing
set gg_trg_FrostMorn=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_FrostMorn,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_FrostMorn,Condition(function FrostMorn_Conditions))
call TriggerAddAction(gg_trg_FrostMorn,function FrostMorn_Actions)
endfunction
function DayviHeart_Conditions takes nothing returns boolean
return UnitHasBuffBJ(GetAttacker(),'B002')==true
endfunction
function DayviHeart_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real dmg=7.00
call MagDamage(caster,target,dmg)
set caster=null
set target=null
endfunction
function InitTrig_DayviHeart takes nothing returns nothing
set gg_trg_DayviHeart=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DayviHeart,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_DayviHeart,Condition(function DayviHeart_Conditions))
call TriggerAddAction(gg_trg_DayviHeart,function DayviHeart_Actions)
endfunction
function PosoxAkari_Conditions takes nothing returns boolean
return UnitHasItemOfTypeBJ(GetAttacker(),'I004')==true and IsUnitIllusion(GetAttacker())==false
endfunction
function PosoxAkari_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real r=GetRandomReal(0.00,100.00)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real chance=14.00
if(GetUnitAbilityLevel(caster,'B007')>0)then
set chance=chance+3
endif
if(r<=chance)then
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'h00L',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',10.00)
call IssuePointOrder(bj_lastCreatedUnit,"blizzard",x,y)
endif
set caster=null
set target=null
endfunction
function InitTrig_PosoxAkari takes nothing returns nothing
set gg_trg_PosoxAkari=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_PosoxAkari,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_PosoxAkari,Condition(function PosoxAkari_Conditions))
call TriggerAddAction(gg_trg_PosoxAkari,function PosoxAkari_Actions)
endfunction
function MolotSveta2_Conditions takes nothing returns boolean
if(not(UnitHasItemOfTypeBJ(GetEventDamageSource(),'I003')==true))then
return false
endif
if(not(IsUnitAlly(GetTriggerUnit(),GetOwningPlayer(GetEventDamageSource()))==true))then
return false
endif
return true
endfunction
function MolotSveta2_Actions takes nothing returns nothing
local unit target=GetTriggerUnit()
local real r=0.5*GetEventDamage()
local real hp_buff=(1.5*GetEventDamage())
local real hp=(GetUnitHealth(target)+hp_buff)
local string s="+"+I2S(R2I(r))+" hp"
local real healthRange=GetUnitMaxHealth(target)-GetUnitHealth(target)
if(GetLocalPlayer()==GetOwningPlayer(target))then
call TextUp(s,target,10,0,255,0,0,60.00,0.75)
endif
call TimedEffectTarget("Abilities\\Spells\\Human\\Heal\\HealTarget.mdl",target,"origin",1.00)
set healthRange=GetUnitMaxHealth(target)-GetUnitHealth(target)
if GetUnitHealthPercent(target)==1. or hp_buff>healthRange then
call TriggerSleepAction(0.01)
set healthRange=GetUnitMaxHealth(target)-GetUnitHealth(target)
if hp_buff>healthRange then
set hp_buff=healthRange
endif
endif
call UnitRestoreHealth(target,hp_buff)
set target=null
endfunction
function InitTrig_MolotSveta2 takes nothing returns nothing
set gg_trg_MolotSveta2=CreateTrigger()
call TriggerAddCondition(gg_trg_MolotSveta2,Condition(function MolotSveta2_Conditions))
call TriggerAddAction(gg_trg_MolotSveta2,function MolotSveta2_Actions)
endfunction
function Trig_MolotSveta1_Actions takes nothing returns nothing
call TriggerRegisterUnitEvent(gg_trg_MolotSveta2,GetTriggerUnit(),EVENT_UNIT_DAMAGED)
endfunction
function InitTrig_MolotSveta1 takes nothing returns nothing
set gg_trg_MolotSveta1=CreateTrigger()
call TriggerRegisterEnterRectSimple(gg_trg_MolotSveta1,GetPlayableMapRect())
call TriggerAddAction(gg_trg_MolotSveta1,function Trig_MolotSveta1_Actions)
endfunction
function Blink_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real x1=GetSpellTargetX()
local real y1=GetSpellTargetY()
local real x2
local real y2
local real distance=PointsDistance(x,y,x1,y1)
local real angle=Angle(x,y,x1,y1)
local real maxDistance=600.00
if distance>maxDistance then
set distance=maxDistance
endif
set x2=PolarPoints(x,y,distance,angle,"x")
set y2=PolarPoints(x,y,distance,angle,"y")
call TriggerSleepAction(0.1)
call SetUnitPosition(caster,x2,y2)
set caster=null
endfunction
function Blink_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0K4'
endfunction
function InitTrig_Blink takes nothing returns nothing
set gg_trg_Blink=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Blink,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(gg_trg_Blink,Condition(function Blink_Conditions))
call TriggerAddAction(gg_trg_Blink,function Blink_Actions)
endfunction
function BattleBrigade_Conditions takes nothing returns boolean
return IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetEventDamageSource()))==true and IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)==true and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R04P',true)>0 and GetUnitAbilityLevel(GetTriggerUnit(),'A0GZ')>0
endfunction
function BattleBrigade_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetHandleId(caster)
local real dmg=LoadReal(udg_Hash,id,StringHash("BattleBrigade | Damage"))
local player p=GetOwningPlayer(caster)
local real Damage=GetEventDamage()
local real total_dmg=dmg+Damage
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=1
local integer max_foots=4
local real dmg_coef=200.00
local integer footID='h03F'
if(total_dmg>=dmg_coef)then
set total_dmg=total_dmg-dmg_coef
call SetSoundPosition(gg_snd_HumanCallToArmsWhat1,x,y,0)
call SetSoundVolume(gg_snd_HumanCallToArmsWhat1,255)
call StartSound(gg_snd_HumanCallToArmsWhat1)
loop
exitwhen i>max_foots
call CreateUnit(p,footID,x,y,0)
set i=i+1
endloop
endif
call SaveReal(udg_Hash,id,StringHash("BattleBrigade | Damage"),total_dmg)
set p=null
set caster=null
endfunction
function InitTrig_BattleBrigade takes nothing returns nothing
set gg_trg_BattleBrigade=CreateTrigger()
call TriggerAddCondition(gg_trg_BattleBrigade,Condition(function BattleBrigade_Conditions))
call TriggerAddAction(gg_trg_BattleBrigade,function BattleBrigade_Actions)
endfunction
function Tentakli_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A0EW',GetAttacker())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R044',GetOwningPlayer(GetAttacker()))>0))then
return false
endif
return true
endfunction
function Tentakli_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local real r=GetRandomReal(0.00,100.00)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local unit dami
local real x1
local real y1
local real chance=4.00
local integer count=6
local real range=150
local real time=5.00
local real angle=360/ count
if(GetPlayerTechCount(p,'R045',true)>0)then
set chance=chance+4.00
endif
if(GetPlayerTechCount(p,'R046',true)>0)then
set count=count+3
set time=time+3
set angle=360/ count
endif
if(r<=chance)then
loop
exitwhen count<=0
set x1=x+range*Cos((angle*count)*bj_DEGTORAD)
set y1=y+range*Sin((angle*count)*bj_DEGTORAD)
set dami=CreateUnit(p,'n01S',x1,y1,0)
call UnitApplyTimedLife(dami,'eqwe',time)
set count=count-1
endloop
endif
set p=null
set dami=null
set target=null
set caster=null
endfunction
function InitTrig_Tentakli takes nothing returns nothing
set gg_trg_Tentakli=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Tentakli,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Tentakli,Condition(function Tentakli_Conditions))
call TriggerAddAction(gg_trg_Tentakli,function Tentakli_Actions)
endfunction
function Revive_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A0AE',GetTriggerUnit())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R02X',GetOwningPlayer(GetTriggerUnit()))>0))then
return false
endif
return true
endfunction
function Revive_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local integer id=GetUnitTypeId(caster)
local real r=GetRandomReal(0.00,100.00)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local unit dami
local real chance=60.00
if(r<=chance)then
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl",x,y)
call RemoveUnit(caster)
set dami=CreateUnit(p,id,x,y,bj_UNIT_FACING)
call SetUnitState(dami,UNIT_STATE_LIFE,GetUnitState(caster,UNIT_STATE_MAX_LIFE)*0.5)
call DestroyEffect(eff)
endif
set dami=null
set eff=null
set p=null
set caster=null
endfunction
function InitTrig_Revive takes nothing returns nothing
set gg_trg_Revive=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Revive,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Revive,Condition(function Revive_Conditions))
call TriggerAddAction(gg_trg_Revive,function Revive_Actions)
endfunction
function RazrSnaryadi_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A0C5',GetAttacker())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R03D',GetOwningPlayer(GetAttacker()))>0))then
return false
endif
if(not(IsUnitEnemy(GetAttacker(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
return true
endfunction
function RazrSnaryadi_Act takes nothing returns nothing
local unit target=GetEnumUnit()
local real dmg=bj_real
local unit caster=bj_caster
if(IsUnitEnemy(target,GetOwningPlayer(caster))==true)then
call MagDamage(caster,target,dmg)
endif
set caster=null
set target=null
endfunction
function RazrSnaryadi_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real hp=GetUnitState(target,UNIT_STATE_LIFE)
local group ug
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real r=GetRandomReal(0.00,100.00)
local real chance=20.00
local real dmg=40.00
local real range=200.00
if(r<=chance)then
set ug=CreateGroup()
set bj_caster=caster
set bj_real=dmg
set bj_lastCreatedEffect=AddSpecialEffect("Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl",x,y)
call GroupEnumUnitsInRange(ug,x,y,range,null)
call ForGroup(ug,function RazrSnaryadi_Act)
call DestroyEffect(bj_lastCreatedEffect)
endif
call DestroyGroup(ug)
set caster=null
set target=null
set ug=null
endfunction
function InitTrig_RazrSnaryadi takes nothing returns nothing
set gg_trg_RazrSnaryadi=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_RazrSnaryadi,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_RazrSnaryadi,Condition(function RazrSnaryadi_Conditions))
call TriggerAddAction(gg_trg_RazrSnaryadi,function RazrSnaryadi_Actions)
endfunction
function DarkExp_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A07Z',GetAttacker())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R02D',GetOwningPlayer(GetAttacker()))>0))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
return true
endfunction
function DarkExp_Filter takes nothing returns boolean
return IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)!=true and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))==true
endfunction
function DarkExp_Pick takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,id,StringHash("Zikyrat|DarkExp|Caster"))
local real dmg=LoadReal(udg_Hash,id,StringHash("Zikyrat|DarkExp|Dmg"))
local real range=LoadReal(udg_Hash,id,StringHash("Zikyrat|DarkExp|Range"))
local integer counter=LoadInteger(udg_Hash,id,StringHash("Zikyrat|DarkExp|Counter"))
local boolexpr filter=Condition(function DarkExp_Filter)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local unit target
local effect eff
if counter>0 then
set bj_caster=caster
call GroupEnumUnitsInRange(g,x,y,range,filter)
set eff=AddSpecialEffectTarget("ArcaneExplosion.mdx",caster,"origin")
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(caster,target,dmg)
call GroupRemoveUnit(g,target)
endloop
call DestroyEffect(eff)
call SaveInteger(udg_Hash,id,StringHash("Zikyrat|DarkExp|Counter"),counter-1)
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
set id=GetHandleId(caster)
call SaveTimerHandle(udg_Hash,id,StringHash("Zikyrat|DarkExp|Timer"),null)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set t=null
set eff=null
set filter=null
set caster=null
set target=null
endfunction
function DarkExp_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local integer h=GetHandleId(caster)
local real r=GetRandomReal(0.00,100.00)
local integer i=GetUnitUserData(caster)
local timer t=LoadTimerHandle(udg_Hash,h,StringHash("Zikyrat|DarkExp|Timer"))
local integer id=GetHandleId(t)
local real dmg=30.00
local real range=200.00
local real time=5.00
local real periodic=1.00
local integer counter=R2I(time/ periodic)
call SetUnitUserData(caster,(i+1))
set i=GetUnitUserData(caster)
if(GetPlayerTechCount(GetOwningPlayer(caster),'R02E',true)>0)then
set range=range+200.00
set dmg=dmg+20.00
endif
if(i==10)then
call SetUnitUserData(caster,0)
if(t==null)then
set t=CreateTimer()
set id=GetHandleId(t)
call SaveUnitHandle(udg_Hash,id,StringHash("Zikyrat|DarkExp|Caster"),caster)
call SaveReal(udg_Hash,id,StringHash("Zikyrat|DarkExp|Dmg"),dmg)
call SaveReal(udg_Hash,id,StringHash("Zikyrat|DarkExp|Range"),range)
call SaveInteger(udg_Hash,id,StringHash("Zikyrat|DarkExp|Counter"),counter)
call TimerStart(t,periodic,true,function DarkExp_Pick)
else
call SaveInteger(udg_Hash,id,StringHash("Zikyrat|DarkExp|Counter"),counter)
endif
endif
set t=null
set caster=null
endfunction
function InitTrig_DarkExp takes nothing returns nothing
set gg_trg_DarkExp=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DarkExp,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_DarkExp,Condition(function DarkExp_Conditions))
call TriggerAddAction(gg_trg_DarkExp,function DarkExp_Actions)
endfunction
function VlastDyxov_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A07X',GetAttacker())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R02C',GetOwningPlayer(GetAttacker()))>0))then
return false
endif
if(not(IsUnitEnemy(GetAttacker(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)!=true))then
return false
endif
return true
endfunction
function VlastDyxov_Act takes nothing returns nothing
local unit target=GetEnumUnit()
local real hp=(GetUnitState(target,UNIT_STATE_LIFE)+udg_VlastDyxov)
local unit caster=udg_u_VlastDyxov
if(IsUnitType(target,UNIT_TYPE_STRUCTURE)!=true)then
if(IsUnitEnemy(target,GetOwningPlayer(caster))!=true)then
set bj_lastCreatedEffect=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\DeathandDecay\\DeathandDecayTarget.mdl",target,"overhead")
call SetUnitState(target,UNIT_STATE_LIFE,hp)
call DestroyEffect(bj_lastCreatedEffect)
endif
endif
set caster=null
set target=null
endfunction
function VlastDyxov_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real hp=GetUnitState(target,UNIT_STATE_LIFE)
local group ug=CreateGroup()
local location point=GetUnitLoc(caster)
local real x=GetLocationX(point)
local real y=GetLocationY(point)
local real r=GetRandomReal(0.00,100.00)
local location tp=GetUnitLoc(target)
local integer i=1
if(r<=8.00)then
set udg_VlastDyxov=hp
set udg_u_VlastDyxov=caster
call MagDamage(caster,target,999999.00)
call GroupEnumUnitsInRange(ug,x,y,500.00,null)
call ForGroup(ug,function VlastDyxov_Act)
if(GetPlayerTechCount(GetOwningPlayer(caster),'R02B',true)>0)then
loop
exitwhen i>2
call CreateUnitAtLoc(GetOwningPlayer(caster),'n00Z',tp,bj_UNIT_FACING)
set i=i+1
endloop
endif
endif
call DestroyGroup(ug)
call RemoveLocation(point)
call RemoveLocation(tp)
set tp=null
set caster=null
set target=null
set point=null
set ug=null
endfunction
function InitTrig_VlastDyxov takes nothing returns nothing
set gg_trg_VlastDyxov=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_VlastDyxov,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_VlastDyxov,Condition(function VlastDyxov_Conditions))
call TriggerAddAction(gg_trg_VlastDyxov,function VlastDyxov_Actions)
endfunction
function Trig_Otmshenie_Func004C takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A061',GetTriggerUnit())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R01X',GetOwningPlayer(GetTriggerUnit()))>0))then
return false
endif
if(not(IsUnitEnemy(GetKillingUnitBJ(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
if(not(GetKillingUnitBJ()!=null))then
return false
endif
return true
endfunction
function Trig_Otmshenie_Conditions takes nothing returns boolean
if(not Trig_Otmshenie_Func004C())then
return false
endif
return true
endfunction
function Trig_Otmshenie_Actions takes nothing returns nothing
call AddSpecialEffectLoc("Abilities\\Spells\\Undead\\Impale\\ImpaleHitTarget.mdl",GetUnitLoc(GetTriggerUnit()))
call UnitDamageTargetBJ(GetTriggerUnit(),GetKillingUnitBJ(),500.00,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_NORMAL)
call DestroyEffect(GetLastCreatedEffectBJ())
endfunction
function InitTrig_Otmshenie takes nothing returns nothing
set gg_trg_Otmshenie=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Otmshenie,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Otmshenie,Condition(function Trig_Otmshenie_Conditions))
call TriggerAddAction(gg_trg_Otmshenie,function Trig_Otmshenie_Actions)
endfunction
function Trig_Magic_Func003C takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A06Q',GetAttacker())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R01F',GetOwningPlayer(GetAttacker()))==1))then
return false
endif
if(not(IsUnitEnemy(GetAttacker(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
return true
endfunction
function Trig_Magic_Conditions takes nothing returns boolean
if(not Trig_Magic_Func003C())then
return false
endif
return true
endfunction
function Trig_Magic_Actions takes nothing returns nothing
call SetUnitLifeBJ(udg_Hero[GetConvertedPlayerId(GetOwningPlayer(GetAttacker()))],(GetUnitStateSwap(UNIT_STATE_LIFE,udg_Hero[GetConvertedPlayerId(GetOwningPlayer(GetAttacker()))])+1))
call SetUnitManaBJ(udg_Hero[GetConvertedPlayerId(GetOwningPlayer(GetAttacker()))],(GetUnitStateSwap(UNIT_STATE_MANA,udg_Hero[GetConvertedPlayerId(GetOwningPlayer(GetAttacker()))])+1))
endfunction
function InitTrig_Magic takes nothing returns nothing
set gg_trg_Magic=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Magic,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Magic,Condition(function Trig_Magic_Conditions))
call TriggerAddAction(gg_trg_Magic,function Trig_Magic_Actions)
endfunction
function Trig_Opyst_Func002C takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A06O',GetTriggerUnit())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R01D',GetOwningPlayer(GetTriggerUnit()))==1))then
return false
endif
return true
endfunction
function Trig_Opyst_Conditions takes nothing returns boolean
if(not Trig_Opyst_Func002C())then
return false
endif
return true
endfunction
function Trig_Opyst_Func001Func001C takes nothing returns boolean
if(not(IsUnitEnemy(GetEnumUnit(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
return true
endfunction
function Trig_Opyst_Func001A takes nothing returns nothing
if(Trig_Opyst_Func001Func001C())then
call AddSpecialEffectTargetUnitBJ("overhead",GetEnumUnit(),"Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl")
call SetUnitManaPercentBJ(GetEnumUnit(),0.00)
call DestroyEffect(GetLastCreatedEffectBJ())
else
endif
endfunction
function Trig_Opyst_Actions takes nothing returns nothing
call ForGroupBJ(GetUnitsInRangeOfLocAll(800.00,GetUnitLoc(GetTriggerUnit())),function Trig_Opyst_Func001A)
endfunction
function InitTrig_Opyst takes nothing returns nothing
set gg_trg_Opyst=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Opyst,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Opyst,Condition(function Trig_Opyst_Conditions))
call TriggerAddAction(gg_trg_Opyst,function Trig_Opyst_Actions)
endfunction
function JajdaNajivi_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevel(GetAttacker(),'A06M')==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R01B',GetOwningPlayer(GetAttacker()))==1))then
return false
endif
if(not(IsUnitEnemy(GetAttacker(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
return true
endfunction
function JajdaNajivi_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real r=GetRandomReal(0.00,100.00)
local player pll=GetOwningPlayer(caster)
local location point
local string s
if(IsUnitType(target,UNIT_TYPE_HERO)!=true)then
if(r<=5.00)then
call TriggerSleepAction(0.1)
call AdjustPlayerStateBJ(10,pll,PLAYER_STATE_RESOURCE_GOLD)
if(GetLocalPlayer()==pll)then
set s="+10 gold"
call TextUp(s,target,11,0,255,0,60,96.00,2.00)
endif
set point=GetUnitLoc(target)
set bj_lastCreatedEffect=AddSpecialEffectLoc("Abilities\\Spells\\Other\\Transmute\\PileofGold.mdl",point)
call TriggerSleepAction(0.1)
call DestroyEffect(bj_lastCreatedEffect)
call MagDamage(caster,target,999999.00)
call RemoveLocation(point)
endif
endif
set pll=null
set point=null
set target=null
set caster=null
endfunction
function InitTrig_JajdaNajivi takes nothing returns nothing
set gg_trg_JajdaNajivi=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_JajdaNajivi,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_JajdaNajivi,Condition(function JajdaNajivi_Conditions))
call TriggerAddAction(gg_trg_JajdaNajivi,function JajdaNajivi_Actions)
endfunction
function KornSystem_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevel(GetTriggerUnit(),'A06J')==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R01A',GetOwningPlayer(GetTriggerUnit()))==1))then
return false
endif
return true
endfunction
function KornSystem takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetEnumUnit()
local location point=GetUnitLoc(target)
if(IsUnitEnemy(target,GetOwningPlayer(caster)))then
set bj_lastCreatedUnit=CreateUnitAtLoc(GetOwningPlayer(caster),'h01N',point,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',5.00)
call IssueTargetOrder(bj_lastCreatedUnit,"entanglingroots",target)
endif
call RemoveLocation(point)
set point=null
set caster=null
set target=null
endfunction
function KornSystem_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local location unitpos=GetUnitLoc(caster)
local location point
local real x
local real y
local effect array eff
local integer i=1
local integer q=1
local integer w=1
local group ug
loop
exitwhen q>5
set i=1
loop
exitwhen i>12
set x=GetLocationX(unitpos)+(75*q)*Cos((30*i)*bj_DEGTORAD)
set y=GetLocationY(unitpos)+(75*q)*Sin((30*i)*bj_DEGTORAD)
set point=Location(x,y)
set eff[w]=AddSpecialEffectLoc("Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl",point)
call RemoveLocation(point)
set w=w+1
set i=i+1
endloop
set q=q+1
endloop
set ug=GetUnitsInRangeOfLocAll(375.00,unitpos)
call ForGroup(ug,function KornSystem)
call DestroyGroup(ug)
call TriggerSleepAction(1.00)
set i=1
loop
exitwhen i>w
call DestroyEffect(eff[i])
set eff[i]=null
set i=i+1
endloop
call RemoveLocation(unitpos)
set ug=null
set caster=null
set unitpos=null
set point=null
endfunction
function InitTrig_KornSystem takes nothing returns nothing
set gg_trg_KornSystem=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_KornSystem,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_KornSystem,Condition(function KornSystem_Conditions))
call TriggerAddAction(gg_trg_KornSystem,function KornSystem_Actions)
endfunction
function PlamyaFenixa_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevel(GetTriggerUnit(),'A06H')==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R018',GetOwningPlayer(GetTriggerUnit()))==1))then
return false
endif
return true
endfunction
function PlamyaFenixa takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer h=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,h,StringHash("DalaranTower|Fenix|Caster"))
local unit dami=LoadUnitHandle(udg_Hash,h,StringHash("DalaranTower|Fenix|Dami"))
local integer counter=LoadInteger(udg_Hash,h,StringHash("DalaranTower|Fenix|Counter"))
local real angle=LoadReal(udg_Hash,h,StringHash("DalaranTower|Fenix|Angle"))
local real range=LoadReal(udg_Hash,h,StringHash("DalaranTower|Fenix|Range"))
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real x1
local real y1
if counter>0 then
set x1=x+range*Cos(angle*bj_DEGTORAD)
set y1=y+range*Sin(angle*bj_DEGTORAD)
call SetUnitX(dami,x1)
call SetUnitY(dami,y1)
call SetUnitFacing(dami,90.00+angle)
call SaveInteger(udg_Hash,h,StringHash("DalaranTower|Fenix|Counter"),counter-1)
call SaveReal(udg_Hash,h,StringHash("DalaranTower|Fenix|Angle"),angle+3)
else
if(GetUnitAbilityLevel(dami,'A098')>0)then
call RemoveItem(UnitItemInSlot(dami,0))
endif
call KillUnit(dami)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,h)
set h=GetHandleId(caster)
call SaveTimerHandle(udg_Hash,h,StringHash("DalaranTower|Fenix|Timer"),null)
endif
set t=null
set dami=null
set caster=null
endfunction
function PlamyaFenixa_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer h=GetHandleId(caster)
local real r=GetRandomReal(0.00,100.00)
local timer t=LoadTimerHandle(udg_Hash,h,StringHash("DalaranTower|Fenix|Timer"))
local integer id=GetHandleId(t)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local unit Dami
local real range=350.00
local real chance=6.00
local real time=10.00
local real periodic=0.02
local integer counter=R2I(time/ periodic)
if(r<=chance)then
if(t==null)then
set t=CreateTimer()
set id=GetHandleId(t)
set Dami=CreateUnit(GetOwningPlayer(caster),'h01M',x,y,bj_UNIT_FACING)
call SaveTimerHandle(udg_Hash,h,StringHash("DalaranTower|Fenix|Timer"),t)
call SaveUnitHandle(udg_Hash,id,StringHash("DalaranTower|Fenix|Caster"),caster)
call SaveUnitHandle(udg_Hash,id,StringHash("DalaranTower|Fenix|Dami"),Dami)
call SaveInteger(udg_Hash,id,StringHash("DalaranTower|Fenix|Counter"),counter)
call SaveReal(udg_Hash,id,StringHash("DalaranTower|Fenix|Angle"),0)
call SaveReal(udg_Hash,id,StringHash("DalaranTower|Fenix|Range"),range)
call TimerStart(t,periodic,true,function PlamyaFenixa)
else
call SaveInteger(udg_Hash,id,StringHash("DalaranTower|Fenix|Counter"),counter)
endif
endif
set t=null
set Dami=null
set caster=null
endfunction
function InitTrig_PlamyaFenixa takes nothing returns nothing
set gg_trg_PlamyaFenixa=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_PlamyaFenixa,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_PlamyaFenixa,Condition(function PlamyaFenixa_Conditions))
call TriggerAddAction(gg_trg_PlamyaFenixa,function PlamyaFenixa_Actions)
endfunction
function SpellDamage takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer h=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,h,StringHash("DalaranTower|Ispepel|Caster"))
local unit target=LoadUnitHandle(udg_Hash,h,StringHash("DalaranTower|Ispepel|Target"))
local integer counter=LoadInteger(udg_Hash,h,StringHash("DalaranTower|Ispepel|Count"))
local effect eff=LoadEffectHandle(udg_Hash,h,StringHash("DalaranTower|Ispepel|Effect"))
local real dmg=LoadReal(udg_Hash,h,StringHash("DalaranTower|Ispepel|Dmg"))
local real hp=GetUnitState(target,UNIT_STATE_LIFE)
if counter>0 and hp>0 then
call MagDamage(caster,target,dmg)
call SaveInteger(udg_Hash,h,StringHash("DalaranTower|Ispepel|Count"),counter-1)
else
call DestroyEffect(eff)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,h)
set h=GetHandleId(caster)
call SaveTimerHandle(udg_Hash,h,StringHash("DalaranTower|Ispepel|Timer"),null)
endif
set eff=null
set caster=null
set target=null
set t=null
endfunction
function Spell takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local integer h=GetHandleId(target)
local timer t=LoadTimerHandle(udg_Hash,h,StringHash("DalaranTower|Ispepel|Timer"))
local integer id=GetHandleId(t)
local real r=GetRandomReal(0.00,100.00)
local effect eff
local real chance=7.00
local real dmg=12.50
local real time=5.00
local real periodic=0.50
local integer counter=R2I(time/ periodic)
if(r<=chance)then
if(t==null)then
set t=CreateTimer()
set id=GetHandleId(t)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl",target,"overhead")
call SaveUnitHandle(udg_Hash,id,StringHash("DalaranTower|Ispepel|Caster"),caster)
call SaveUnitHandle(udg_Hash,id,StringHash("DalaranTower|Ispepel|Target"),target)
call SaveInteger(udg_Hash,id,StringHash("DalaranTower|Ispepel|Count"),counter)
call SaveEffectHandle(udg_Hash,id,StringHash("DalaranTower|Ispepel|Effect"),eff)
call SaveReal(udg_Hash,id,StringHash("DalaranTower|Ispepel|Dmg"),dmg)
call TimerStart(t,periodic,true,function SpellDamage)
else
call SaveUnitHandle(udg_Hash,id,StringHash("DalaranTower|Ispepel|Caster"),caster)
call SaveUnitHandle(udg_Hash,id,StringHash("DalaranTower|Ispepel|Target"),target)
call SaveInteger(udg_Hash,id,StringHash("DalaranTower|Ispepel|Count"),counter)
endif
endif
set eff=null
set caster=null
set target=null
set t=null
endfunction
function SpellCond takes nothing returns boolean
if(not(GetUnitAbilityLevel(GetAttacker(),'A06G')==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R017',GetOwningPlayer(GetAttacker()))==1))then
return false
endif
if(not(IsUnitEnemy(GetAttacker(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
return true
endfunction
function InitTrig_Ispepel takes nothing returns nothing
set gg_trg_Ispepel=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Ispepel,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Ispepel,Condition(function SpellCond))
call TriggerAddAction(gg_trg_Ispepel,function Spell)
endfunction
function Trig_Vendetta_Func002C takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A06D',GetTriggerUnit())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R014',GetOwningPlayer(GetTriggerUnit()))==1))then
return false
endif
return true
endfunction
function Trig_Vendetta_Conditions takes nothing returns boolean
if(not Trig_Vendetta_Func002C())then
return false
endif
return true
endfunction
function Trig_Vendetta_Func001Func001C takes nothing returns boolean
if(not(IsUnitEnemy(GetEnumUnit(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
return true
endfunction
function Trig_Vendetta_Func001A takes nothing returns nothing
if(Trig_Vendetta_Func001Func001C())then
call AddSpecialEffectTargetUnitBJ("overhead",GetEnumUnit(),"Units\\NightElf\\Wisp\\WispExplode.mdl")
call UnitDamageTargetBJ(GetTriggerUnit(),GetEnumUnit(),(GetUnitStateSwap(UNIT_STATE_MAX_MANA,GetEnumUnit())-GetUnitStateSwap(UNIT_STATE_MANA,GetEnumUnit())),ATTACK_TYPE_NORMAL,DAMAGE_TYPE_NORMAL)
call DestroyEffect(GetLastCreatedEffectBJ())
else
endif
endfunction
function Trig_Vendetta_Actions takes nothing returns nothing
call ForGroupBJ(GetUnitsInRangeOfLocAll(800.00,GetUnitLoc(GetTriggerUnit())),function Trig_Vendetta_Func001A)
endfunction
function InitTrig_Vendetta takes nothing returns nothing
set gg_trg_Vendetta=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Vendetta,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Vendetta,Condition(function Trig_Vendetta_Conditions))
call TriggerAddAction(gg_trg_Vendetta,function Trig_Vendetta_Actions)
endfunction
function VolsSnar_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevel(GetAttacker(),'A06C')==1))then
return false
endif
if(not(GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R013',true)>0))then
return false
endif
return true
endfunction
function VolsSnar_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local integer i
call SetUnitUserData(caster,(GetUnitUserData(caster)+1))
set i=GetUnitUserData(caster)
if(i==10)then
call SetUnitUserData(caster,0)
call MagDamage(caster,target,50.00)
else
endif
set caster=null
set target=null
endfunction
function InitTrig_VolsSnar takes nothing returns nothing
set gg_trg_VolsSnar=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_VolsSnar,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_VolsSnar,Condition(function VolsSnar_Conditions))
call TriggerAddAction(gg_trg_VolsSnar,function VolsSnar_Actions)
endfunction
function BombBrigade_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=GetRandomInt(0,3)
loop
exitwhen i==0
call CreateUnit(GetOwningPlayer(caster),'n017',x,y,bj_UNIT_FACING)
set i=i-1
endloop
set caster=null
endfunction
function BombBrigade_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A006')>0
endfunction
function InitTrig_BombBrigade takes nothing returns nothing
set gg_trg_BombBrigade=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BombBrigade,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_BombBrigade,Condition(function BombBrigade_Conditions))
call TriggerAddAction(gg_trg_BombBrigade,function BombBrigade_Actions)
endfunction
function EngineeringMiracle_Conditions takes nothing returns boolean
return IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetKillingUnit()))and GetUnitAbilityLevel(GetTriggerUnit(),'A0H8')>0 and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R04Q',true)>3
endfunction
function EngineeringMiracle_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local unit dummy=null
local real time=30.00
set dummy=CreateUnit(GetOwningPlayer(caster),'n026',x,y,0)
set eff=AddSpecialEffect("Abilities\\Weapons\\Bolt\\BoltImpact.mdl",x,y)
call DestroyEffect(eff)
call UnitApplyTimedLife(dummy,'eqwe',time)
call RemoveUnit(caster)
set eff=null
set dummy=null
set caster=null
endfunction
function InitTrig_EngineeringMiracle takes nothing returns nothing
set gg_trg_EngineeringMiracle=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_EngineeringMiracle,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_EngineeringMiracle,Condition(function EngineeringMiracle_Conditions))
call TriggerAddAction(gg_trg_EngineeringMiracle,function EngineeringMiracle_Actions)
endfunction
function RuneArmor_Condition takes nothing returns boolean
return GetUnitAbilityLevel(GetFilterUnit(),'A0H4')>0 and GetPlayerTechCount(GetOwningPlayer(GetFilterUnit()),'R04Q',true)>2
endfunction
function RuneArmor takes nothing returns nothing
local unit caster=GetEnumUnit()
local real hp=GetUnitState(caster,UNIT_STATE_LIFE)
local real max_hp=GetUnitState(caster,UNIT_STATE_MAX_LIFE)
local integer lvl=GetUnitAbilityLevel(caster,'A0H5')
local real percent=0.35
local real hp_proc=max_hp*percent
if hp<=hp_proc then
if lvl==0 then
call UnitAddAbility(caster,'A0H5')
endif
else
call UnitRemoveAbility(caster,'A0H5')
call UnitRemoveAbility(caster,'B01S')
endif
set caster=null
endfunction
function RuneArmor_Actions takes nothing returns nothing
local group g=CreateGroup()
local boolexpr cond=Condition(function RuneArmor_Condition)
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,cond)
call ForGroup(g,function RuneArmor)
call DestroyGroup(g)
call DestroyBoolExpr(cond)
set g=null
set cond=null
endfunction
function InitTrig_RuneArmor takes nothing returns nothing
set gg_trg_RuneArmor=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_RuneArmor,0.30)
call TriggerAddAction(gg_trg_RuneArmor,function RuneArmor_Actions)
endfunction
function RuneShieldUnit_Conditions takes nothing returns boolean
return IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetAttacker()))and GetUnitAbilityLevel(GetTriggerUnit(),'A0H3')>0 and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R04Q',true)>1
endfunction
function RuneShieldUnit_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real chance=15.00
local real power=60.00
local real cooldown=10.00
if Chance(caster,chance)then
call RuneShield_Cast(caster,power)
call AbilityCooldown(caster,'A0H3',cooldown)
endif
set caster=null
endfunction
function InitTrig_RuneShieldUnit takes nothing returns nothing
set gg_trg_RuneShieldUnit=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_RuneShieldUnit,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_RuneShieldUnit,Condition(function RuneShieldUnit_Conditions))
call TriggerAddAction(gg_trg_RuneShieldUnit,function RuneShieldUnit_Actions)
endfunction
function CuttingBlow_Conditions takes nothing returns boolean
return not IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)and IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetAttacker()))and GetUnitAbilityLevel(GetAttacker(),'A0H2')>0 and GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R04Q',true)>0
endfunction
function CuttingBlow_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real time=5.00
local real l__damage=10.00
local real chance=20.00
local string Type="Cutting"
local string dmgEffPath="Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodLarge0.mdl"
if Chance(caster,chance)then
call PeriodicDamage_Start(Type,dmgEffPath,caster,target,l__damage,time,0)
endif
set caster=null
set target=null
endfunction
function InitTrig_CuttingBlow takes nothing returns nothing
set gg_trg_CuttingBlow=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_CuttingBlow,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_CuttingBlow,Condition(function CuttingBlow_Conditions))
call TriggerAddAction(gg_trg_CuttingBlow,function CuttingBlow_Actions)
endfunction
function Zombification_Conditions takes nothing returns boolean
return not isUnitSummon(GetKillingUnit())and GetUnitAbilityLevel(GetTriggerUnit(),'A0GH')==0 and GetUnitAbilityLevel(GetKillingUnit(),'A0GH')>0 and isUnitEnemy(GetTriggerUnit(),GetKillingUnit())and not isUnitSummon(GetTriggerUnit())and not isUnitStruct(GetTriggerUnit())and not isUnitHero(GetTriggerUnit())
endfunction
function Zombification_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local unit target=GetTriggerUnit()
local integer id=GetUnitTypeId(caster)
local boolean isHero=isUnitHero(caster)
local real angle=GetUnitFacing(target)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local effect eff
if isHero then
set id='n025'
endif
call RemoveUnit(target)
set target=CreateUnit(GetOwningPlayer(caster),id,x,y,angle)
set eff=AddSpecialEffect("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",x,y)
call SetUnitAnimation(target,"birth")
call DestroyEffect(eff)
set eff=null
set caster=null
set target=null
endfunction
function InitTrig_Zombification takes nothing returns nothing
set gg_trg_Zombification=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Zombification,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Zombification,Condition(function Zombification_Conditions))
call TriggerAddAction(gg_trg_Zombification,function Zombification_Actions)
endfunction
function LifeAura_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'B01L')>0
endfunction
function LifeAura_filter takes nothing returns boolean
return GetOwningPlayer(bj_caster)==GetOwningPlayer(GetFilterUnit())and(GetUnitTypeId(GetFilterUnit())=='h02Z' or GetUnitTypeId(GetFilterUnit())=='h02W')
endfunction
function LifeAura_Actions takes nothing returns nothing
local boolexpr filter=Condition(function LifeAura_filter)
local unit caster=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local integer lvl
local unit target
local real range=1000.00
local real heal=5.00
set bj_caster=caster
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call HP_RESTORE(target,heal,null,10.00,0,255,0,0,96.00,0.75)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_LifeAura takes nothing returns nothing
set gg_trg_LifeAura=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_LifeAura,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_LifeAura,Condition(function LifeAura_Conditions))
call TriggerAddAction(gg_trg_LifeAura,function LifeAura_Actions)
endfunction
function Trig_Old_Magic_Conditions takes nothing returns boolean
if(not(GetSpellAbilityId()=='A0EN'))then
return false
endif
return true
endfunction
function Trig_Old_Magic_Actions takes nothing returns nothing
call CreateNUnitsAtLoc(30,udg_Unit[GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))],GetOwningPlayer(GetTriggerUnit()),GetUnitLoc(GetTriggerUnit()),bj_UNIT_FACING)
endfunction
function InitTrig_Old_Magic takes nothing returns nothing
set gg_trg_Old_Magic=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Old_Magic,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Old_Magic,Condition(function Trig_Old_Magic_Conditions))
call TriggerAddAction(gg_trg_Old_Magic,function Trig_Old_Magic_Actions)
endfunction
function Trig_Berserks_Conditions takes nothing returns boolean
if(not(GetResearched()=='R03J'))then
return false
endif
return true
endfunction
function Trig_Berserks_Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R03J',GetOwningPlayer(GetTriggerUnit()))==4))then
return false
endif
return true
endfunction
function Trig_Berserks_Actions takes nothing returns nothing
if(Trig_Berserks_Func001C())then
set udg_Unit[GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))]='o00E'
else
endif
endfunction
function InitTrig_Berserks takes nothing returns nothing
set gg_trg_Berserks=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Berserks,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_Berserks,Condition(function Trig_Berserks_Conditions))
call TriggerAddAction(gg_trg_Berserks,function Trig_Berserks_Actions)
endfunction
function Bezymie_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetKillingUnit(),'B01F')>0
endfunction
function Bezymie_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local integer lvl
local integer lvlAb=GetUnitAbilityLevel(caster,'A0D3')
local real time
local effect eff
set time=30.00
if lvlAb<1 then
call UnitAddAbility(caster,'A0D3')
endif
if lvlAb<5 then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",caster,"head")
call IncUnitAbilityLevel(caster,'A0D3')
call TriggerSleepAction(time)
call DecUnitAbilityLevel(caster,'A0D3')
call DestroyEffect(eff)
endif
set eff=null
set caster=null
endfunction
function InitTrig_Bezymie takes nothing returns nothing
set gg_trg_Bezymie=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Bezymie,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Bezymie,Condition(function Bezymie_Conditions))
call TriggerAddAction(gg_trg_Bezymie,function Bezymie_Actions)
endfunction
function BoeboyDyx_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetKillingUnit(),'B01E')>0 and IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)==false
endfunction
function BoeboyDyx_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local string s
local real hp=75.00
set s="+"+I2S(R2I(hp))+" hp"
call HP_RESTORE(caster,hp,s,10.00,0,255,0,0,96.00,0.75)
set caster=null
endfunction
function InitTrig_BoeboyDyx takes nothing returns nothing
set gg_trg_BoeboyDyx=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BoeboyDyx,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_BoeboyDyx,Condition(function BoeboyDyx_Conditions))
call TriggerAddAction(gg_trg_BoeboyDyx,function BoeboyDyx_Actions)
endfunction
function DyxiPredkov_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A0CY')>0 and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R03F',true)>1 and IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)==false
endfunction
function DyxiPredkov_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real angle=GetUnitFacing(caster)+180
local player p=GetOwningPlayer(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local real x1
local real y1
local real chance=20.00
if Chance(caster,chance)then
set x1=x+200*Cos(angle*bj_DEGTORAD)
set y1=y+200*Sin(angle*bj_DEGTORAD)
if(GetPlayerTechCount(p,'R03U',true)==1)then
call CreateUnit(GetOwningPlayer(caster),'o00I',x1,y1,angle-180)
else
call CreateUnit(GetOwningPlayer(caster),'o00G',x1,y1,angle-180)
endif
set eff=AddSpecialEffect("Abilities\\Spells\\Orc\\AncestralSpirit\\AncestralSpiritCaster.mdl",x,y)
call TriggerSleepAction(1.00)
call DestroyEffect(eff)
endif
set p=null
set eff=null
set caster=null
endfunction
function InitTrig_DyxiPredkov takes nothing returns nothing
set gg_trg_DyxiPredkov=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DyxiPredkov,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_DyxiPredkov,Condition(function DyxiPredkov_Conditions))
call TriggerAddAction(gg_trg_DyxiPredkov,function DyxiPredkov_Actions)
endfunction
function BloodAura_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'B019')>0
endfunction
function BloodAura_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local integer lvl
local integer lvlAb=GetUnitAbilityLevel(caster,'A0CB')
local real time
local effect eff
set time=10.00
if lvlAb<1 then
call UnitAddAbility(caster,'A0CB')
endif
if lvlAb<11 then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",caster,"chest")
call IncUnitAbilityLevel(caster,'A0CB')
call TriggerSleepAction(time)
call DecUnitAbilityLevel(caster,'A0CB')
call DestroyEffect(eff)
endif
set eff=null
set caster=null
endfunction
function InitTrig_BloodAura takes nothing returns nothing
set gg_trg_BloodAura=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BloodAura,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_BloodAura,Condition(function BloodAura_Conditions))
call TriggerAddAction(gg_trg_BloodAura,function BloodAura_Actions)
endfunction
function BloodOrcs_Conditions takes nothing returns boolean
return GetResearched()=='R03A' and GetPlayerTechCount(Owner(GetTriggerUnit()),'R03A',true)==4
endfunction
function BloodOrcs_Actions takes nothing returns nothing
local integer id=OwnerId(GetTriggerUnit())
set bj_unitDamageType[id+1]=5
set udg_Unit[id+1]='h02G'
endfunction
function InitTrig_BloodOrcs takes nothing returns nothing
set gg_trg_BloodOrcs=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BloodOrcs,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_BloodOrcs,Condition(function BloodOrcs_Conditions))
call TriggerAddAction(gg_trg_BloodOrcs,function BloodOrcs_Actions)
endfunction
function BerserkFrenzy_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0BY'
endfunction
function BerserkFrenzy_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local string s
local real hp=100.00
set s="+"+I2S(R2I(hp))+" hp"
call HP_RESTORE(caster,hp,s,10.00,0,255,0,0,96.00,0.75)
set caster=null
endfunction
function InitTrig_BerserkFrenzy takes nothing returns nothing
set gg_trg_BerserkFrenzy=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BerserkFrenzy,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_BerserkFrenzy,Condition(function BerserkFrenzy_Conditions))
call TriggerAddAction(gg_trg_BerserkFrenzy,function BerserkFrenzy_Actions)
endfunction
function Grabej_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local player p1=GetOwningPlayer(caster)
local player p2=GetOwningPlayer(target)
local string s
local real chance=20.00
local integer MinGold=1
local integer MaxGold=4
local integer Gold=GetRandomInt(MinGold,MaxGold)
if Chance(caster,chance)then
call AdjustPlayerStateBJ(-Gold,p2,PLAYER_STATE_RESOURCE_GOLD)
if GetLocalPlayer()==p2 then
set s="-"+I2S(Gold)
call TextUp(s,target,11,0,255,0,60,96.00,2.00)
endif
call AdjustPlayerStateBJ(Gold,p1,PLAYER_STATE_RESOURCE_GOLD)
if GetLocalPlayer()==p1 then
set s="+"+I2S(Gold)
call TextUp(s,caster,11,0,255,0,60,96.00,2.00)
endif
endif
set p1=null
set p2=null
set caster=null
set target=null
endfunction
function Grabej_Conditions takes nothing returns boolean
local boolean lvl=GetUnitAbilityLevel(GetAttacker(),'A0BX')>0 and GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R03A',true)>1
return lvl and GetPlayerGold(Owner(GetTriggerUnit()))>=4 and isUnitStruct(GetTriggerUnit())
endfunction
function InitTrig_Grabej takes nothing returns nothing
set gg_trg_Grabej=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Grabej,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Grabej,Condition(function Grabej_Conditions))
call TriggerAddAction(gg_trg_Grabej,function Grabej_Actions)
endfunction
function ZahvatKontrolya_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'A0AK')==1 and GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R031',true)>3 and isUnitSummon(GetTriggerUnit())and isUnitEnemy(GetTriggerUnit(),GetAttacker())and not isUnitHero(GetAttacker())
endfunction
function ZahvatKontrolya_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local effect eff
local real chance=40.00
if Chance(caster,chance)then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\ControlMagic\\ControlMagicTarget.mdl",target,"overhead")
call SetUnitOwner(target,GetOwningPlayer(caster),true)
call SetUnitState(target,UNIT_STATE_LIFE,GetUnitState(target,UNIT_STATE_MAX_LIFE))
call TriggerSleepAction(1.00)
call DestroyEffect(eff)
endif
set caster=null
set target=null
set eff=null
endfunction
function InitTrig_ZahvatKontrolya takes nothing returns nothing
set gg_trg_ZahvatKontrolya=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ZahvatKontrolya,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_ZahvatKontrolya,Condition(function ZahvatKontrolya_Conditions))
call TriggerAddAction(gg_trg_ZahvatKontrolya,function ZahvatKontrolya_Actions)
endfunction
function AuraAntimagic_Conditions takes nothing returns boolean
return UnitHasBuffBJ(GetTriggerUnit(),'B012')==true
endfunction
function AuraFilter takes nothing returns boolean
return IsPlayerEnemy(GetOwningPlayer(GetFilterUnit()),GetOwningPlayer(bj_caster))and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and GetUnitTypeId(GetFilterUnit())=='h024'
endfunction
function AuraAntimagic_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local unit damager
local effect eff
set bj_caster=caster
call GroupEnumUnitsInRange(g,x,y,725,Condition(function AuraFilter))
set damager=FirstOfGroup(g)
call DestroyGroup(g)
if damager!=null then
call MagDamage(damager,caster,20.00)
endif
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl",caster,"origin")
call DestroyEffect(eff)
set eff=null
set g=null
set damager=null
set caster=null
endfunction
function InitTrig_AuraAntimagic takes nothing returns nothing
set gg_trg_AuraAntimagic=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_AuraAntimagic,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_AuraAntimagic,Condition(function AuraAntimagic_Conditions))
call TriggerAddAction(gg_trg_AuraAntimagic,function AuraAntimagic_Actions)
endfunction
function AuraPredkov_Conditions takes nothing returns boolean
return UnitHasBuffBJ(GetKillingUnit(),'B014')==true
endfunction
function AuraPredkov_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local real r=GetRandomReal(0.00,100.00)
local real chance=100.00
if(IsUnitType(caster,UNIT_TYPE_HERO)==true)then
set chance=2.00
endif
if(r<=chance)then
call UnitResetCooldown(caster)
endif
set caster=null
endfunction
function InitTrig_AuraPredkov takes nothing returns nothing
set gg_trg_AuraPredkov=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_AuraPredkov,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_AuraPredkov,Condition(function AuraPredkov_Conditions))
call TriggerAddAction(gg_trg_AuraPredkov,function AuraPredkov_Actions)
endfunction
function Storojili_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0AJ'
endfunction
function Storojili_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=12
local real r=360/ lvl
local integer q=1
local real x
local real y
loop
exitwhen q>lvl
set x=GetUnitX(caster)+300.00*Cos((r*q)*bj_DEGTORAD)
set y=GetUnitY(caster)+300.00*Sin((r*q)*bj_DEGTORAD)
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'o00A',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',10.00)
set q=q+1
endloop
set caster=null
endfunction
function InitTrig_Storojili takes nothing returns nothing
set gg_trg_Storojili=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Storojili,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Storojili,Condition(function Storojili_Conditions))
call TriggerAddAction(gg_trg_Storojili,function Storojili_Actions)
endfunction
function YarostByri_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0A6'
endfunction
function YarostByri_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real time=20.00
call TimedAbility(caster,'A0A7',time)
call TimedEffectTarget("Abilities\\Spells\\Orc\\Purge\\PurgeBuffTarget.mdl",caster,"origin",time)
set caster=null
endfunction
function InitTrig_YarostByri takes nothing returns nothing
set gg_trg_YarostByri=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_YarostByri,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_YarostByri,Condition(function YarostByri_Conditions))
call TriggerAddAction(gg_trg_YarostByri,function YarostByri_Actions)
endfunction
function GromAndMolnia_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A0A5',GetAttacker())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R02S',GetOwningPlayer(GetAttacker()))>3))then
return false
endif
return true
endfunction
function GromAndMolnia_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real chance=10.00
if Chance(caster,chance)then
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'h021',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',3.00)
call IssueTargetOrder(bj_lastCreatedUnit,"chainlightning",target)
endif
set caster=null
set target=null
endfunction
function InitTrig_GromAndMolnia takes nothing returns nothing
set gg_trg_GromAndMolnia=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_GromAndMolnia,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_GromAndMolnia,Condition(function GromAndMolnia_Conditions))
call TriggerAddAction(gg_trg_GromAndMolnia,function GromAndMolnia_Actions)
endfunction
function OldAura_timer takes nothing returns boolean
return GetPlayerTechCount(GetOwningPlayer(GetFilterUnit()),'R02Q',true)>0 and IsUnitType(GetFilterUnit(),UNIT_TYPE_HERO)==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_SUMMONED)==false
endfunction
function OLD_AURA_Actions takes nothing returns nothing
local boolexpr filter=Condition(function OldAura_timer)
local group g=CreateGroup()
local unit target
call GroupEnumUnitsInRange(g,0,0,99999999,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
if(GetUnitAbilityLevel(target,'B01K')>0)then
call UnitAddAbility(target,'A0ET')
else
call UnitRemoveAbility(target,'A0ET')
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set target=null
set filter=null
endfunction
function InitTrig_OLD_AURA takes nothing returns nothing
set gg_trg_OLD_AURA=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_OLD_AURA,0.10)
call TriggerAddAction(gg_trg_OLD_AURA,function OLD_AURA_Actions)
endfunction
function KRIT_AURA_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetEventDamageSource(),'B013')>0 and LoadBoolean(udg_Hash,GetHandleId(GetTriggerUnit()),2)==true
endfunction
function KRIT_AURA_Actions takes nothing returns nothing
local unit caster=GetEventDamageSource()
local unit target=GetTriggerUnit()
local integer id=GetHandleId(target)
local real dmg=GetEventDamage()
local real r=GetRandomReal(0.00,100.00)
local real crit
local string s
local real chance=25.00
local real procent=3.00
if(r<=chance)then
set crit=(dmg*procent)-dmg
call SaveBoolean(udg_Hash,id,2,false)
set s=(I2S(R2I(dmg*procent))+"!")
call TextUp(s,target,10,255,51,0,0,60.00,0.75)
call MagDamage(caster,target,crit)
call SaveBoolean(udg_Hash,id,2,true)
endif
set caster=null
set target=null
endfunction
function InitTrig_KRIT_AURA takes nothing returns nothing
set gg_trg_KRIT_AURA=CreateTrigger()
call TriggerAddCondition(gg_trg_KRIT_AURA,Condition(function KRIT_AURA_Conditions))
call TriggerAddAction(gg_trg_KRIT_AURA,function KRIT_AURA_Actions)
endfunction
function DEATH_AURA_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetKillingUnit(),'B00V')>0 and IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true and IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)!=true and IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)!=true
endfunction
function DEATH_AURA_Actions takes nothing returns nothing
local real r=GetRandomReal(0.00,100.00)
local unit caster=GetKillingUnit()
local unit target=GetTriggerUnit()
local integer id=GetUnitTypeId(caster)
local player p=GetOwningPlayer(caster)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local effect eff
local real chance=40.00
if(r<=chance)then
call RemoveUnit(target)
call CreateUnit(p,id,x,y,bj_UNIT_FACING)
set eff=AddSpecialEffect("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",x,y)
call DestroyEffect(eff)
endif
set target=null
set p=null
set eff=null
set caster=null
endfunction
function InitTrig_DEATH_AURA takes nothing returns nothing
set gg_trg_DEATH_AURA=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DEATH_AURA,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_DEATH_AURA,Condition(function DEATH_AURA_Conditions))
call TriggerAddAction(gg_trg_DEATH_AURA,function DEATH_AURA_Actions)
endfunction
function NIGHT_AURA_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetEventDamageSource(),'B00U')>0 and LoadBoolean(udg_Hash,GetHandleId(GetTriggerUnit()),1)==true and(GetFloatGameState(GAME_STATE_TIME_OF_DAY)<6.00 or GetFloatGameState(GAME_STATE_TIME_OF_DAY)>18.00)
endfunction
function NIGHT_AURA_Actions takes nothing returns nothing
local unit caster=GetEventDamageSource()
local unit target=GetTriggerUnit()
local integer id=GetHandleId(target)
local real dmg=GetEventDamage()
local string s
local real procent=0.40
set dmg=dmg*procent
call SaveBoolean(udg_Hash,id,1,false)
set s=(I2S(R2I(dmg))+"!")
call TextUp(s,target,10,255,51,0,0,60.00,0.75)
call MagDamage(caster,target,dmg)
call SaveBoolean(udg_Hash,id,1,true)
set caster=null
set target=null
endfunction
function InitTrig_NIGHT_AURA takes nothing returns nothing
set gg_trg_NIGHT_AURA=CreateTrigger()
call TriggerAddCondition(gg_trg_NIGHT_AURA,Condition(function NIGHT_AURA_Conditions))
call TriggerAddAction(gg_trg_NIGHT_AURA,function NIGHT_AURA_Actions)
endfunction
function HEAVEN_AURA_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'B00T')>0
endfunction
function HEAVEN_AURA_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local integer id=GetUnitTypeId(caster)
local real r=GetRandomReal(0.00,100.00)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local unit dami
local real time=5.00
local real chance=32.00
if Chance(caster,chance)then
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl",x,y)
call RemoveUnit(caster)
set dami=CreateUnit(p,id,x,y,bj_UNIT_FACING)
call DestroyEffect(eff)
call SetUnitState(dami,UNIT_STATE_MANA,GetUnitState(dami,UNIT_STATE_MAX_MANA))
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\DivineShield\\DivineShieldTarget.mdl",dami,"origin")
call SetUnitInvulnerable(dami,true)
call TriggerSleepAction(time)
call SetUnitInvulnerable(dami,false)
call DestroyEffect(eff)
endif
set dami=null
set eff=null
set p=null
set caster=null
endfunction
function InitTrig_HEAVEN_AURA takes nothing returns nothing
set gg_trg_HEAVEN_AURA=CreateTrigger()
call TriggerAddCondition(gg_trg_HEAVEN_AURA,Condition(function HEAVEN_AURA_Conditions))
call TriggerAddAction(gg_trg_HEAVEN_AURA,function HEAVEN_AURA_Actions)
endfunction
function Detonation_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A092'
endfunction
function Detonation takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real dmg=bj_real
local unit target=GetEnumUnit()
if(IsUnitEnemy(caster,GetOwningPlayer(target))==true)then
call MagDamage(caster,target,dmg)
endif
set caster=null
set target=null
endfunction
function Detonation_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local group g=CreateGroup()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real range=125.00
local real dmg=25.00
set bj_real=dmg
call GroupEnumUnitsInRange(g,x,y,range,null)
call ForGroup(g,function Detonation)
call DestroyGroup(g)
call KillUnit(caster)
set g=null
set caster=null
endfunction
function InitTrig_Detonation takes nothing returns nothing
set gg_trg_Detonation=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Detonation,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Detonation,Condition(function Detonation_Conditions))
call TriggerAddAction(gg_trg_Detonation,function Detonation_Actions)
endfunction
function Tarakanshina_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A08R',GetTriggerUnit())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R02I',GetOwningPlayer(GetTriggerUnit()))>0))then
return false
endif
return true
endfunction
function Tarakanshina_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real hp
local integer i=1
local string s
local real hpbuff=12.00
local real chance=15.00
local integer max=5
local real Reload=15.00
if Chance(caster,chance)then
if GetUnitUserData(caster)==0 then
call SetUnitUserData(caster,1)
loop
exitwhen i>max
set hp=(GetUnitState(caster,UNIT_STATE_LIFE)+hpbuff)
call SetUnitState(caster,UNIT_STATE_LIFE,hp)
set s=("+"+I2S(R2I(hpbuff))+" hp")
if(GetLocalPlayer()==GetOwningPlayer(caster))then
call TextUp(s,caster,10,0,255,0,0,60.00,0.75)
endif
call TriggerSleepAction(1.00)
set Reload=Reload-1.00
set i=i+1
endloop
call TriggerSleepAction(Reload)
call SetUnitUserData(caster,0)
endif
endif
set caster=null
endfunction
function InitTrig_Tarakanshina takes nothing returns nothing
set gg_trg_Tarakanshina=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Tarakanshina,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Tarakanshina,Condition(function Tarakanshina_Conditions))
call TriggerAddAction(gg_trg_Tarakanshina,function Tarakanshina_Actions)
endfunction
function Jychara_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A08S',GetAttacker())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R02I',GetOwningPlayer(GetAttacker()))>3))then
return false
endif
return true
endfunction
function Jychara_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local integer lvlAb=GetUnitAbilityLevel(caster,'A08T')
local effect eff
local real time=10.00
if lvlAb<6 then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdl",caster,"chest")
call IncUnitAbilityLevel(caster,'A08T')
call TriggerSleepAction(time)
call DecUnitAbilityLevel(caster,'A08T')
call DestroyEffect(eff)
endif
set eff=null
set caster=null
endfunction
function InitTrig_Jychara takes nothing returns nothing
set gg_trg_Jychara=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Jychara,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Jychara,Condition(function Jychara_Conditions))
call TriggerAddAction(gg_trg_Jychara,function Jychara_Actions)
endfunction
function Pancir_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A08Q')==1 and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R02I',true)>2 and IsUnitEnemy(GetAttacker(),GetOwningPlayer(GetTriggerUnit()))==true
endfunction
function Pancir_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetAttacker()
local real dmg=12.00
call MagDamage(caster,target,dmg)
set caster=null
set target=null
endfunction
function InitTrig_Pancir takes nothing returns nothing
set gg_trg_Pancir=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Pancir,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Pancir,Condition(function Pancir_Conditions))
call TriggerAddAction(gg_trg_Pancir,function Pancir_Actions)
endfunction
function AuraPleti_Conditions takes nothing returns boolean
return UnitHasBuffBJ(GetAttacker(),'B00N')==true
endfunction
function AuraPleti_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local real hp=(GetUnitState(caster,UNIT_STATE_LIFE)+10.00)
call SetUnitState(caster,UNIT_STATE_LIFE,hp)
set caster=null
endfunction
function InitTrig_AuraPleti takes nothing returns nothing
set gg_trg_AuraPleti=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_AuraPleti,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_AuraPleti,Condition(function AuraPleti_Conditions))
call TriggerAddAction(gg_trg_AuraPleti,function AuraPleti_Actions)
endfunction
function Gylefication_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A08F',GetKillingUnit())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R02F',GetOwningPlayer(GetKillingUnit()))>1))then
return false
endif
if(not(IsUnitEnemy(GetKillingUnit(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
return true
endfunction
function Gylefication_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
set bj_lastCreatedEffect=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",target,"origin")
call CreateUnit(GetOwningPlayer(caster),'u014',x,y,bj_UNIT_FACING)
call DestroyEffect(bj_lastCreatedEffect)
set caster=null
set target=null
endfunction
function InitTrig_Gylefication takes nothing returns nothing
set gg_trg_Gylefication=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Gylefication,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Gylefication,Condition(function Gylefication_Conditions))
call TriggerAddAction(gg_trg_Gylefication,function Gylefication_Actions)
endfunction
function YarostVyrd_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A084',GetKillingUnit())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R02F',GetOwningPlayer(GetKillingUnit()))>3))then
return false
endif
if(not(IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetKillingUnit()))==true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
if(not(GetKillingUnit()!=null))then
return false
endif
return true
endfunction
function YarostVyrd_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local effect eff
local integer i=GetUnitUserData(caster)
if i==0 then
call SetUnitUserData(caster,1)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl",caster,"origin")
call UnitAddAbility(caster,'A086')
call TriggerSleepAction(10.00)
call UnitRemoveAbility(caster,'A086')
call DestroyEffect(eff)
call SetUnitUserData(caster,0)
endif
set caster=null
set eff=null
endfunction
function InitTrig_YarostVyrd takes nothing returns nothing
set gg_trg_YarostVyrd=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_YarostVyrd,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_YarostVyrd,Condition(function YarostVyrd_Conditions))
call TriggerAddAction(gg_trg_YarostVyrd,function YarostVyrd_Actions)
endfunction
function Trig_Nekromantia_Conditions takes nothing returns boolean
if(not(GetResearched()=='R023'))then
return false
endif
return true
endfunction
function Trig_Nekromantia_Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R023',GetOwningPlayer(GetTriggerUnit()))>3))then
return false
endif
return true
endfunction
function Trig_Nekromantia_Actions takes nothing returns nothing
if(Trig_Nekromantia_Func001C())then
call SetPlayerTechResearchedSwap('R024',1,GetOwningPlayer(GetTriggerUnit()))
else
endif
endfunction
function InitTrig_Nekromantia takes nothing returns nothing
set gg_trg_Nekromantia=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Nekromantia,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_Nekromantia,Condition(function Trig_Nekromantia_Conditions))
call TriggerAddAction(gg_trg_Nekromantia,function Trig_Nekromantia_Actions)
endfunction
function FuryOfDamned_Condition takes nothing returns boolean
return GetUnitAbilityLevel(GetFilterUnit(),'A07H')>0 and GetPlayerTechCount(GetOwningPlayer(GetFilterUnit()),'R023',true)>2
endfunction
function FuryOfDamned takes nothing returns nothing
local unit caster=GetEnumUnit()
local real hp=GetUnitState(caster,UNIT_STATE_LIFE)
local real max_hp=GetUnitState(caster,UNIT_STATE_MAX_LIFE)
local integer lvl=GetUnitAbilityLevel(caster,'A07J')
local real percent=0.45
local real hp_proc=max_hp*percent
if hp<=hp_proc then
if lvl==0 then
call UnitAddAbility(caster,'A07J')
endif
else
call UnitRemoveAbility(caster,'A07J')
call UnitRemoveAbility(caster,'B00I')
endif
set caster=null
endfunction
function FuryOfDamned_Actions takes nothing returns nothing
local group g=CreateGroup()
local boolexpr cond=Condition(function FuryOfDamned_Condition)
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,cond)
call ForGroup(g,function FuryOfDamned)
call DestroyGroup(g)
call DestroyBoolExpr(cond)
set g=null
set cond=null
endfunction
function InitTrig_FuryOfDamned takes nothing returns nothing
set gg_trg_FuryOfDamned=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_FuryOfDamned,0.30)
call TriggerAddAction(gg_trg_FuryOfDamned,function FuryOfDamned_Actions)
endfunction
function SkeletPowerDamage takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer h=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,h,StringHash("Nekr|Yveche|Caster"))
local unit target=LoadUnitHandle(udg_Hash,h,StringHash("Nekr|Yveche|Target"))
local integer counter=LoadInteger(udg_Hash,h,StringHash("Nekr|Yveche|Count"))
local effect eff=LoadEffectHandle(udg_Hash,h,StringHash("Nekr|Yveche|Effect"))
local real dmg=LoadReal(udg_Hash,h,StringHash("Nekr|Yveche|Dmg"))
local real hp=GetUnitState(target,UNIT_STATE_LIFE)
if counter>0 and hp>0 then
call MagDamage(caster,target,dmg)
call SaveInteger(udg_Hash,h,StringHash("Nekr|Yveche|Count"),counter-1)
else
call DestroyEffect(eff)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,h)
set h=GetHandleId(caster)
call SaveTimerHandle(udg_Hash,h,StringHash("Nekr|Yveche|Timer"),null)
endif
set eff=null
set caster=null
set target=null
set t=null
endfunction
function SkeletPower takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local integer h=GetHandleId(target)
local timer t=LoadTimerHandle(udg_Hash,h,StringHash("Nekr|Yveche|Timer"))
local integer id=GetHandleId(t)
local real r=GetRandomReal(0.00,100.00)
local effect eff
local real chance=10.00
local real dmg=15.00
local real time=5.00
local real periodic=1.00
local integer counter=R2I(time/ periodic)
if Chance(caster,chance)then
if(t==null)then
set t=CreateTimer()
set id=GetHandleId(t)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\Cripple\\CrippleTarget.mdl",target,"origin")
call SaveUnitHandle(udg_Hash,id,StringHash("Nekr|Yveche|Caster"),caster)
call SaveUnitHandle(udg_Hash,id,StringHash("Nekr|Yveche|Target"),target)
call SaveInteger(udg_Hash,id,StringHash("Nekr|Yveche|Count"),counter)
call SaveEffectHandle(udg_Hash,id,StringHash("Nekr|Yveche|Effect"),eff)
call SaveReal(udg_Hash,id,StringHash("Nekr|Yveche|Dmg"),dmg)
call TimerStart(t,periodic,true,function SkeletPowerDamage)
else
call SaveUnitHandle(udg_Hash,id,StringHash("Nekr|Yveche|Caster"),caster)
call SaveUnitHandle(udg_Hash,id,StringHash("Nekr|Yveche|Target"),target)
call SaveInteger(udg_Hash,id,StringHash("Nekr|Yveche|Count"),counter)
endif
endif
set eff=null
set caster=null
set target=null
set t=null
endfunction
function SkeletPowerCond takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'A07G')>0 and GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R023',true)>1 and IsUnitEnemy(GetAttacker(),GetOwningPlayer(GetTriggerUnit()))==true
endfunction
function InitTrig_Yveche takes nothing returns nothing
set gg_trg_Yveche=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Yveche,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Yveche,Condition(function SkeletPowerCond))
call TriggerAddAction(gg_trg_Yveche,function SkeletPower)
endfunction
function Trig_Zaxvatt_Conditions takes nothing returns boolean
if(not(GetSpellAbilityId()=='A000'))then
return false
endif
return true
endfunction
function Trig_Zaxvatt_Func001Func001Func004C takes nothing returns boolean
if(not(IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
if(not(IsUnitType(GetEnumUnit(),UNIT_TYPE_HERO)!=true))then
return false
endif
if(not(IsUnitAliveBJ(GetEnumUnit())==true))then
return false
endif
if(not(IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetEnumUnit()))==true))then
return false
endif
if(not(GetUnitTypeId(GetEnumUnit())!='h01O'))then
return false
endif
if(not(GetUnitTypeId(GetEnumUnit())!='hprt'))then
return false
endif
return true
endfunction
function Trig_Zaxvatt_Func001Func001C takes nothing returns boolean
if(not Trig_Zaxvatt_Func001Func001Func004C())then
return false
endif
return true
endfunction
function Trig_Zaxvatt_Func001A takes nothing returns nothing
if(Trig_Zaxvatt_Func001Func001C())then
call AddSpecialEffectTargetUnitBJ("origin",GetEnumUnit(),"Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl")
call SetUnitOwner(GetEnumUnit(),GetOwningPlayer(GetTriggerUnit()),true)
call DestroyEffect(GetLastCreatedEffectBJ())
else
endif
endfunction
function Trig_Zaxvatt_Actions takes nothing returns nothing
call ForGroupBJ(GetUnitsInRangeOfLocAll(700.00,GetUnitLoc(GetTriggerUnit())),function Trig_Zaxvatt_Func001A)
endfunction
function InitTrig_Zaxvatt takes nothing returns nothing
set gg_trg_Zaxvatt=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Zaxvatt,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Zaxvatt,Condition(function Trig_Zaxvatt_Conditions))
call TriggerAddAction(gg_trg_Zaxvatt,function Trig_Zaxvatt_Actions)
endfunction
function Mest_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A06Z',GetTriggerUnit())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R01G',GetOwningPlayer(GetTriggerUnit()))>2))then
return false
endif
if(not(IsUnitEnemy(GetKillingUnit(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
if(not(GetKillingUnit()!=null))then
return false
endif
return true
endfunction
function Mest_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetKillingUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real dmg=100.00
if isUnitStruct(target)then
set dmg=dmg*0.5
endif
set bj_lastCreatedEffect=AddSpecialEffect("Abilities\\Spells\\Undead\\Impale\\ImpaleHitTarget.mdl",x,y)
call MagDamage(caster,target,dmg)
call DestroyEffect(bj_lastCreatedEffect)
set caster=null
set target=null
endfunction
function InitTrig_Mest takes nothing returns nothing
set gg_trg_Mest=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Mest,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Mest,Condition(function Mest_Conditions))
call TriggerAddAction(gg_trg_Mest,function Mest_Actions)
endfunction
function Podchinenie_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A06W',GetAttacker())==1))then
return false
endif
if(not(GetPlayerTechCountSimple('R01G',GetOwningPlayer(GetAttacker()))>3))then
return false
endif
if(not(IsUnitEnemy(GetAttacker(),GetOwningPlayer(GetTriggerUnit()))==true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)!=true))then
return false
endif
return true
endfunction
function Podchinenie_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real chance=12.00
if Chance(caster,chance)then
set bj_lastCreatedEffect=AddSpecialEffect("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",x,y)
call SetUnitOwner(target,GetOwningPlayer(caster),true)
call DestroyEffect(bj_lastCreatedEffect)
endif
set caster=null
set target=null
endfunction
function InitTrig_Podchinenie takes nothing returns nothing
set gg_trg_Podchinenie=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Podchinenie,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Podchinenie,Condition(function Podchinenie_Conditions))
call TriggerAddAction(gg_trg_Podchinenie,function Podchinenie_Actions)
endfunction
function AuraProklyat_Conditions takes nothing returns boolean
return(GetUnitAbilityLevel(GetKillingUnit(),'B00E')>0)
endfunction
function AuraProklyat_Actions takes nothing returns nothing
local unit target=GetTriggerUnit()
local unit caster=GetKillingUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
if IsUnitType(target,UNIT_TYPE_SUMMONED)!=true then
set bj_lastCreatedEffect=AddSpecialEffect("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",x,y)
call CreateUnit(GetOwningPlayer(caster),'u00O',x,y,bj_UNIT_FACING)
call DestroyEffect(bj_lastCreatedEffect)
endif
set caster=null
set target=null
endfunction
function InitTrig_AuraProklyat takes nothing returns nothing
set gg_trg_AuraProklyat=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_AuraProklyat,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_AuraProklyat,Condition(function AuraProklyat_Conditions))
call TriggerAddAction(gg_trg_AuraProklyat,function AuraProklyat_Actions)
endfunction
function Reznya_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevel(GetAttacker(),'A03R')>0))then
return false
endif
if(not(GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R00T',true)>3))then
return false
endif
return true
endfunction
function Reznya_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local integer i=GetUnitUserData(caster)
local integer hitCount=5
call SetUnitUserData(caster,(i+1))
set i=GetUnitUserData(caster)
if i==hitCount then
call SetUnitUserData(caster,0)
if not isUnitHero(target)and not isUnitStruct(target)then
call MagDamage(caster,target,999999.00)
endif
endif
set caster=null
set target=null
endfunction
function InitTrig_Reznya takes nothing returns nothing
set gg_trg_Reznya=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Reznya,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Reznya,Condition(function Reznya_Conditions))
call TriggerAddAction(gg_trg_Reznya,function Reznya_Actions)
endfunction
function Trig_NevidimkaGrade_Conditions takes nothing returns boolean
if(not(GetResearched()=='R00T'))then
return false
endif
return true
endfunction
function Trig_NevidimkaGrade_Func001Func001A takes nothing returns nothing
call UnitAddAbilityBJ('A03M',GetEnumUnit())
endfunction
function Trig_NevidimkaGrade_Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R00T',GetOwningPlayer(GetTriggerUnit()))==1))then
return false
endif
return true
endfunction
function Trig_NevidimkaGrade_Actions takes nothing returns nothing
if(Trig_NevidimkaGrade_Func001C())then
call ForGroupBJ(GetUnitsOfPlayerAndTypeId(GetOwningPlayer(GetTriggerUnit()),'h01F'),function Trig_NevidimkaGrade_Func001Func001A)
else
endif
endfunction
function InitTrig_NevidimkaGrade takes nothing returns nothing
set gg_trg_NevidimkaGrade=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_NevidimkaGrade,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_NevidimkaGrade,Condition(function Trig_NevidimkaGrade_Conditions))
call TriggerAddAction(gg_trg_NevidimkaGrade,function Trig_NevidimkaGrade_Actions)
endfunction
function Trig_Nevidimka_Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R00T',GetOwningPlayer(GetTriggerUnit()))>0))then
return false
endif
if(not(GetUnitTypeId(GetTriggerUnit())=='h01F'))then
return false
endif
return true
endfunction
function Trig_Nevidimka_Conditions takes nothing returns boolean
if(not Trig_Nevidimka_Func001C())then
return false
endif
return true
endfunction
function Trig_Nevidimka_Actions takes nothing returns nothing
call UnitAddAbilityBJ('A03M',GetTriggerUnit())
endfunction
function InitTrig_Nevidimka takes nothing returns nothing
set gg_trg_Nevidimka=CreateTrigger()
call TriggerRegisterEnterRectSimple(gg_trg_Nevidimka,GetPlayableMapRect())
call TriggerAddCondition(gg_trg_Nevidimka,Condition(function Trig_Nevidimka_Conditions))
call TriggerAddAction(gg_trg_Nevidimka,function Trig_Nevidimka_Actions)
endfunction
function WoodDecay_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A02Y')>0 and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R00L',true)>3
endfunction
function WoodDecay_Actions takes nothing returns nothing
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local integer index=1
local integer count=2
loop
exitwhen index>count
call CreateUnit(GetOwningPlayer(target),'h015',x,y,bj_UNIT_FACING)
set index=index+1
endloop
set target=null
endfunction
function InitTrig_WoodDecay takes nothing returns nothing
set gg_trg_WoodDecay=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_WoodDecay,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_WoodDecay,Condition(function WoodDecay_Conditions))
call TriggerAddAction(gg_trg_WoodDecay,function WoodDecay_Actions)
endfunction
function Trig_Vhod_Actions takes nothing returns nothing
call TriggerRegisterUnitLifeEvent(gg_trg_DrevesAura,GetTriggerUnit(),LESS_THAN,0.90)
endfunction
function InitTrig_Vhod takes nothing returns nothing
set gg_trg_Vhod=CreateTrigger()
call TriggerRegisterEnterRectSimple(gg_trg_Vhod,GetPlayableMapRect())
call TriggerAddAction(gg_trg_Vhod,function Trig_Vhod_Actions)
endfunction
function DrevesAura_Conditions takes nothing returns boolean
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)!=true))then
return false
endif
if(not(GetUnitAbilityLevel(GetTriggerUnit(),'B008')>0))then
return false
endif
return true
endfunction
function DrevesAura_Actions takes nothing returns nothing
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
call CreateUnit(GetOwningPlayer(target),'h015',x,y,bj_UNIT_FACING)
set target=null
endfunction
function InitTrig_DrevesAura takes nothing returns nothing
set gg_trg_DrevesAura=CreateTrigger()
call TriggerAddCondition(gg_trg_DrevesAura,Condition(function DrevesAura_Conditions))
call TriggerAddAction(gg_trg_DrevesAura,function DrevesAura_Actions)
endfunction
function KorniMirDreva_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetAttacker()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real chance=10.00
local real l__damage=20.00
local real periodic=1.00
local real time=5.00
if isUnitHero(target)then
set time=0.35
endif
if Chance(caster,chance)then
call Roots_Start(caster,target,l__damage,periodic,time)
endif
set caster=null
set target=null
endfunction
function KorniMirDreva_Conditions takes nothing returns boolean
local boolean lvlFilter=GetUnitAbilityLevel(GetTriggerUnit(),'A02W')>0 and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R00L',true)>0
return lvlFilter and not isUnitStruct(GetAttacker())
endfunction
function InitTrig_KorniMirDreva takes nothing returns nothing
set gg_trg_KorniMirDreva=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_KorniMirDreva,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_KorniMirDreva,Condition(function KorniMirDreva_Conditions))
call TriggerAddAction(gg_trg_KorniMirDreva,function KorniMirDreva_Actions)
endfunction
function Trig_IskystvaWar_Conditions takes nothing returns boolean
if(not(GetResearched()=='R00L'))then
return false
endif
return true
endfunction
function Trig_IskystvaWar_Func001Func002A takes nothing returns nothing
call ReplaceUnitBJ(GetEnumUnit(),'h012',bj_UNIT_STATE_METHOD_RELATIVE)
endfunction
function Trig_IskystvaWar_Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R00L',GetOwningPlayer(GetTriggerUnit()))==2))then
return false
endif
return true
endfunction
function Trig_IskystvaWar_Actions takes nothing returns nothing
if(Trig_IskystvaWar_Func001C())then
set udg_Unit[GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))]='h012'
call ForGroupBJ(GetUnitsOfPlayerAndTypeId(GetOwningPlayer(GetTriggerUnit()),'h011'),function Trig_IskystvaWar_Func001Func002A)
else
endif
endfunction
function InitTrig_IskystvaWar takes nothing returns nothing
set gg_trg_IskystvaWar=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_IskystvaWar,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_IskystvaWar,Condition(function Trig_IskystvaWar_Conditions))
call TriggerAddAction(gg_trg_IskystvaWar,function Trig_IskystvaWar_Actions)
endfunction
function GnevPrirodi_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real chance=7.00
local real l__damage=12.00
local real periodic=1.00
local real time=4.00
if isUnitHero(target)then
set time=0.25
endif
if Chance(caster,chance)then
call Roots_Start(caster,target,l__damage,periodic,time)
endif
set caster=null
set target=null
endfunction
function GnevPrirodi_Conditions takes nothing returns boolean
local boolean lvlFilter=GetUnitAbilityLevel(GetAttacker(),'A02N')>0 and GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R00H',true)>1
return lvlFilter and not isUnitStruct(GetTriggerUnit())and not isUnitRooted(GetTriggerUnit())
endfunction
function InitTrig_GnevPrirodi takes nothing returns nothing
set gg_trg_GnevPrirodi=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_GnevPrirodi,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_GnevPrirodi,Condition(function GnevPrirodi_Conditions))
call TriggerAddAction(gg_trg_GnevPrirodi,function GnevPrirodi_Actions)
endfunction
function Trig_OjereleGrade_Conditions takes nothing returns boolean
if(not(GetResearched()=='R00H'))then
return false
endif
return true
endfunction
function Trig_OjereleGrade_Func001Func001A takes nothing returns nothing
call UnitAddAbilityBJ('A02H',GetEnumUnit())
endfunction
function Trig_OjereleGrade_Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R00H',GetOwningPlayer(GetTriggerUnit()))==3))then
return false
endif
return true
endfunction
function Trig_OjereleGrade_Actions takes nothing returns nothing
if(Trig_OjereleGrade_Func001C())then
call ForGroupBJ(GetUnitsOfPlayerAndTypeId(GetOwningPlayer(GetTriggerUnit()),'e000'),function Trig_OjereleGrade_Func001Func001A)
else
endif
endfunction
function InitTrig_OjereleGrade takes nothing returns nothing
set gg_trg_OjereleGrade=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_OjereleGrade,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_OjereleGrade,Condition(function Trig_OjereleGrade_Conditions))
call TriggerAddAction(gg_trg_OjereleGrade,function Trig_OjereleGrade_Actions)
endfunction
function Trig_OjereleDriadi_Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R00H',GetOwningPlayer(GetTriggerUnit()))>2))then
return false
endif
if(not(GetUnitTypeId(GetTriggerUnit())=='e000'))then
return false
endif
return true
endfunction
function Trig_OjereleDriadi_Conditions takes nothing returns boolean
if(not Trig_OjereleDriadi_Func001C())then
return false
endif
return true
endfunction
function Trig_OjereleDriadi_Actions takes nothing returns nothing
call UnitAddAbilityBJ('A02H',GetTriggerUnit())
endfunction
function InitTrig_OjereleDriadi takes nothing returns nothing
set gg_trg_OjereleDriadi=CreateTrigger()
call TriggerRegisterEnterRectSimple(gg_trg_OjereleDriadi,GetPlayableMapRect())
call TriggerAddCondition(gg_trg_OjereleDriadi,Condition(function Trig_OjereleDriadi_Conditions))
call TriggerAddAction(gg_trg_OjereleDriadi,function Trig_OjereleDriadi_Actions)
endfunction
function Flag_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FV'
endfunction
function Flag_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local integer id=GetHandleId(caster)
call SaveReal(udg_Hash,id,StringHash("Flag|X"),x)
call SaveReal(udg_Hash,id,StringHash("Flag|y"),y)
set target=null
set caster=null
endfunction
function InitTrig_Flag takes nothing returns nothing
set gg_trg_Flag=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Flag,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Flag,Condition(function Flag_Conditions))
call TriggerAddAction(gg_trg_Flag,function Flag_Actions)
endfunction
function Patrol_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A029'
endfunction
function Patrol_filter takes nothing returns boolean
return GetOwningPlayer(bj_caster)==GetOwningPlayer(GetFilterUnit())and IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)!=true and IsUnitType(GetFilterUnit(),UNIT_TYPE_HERO)!=true
endfunction
function Patrol_Actions takes nothing returns nothing
local boolexpr filter=Condition(function Patrol_filter)
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local unit dami
set bj_caster=caster
call GroupEnumUnitsInRange(g,0,0,999999999,filter)
loop
set dami=FirstOfGroup(g)
exitwhen dami==null
call IssuePointOrder(dami,"patrol",x,y)
call GroupRemoveUnit(g,dami)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set dami=null
set caster=null
set filter=null
endfunction
function InitTrig_Patrol takes nothing returns nothing
set gg_trg_Patrol=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Patrol,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Patrol,Condition(function Patrol_Conditions))
call TriggerAddAction(gg_trg_Patrol,function Patrol_Actions)
endfunction
function Move_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A028'
endfunction
function Move_filter takes nothing returns boolean
return GetOwningPlayer(bj_caster)==GetOwningPlayer(GetFilterUnit())and IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)!=true and IsUnitType(GetFilterUnit(),UNIT_TYPE_HERO)!=true
endfunction
function Move_Actions takes nothing returns nothing
local boolexpr filter=Condition(function Patrol_filter)
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local unit dami
set bj_caster=caster
call GroupEnumUnitsInRange(g,0,0,999999999,filter)
loop
set dami=FirstOfGroup(g)
exitwhen dami==null
call IssuePointOrder(dami,"move",x,y)
call GroupRemoveUnit(g,dami)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set dami=null
set caster=null
set filter=null
endfunction
function InitTrig_Move takes nothing returns nothing
set gg_trg_Move=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Move,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Move,Condition(function Move_Conditions))
call TriggerAddAction(gg_trg_Move,function Move_Actions)
endfunction
function Stay_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A02C'
endfunction
function Stay_filter takes nothing returns boolean
return GetOwningPlayer(bj_caster)==GetOwningPlayer(GetFilterUnit())and IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)!=true and IsUnitType(GetFilterUnit(),UNIT_TYPE_HERO)!=true
endfunction
function Stay_Actions takes nothing returns nothing
local boolexpr filter=Condition(function Patrol_filter)
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local unit dami
set bj_caster=caster
call GroupEnumUnitsInRange(g,0,0,999999999,filter)
loop
set dami=FirstOfGroup(g)
exitwhen dami==null
call IssueImmediateOrder(dami,"holdposition")
call GroupRemoveUnit(g,dami)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set dami=null
set caster=null
set filter=null
endfunction
function InitTrig_Stay takes nothing returns nothing
set gg_trg_Stay=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Stay,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Stay,Condition(function Stay_Conditions))
call TriggerAddAction(gg_trg_Stay,function Stay_Actions)
endfunction
function Stop_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A02B'
endfunction
function Stop_filter takes nothing returns boolean
return GetOwningPlayer(bj_caster)==GetOwningPlayer(GetFilterUnit())and IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)!=true and IsUnitType(GetFilterUnit(),UNIT_TYPE_HERO)!=true
endfunction
function Stop_Actions takes nothing returns nothing
local boolexpr filter=Condition(function Patrol_filter)
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local unit dami
set bj_caster=caster
call GroupEnumUnitsInRange(g,0,0,999999999,filter)
loop
set dami=FirstOfGroup(g)
exitwhen dami==null
call IssueImmediateOrder(dami,"stop")
call GroupRemoveUnit(g,dami)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set dami=null
set caster=null
set filter=null
endfunction
function InitTrig_Stop takes nothing returns nothing
set gg_trg_Stop=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Stop,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Stop,Condition(function Stop_Conditions))
call TriggerAddAction(gg_trg_Stop,function Stop_Actions)
endfunction
function Attack_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A026'
endfunction
function Attack_filter takes nothing returns boolean
return GetOwningPlayer(bj_caster)==GetOwningPlayer(GetFilterUnit())and IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)!=true and IsUnitType(GetFilterUnit(),UNIT_TYPE_HERO)!=true
endfunction
function Attack_Actions takes nothing returns nothing
local boolexpr filter=Condition(function Patrol_filter)
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local unit dami
set bj_caster=caster
call GroupEnumUnitsInRange(g,0,0,999999999,filter)
loop
set dami=FirstOfGroup(g)
exitwhen dami==null
call IssuePointOrder(dami,"attack",x,y)
call GroupRemoveUnit(g,dami)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set dami=null
set caster=null
set filter=null
endfunction
function InitTrig_Attack takes nothing returns nothing
set gg_trg_Attack=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Attack,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Attack,Condition(function Attack_Conditions))
call TriggerAddAction(gg_trg_Attack,function Attack_Actions)
endfunction
function ProklyatieKnight_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetKillingUnit(),'A01Y')>0 and not isUnitHero(GetTriggerUnit())and not isUnitStruct(GetTriggerUnit())and not isUnitSummon(GetTriggerUnit())
endfunction
function ProklyatieKnight_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
call TimedEffect("Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilSpecialArt.mdl",x,y,0.5)
call CreateUnit(GetOwningPlayer(caster),'n003',x,y,bj_UNIT_FACING)
if(GetUnitAbilityLevel(target,'A098')>0)then
call RemoveItem(UnitItemInSlot(target,0))
endif
call RemoveUnit(target)
set caster=null
set target=null
endfunction
function InitTrig_ProklyatieKnight takes nothing returns nothing
set gg_trg_ProklyatieKnight=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ProklyatieKnight,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_ProklyatieKnight,Condition(function ProklyatieKnight_Conditions))
call TriggerAddAction(gg_trg_ProklyatieKnight,function ProklyatieKnight_Actions)
endfunction
function isUnitHasOpenedCursed takes unit caster returns boolean
return GetUnitAbilityLevel(caster,'A01R')>0 and GetPlayerTechCount(Owner(caster),'R00E',true)>3
endfunction
function Proklyatie_Conditions takes nothing returns boolean
return isUnitHasOpenedCursed(GetKillingUnit())and not isUnitHero(GetTriggerUnit())and not isUnitStruct(GetTriggerUnit())and not isUnitSummon(GetTriggerUnit())
endfunction
function Proklyatie_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
call TimedEffect("Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilSpecialArt.mdl",x,y,0.5)
call CreateUnit(GetOwningPlayer(caster),'n003',x,y,bj_UNIT_FACING)
if GetUnitAbilityLevel(target,'A098')>0 then
call RemoveItem(UnitItemInSlot(target,0))
endif
call RemoveUnit(target)
set caster=null
set target=null
endfunction
function InitTrig_Proklyatie takes nothing returns nothing
set gg_trg_Proklyatie=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Proklyatie,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Proklyatie,Condition(function Proklyatie_Conditions))
call TriggerAddAction(gg_trg_Proklyatie,function Proklyatie_Actions)
endfunction
function Oderjimost_Conditions takes nothing returns boolean
return GetPlayerTechCount(GetOwningPlayer(GetDyingUnit()),'R00E',true)>0 and GetUnitAbilityLevel(GetDyingUnit(),'A01O')>0
endfunction
function Oderjimost_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local real chance=20.00
if Chance(caster,chance)then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",caster,"origin")
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'n003',x,y,bj_UNIT_FACING)
if(GetUnitAbilityLevel(caster,'A098')>0)then
call RemoveItem(UnitItemInSlot(caster,0))
endif
call RemoveUnit(caster)
call TriggerSleepAction(0.5)
call DestroyEffect(eff)
endif
set caster=null
set eff=null
endfunction
function InitTrig_Oderjimost takes nothing returns nothing
set gg_trg_Oderjimost=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Oderjimost,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Oderjimost,Condition(function Oderjimost_Conditions))
call TriggerAddAction(gg_trg_Oderjimost,function Oderjimost_Actions)
endfunction
function Pistolet_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0EI'
endfunction
function Pistolet_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local real dmg=35.00
call MagDamage(caster,target,dmg)
set caster=null
set target=null
endfunction
function InitTrig_Pistolet takes nothing returns nothing
set gg_trg_Pistolet=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Pistolet,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Pistolet,Condition(function Pistolet_Conditions))
call TriggerAddAction(gg_trg_Pistolet,function Pistolet_Actions)
endfunction
function PirateNature_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'A01C')>0 and GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R00B',true)>0 and GetPlayerState(GetOwningPlayer(GetTriggerUnit()),PLAYER_STATE_RESOURCE_GOLD)>0
endfunction
function PirateNature_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local player pllcast=GetOwningPlayer(caster)
local player plltarg=GetOwningPlayer(target)
local string s
local real chance=7.00
if Chance(caster,chance)then
call AdjustPlayerStateBJ(-1,plltarg,PLAYER_STATE_RESOURCE_GOLD)
if(GetLocalPlayer()==plltarg)then
set s="-1"
call TextUp(s,target,11,0,255,0,60,96.00,2.00)
endif
call AdjustPlayerStateBJ(1,GetOwningPlayer(caster),PLAYER_STATE_RESOURCE_GOLD)
if(GetLocalPlayer()==pllcast)then
set s="+1"
call TextUp(s,caster,11,0,255,0,60,96.00,2.00)
endif
endif
set pllcast=null
set plltarg=null
set caster=null
set target=null
endfunction
function InitTrig_PirateNature takes nothing returns nothing
set gg_trg_PirateNature=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_PirateNature,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_PirateNature,Condition(function PirateNature_Conditions))
call TriggerAddAction(gg_trg_PirateNature,function PirateNature_Actions)
endfunction
function CepMolni_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'A017')>0
endfunction
function CepMolni_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real r=GetRandomReal(0.00,100.00)
local real lvl=30.00
if(GetUnitAbilityLevel(caster,'B007')>0)then
set lvl=lvl+3
endif
if(r<=lvl)then
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'h00K',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',3.00)
call IssueTargetOrder(bj_lastCreatedUnit,"chainlightning",target)
endif
set caster=null
set target=null
endfunction
function InitTrig_CepMolni takes nothing returns nothing
set gg_trg_CepMolni=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_CepMolni,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_CepMolni,Condition(function CepMolni_Conditions))
call TriggerAddAction(gg_trg_CepMolni,function CepMolni_Actions)
endfunction
function Shtorm_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'A014')>0
endfunction
function Shtorm_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real chance=30.00
if Chance(caster,chance)then
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'h00J',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',3.00)
call IssueTargetOrder(bj_lastCreatedUnit,"cyclone",target)
endif
set caster=null
set target=null
endfunction
function InitTrig_Shtorm takes nothing returns nothing
set gg_trg_Shtorm=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Shtorm,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Shtorm,Condition(function Shtorm_Conditions))
call TriggerAddAction(gg_trg_Shtorm,function Shtorm_Actions)
endfunction
function Razmnojenie_Conditions takes nothing returns boolean
return GetUnitTypeId(GetAttacker())=='h00I'
endfunction
function Razmnojenie_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local integer i=GetUnitUserData(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local unit dummy
call SetUnitUserData(caster,(i+1))
set i=GetUnitUserData(caster)
if i==8 then
call SetUnitUserData(caster,0)
set dummy=CreateUnit(GetOwningPlayer(caster),'h00I',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(dummy,'BTLF',15.00)
call SetUnitExploded(dummy,true)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",dummy,"origin")
call DestroyEffect(eff)
endif
set eff=null
set dummy=null
set caster=null
endfunction
function InitTrig_Razmnojenie takes nothing returns nothing
set gg_trg_Razmnojenie=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Razmnojenie,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_Razmnojenie,Condition(function Razmnojenie_Conditions))
call TriggerAddAction(gg_trg_Razmnojenie,function Razmnojenie_Actions)
endfunction
function PortalInDalaran_Conditions takes nothing returns boolean
return GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R006',true)>3 and GetUnitAbilityLevel(GetAttacker(),'A010')>0
endfunction
function PortalInDalaran_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local unit dummy
local real chance=5.00
local real cdTime=12.00
if Chance(caster,chance)then
call AbilityCooldown(caster,'A010',cdTime)
set dummy=CreateUnit(GetOwningPlayer(caster),'h00I',x,y,GetUnitFacing(caster))
call UnitApplyTimedLife(dummy,'BTLF',20.00)
call SetUnitExploded(dummy,true)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",dummy,"origin")
call DestroyEffect(eff)
endif
set eff=null
set dummy=null
set caster=null
endfunction
function InitTrig_PortalInDalaran takes nothing returns nothing
set gg_trg_PortalInDalaran=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_PortalInDalaran,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_PortalInDalaran,Condition(function PortalInDalaran_Conditions))
call TriggerAddAction(gg_trg_PortalInDalaran,function PortalInDalaran_Actions)
endfunction
function MagicGnev_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'A011')>0 and GetPlayerTechCount(GetOwningPlayer(GetAttacker()),'R006',true)>2 and not isUnitStruct(GetTriggerUnit())
endfunction
function MagicGnev_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local effect eff
local real chance=10.00
local real mana=20.00
local real health=20.00
if Chance(caster,chance)then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl",target,"origin")
call DestroyEffect(eff)
call MagDamage(caster,target,health)
call UnitRestoreMana(target,-mana)
call UnitRestoreHealth(caster,health)
call UnitRestoreMana(caster,mana)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl",caster,"origin")
call DestroyEffect(eff)
endif
set eff=null
set caster=null
set target=null
endfunction
function InitTrig_MagicGnev takes nothing returns nothing
set gg_trg_MagicGnev=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_MagicGnev,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_MagicGnev,Condition(function MagicGnev_Conditions))
call TriggerAddAction(gg_trg_MagicGnev,function MagicGnev_Actions)
endfunction
function GodDefense2_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A00H')>0 and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R003',true)>2
endfunction
function GodDefense2_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetEventDamageSource()
local real dmg=GetEventDamage()*1.50
local real chance=12.00
if Chance(caster,chance)then
if(IsUnitType(target,UNIT_TYPE_STRUCTURE)!=true)then
set bj_lastCreatedEffect=AddSpecialEffectTarget("Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl",target,"origin")
call MagDamage(caster,target,dmg)
call DestroyEffect(bj_lastCreatedEffect)
endif
endif
set caster=null
set target=null
endfunction
function InitTrig_GodDefense2 takes nothing returns nothing
set gg_trg_GodDefense2=CreateTrigger()
call TriggerAddCondition(gg_trg_GodDefense2,Condition(function GodDefense2_Conditions))
call TriggerAddAction(gg_trg_GodDefense2,function GodDefense2_Actions)
endfunction
function GodDefense1_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())=='h005'
endfunction
function GodDefense1_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
call TriggerRegisterUnitEvent(gg_trg_GodDefense2,caster,EVENT_UNIT_DAMAGED)
set caster=null
endfunction
function InitTrig_GodDefense1 takes nothing returns nothing
set gg_trg_GodDefense1=CreateTrigger()
call TriggerRegisterEnterRectSimple(gg_trg_GodDefense1,bj_mapInitialPlayableArea)
call TriggerAddCondition(gg_trg_GodDefense1,Condition(function GodDefense1_Conditions))
call TriggerAddAction(gg_trg_GodDefense1,function GodDefense1_Actions)
endfunction
function Astral_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0I4'
endfunction
function Astral_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and not IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)
endfunction
function Astral_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lnLvl=GetUnitAbilityLevel(caster,'A0HI')
local integer ieLvl=GetUnitAbilityLevel(caster,'A0HH')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local boolexpr filter
local unit target
local unit dummy
local real lnBuff=1.+((lnLvl-1)*0.2)
local real range=250.
local real l__damage=50.*lnBuff
call RangeEffect_start(caster,x,y,range,0.5)
set bj_caster=caster
set filter=Condition(function Astral_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set dummy=CreateDummy(GetOwningPlayer(caster),GetUnitX(target),GetUnitY(target),'A0I5',ieLvl,5.00)
call IssueTargetOrder(dummy,"banish",target)
if isUnitEnemy(caster,target)then
call MagDamage(caster,target,l__damage)
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set dummy=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_Astral takes nothing returns nothing
set gg_trg_Astral=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Astral,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Astral,Condition(function Astral_Conditions))
call TriggerAddAction(gg_trg_Astral,function Astral_Actions)
endfunction
function s__Transfer_st_Destroy takes integer this returns nothing
call DestroyLightning(s__Transfer_st_link[this])
set s__Transfer_st_link[this]=null
set s__Transfer_st_caster[this]=null
set s__Transfer_st_target[this]=null
call s__Transfer_st_deallocate(this)
endfunction
function Transfer_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0I3'
endfunction
function Transfer_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer trans=LoadInt(id,"Transfer | Structure")
local real casterMaxHP=GetUnitMaxHealth(s__Transfer_st_caster[trans])
local real casterHP=GetUnitHealth(s__Transfer_st_caster[trans])
local real targetHP=GetUnitHealth(s__Transfer_st_target[trans])
local real casterMP=GetUnitMana(s__Transfer_st_caster[trans])
local real targetMP=GetUnitMana(s__Transfer_st_target[trans])
local real x1=GetUnitX(s__Transfer_st_caster[trans])
local real y1=GetUnitY(s__Transfer_st_caster[trans])
local real x2=GetUnitX(s__Transfer_st_target[trans])
local real y2=GetUnitY(s__Transfer_st_target[trans])
if(s__Transfer_st_time[trans]>0 and casterHP>0 and targetHP>0)then
call MoveLightningEx(s__Transfer_st_link[trans],true,x2,y2,75,x1,y1,75)
set s__Transfer_st_cPeriodic[trans]=s__Transfer_st_cPeriodic[trans]-s__Transfer_st_mPeriodic[trans]
if s__Transfer_st_cPeriodic[trans]<=0 then
set s__Transfer_st_cPeriodic[trans]=s__Transfer_st_periodic[trans]
if casterHP>casterMaxHP*0.1 then
call UnitRestoreHealth(s__Transfer_st_target[trans],s__Transfer_st_hp[trans])
call UnitRestoreHealth(s__Transfer_st_caster[trans],-s__Transfer_st_hp[trans])
endif
if casterMP>=s__Transfer_st_mp[trans]then
call UnitRestoreMana(s__Transfer_st_target[trans],s__Transfer_st_mp[trans])
call UnitRestoreMana(s__Transfer_st_caster[trans],-s__Transfer_st_mp[trans])
endif
endif
set s__Transfer_st_time[trans]=s__Transfer_st_time[trans]-s__Transfer_st_mPeriodic[trans]
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__Transfer_st_Destroy(trans)
endif
set t=null
endfunction
function Transfer_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer trans=s__Transfer_st__allocate()
local integer frLvl=GetUnitAbilityLevel(caster,'A0HG')
local integer ieLvl=GetUnitAbilityLevel(caster,'A0HH')
local real x1=GetUnitX(caster)
local real y1=GetUnitY(caster)
local real x2=GetUnitX(target)
local real y2=GetUnitY(target)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real frBuff=1.+((frLvl-1)*0.1)
local real ieBuff=1.+((ieLvl-1)*0.2)
set s__Transfer_st_link[trans]=AddLightningEx("DRAM",true,x2,y2,75,x1,y1,75)
set s__Transfer_st_caster[trans]=caster
set s__Transfer_st_target[trans]=target
set s__Transfer_st_mPeriodic[trans]=.02
set s__Transfer_st_cPeriodic[trans]=1.
set s__Transfer_st_periodic[trans]=1.
set s__Transfer_st_time[trans]=10.
set s__Transfer_st_hp[trans]=20.*frBuff
set s__Transfer_st_mp[trans]=10.*ieBuff
call SaveInt(id,"Transfer | Structure",trans)
call TimerStart(t,s__Transfer_st_mPeriodic[trans],true,function Transfer_timer)
set t=null
set caster=null
set target=null
endfunction
function InitTrig_Transfer takes nothing returns nothing
set gg_trg_Transfer=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Transfer,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Transfer,Condition(function Transfer_Conditions))
call TriggerAddAction(gg_trg_Transfer,function Transfer_Actions)
endfunction
function s__Gust_st_Destroy takes integer this returns nothing
set s__Gust_st_target[this]=null
call s__Gust_st_deallocate(this)
endfunction
function Gust_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0I2'
endfunction
function Gust_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer gust=LoadInt(id,"Gust | Structure")
local real fly=GetUnitFlyHeight(s__Gust_st_target[gust])
local real x=GetUnitX(s__Gust_st_target[gust])
local real y=GetUnitY(s__Gust_st_target[gust])
local effect eff
local real x1
local real y1
if s__Gust_st_distance[gust]>s__Gust_st_totalDist[gust]then
if s__Gust_st_totalDist[gust]<(s__Gust_st_distance[gust]/ 2)then
call SetUnitFlyHeight(s__Gust_st_target[gust],fly+s__Gust_st_speed[gust]/ 2,s__Gust_st_speed[gust]/ 2/ 0.03)
else
call SetUnitFlyHeight(s__Gust_st_target[gust],fly-s__Gust_st_speed[gust]/ 2,s__Gust_st_speed[gust]/ 2/ 0.03)
endif
set x1=PolarPoints(x,y,s__Gust_st_speed[gust],s__Gust_st_angle[gust],"x")
set y1=PolarPoints(x,y,s__Gust_st_speed[gust],s__Gust_st_angle[gust],"y")
if(IsTerrainPathable(x1,y1,PATHING_TYPE_FLYABILITY)==false)then
call SetUnitX(s__Gust_st_target[gust],x1)
call SetUnitY(s__Gust_st_target[gust],y1)
endif
set s__Gust_st_totalDist[gust]=s__Gust_st_totalDist[gust]+s__Gust_st_speed[gust]
else
call DestroyTimer(t)
call PauseUnit(s__Gust_st_target[gust],false)
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",x,y)
call DestroyEffect(eff)
call FlushChildHashtable(udg_Hash,id)
call s__Gust_st_Destroy(gust)
endif
set t=null
set eff=null
endfunction
function Gust_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer frLvl=GetUnitAbilityLevel(caster,'A0HG')
local integer ieLvl=GetUnitAbilityLevel(caster,'A0HH')
local integer gust=s__Gust_st__allocate()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real x1=GetUnitX(target)
local real y1=GetUnitY(target)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local effect eff
local real frBuff=1.+((frLvl-1)*0.2)
local real ieBuff=1.+((ieLvl-1)*0.1)
set s__Gust_st_target[gust]=target
set s__Gust_st_angle[gust]=PointsAngle(x,y,x1,y1)
set s__Gust_st_distance[gust]=500.*frBuff
set s__Gust_st_totalDist[gust]=0.
set s__Gust_st_speed[gust]=25.*ieBuff
set s__Gust_st_periodic[gust]=.03
call UnitAddAbility(s__Gust_st_target[gust],'Arav')
call UnitRemoveAbility(s__Gust_st_target[gust],'Arav')
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",x,y)
call DestroyEffect(eff)
call PauseUnit(s__Gust_st_target[gust],true)
call SaveInt(id,"Gust | Structure",gust)
call TimerStart(t,s__Gust_st_periodic[gust],true,function Gust_timer)
set t=null
set eff=null
set target=null
set caster=null
endfunction
function InitTrig_Gust takes nothing returns nothing
set gg_trg_Gust=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Gust,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Gust,Condition(function Gust_Conditions))
call TriggerAddAction(gg_trg_Gust,function Gust_Actions)
endfunction
function FrostyInspiration_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HY'
endfunction
function FrostyInspiration_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lnLvl=GetUnitAbilityLevel(caster,'A0HI')
local integer ieLvl=GetUnitAbilityLevel(caster,'A0HH')
local unit target=GetSpellTargetUnit()
local real lnBuff=1.+((lnLvl-1)*0.15)
local real time=10.00*lnBuff
local integer abilID='A0I1'
call TimedAbility(target,abilID,time)
call SetUnitAbilityLevel(target,'A0HZ',ieLvl)
set caster=null
set target=null
endfunction
function InitTrig_FrostyInspiration takes nothing returns nothing
set gg_trg_FrostyInspiration=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_FrostyInspiration,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_FrostyInspiration,Condition(function FrostyInspiration_Conditions))
call TriggerAddAction(gg_trg_FrostyInspiration,function FrostyInspiration_Actions)
endfunction
function ThreeElements_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HX'
endfunction
function ThreeElements_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lnLvl=GetUnitAbilityLevel(caster,'A0HI')
local integer frLvl=GetUnitAbilityLevel(caster,'A0HG')
local integer ieLvl=GetUnitAbilityLevel(caster,'A0HH')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer index=1
local unit dummy
local real time=30.00
local integer lnCount=1+1*lnLvl
local integer frCount=1+1*frLvl
local integer ieCount=1+1*ieLvl
loop
exitwhen index>lnCount
set dummy=CreateUnit(GetOwningPlayer(caster),'h00G',x,y,0)
call UnitApplyTimedLife(dummy,'eqwe',time)
set index=index+1
endloop
set index=1
loop
exitwhen index>frCount
set dummy=CreateUnit(GetOwningPlayer(caster),'h00D',x,y,0)
call UnitApplyTimedLife(dummy,'eqwe',time)
set index=index+1
endloop
set index=1
loop
exitwhen index>ieCount
set dummy=CreateUnit(GetOwningPlayer(caster),'h00C',x,y,0)
call UnitApplyTimedLife(dummy,'eqwe',time)
set index=index+1
endloop
set dummy=null
set caster=null
endfunction
function InitTrig_ThreeElements takes nothing returns nothing
set gg_trg_ThreeElements=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ThreeElements,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_ThreeElements,Condition(function ThreeElements_Conditions))
call TriggerAddAction(gg_trg_ThreeElements,function ThreeElements_Actions)
endfunction
function Arson_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HW'
endfunction
function Arson_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lnLvl=GetUnitAbilityLevel(caster,'A0HI')
local integer frLvl=GetUnitAbilityLevel(caster,'A0HG')
local unit target=GetSpellTargetUnit()
local real lnBuff=1.+((lnLvl-1)*0.1)
local real frBuff=1.+((frLvl-1)*0.2)
local real l__damage=60.00*frBuff
local real fireDamage=25.00*frBuff
local real fireTime=5.00*lnBuff
local string dmgEffPath="Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeDamageTarget.mdl"
local string Type="Fire"
call MagDamage(caster,target,l__damage)
call PeriodicDamage_Start(Type,dmgEffPath,caster,target,fireDamage,fireTime,0)
set caster=null
set target=null
endfunction
function InitTrig_Arson takes nothing returns nothing
set gg_trg_Arson=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Arson,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Arson,Condition(function Arson_Conditions))
call TriggerAddAction(gg_trg_Arson,function Arson_Actions)
endfunction
function s__Monsoon_st_Destroy takes integer this returns nothing
call DestroyEffect(s__Monsoon_st_aroundEff[this])
set s__Monsoon_st_caster[this]=null
set s__Monsoon_st_aroundEff[this]=null
call s__Monsoon_st_deallocate(this)
endfunction
function Monsoon_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HO'
endfunction
function Monsoon_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))
endfunction
function Monsoon_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer monsoon=LoadInt(id,"Monsoon | Structure")
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
if(s__Monsoon_st_time[monsoon]>=s__Monsoon_st_periodic[monsoon])then
set s__Monsoon_st_time[monsoon]=s__Monsoon_st_time[monsoon]-s__Monsoon_st_periodic[monsoon]
set bj_caster=s__Monsoon_st_caster[monsoon]
set filter=Condition(function Monsoon_filter)
call GroupEnumUnitsInRange(g,s__Monsoon_st_x[monsoon],s__Monsoon_st_y[monsoon],s__Monsoon_st_range[monsoon],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl",GetUnitX(target),GetUnitY(target))
call DestroyEffect(eff)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\Purge\\PurgeBuffTarget.mdl",target,"origin")
call DestroyEffect(eff)
call MagDamage(s__Monsoon_st_caster[monsoon],target,s__Monsoon_st_damage[monsoon])
call GroupRemoveUnit(g,target)
endloop
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__Monsoon_st_Destroy(monsoon)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set t=null
set g=null
set eff=null
set filter=null
set target=null
endfunction
function Monsoon_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0HI')
local integer monsoon=s__Monsoon_st__allocate()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real lvlBuff=1.+((lvl-1)*0.3)
set s__Monsoon_st_caster[monsoon]=caster
set s__Monsoon_st_x[monsoon]=GetSpellTargetX()
set s__Monsoon_st_y[monsoon]=GetSpellTargetY()
set s__Monsoon_st_aroundEff[monsoon]=AddSpecialEffect("Abilities\\Spells\\Other\\Monsoon\\MonsoonRain.mdl",s__Monsoon_st_x[monsoon],s__Monsoon_st_y[monsoon])
set s__Monsoon_st_damage[monsoon]=20.00*lvlBuff
set s__Monsoon_st_range[monsoon]=350.00
set s__Monsoon_st_time[monsoon]=10.00*lvlBuff
set s__Monsoon_st_periodic[monsoon]=2.00
call RangeEffect_start(caster,x,y,s__Monsoon_st_range[monsoon],s__Monsoon_st_time[monsoon])
call SaveInt(id,"Monsoon | Structure",monsoon)
call TimerStart(t,s__Monsoon_st_periodic[monsoon],true,function Monsoon_timer)
set t=null
set caster=null
endfunction
function InitTrig_Monsoon takes nothing returns nothing
set gg_trg_Monsoon=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Monsoon,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Monsoon,Condition(function Monsoon_Conditions))
call TriggerAddAction(gg_trg_Monsoon,function Monsoon_Actions)
endfunction
function Flash_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HT'
endfunction
function Flash_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))and not IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)
endfunction
function Flash_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lnLvl=GetUnitAbilityLevel(caster,'A0HI')
local integer frLvl=GetUnitAbilityLevel(caster,'A0HG')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
local real lnBuff=1.+((lnLvl-1)*0.2)
local real frBuff=1.+((frLvl-1)*0.1)
local real time=3.00*frBuff
local real l__damage=90.00*lnBuff
local real range=250.00
local integer abilID='A0HV'
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl",x,y)
call DestroyEffect(eff)
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",x,y)
call DestroyEffect(eff)
call TimedAbility(caster,abilID,time)
call RangeEffect_start(caster,x,y,range,0.5)
set bj_caster=caster
set filter=Condition(function Flash_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(caster,target,l__damage)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_Flash takes nothing returns nothing
set gg_trg_Flash=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Flash,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Flash,Condition(function Flash_Conditions))
call TriggerAddAction(gg_trg_Flash,function Flash_Actions)
endfunction
function IceFront_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HP'
endfunction
function IceFront_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))and not IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)
endfunction
function IceFront_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0HH')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local boolexpr filter
local unit target
local real lvlBuff=1.+((lvl-1)*0.3)
local real time=5.00*lvlBuff
local real range=450.00
local integer abilID='A0HS'
call RangeEffect_start(caster,x,y,range,0.5)
set bj_caster=caster
set filter=Condition(function IceFront_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call TimedAbility(target,abilID,time)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_IceFront takes nothing returns nothing
set gg_trg_IceFront=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_IceFront,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_IceFront,Condition(function IceFront_Conditions))
call TriggerAddAction(gg_trg_IceFront,function IceFront_Actions)
endfunction
function Sunstrike_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HN'
endfunction
function Sunstrike_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))and not IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)
endfunction
function Sunstrike_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0HG')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local boolexpr filter
local unit target
local real lvlBuff=1.+((lvl-1)*0.3)
local real range=200.00
local real l__damage=35.00*lvlBuff
local real fireDamage=8.00*lvlBuff
local real fireTime=5.00*lvlBuff
local string dmgEffPath="Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeDamageTarget.mdl"
local string Type="Fire"
call RangeEffect_start(caster,x,y,range,0.5)
set bj_caster=caster
set filter=Condition(function Sunstrike_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(caster,target,l__damage)
call PeriodicDamage_Start(Type,dmgEffPath,caster,target,fireDamage,fireTime,0)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_Sunstrike takes nothing returns nothing
set gg_trg_Sunstrike=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Sunstrike,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Sunstrike,Condition(function Sunstrike_Conditions))
call TriggerAddAction(gg_trg_Sunstrike,function Sunstrike_Actions)
endfunction
function ElectroStrike_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0HD'
endfunction
function s__ElectroStrike_st_Destroy takes integer this returns nothing
call RemoveUnit(s__ElectroStrike_st_dummy[this])
set s__ElectroStrike_st_caster[this]=null
set s__ElectroStrike_st_dummy[this]=null
call s__ElectroStrike_st_deallocate(this)
endfunction
function s__ElectroStrikeLaunch_st_Destroy takes integer this returns nothing
set s__ElectroStrikeLaunch_st_caster[this]=null
call s__ElectroStrikeLaunch_st_deallocate(this)
endfunction
function ElectroStrike_filter takes nothing returns boolean
return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))==true and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0.405
endfunction
function ElectroStrike_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer strike=LoadInt(id,"ElectroStrike | Structure")
local real x=GetUnitX(s__ElectroStrike_st_dummy[strike])
local real y=GetUnitY(s__ElectroStrike_st_dummy[strike])
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
local real x1
local real y1
if(s__ElectroStrike_st_distance[strike]>0)then
set x1=PolarPoints(x,y,s__ElectroStrike_st_speed[strike],GetUnitFacing(s__ElectroStrike_st_dummy[strike]),"x")
set y1=PolarPoints(x,y,s__ElectroStrike_st_speed[strike],GetUnitFacing(s__ElectroStrike_st_dummy[strike]),"y")
call SetUnitPosition(s__ElectroStrike_st_dummy[strike],x1,y1)
set s__ElectroStrike_st_distance[strike]=s__ElectroStrike_st_distance[strike]-s__ElectroStrike_st_speed[strike]
set bj_caster=s__ElectroStrike_st_caster[strike]
set filter=Condition(function ElectroStrike_filter)
call GroupEnumUnitsInRange(g,x1,y1,125.00,filter)
set target=FirstOfGroup(g)
if(target!=null)then
call GroupClear(g)
set filter=Condition(function ElectroStrike_filter)
call GroupEnumUnitsInRange(g,x1,y1,s__ElectroStrike_st_dmgRange[strike],filter)
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl",x1,y1)
call DestroyEffect(eff)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(s__ElectroStrike_st_caster[strike],target,s__ElectroStrike_st_damage[strike])
call GroupRemoveUnit(g,target)
endloop
call s__ElectroStrike_st_Destroy(strike)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
endif
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
set eff=AddSpecialEffect("Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl",x,y)
call DestroyEffect(eff)
set bj_caster=s__ElectroStrike_st_caster[strike]
set filter=Condition(function ElectroStrike_filter)
call GroupEnumUnitsInRange(g,x,y,s__ElectroStrike_st_dmgRange[strike],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(s__ElectroStrike_st_caster[strike],target,s__ElectroStrike_st_damage[strike])
call GroupRemoveUnit(g,target)
endloop
call s__ElectroStrike_st_Destroy(strike)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set t=null
set g=null
set eff=null
set filter=null
set target=null
endfunction
function ElectroStrike_launch takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer strike=LoadInt(id,"ElectroStrikeLaunch | Structure")
local real x=GetUnitX(s__ElectroStrikeLaunch_st_caster[strike])
local real y=GetUnitY(s__ElectroStrikeLaunch_st_caster[strike])
local timer spellTimer=CreateTimer()
local integer spellTimerID=GetHandleId(spellTimer)
local integer spellStrike=0
local real x1
local real y1
local real l__damage=30+((GetHeroLevel(s__ElectroStrikeLaunch_st_caster[strike])-1)*5)
local real distance=1000.00
local real dmgRange=150.00
local real periodic=0.03
local real speed=25.00
if GetUnitCurrentOrder(s__ElectroStrikeLaunch_st_caster[strike])==OrderId("channel")then
set s__ElectroStrikeLaunch_st_offsetAngle[strike]=s__ElectroStrikeLaunch_st_offsetAngle[strike]*-1
set x1=PolarPoints(x,y,s__ElectroStrikeLaunch_st_offset[strike],s__ElectroStrikeLaunch_st_angle[strike]+s__ElectroStrikeLaunch_st_offsetAngle[strike],"x")
set y1=PolarPoints(x,y,s__ElectroStrikeLaunch_st_offset[strike],s__ElectroStrikeLaunch_st_angle[strike]+s__ElectroStrikeLaunch_st_offsetAngle[strike],"y")
set spellStrike=s__ElectroStrike_st__allocate()
set s__ElectroStrike_st_caster[spellStrike]=s__ElectroStrikeLaunch_st_caster[strike]
set s__ElectroStrike_st_dummy[spellStrike]=CreateUnit(GetOwningPlayer(s__ElectroStrikeLaunch_st_caster[strike]),'h03I',x1,y1,s__ElectroStrikeLaunch_st_angle[strike])
set s__ElectroStrike_st_damage[spellStrike]=l__damage
set s__ElectroStrike_st_distance[spellStrike]=distance
set s__ElectroStrike_st_speed[spellStrike]=speed
set s__ElectroStrike_st_dmgRange[spellStrike]=dmgRange
call SaveInt(spellTimerID,"ElectroStrike | Structure",spellStrike)
call TimerStart(spellTimer,periodic,true,function ElectroStrike_timer)
else
call DestroyTimer(t)
call DestroyTimer(spellTimer)
call FlushChildHashtable(udg_Hash,id)
call s__ElectroStrikeLaunch_st_Destroy(strike)
endif
set t=null
set spellTimer=null
endfunction
function ElectroStrike_Actions takes nothing returns nothing
local integer strike=s__ElectroStrikeLaunch_st__allocate()
local unit caster=GetTriggerUnit()
local integer spellID=GetSpellAbilityId()
local real x1=GetSpellTargetX()
local real y1=GetSpellTargetY()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer id=0
local timer t
local real periodic=0.25
local real angle=Angle(x,y,x1,y1)
set s__ElectroStrikeLaunch_st_angle[strike]=angle
set s__ElectroStrikeLaunch_st_caster[strike]=caster
set s__ElectroStrikeLaunch_st_offset[strike]=150.00
set s__ElectroStrikeLaunch_st_offsetAngle[strike]=90.00
set t=CreateTimer()
set id=GetHandleId(t)
call SaveInt(id,"ElectroStrikeLaunch | Structure",strike)
call TimerStart(t,periodic,true,function ElectroStrike_launch)
set t=null
set caster=null
endfunction
function InitTrig_ElectroStrike takes nothing returns nothing
set gg_trg_ElectroStrike=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ElectroStrike,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_ElectroStrike,Condition(function ElectroStrike_Conditions))
call TriggerAddAction(gg_trg_ElectroStrike,function ElectroStrike_Actions)
endfunction
function s__StormBolt_st_Destroy takes integer this returns nothing
call RemoveUnit(s__StormBolt_st_dummy[this])
set s__StormBolt_st_caster[this]=null
set s__StormBolt_st_target[this]=null
set s__StormBolt_st_dummy[this]=null
call s__StormBolt_st_deallocate(this)
endfunction
function StormBolt_filter takes nothing returns boolean
return IsUnitEnemy(bj_caster,GetOwningPlayer(GetFilterUnit()))and GetWidgetLife(GetFilterUnit())>0.5 and not IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)
endfunction
function StormBolt_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer bolt=LoadInt(id,"StormBolt | Structure")
local real tX=GetUnitX(s__StormBolt_st_target[bolt])
local real tY=GetUnitY(s__StormBolt_st_target[bolt])
local real dX=GetUnitX(s__StormBolt_st_dummy[bolt])
local real dY=GetUnitY(s__StormBolt_st_dummy[bolt])
local group g=CreateGroup()
local boolexpr filter
local unit target
local unit dummy
local effect eff
local real x
local real y
local real dist=PointsDistance(dX,dY,tX,tY)
local real angle=PointsAngle(dX,dY,tX,tY)
local real stun=0.
local real l__damage=0.
if dist>75.00 then
set x=PolarPoints(dX,dY,30.00,angle,"x")
set y=PolarPoints(dX,dY,30.00,angle,"y")
call SetUnitPosition(s__StormBolt_st_dummy[bolt],x,y)
call SetUnitFacing(s__StormBolt_st_dummy[bolt],angle)
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",tX,tY)
call DestroyEffect(eff)
set bj_caster=s__StormBolt_st_caster[bolt]
set filter=Condition(function StormBolt_filter)
call GroupEnumUnitsInRange(g,tX,tY,s__StormBolt_st_range[bolt],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set l__damage=s__StormBolt_st_damage[bolt]
if isUnitHero(target)then
set stun=s__StormBolt_st_stun[bolt]/ 2
else
set stun=s__StormBolt_st_stun[bolt]
endif
if isPlayerHasSoloHero(Owner(s__StormBolt_st_caster[bolt]))and target==s__StormBolt_st_target[bolt]then
set l__damage=l__damage*1.3
set stun=stun+1.
endif
call Stun_Start(target,stun)
call MagDamage(s__StormBolt_st_caster[bolt],target,l__damage)
call GroupRemoveUnit(g,target)
endloop
call s__StormBolt_st_Destroy(bolt)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set t=null
set eff=null
set dummy=null
set target=null
set filter=null
endfunction
function StormBolt_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A03D')
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer bolt=s__StormBolt_st__allocate()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
set s__StormBolt_st_caster[bolt]=caster
set s__StormBolt_st_target[bolt]=target
set s__StormBolt_st_dummy[bolt]=CreateUnit(GetOwningPlayer(caster),'h03B',x,y,0)
set s__StormBolt_st_range[bolt]=200.00
set s__StormBolt_st_damage[bolt]=25+(25*lvl)
set s__StormBolt_st_stun[bolt]=0.5*lvl
set s__StormBolt_st_lvl[bolt]=lvl
call SaveInt(id,"StormBolt | Structure",bolt)
call TimerStart(t,0.04,true,function StormBolt_timer)
set t=null
set caster=null
set target=null
endfunction
function StormBolt_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A03D'
endfunction
function InitTrig_StormBolt takes nothing returns nothing
set gg_trg_StormBolt=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_StormBolt,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_StormBolt,Condition(function StormBolt_Conditions))
call TriggerAddAction(gg_trg_StormBolt,function StormBolt_Actions)
endfunction
function s__RocksInMe_st_Destroy takes integer this returns nothing
call DestroyEffect(s__RocksInMe_st_dummy[this])
set s__RocksInMe_st_caster[this]=null
set s__RocksInMe_st_dummy[this]=null
call s__RocksInMe_st_deallocate(this)
endfunction
function s__RocksInMeLaunch_st_Destroy takes integer this returns nothing
set s__RocksInMeLaunch_st_caster[this]=null
set s__RocksInMeLaunch_st_count[this]=0
call s__RocksInMeLaunch_st_deallocate(this)
endfunction
function RocksInMe_filter takes nothing returns boolean
return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))==true and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0.405
endfunction
function RocksInMe_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer strike=LoadInt(id,"RocksInMe | Structure")
local boolexpr filter
local unit target
local group g
local string effectPath="Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl"
local real angle=GetEffectFacing(s__RocksInMe_st_dummy[strike])
local real x=GetEffectX(s__RocksInMe_st_dummy[strike])
local real y=GetEffectY(s__RocksInMe_st_dummy[strike])
local real upSpeed=s__RocksInMe_st_speed[strike]*2
local real x1
local real y1
if s__RocksInMe_st_distance[strike]<s__RocksInMe_st_maxDistance[strike]then
call SetEffectHeightByDistance(s__RocksInMe_st_dummy[strike],s__RocksInMe_st_distance[strike],s__RocksInMe_st_maxDistance[strike],upSpeed)
set x1=PolarPoints(x,y,s__RocksInMe_st_speed[strike],angle,"x")
set y1=PolarPoints(x,y,s__RocksInMe_st_speed[strike],angle,"y")
call SetEffectX(s__RocksInMe_st_dummy[strike],x1)
call SetEffectY(s__RocksInMe_st_dummy[strike],y1)
set s__RocksInMe_st_distance[strike]=s__RocksInMe_st_distance[strike]+s__RocksInMe_st_speed[strike]
else
call DestroyTimer(t)
call TimedEffect(effectPath,x,y,1.00)
set g=CreateGroup()
set bj_caster=s__RocksInMe_st_caster[strike]
set filter=Condition(function RocksInMe_filter)
call GroupEnumUnitsInRange(g,x,y,s__RocksInMe_st_dmgRange[strike],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(s__RocksInMe_st_caster[strike],target,s__RocksInMe_st_damage[strike])
if not isUnitStruct(target)then
call Stun_Start(target,2.00)
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call CreateSummon(Owner(s__RocksInMe_st_caster[strike]),'n00D',x,y,angle,45.00)
call FlushChildHashtable(udg_Hash,id)
call s__RocksInMe_st_Destroy(strike)
endif
set t=null
set g=null
set target=null
set filter=null
endfunction
function RocksInMe_launch takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer strike=LoadInt(id,"RocksInMeLaunch | Structure")
local real x=GetUnitX(s__RocksInMeLaunch_st_caster[strike])
local real y=GetUnitY(s__RocksInMeLaunch_st_caster[strike])
local timer spellTimer=CreateTimer()
local integer spellTimerID=GetHandleId(spellTimer)
local integer spellStrike=0
local real x1=GetRandomPointInRange(x,y,1000,"x")
local real y1=GetRandomPointInRange(x,y,1000,"y")
local real distance=PointsDistance(x,y,x1,y1)
local real dmgRange=200.00
local real periodic=0.03
local real speed=25.00
local real angle=Angle(x,y,x1,y1)
local string effectPath="Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl"
if distance<300.00 then
set distance=300.00
endif
if GetUnitCurrentOrder(s__RocksInMeLaunch_st_caster[strike])==OrderId("clusterrockets")and s__RocksInMeLaunch_st_count[strike]>0 then
set spellStrike=s__RocksInMe_st__allocate()
set s__RocksInMe_st_caster[spellStrike]=s__RocksInMeLaunch_st_caster[strike]
set s__RocksInMe_st_dummy[spellStrike]=AddSpecialEffect(effectPath,x,y)
set s__RocksInMe_st_damage[spellStrike]=s__RocksInMeLaunch_st_damage[strike]
set s__RocksInMe_st_distance[spellStrike]=0.00
set s__RocksInMe_st_speed[spellStrike]=speed
set s__RocksInMe_st_dmgRange[spellStrike]=dmgRange
set s__RocksInMe_st_maxDistance[spellStrike]=distance
call SetEffectFacing(s__RocksInMe_st_dummy[spellStrike],angle)
call SetEffectScale(s__RocksInMe_st_dummy[spellStrike],2.00)
call SaveInt(spellTimerID,"RocksInMe | Structure",spellStrike)
call TimerStart(spellTimer,periodic,true,function RocksInMe_timer)
set s__RocksInMeLaunch_st_count[strike]=s__RocksInMeLaunch_st_count[strike]-1
else
call DestroyTimer(t)
call DestroyTimer(spellTimer)
call FlushChildHashtable(udg_Hash,id)
call s__RocksInMeLaunch_st_Destroy(strike)
endif
set t=null
set spellTimer=null
endfunction
function RocksInMe_Actions takes nothing returns nothing
local integer strike=s__RocksInMeLaunch_st__allocate()
local unit caster=GetTriggerUnit()
local integer spellID=GetSpellAbilityId()
local integer lvl=GetUnitAbilityLevel(caster,spellID)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real periodic=0.10
local integer count=lvl*2
local real l__damage=20*lvl
set s__RocksInMeLaunch_st_damage[strike]=l__damage
set s__RocksInMeLaunch_st_count[strike]=count
set s__RocksInMeLaunch_st_caster[strike]=caster
call SaveInt(id,"RocksInMeLaunch | Structure",strike)
call TimerStart(t,periodic,true,function RocksInMe_launch)
set t=null
set caster=null
endfunction
function RocksInMe_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A054'
endfunction
function InitTrig_RocksInMe takes nothing returns nothing
local trigger t=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(t,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(t,Condition(function RocksInMe_Conditions))
call TriggerAddAction(t,function RocksInMe_Actions)
set t=null
endfunction
function WarStomp_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0E1'
endfunction
function WarStomp_filter takes nothing returns boolean
return IsUnitEnemy(bj_caster,GetOwningPlayer(GetFilterUnit()))and GetWidgetLife(GetFilterUnit())>0.5
endfunction
function WarStomp_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,id,StringHash("WarStomp|Caster"))
local integer currentWave=LoadInteger(udg_Hash,id,StringHash("WarStomp|CurrentWave"))
local integer count=LoadInteger(udg_Hash,id,StringHash("WarStomp|Count"))
local integer waves=LoadInteger(udg_Hash,id,StringHash("WarStomp|Waves"))
local group g=LoadGroupHandle(udg_Hash,id,StringHash("WarStomp|Group"))
local real l__damage=LoadReal(udg_Hash,id,StringHash("WarStomp|Damage"))
local real x=LoadReal(udg_Hash,id,StringHash("WarStomp|X"))
local real y=LoadReal(udg_Hash,id,StringHash("WarStomp|Y"))
local integer i=1
local boolexpr filter
local unit target
local effect eff
local real x1
local real y1
local real angle=360/ count
local real damageRange=250.00
local real waveRange=100.00
if(currentWave<=waves)then
loop
exitwhen i>count
set x1=PolarPoints(x,y,waveRange*currentWave,angle*i,"x")
set y1=PolarPoints(x,y,waveRange*currentWave,angle*i,"y")
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl",x1,y1)
call DestroyEffect(eff)
set bj_caster=caster
set filter=Condition(function WarStomp_filter)
call GroupEnumUnitsInRange(g,x1,y1,damageRange,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(caster,target,l__damage)
call GroupRemoveUnit(g,target)
endloop
call DestroyBoolExpr(filter)
set i=i+1
endloop
call SaveInteger(udg_Hash,id,StringHash("WarStomp|CurrentWave"),currentWave+1)
else
call DestroyTimer(t)
call DestroyGroup(g)
call FlushChildHashtable(udg_Hash,id)
endif
call DestroyBoolExpr(filter)
set t=null
set g=null
set eff=null
set caster=null
set target=null
set filter=null
endfunction
function WarStomp_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local timer t=CreateTimer()
local group g=CreateGroup()
local integer id=GetHandleId(t)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=1
local integer count=6
local integer waves=5
local real periodic=0.20
local real l__damage=15+(4*(lvl-1))
call SaveUnitHandle(udg_Hash,id,StringHash("WarStomp|Caster"),caster)
call SaveInteger(udg_Hash,id,StringHash("WarStomp|CurrentWave"),1)
call SaveInteger(udg_Hash,id,StringHash("WarStomp|Count"),count)
call SaveInteger(udg_Hash,id,StringHash("WarStomp|Waves"),waves)
call SaveGroupHandle(udg_Hash,id,StringHash("WarStomp|Group"),g)
call SaveReal(udg_Hash,id,StringHash("WarStomp|Damage"),l__damage)
call SaveReal(udg_Hash,id,StringHash("WarStomp|X"),x)
call SaveReal(udg_Hash,id,StringHash("WarStomp|Y"),y)
call TimerStart(t,periodic,true,function WarStomp_timer)
set t=null
set g=null
set caster=null
endfunction
function InitTrig_WarStomp takes nothing returns nothing
set gg_trg_WarStomp=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_WarStomp,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_WarStomp,Condition(function WarStomp_Conditions))
call TriggerAddAction(gg_trg_WarStomp,function WarStomp_Actions)
endfunction
function RatUp_Conditions takes nothing returns boolean
return GetLearnedSkill()=='A0FX' or GetLearnedSkill()=='A0FZ' or GetLearnedSkill()=='A0G0'
endfunction
function RatUp_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetLearnedSkill()
local integer lvl=GetUnitAbilityLevel(caster,id)
local integer total_grade=0
if(id=='A0FZ')then
set total_grade='R04G'
elseif(id=='A0G0')then
set total_grade='R04H'
elseif(id=='A0FX')then
set total_grade='R04F'
endif
call SetPlayerTechResearched(GetOwningPlayer(caster),total_grade,lvl)
set caster=null
endfunction
function InitTrig_RatUp takes nothing returns nothing
set gg_trg_RatUp=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_RatUp,EVENT_PLAYER_HERO_SKILL)
call TriggerAddCondition(gg_trg_RatUp,Condition(function RatUp_Conditions))
call TriggerAddAction(gg_trg_RatUp,function RatUp_Actions)
endfunction
function CursedSeno_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FW'
endfunction
function CursedSeno_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local texttag tt=LoadTextTagHandle(udg_Hash,id,StringHash("CursedSeno|TextTag"))
local real periodic=LoadReal(udg_Hash,id,StringHash("CursedSeno|Periodic"))
local real max_time=LoadReal(udg_Hash,id,StringHash("CursedSeno|MaxTime"))
local unit dami=LoadUnitHandle(udg_Hash,id,StringHash("CursedSeno|Dami"))
local real time=LoadReal(udg_Hash,id,StringHash("CursedSeno|Time"))
local real x=GetUnitX(dami)
local real y=GetUnitY(dami)
local effect eff
local string s
if(dami!=null and GetUnitState(dami,UNIT_STATE_LIFE)>0)then
set s=R2SW(time,0,1)
call SetTextTagText(tt,s,(10*0.023)/ 10)
call SetTextTagPosUnit(tt,dami,0)
call SaveReal(udg_Hash,id,StringHash("CursedSeno|Time"),time-periodic)
if(time<0.10)then
if(Rats[GetPlayerId(GetOwningPlayer(dami))+1]<Rat_Limit)then
call CreateUnit(GetOwningPlayer(dami),'h010',x,y,270)
endif
call SaveReal(udg_Hash,id,StringHash("CursedSeno|Time"),max_time)
set eff=AddSpecialEffect("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",x,y)
call DestroyEffect(eff)
endif
else
call DestroyTimer(t)
call DestroyTextTag(tt)
call FlushChildHashtable(udg_Hash,id)
endif
set t=null
set tt=null
set eff=null
set dami=null
endfunction
function CursedSeno_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0FW')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local texttag tt
local unit dami
local real lvl_coef=2.50
local real time=25.00-(lvl_coef*(lvl-1))
local real periodic=0.10
set dami=CreateUnit(GetOwningPlayer(caster),'u01O',x,y,270)
set tt=Timer_Text(dami,time)
call SaveTextTagHandle(udg_Hash,id,StringHash("CursedSeno|TextTag"),tt)
call SaveReal(udg_Hash,id,StringHash("CursedSeno|Periodic"),periodic)
call SaveUnitHandle(udg_Hash,id,StringHash("CursedSeno|Dami"),dami)
call SaveReal(udg_Hash,id,StringHash("CursedSeno|MaxTime"),time)
call SaveReal(udg_Hash,id,StringHash("CursedSeno|Time"),time)
call TimerStart(t,periodic,true,function CursedSeno_timer)
set t=null
set tt=null
set dami=null
set caster=null
endfunction
function InitTrig_CursedSeno takes nothing returns nothing
set gg_trg_CursedSeno=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_CursedSeno,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_CursedSeno,Condition(function CursedSeno_Conditions))
call TriggerAddAction(gg_trg_CursedSeno,function CursedSeno_Actions)
endfunction
function GuardSouls_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FI'
endfunction
function GuardSouls takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer h=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,h,1)
local unit Dami=LoadUnitHandle(udg_Hash,h,2)
local integer counter=LoadInteger(udg_Hash,h,3)
local integer grad=LoadInteger(udg_Hash,h,4)
local integer nap=LoadInteger(udg_Hash,h,5)
local integer face=LoadInteger(udg_Hash,h,6)
local real x=GetUnitX(caster)+350*Cos(grad*bj_DEGTORAD)
local real y=GetUnitY(caster)+350*Sin(grad*bj_DEGTORAD)
if counter>0 then
call SetUnitPosition(Dami,x,y)
call SetUnitFacing(Dami,face+grad)
call SaveInteger(udg_Hash,h,3,counter-1)
call SaveInteger(udg_Hash,h,4,grad+nap)
else
if(GetUnitAbilityLevel(Dami,'A098')>0)then
call RemoveItem(UnitItemInSlot(Dami,0))
endif
call KillUnit(Dami)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,h)
endif
set Dami=null
set caster=null
set t=null
endfunction
function GuardSouls_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0FI')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer q=1
local timer t
local integer h
local unit Dami
local real max=2
local real time=5+(5*lvl)
local integer i=R2I(time/ 0.02)
loop
exitwhen q>max
set t=CreateTimer()
set h=GetHandleId(t)
set Dami=CreateUnit(GetOwningPlayer(caster),'h035',x,y,bj_UNIT_FACING)
call SetUnitAbilityLevel(Dami,'A0FJ',lvl)
call SaveUnitHandle(udg_Hash,h,1,caster)
call SaveUnitHandle(udg_Hash,h,2,Dami)
call SaveInteger(udg_Hash,h,3,i)
call SaveInteger(udg_Hash,h,4,0)
call SaveInteger(udg_Hash,h,5,(-3+((q-1)*6)))
call SaveInteger(udg_Hash,h,6,(-90+((q-1)*180)))
call TimerStart(t,0.02,true,function GuardSouls)
set q=q+1
endloop
set Dami=null
set caster=null
set t=null
endfunction
function InitTrig_GuardSouls takes nothing returns nothing
set gg_trg_GuardSouls=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_GuardSouls,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_GuardSouls,Condition(function GuardSouls_Conditions))
call TriggerAddAction(gg_trg_GuardSouls,function GuardSouls_Actions)
endfunction
function HealCircle_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FH'
endfunction
function HealCircle_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))==false
endfunction
function HealCircle_Actions takes nothing returns nothing
local boolexpr filter=Condition(function HealCircle_filter)
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0FH')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local lightning array light
local integer i=1
local unit target
local effect eff
local real heal
local real mana
local string s
local real x1
local real y1
local real x2
local real y2
local integer count=10
local real range=500.00
local real procent=0.015*lvl
local real angle=360/ count
local integer light_count=count
loop
exitwhen i>light_count
call DestroyLightning(light[i])
set x1=x+range*Cos((angle*i)*bj_DEGTORAD)
set y1=y+range*Sin((angle*i)*bj_DEGTORAD)
set x2=x+range*Cos((angle*(i+1))*bj_DEGTORAD)
set y2=y+range*Sin((angle*(i+1))*bj_DEGTORAD)
set light[i]=AddLightningEx("SPLK",true,x1,y1,50,x2,y2,50)
set i=i+1
endloop
loop
exitwhen count<=0
set bj_caster=caster
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set heal=GetUnitState(target,UNIT_STATE_MAX_LIFE)*procent
set mana=GetUnitState(target,UNIT_STATE_MAX_MANA)*procent
if isUnitStruct(target)then
set heal=GetUnitState(target,UNIT_STATE_MAX_LIFE)*(procent/ 8)
set mana=GetUnitState(target,UNIT_STATE_MAX_MANA)*(procent/ 8)
endif
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\ReplenishMana\\SpiritTouchTarget.mdl",target,"origin")
set s="+"+I2S(R2I(heal))+" hp"
call HP_RESTORE(target,heal,s,10.00,0,255,0,60,96.00,0.75)
set s="+"+I2S(R2I(mana))+" mp"
call MP_RESTORE(target,mana,s,10.00,0,51,255,0,96.00,0.75)
call DestroyEffect(eff)
call GroupRemoveUnit(g,target)
endloop
call TriggerSleepAction(1.00)
set range=range*0.90
set procent=procent*1.10
set i=1
loop
exitwhen i>light_count
call DestroyLightning(light[i])
set light[i]=null
if(count>1)then
set x1=x+range*Cos((angle*i)*bj_DEGTORAD)
set y1=y+range*Sin((angle*i)*bj_DEGTORAD)
set x2=x+range*Cos((angle*(i+1))*bj_DEGTORAD)
set y2=y+range*Sin((angle*(i+1))*bj_DEGTORAD)
set light[i]=AddLightningEx("SPLK",true,x1,y1,50,x2,y2,50)
endif
set i=i+1
endloop
set count=count-1
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_HealCircle takes nothing returns nothing
set gg_trg_HealCircle=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_HealCircle,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_HealCircle,Condition(function HealCircle_Conditions))
call TriggerAddAction(gg_trg_HealCircle,function HealCircle_Actions)
endfunction
function Portals_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FF'
endfunction
function Portals_filter takes nothing returns boolean
return not isUnitStruct(GetFilterUnit())
endfunction
function Portals_move takes nothing returns nothing
local trigger Trigger=GetTriggeringTrigger()
local integer id=GetHandleId(Trigger)
local unit caster=LoadUnitHandle(udg_Hash,id,StringHash("Portals|Caster"))
local integer caster_id=GetHandleId(caster)
local unit first_portal=LoadUnitHandle(udg_Hash,caster_id,StringHash("Portals|FirstPortal"))
local unit second_portal=LoadUnitHandle(udg_Hash,caster_id,StringHash("Portals|SecondPortal"))
local integer number=LoadInteger(udg_Hash,id,StringHash("Portals|Number"))
local unit target=GetTriggerUnit()
local effect eff
local real angle
local real x
local real y
local real dist=300.00
if IsUnitType(target,UNIT_TYPE_STRUCTURE)==false and GetUnitHealth(first_portal)>0 and GetUnitHealth(second_portal)>0 then
call PauseUnit(target,true)
call IssueImmediateOrder(target,"stop")
call PauseUnit(target,false)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",target,"origin")
call DestroyEffect(eff)
if(number==1)then
set angle=GetUnitFacing(second_portal)
set x=GetUnitX(second_portal)+dist*Cos(angle*bj_DEGTORAD)
set y=GetUnitY(second_portal)+dist*Sin(angle*bj_DEGTORAD)
call SetUnitX(target,x)
call SetUnitY(target,y)
else
set angle=GetUnitFacing(first_portal)
set x=GetUnitX(first_portal)+dist*Cos(angle*bj_DEGTORAD)
set y=GetUnitY(first_portal)+dist*Sin(angle*bj_DEGTORAD)
call SetUnitX(target,x)
call SetUnitY(target,y)
endif
endif
set eff=null
set target=null
set caster=null
set Trigger=null
set first_portal=null
set second_portal=null
endfunction
function Portals_Actions takes nothing returns nothing
local boolexpr filter=Condition(function Portals_filter)
local unit caster=GetTriggerUnit()
local integer id=GetHandleId(caster)
local trigger first_trigger=LoadTriggerHandle(udg_Hash,id,StringHash("Portals|FirstTrigger"))
local integer first_id=GetHandleId(first_trigger)
local trigger second_trigger=LoadTriggerHandle(udg_Hash,id,StringHash("Portals|SecondTrigger"))
local integer second_id=GetHandleId(second_trigger)
local unit first_portal=LoadUnitHandle(udg_Hash,id,StringHash("Portals|FirstPortal"))
local unit second_portal=LoadUnitHandle(udg_Hash,id,StringHash("Portals|SecondPortal"))
local player p=GetOwningPlayer(caster)
local real angle=GetUnitFacing(caster)+180.00
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local integer portal_id='hprt'
local real range=150.00
if first_portal==null or GetUnitHealth(first_portal)<=0 then
set first_portal=CreateUnit(p,portal_id,x,y,angle)
call SetUnitAnimation(first_portal,"birth")
set first_trigger=CreateTrigger()
set first_id=GetHandleId(first_trigger)
call TriggerRegisterUnitInRange(first_trigger,first_portal,range,filter)
elseif second_portal==null or GetUnitHealth(second_portal)<=0 then
set second_portal=CreateUnit(p,portal_id,x,y,angle)
call SetUnitAnimation(second_portal,"birth")
set second_trigger=CreateTrigger()
set second_id=GetHandleId(second_trigger)
call TriggerRegisterUnitInRange(second_trigger,second_portal,range,filter)
call TriggerAddAction(second_trigger,function Portals_move)
call TriggerAddAction(first_trigger,function Portals_move)
else
call KillUnit(first_portal)
call DestroyTrigger(first_trigger)
call FlushChildHashtable(udg_Hash,first_id)
set first_trigger=second_trigger
set first_portal=second_portal
set first_id=GetHandleId(first_trigger)
set second_portal=CreateUnit(p,portal_id,x,y,angle)
call SetUnitAnimation(second_portal,"birth")
set second_trigger=CreateTrigger()
set second_id=GetHandleId(second_trigger)
call TriggerRegisterUnitInRange(second_trigger,second_portal,range,filter)
call TriggerAddAction(second_trigger,function Portals_move)
endif
call SaveTriggerHandle(udg_Hash,id,StringHash("Portals|FirstTrigger"),first_trigger)
call SaveUnitHandle(udg_Hash,id,StringHash("Portals|FirstPortal"),first_portal)
call SaveUnitHandle(udg_Hash,first_id,StringHash("Portals|Caster"),caster)
call SaveInteger(udg_Hash,first_id,StringHash("Portals|Number"),1)
call SaveTriggerHandle(udg_Hash,id,StringHash("Portals|SecondTrigger"),second_trigger)
call SaveUnitHandle(udg_Hash,id,StringHash("Portals|SecondPortal"),second_portal)
call SaveUnitHandle(udg_Hash,second_id,StringHash("Portals|Caster"),caster)
call SaveInteger(udg_Hash,second_id,StringHash("Portals|Number"),2)
call DestroyBoolExpr(filter)
set filter=null
set caster=null
set first_portal=null
set second_portal=null
set first_trigger=null
set second_trigger=null
endfunction
function InitTrig_Portals takes nothing returns nothing
set gg_trg_Portals=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Portals,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Portals,Condition(function Portals_Conditions))
call TriggerAddAction(gg_trg_Portals,function Portals_Actions)
endfunction
function KokonSpawn_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())=='u01I'
endfunction
function KokonSpawn_Actions takes nothing returns nothing
local integer id=GetSpellAbilityId()
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,id)
local player p=GetOwningPlayer(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer count
local integer u_id
local integer lvl_coef=0
if(id=='A0FA')then
set u_id='z001'
set lvl_coef=2
elseif(id=='A0FB')then
set u_id='z000'
set lvl_coef=1
elseif(id=='A0FC')then
set u_id='n01Z'
set lvl_coef=1
elseif(id=='A0FD')then
set u_id='u01J'
set lvl_coef=1
endif
set count=lvl_coef*lvl
loop
exitwhen count<=0
call CreateUnit(p,u_id,x,y,0)
set count=count-1
endloop
call KillUnit(caster)
set caster=null
endfunction
function InitTrig_KokonSpawn takes nothing returns nothing
set gg_trg_KokonSpawn=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_KokonSpawn,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_KokonSpawn,Condition(function KokonSpawn_Conditions))
call TriggerAddAction(gg_trg_KokonSpawn,function KokonSpawn_Actions)
endfunction
function Ultralish_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0F9'
endfunction
function Ultralisk_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local texttag tt_target=LoadTextTagHandle(udg_Hash,id,StringHash("Ultralisk|TextTag_Target"))
local unit target=LoadUnitHandle(udg_Hash,id,StringHash("Ultralisk|Dami"))
local real periodic=LoadReal(udg_Hash,id,StringHash("Ultralisk|Periodic"))
local real time=LoadReal(udg_Hash,id,StringHash("Ultralisk|Time"))
local real hp=GetUnitState(target,UNIT_STATE_LIFE)
local player p=GetOwningPlayer(target)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local string s
if(time>0 and hp>0)then
set s=R2SW(time,0,1)
call SetTextTagText(tt_target,s,(12*0.023)/ 10)
call SetTextTagPosUnit(tt_target,target,0)
call SaveReal(udg_Hash,id,StringHash("Ultralisk|Time"),time-periodic)
else
if(hp>0)then
call KillUnit(target)
call CreateUnit(p,'n020',x,y,0)
endif
call DestroyTimer(t)
call DestroyTextTag(tt_target)
call FlushChildHashtable(udg_Hash,id)
endif
set p=null
set t=null
set target=null
set tt_target=null
endfunction
function Ultralish_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0F9')
local player p=GetOwningPlayer(caster)
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local texttag tt_target
local unit dami
local string s
local real lvl_coef=10.00
local real time=40.00-(lvl_coef*lvl)
local real periodic=0.10
set dami=CreateUnit(p,'u01K',x,y,0)
set tt_target=Timer_Text(dami,time)
call SaveTextTagHandle(udg_Hash,id,StringHash("Ultralisk|TextTag_Target"),tt_target)
call SaveReal(udg_Hash,id,StringHash("Ultralisk|Periodic"),periodic)
call SaveUnitHandle(udg_Hash,id,StringHash("Ultralisk|Dami"),dami)
call SaveReal(udg_Hash,id,StringHash("Ultralisk|Time"),time)
call TimerStart(t,periodic,true,function Ultralisk_timer)
set t=null
set p=null
set dami=null
set caster=null
set tt_target=null
endfunction
function InitTrig_Ultralish takes nothing returns nothing
set gg_trg_Ultralish=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Ultralish,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Ultralish,Condition(function Ultralish_Conditions))
call TriggerAddAction(gg_trg_Ultralish,function Ultralish_Actions)
endfunction
function Kor_Kokon_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0F8'
endfunction
function Kor_Kokon_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local integer lvl=GetUnitAbilityLevel(caster,'A0F8')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local unit dami
set dami=CreateUnit(p,'u01I',x,y,270)
call SetUnitAbilityLevel(dami,'A0FA',lvl)
call SetUnitAbilityLevel(dami,'A0FB',lvl)
call SetUnitAbilityLevel(dami,'A0FC',lvl)
call SetUnitAbilityLevel(dami,'A0FD',lvl)
set p=null
set dami=null
set caster=null
endfunction
function InitTrig_Kor_Kokon takes nothing returns nothing
set gg_trg_Kor_Kokon=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Kor_Kokon,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Kor_Kokon,Condition(function Kor_Kokon_Conditions))
call TriggerAddAction(gg_trg_Kor_Kokon,function Kor_Kokon_Actions)
endfunction
function Trig_Evolution_Conditions takes nothing returns boolean
if(not(GetLearnedSkillBJ()=='A0F5'))then
return false
endif
return true
endfunction
function Trig_Evolution_Actions takes nothing returns nothing
call SetPlayerTechResearchedSwap('R048',(GetUnitAbilityLevelSwapped('A0F5',GetTriggerUnit())+0),GetOwningPlayer(GetTriggerUnit()))
endfunction
function InitTrig_Evolution takes nothing returns nothing
set gg_trg_Evolution=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Evolution,EVENT_PLAYER_HERO_SKILL)
call TriggerAddCondition(gg_trg_Evolution,Condition(function Trig_Evolution_Conditions))
call TriggerAddAction(gg_trg_Evolution,function Trig_Evolution_Actions)
endfunction
function Zabitoe_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0EJ'
endfunction
function Zabitoe_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,id,StringHash("Zabitoe|Caster"))
local integer count=LoadInteger(udg_Hash,id,StringHash("Zabitoe|Count"))
local real range=LoadReal(udg_Hash,id,StringHash("Zabitoe|Range"))
local real x1=LoadReal(udg_Hash,id,StringHash("Zabitoe|X"))
local real y1=LoadReal(udg_Hash,id,StringHash("Zabitoe|Y"))
local player p=GetOwningPlayer(caster)
local unit dami
local real x
local real y
if(count>0)then
set x=GetRandomReal(x1-(range/ 2),x1+(range/ 2))
set y=GetRandomReal(y1-(range/ 2),y1+(range/ 2))
set dami=CreateUnit(p,'n01S',x,y,0)
call UnitApplyTimedLife(dami,'eqwe',60)
call SaveInteger(udg_Hash,id,StringHash("Zabitoe|Count"),count-1)
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
endif
set t=null
set p=null
set dami=null
set caster=null
endfunction
function Zabitoe_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0EJ')
local real x1=GetUnitX(caster)
local real y1=GetUnitY(caster)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer count=13*lvl
local real range=750.00+((lvl*100)-100)
if isPlayerHasSoloHero(Owner(caster))then
set count=count+5
endif
call SaveUnitHandle(udg_Hash,id,StringHash("Zabitoe|Caster"),caster)
call SaveInteger(udg_Hash,id,StringHash("Zabitoe|Count"),count)
call SaveReal(udg_Hash,id,StringHash("Zabitoe|Range"),range)
call SaveReal(udg_Hash,id,StringHash("Zabitoe|X"),x1)
call SaveReal(udg_Hash,id,StringHash("Zabitoe|Y"),y1)
call TimerStart(t,0.05,true,function Zabitoe_timer)
set t=null
set caster=null
endfunction
function InitTrig_Zabitoe takes nothing returns nothing
set gg_trg_Zabitoe=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Zabitoe,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Zabitoe,Condition(function Zabitoe_Conditions))
call TriggerAddAction(gg_trg_Zabitoe,function Zabitoe_Actions)
endfunction
function Trig_OldMosh_Conditions takes nothing returns boolean
if(not(GetLearnedSkillBJ()=='A0EK'))then
return false
endif
return true
endfunction
function Trig_OldMosh_Actions takes nothing returns nothing
call SetPlayerTechResearchedSwap('R03X',(GetUnitAbilityLevelSwapped('A0EK',GetTriggerUnit())+0),GetOwningPlayer(GetTriggerUnit()))
endfunction
function InitTrig_OldMosh takes nothing returns nothing
set gg_trg_OldMosh=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_OldMosh,EVENT_PLAYER_HERO_SKILL)
call TriggerAddCondition(gg_trg_OldMosh,Condition(function Trig_OldMosh_Conditions))
call TriggerAddAction(gg_trg_OldMosh,function Trig_OldMosh_Actions)
endfunction
function s__LifeObmen_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__LifeObmen_st_Timer[this])
call DestroyTimer(s__LifeObmen_st_Timer[this])
call DestroyLightning(s__LifeObmen_st_light[this])
call DestroyTextTag(s__LifeObmen_st_ttCaster[this])
call DestroyTextTag(s__LifeObmen_st_ttTarget[this])
call FlushChildHashtable(udg_Hash,id)
set s__LifeObmen_st_Timer[this]=null
set s__LifeObmen_st_target[this]=null
set s__LifeObmen_st_caster[this]=null
set s__LifeObmen_st_ttCaster[this]=null
set s__LifeObmen_st_ttTarget[this]=null
set s__LifeObmen_st_light[this]=null
call s__LifeObmen_st_deallocate(this)
endfunction
function LifeObmen_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer lo=LoadInt(id,"LifeObmen | Structure")
local real casterHp=GetUnitHealthPercent(s__LifeObmen_st_caster[lo])*GetUnitMaxHealth(s__LifeObmen_st_target[lo])
local real targetHp=GetUnitHealthPercent(s__LifeObmen_st_target[lo])*GetUnitMaxHealth(s__LifeObmen_st_caster[lo])
local real x1=GetUnitX(s__LifeObmen_st_caster[lo])
local real y1=GetUnitY(s__LifeObmen_st_caster[lo])
local real x2=GetUnitX(s__LifeObmen_st_target[lo])
local real y2=GetUnitY(s__LifeObmen_st_target[lo])
local real dx=x2-x1
local real dy=y2-y1
local real distance=SquareRoot(dx*dx+dy*dy)
local effect eff
local string s
local real casterManaPer=0.
local real targetManaPer=0.
if GetUnitMaxMana(s__LifeObmen_st_target[lo])>0.00 then
set casterManaPer=GetUnitManaPercent_new(s__LifeObmen_st_target[lo])*GetUnitMaxMana(s__LifeObmen_st_caster[lo])
set targetManaPer=GetUnitManaPercent_new(s__LifeObmen_st_caster[lo])*GetUnitMaxMana(s__LifeObmen_st_target[lo])
endif
if s__LifeObmen_st_time[lo]>0 and s__LifeObmen_st_target[lo]!=null then
set s=R2SW(s__LifeObmen_st_time[lo],0,1)
call SetTextTagText(s__LifeObmen_st_ttCaster[lo],s,(12*0.023)/ 10)
call SetTextTagPosUnit(s__LifeObmen_st_ttCaster[lo],s__LifeObmen_st_caster[lo],0)
call SetTextTagText(s__LifeObmen_st_ttTarget[lo],s,(12*0.023)/ 10)
call SetTextTagPosUnit(s__LifeObmen_st_ttTarget[lo],s__LifeObmen_st_target[lo],0)
call MoveLightningEx(s__LifeObmen_st_light[lo],true,x1,y1,75,x2,y2,75)
if distance>s__LifeObmen_st_maxDistance[lo]then
call SetLightningColor(s__LifeObmen_st_light[lo],0.50,0.50,0.50,0.50)
else
call SetLightningColor(s__LifeObmen_st_light[lo],1,1,1,1)
endif
set s__LifeObmen_st_time[lo]=s__LifeObmen_st_time[lo]-s__LifeObmen_st_periodic[lo]
else
if isPlayerHasSoloHero(Owner(s__LifeObmen_st_caster[lo]))then
call SetUnitMana(s__LifeObmen_st_caster[lo],casterManaPer)
call SetUnitMana(s__LifeObmen_st_target[lo],targetManaPer)
endif
if distance>s__LifeObmen_st_maxDistance[lo]then
if casterHp>0 and targetHp>0 then
call SetUnitState(s__LifeObmen_st_caster[lo],UNIT_STATE_LIFE,targetHp)
call SetUnitState(s__LifeObmen_st_target[lo],UNIT_STATE_LIFE,casterHp)
endif
else
call SetUnitState(s__LifeObmen_st_caster[lo],UNIT_STATE_LIFE,targetHp)
call SetUnitState(s__LifeObmen_st_target[lo],UNIT_STATE_LIFE,casterHp)
endif
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl",s__LifeObmen_st_caster[lo],"origin")
call DestroyEffect(eff)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl",s__LifeObmen_st_target[lo],"origin")
call DestroyEffect(eff)
call s__LifeObmen_st_Destroy(lo)
endif
set t=null
set eff=null
endfunction
function LifeObmen_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0EZ')
local real x1=GetUnitX(caster)
local real y1=GetUnitY(caster)
local real x2=GetUnitX(target)
local real y2=GetUnitY(target)
local integer id=0
local real lvl_coef=2.50
local real time=15.00-(lvl_coef*(lvl-1))
local real range=800.00+(100.00*lvl)
local real periodic=0.02
local string linkType="DRAB"
local integer lo=s__LifeObmen_st__allocate()
set id=GetHandleId(s__LifeObmen_st_Timer[lo])
set s__LifeObmen_st_caster[lo]=caster
set s__LifeObmen_st_target[lo]=target
set s__LifeObmen_st_time[lo]=time
set s__LifeObmen_st_maxDistance[lo]=range
set s__LifeObmen_st_periodic[lo]=periodic
set s__LifeObmen_st_linkType[lo]=linkType
set s__LifeObmen_st_ttCaster[lo]=Timer_Text(s__LifeObmen_st_caster[lo],time)
set s__LifeObmen_st_ttTarget[lo]=Timer_Text(s__LifeObmen_st_target[lo],time)
if isPlayerHasSoloHero(Owner(caster))then
set s__LifeObmen_st_linkType[lo]="SPLK"
set s__LifeObmen_st_maxDistance[lo]=s__LifeObmen_st_maxDistance[lo]+350.
endif
set s__LifeObmen_st_light[lo]=AddLightningEx(s__LifeObmen_st_linkType[lo],true,x1,y1,75,x2,y2,75)
call SaveInt(id,"LifeObmen | Structure",lo)
call TimerStart(s__LifeObmen_st_Timer[lo],s__LifeObmen_st_periodic[lo],true,function LifeObmen_timer)
set caster=null
set target=null
endfunction
function LifeObmen_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0EZ'
endfunction
function InitTrig_LifeObmen takes nothing returns nothing
set gg_trg_LifeObmen=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_LifeObmen,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_LifeObmen,Condition(function LifeObmen_Conditions))
call TriggerAddAction(gg_trg_LifeObmen,function LifeObmen_Actions)
endfunction
function Kartech_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0EG'
endfunction
function Kartech_Filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))
endfunction
function Kartech_Timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer h=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,h,StringHash("Kartech|Caster"))
local unit dami=LoadUnitHandle(udg_Hash,h,StringHash("Kartech|Dami"))
local real dmg=LoadReal(udg_Hash,h,StringHash("Kartech|DMG"))
local real speed=LoadReal(udg_Hash,h,StringHash("Kartech|Speed"))
local real enemie_dmg=LoadReal(udg_Hash,h,StringHash("Kartech|Enemie"))
local real dist_dmg=LoadReal(udg_Hash,h,StringHash("Kartech|Dist_Dmg"))
local real max_dist=LoadReal(udg_Hash,h,StringHash("Kartech|Max_Dist"))
local real dist=LoadReal(udg_Hash,h,StringHash("Kartech|Dist"))
local group g=LoadGroupHandle(udg_Hash,h,StringHash("Kartech|Group"))
local group gg=LoadGroupHandle(udg_Hash,h,StringHash("Kartech|Group_Two"))
local boolexpr filter=Condition(function Kartech_Filter)
local real angle=GetUnitFacing(dami)
local real x=GetUnitX(dami)
local real y=GetUnitY(dami)
local unit target
local effect eff
local real x1
local real y1
if(dist<=max_dist)then
set x1=x+speed*Cos(angle*bj_DEGTORAD)
set y1=y+speed*Sin(angle*bj_DEGTORAD)
call SetUnitX(dami,x1)
call SetUnitY(dami,y1)
call GroupClear(g)
set bj_caster=caster
call GroupEnumUnitsInRange(g,x1,y1,75,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
if(IsUnitInGroup(target,gg)==false)then
set eff=AddSpecialEffectTarget("Abilities\\Weapons\\FragDriller\\FragDriller.mdl",target,"origin")
call MagDamage(caster,target,dmg)
set dmg=dmg-enemie_dmg
call SaveReal(udg_Hash,h,StringHash("Kartech|DMG"),dmg)
call DestroyEffect(eff)
call GroupAddUnit(gg,target)
endif
call GroupRemoveUnit(g,target)
endloop
call SaveReal(udg_Hash,h,StringHash("Kartech|DMG"),dmg+dist_dmg)
call SaveReal(udg_Hash,h,StringHash("Kartech|Dist"),dist+speed)
else
call RemoveUnit(dami)
call DestroyTimer(t)
call DestroyGroup(g)
call DestroyGroup(gg)
call FlushChildHashtable(udg_Hash,h)
endif
call DestroyBoolExpr(filter)
set t=null
set g=null
set gg=null
set eff=null
set dami=null
set filter=null
set target=null
set caster=null
endfunction
function Kartech_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0EG')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real x1=GetSpellTargetX()
local real y1=GetSpellTargetY()
local real angle=bj_RADTODEG*Atan2(y1-y,x1-x)
local player p=GetOwningPlayer(caster)
local integer i=1
local unit dami
local integer h
local timer t
local group g
local group gg
local integer max_kart=3
local real dmg=50*lvl
local real speed=20.00
local real periodic=0.02
local real enemie_dmg_minus=10.00
local real dist_dmg=3*lvl
local real max_dist=1300.00
set angle=angle-15.00
loop
exitwhen i>max_kart
set g=CreateGroup()
set gg=CreateGroup()
set t=CreateTimer()
set h=GetHandleId(t)
set dami=CreateUnit(p,'h02S',x,y,angle)
call SaveUnitHandle(udg_Hash,h,StringHash("Kartech|Caster"),caster)
call SaveUnitHandle(udg_Hash,h,StringHash("Kartech|Dami"),dami)
call SaveReal(udg_Hash,h,StringHash("Kartech|DMG"),dmg)
call SaveReal(udg_Hash,h,StringHash("Kartech|Speed"),speed)
call SaveReal(udg_Hash,h,StringHash("Kartech|Enemie"),enemie_dmg_minus)
call SaveReal(udg_Hash,h,StringHash("Kartech|Dist_Dmg"),dist_dmg)
call SaveReal(udg_Hash,h,StringHash("Kartech|Max_Dist"),max_dist)
call SaveReal(udg_Hash,h,StringHash("Kartech|Dist"),0)
call SaveGroupHandle(udg_Hash,h,StringHash("Kartech|Group"),g)
call SaveGroupHandle(udg_Hash,h,StringHash("Kartech|Group_Two"),gg)
call TimerStart(t,periodic,true,function Kartech_Timer)
set angle=angle+15.00
set i=i+1
endloop
set t=null
set p=null
set g=null
set gg=null
set dami=null
set caster=null
endfunction
function InitTrig_Kartech takes nothing returns nothing
set gg_trg_Kartech=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Kartech,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Kartech,Condition(function Kartech_Conditions))
call TriggerAddAction(gg_trg_Kartech,function Kartech_Actions)
endfunction
function PricelSet_Conditions takes nothing returns boolean
return LoadBoolean(udg_Hash,GetHandleId(GetTriggerUnit()),StringHash("Pricel"+I2S(GetHandleId(GetAttacker()))))==false and GetUnitAbilityLevel(GetAttacker(),'A0EE')>0
endfunction
function PricelSet_Actions takes nothing returns nothing
local unit target=GetTriggerUnit()
local unit caster=GetAttacker()
call SaveBoolean(udg_Hash,GetHandleId(target),StringHash("Pricel"+I2S(GetHandleId(caster))),true)
set target=null
set caster=null
endfunction
function InitTrig_PricelSet takes nothing returns nothing
set gg_trg_PricelSet=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_PricelSet,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_PricelSet,Condition(function PricelSet_Conditions))
call TriggerAddAction(gg_trg_PricelSet,function PricelSet_Actions)
endfunction
function Trig_Myshketi_Conditions takes nothing returns boolean
if(not(GetLearnedSkillBJ()=='A0EF'))then
return false
endif
return true
endfunction
function Trig_Myshketi_Actions takes nothing returns nothing
call SetPlayerTechResearchedSwap('R03P',GetUnitAbilityLevelSwapped('A0EF',GetTriggerUnit()),GetOwningPlayer(GetTriggerUnit()))
endfunction
function InitTrig_Myshketi takes nothing returns nothing
set gg_trg_Myshketi=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Myshketi,EVENT_PLAYER_HERO_SKILL)
call TriggerAddCondition(gg_trg_Myshketi,Condition(function Trig_Myshketi_Conditions))
call TriggerAddAction(gg_trg_Myshketi,function Trig_Myshketi_Actions)
endfunction
function MagicFire_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FP'
endfunction
function MagicFire_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer id=GetHandleId(caster)
local string s
local real coef=0.04
local real min_dmg=60.00
local real dmg=LoadReal(udg_Hash,id,StringHash("MagicFire|Damage"))
if(dmg<min_dmg)then
set dmg=min_dmg
endif
if(IsUnitEnemy(caster,GetOwningPlayer(target))==true)then
call MagDamage(caster,target,dmg)
else
set s="+"+I2S(R2I(dmg/ 2))+" hp"
call HP_RESTORE(target,dmg/ 2,s,10.00,0,255,0,0,96.00,0.75)
endif
set dmg=dmg+(dmg*coef)
call SaveReal(udg_Hash,id,StringHash("MagicFire|Damage"),dmg)
set caster=null
set target=null
endfunction
function InitTrig_MagicFire takes nothing returns nothing
set gg_trg_MagicFire=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_MagicFire,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_MagicFire,Condition(function MagicFire_Conditions))
call TriggerAddAction(gg_trg_MagicFire,function MagicFire_Actions)
endfunction
function MagicShield_Condition takes nothing returns boolean
return GetUnitAbilityLevel(GetFilterUnit(),'A0DW')>0
endfunction
function MagicShield takes nothing returns nothing
local unit caster=GetEnumUnit()
local real mp=GetUnitState(caster,UNIT_STATE_MANA)
local real max_mp=GetUnitState(caster,UNIT_STATE_MAX_MANA)
local integer lvl=GetUnitAbilityLevel(caster,'A0DY')
local real procent=0.30
local real mp_proc=max_mp*procent
if(mp<=mp_proc)then
if(lvl==0)then
call UnitAddAbility(caster,'A0DY')
endif
else
call UnitRemoveAbility(caster,'A0DY')
call UnitRemoveAbility(caster,'B01I')
endif
set caster=null
endfunction
function MagicShield_Actions takes nothing returns nothing
local group g=CreateGroup()
local boolexpr cond=Condition(function MagicShield_Condition)
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,cond)
call ForGroup(g,function MagicShield)
call DestroyBoolExpr(cond)
call DestroyGroup(g)
set g=null
set cond=null
endfunction
function InitTrig_MagicShield takes nothing returns nothing
set gg_trg_MagicShield=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_MagicShield,0.30)
call TriggerAddAction(gg_trg_MagicShield,function MagicShield_Actions)
endfunction
function ShieldDoblesti_Condition takes nothing returns boolean
return GetUnitAbilityLevel(GetFilterUnit(),'A0DK')>0
endfunction
function ShieldDoblesti takes nothing returns nothing
local unit caster=GetEnumUnit()
local real hp=GetUnitState(caster,UNIT_STATE_LIFE)
local real max_hp=GetUnitState(caster,UNIT_STATE_MAX_LIFE)
local integer lvl=GetUnitAbilityLevel(caster,'A0DN')
local real procent=0.30
local real hp_proc=max_hp*procent
if(hp<=hp_proc)then
if(lvl==0)then
call UnitAddAbility(caster,'A0DN')
endif
else
call UnitRemoveAbility(caster,'A0DN')
call UnitRemoveAbility(caster,'B01G')
endif
set caster=null
endfunction
function ShieldDoblesti_Actions takes nothing returns nothing
local group g=CreateGroup()
local boolexpr cond=Condition(function ShieldDoblesti_Condition)
call GroupEnumUnitsInRect(g,bj_mapInitialPlayableArea,cond)
call ForGroup(g,function ShieldDoblesti)
call DestroyBoolExpr(cond)
call DestroyGroup(g)
set g=null
set cond=null
endfunction
function InitTrig_ShieldDoblesti takes nothing returns nothing
set gg_trg_ShieldDoblesti=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_ShieldDoblesti,0.30)
call TriggerAddAction(gg_trg_ShieldDoblesti,function ShieldDoblesti_Actions)
endfunction
function GreenKrest_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetKillingUnit(),'A0DJ')>0 and IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)!=true and IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetKillingUnit()))==true
endfunction
function GreenKrest_Actions takes nothing returns nothing
local real r=GetRandomReal(0.00,100.00)
local integer i=GetRandomInt(1,3)
local unit caster=GetKillingUnit()
local string s
local real chance=22.00
local integer stat=1
if Chance(caster,chance)then
if(i==1)then
call SetHeroStr(caster,GetHeroStr(caster,false)+stat,true)
if(GetLocalPlayer()==GetOwningPlayer(caster))then
set s="+"+I2S(stat)+" str"
call TextUp(s,caster,9,0,255,0,0,60.00,0.75)
endif
endif
if(i==2)then
call SetHeroAgi(caster,GetHeroAgi(caster,false)+stat,true)
if(GetLocalPlayer()==GetOwningPlayer(caster))then
set s="+"+I2S(stat)+" agi"
call TextUp(s,caster,9,0,255,0,0,60.00,0.75)
endif
endif
if(i==3)then
call SetHeroInt(caster,GetHeroInt(caster,false)+stat,true)
if(GetLocalPlayer()==GetOwningPlayer(caster))then
set s="+"+I2S(stat)+" int"
call TextUp(s,caster,9,0,255,0,0,60.00,0.75)
endif
endif
endif
set caster=null
endfunction
function InitTrig_GreenKrest takes nothing returns nothing
set gg_trg_GreenKrest=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_GreenKrest,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_GreenKrest,Condition(function GreenKrest_Conditions))
call TriggerAddAction(gg_trg_GreenKrest,function GreenKrest_Actions)
endfunction
function GiveAbility_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FO' or GetSpellAbilityId()=='A01G' or GetSpellAbilityId()=='A0DF' or GetSpellAbilityId()=='A0DG' or GetSpellAbilityId()=='A0DH'
endfunction
function GiveAbility_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetSpellAbilityId()
if(id=='A0DF')then
call UnitAddAbility(caster,'A0DJ')
call UnitMakeAbilityPermanent(caster,true,'A0DJ')
endif
if(id=='A0DG')then
call UnitAddAbility(caster,'A0DI')
call UnitMakeAbilityPermanent(caster,true,'A0DI')
endif
if(id=='A0DH')then
call UnitAddAbility(caster,'A0DK')
call UnitMakeAbilityPermanent(caster,true,'A0DK')
endif
if(id=='A01G')then
call UnitAddAbility(caster,'A0DW')
call UnitMakeAbilityPermanent(caster,true,'A0DW')
endif
if(id=='A0FO')then
call UnitAddAbility(caster,'A0FP')
call UnitMakeAbilityPermanent(caster,true,'A0FP')
endif
call UnitRemoveAbility(caster,'A0DE')
call SetPlayerAbilityAvailable(GetOwningPlayer(caster),'A0DE',false)
set caster=null
endfunction
function InitTrig_GiveAbility takes nothing returns nothing
set gg_trg_GiveAbility=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_GiveAbility,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_GiveAbility,Condition(function GiveAbility_Conditions))
call TriggerAddAction(gg_trg_GiveAbility,function GiveAbility_Actions)
endfunction
function isUnitRaged takes unit target returns boolean
return GetUnitAbilityLevel(target,'A0CT')>0
endfunction
function RagePotion_filter takes nothing returns boolean
return not isUnitRaged(GetFilterUnit())and isUnitAlly(bj_caster,GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0.00 and not isUnitStruct(GetFilterUnit())
endfunction
function RagePotion_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local boolexpr filter
local unit target
local integer l__damage=10*lvl
local real range=250.00
local real time=10.00+(5.00*lvl)
local real changeTime=2.00
local integer tdamage=0
local real ttime=0.00
set bj_caster=caster
set filter=Condition(function RagePotion_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set tdamage=l__damage
set ttime=time
if isUnitHero(target)then
set tdamage=tdamage*2
set ttime=ttime*1.5
endif
call TimedEffectTarget("Abilities\\Spells\\Orc\\Disenchant\\DisenchantSpecialArt.mdl",target,"head",0.5)
call TimedDamage(target,tdamage,ttime)
call TimedRageEffect(target,time,changeTime)
call TimedAbility(target,'A09L',ttime)
call SetUnitAbilityLevel(target,'A0CT',lvl)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set filter=null
set caster=null
set target=null
endfunction
function RagePotion_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0CS'
endfunction
function InitTrig_RagePotion takes nothing returns nothing
set gg_trg_RagePotion=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_RagePotion,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_RagePotion,Condition(function RagePotion_Conditions))
call TriggerAddAction(gg_trg_RagePotion,function RagePotion_Actions)
endfunction
function KoldAura_Conditions takes nothing returns boolean
return IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)==false and IsUnitType(GetAttacker(),UNIT_TYPE_SUMMONED)==false and GetUnitAbilityLevel(GetAttacker(),'B00P')>0 or GetUnitAbilityLevel(GetAttacker(),'B00Q')>0 or GetUnitAbilityLevel(GetAttacker(),'B00R')>0 or GetUnitAbilityLevel(GetAttacker(),'B01A')>0 or GetUnitAbilityLevel(GetAttacker(),'B01B')>0
endfunction
function KoldAura_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local integer lvl
local integer lvlAb=GetUnitAbilityLevel(target,'A0CI')
local real time
local effect eff
set time=1.50
if(GetUnitAbilityLevel(caster,'B00P')>0)then
set time=time*1
endif
if(GetUnitAbilityLevel(caster,'B00Q')>0)then
set time=time*2
endif
if(GetUnitAbilityLevel(caster,'B00R')>0)then
set time=time*3
endif
if(GetUnitAbilityLevel(caster,'B01A')>0)then
set time=time*4
endif
if(GetUnitAbilityLevel(caster,'B01B')>0)then
set time=time*5
endif
if(lvlAb<1)then
call UnitAddAbility(target,'A0CI')
endif
if(lvlAb<6)then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIso\\BIsvTarget.mdl",target,"chest")
call IncUnitAbilityLevel(target,'A0CI')
call TriggerSleepAction(time)
call DecUnitAbilityLevel(target,'A0CI')
call DestroyEffect(eff)
endif
set eff=null
set target=null
set caster=null
endfunction
function InitTrig_KoldAura takes nothing returns nothing
set gg_trg_KoldAura=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_KoldAura,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_KoldAura,Condition(function KoldAura_Conditions))
call TriggerAddAction(gg_trg_KoldAura,function KoldAura_Actions)
endfunction
function Vozmezdie_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A0CG')>0
endfunction
function Vozmezdie_Filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(GetTriggerUnit()))
endfunction
function Vozmezdie_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0CG')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local unit target
local effect eff
local real range=200.00+(200.00*lvl)
local real dmg=125.00*lvl
local real HouseDamage=0.50
call RangeEffect_start(caster,x,y,range,0.5)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl",caster,"origin")
call DestroyEffect(eff)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\AncestralSpirit\\AncestralSpiritCaster.mdl",caster,"origin")
call DestroyEffect(eff)
call GroupEnumUnitsInRange(g,x,y,range,Condition(function Vozmezdie_Filter))
loop
set target=FirstOfGroup(g)
exitwhen target==null
if not isUnitStruct(target)then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl",target,"origin")
call MagDamage(caster,target,dmg)
call DestroyEffect(eff)
else
if isPlayerHasSoloHero(Owner(caster))then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl",target,"origin")
call MagDamage(caster,target,dmg*HouseDamage)
call DestroyEffect(eff)
endif
endif
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
set eff=null
set g=null
set target=null
set caster=null
endfunction
function InitTrig_Vozmezdie takes nothing returns nothing
set gg_trg_Vozmezdie=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Vozmezdie,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Vozmezdie,Condition(function Vozmezdie_Conditions))
call TriggerAddAction(gg_trg_Vozmezdie,function Vozmezdie_Actions)
endfunction
function Potomstvo2_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())=='n01I'
endfunction
function Potomstvo2_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=1
local integer count=1
loop
exitwhen i>count
call CreateUnit(p,'n01J',x,y,0)
set i=i+1
endloop
set p=null
set caster=null
endfunction
function InitTrig_Potomstvo2 takes nothing returns nothing
set gg_trg_Potomstvo2=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Potomstvo2,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Potomstvo2,Condition(function Potomstvo2_Conditions))
call TriggerAddAction(gg_trg_Potomstvo2,function Potomstvo2_Actions)
endfunction
function Potomstvo_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A0BE')>0
endfunction
function Potomstvo_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0BE')
local player p=GetOwningPlayer(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=1
local integer max=7*lvl
loop
exitwhen i>max
call CreateUnit(p,'n01I',x,y,270.00)
set i=i+1
endloop
set p=null
set caster=null
endfunction
function InitTrig_Potomstvo takes nothing returns nothing
set gg_trg_Potomstvo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Potomstvo,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Potomstvo,Condition(function Potomstvo_Conditions))
call TriggerAddAction(gg_trg_Potomstvo,function Potomstvo_Actions)
endfunction
function XarchaSet_Conditions takes nothing returns boolean
return(IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)==true or IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)==true)and LoadBoolean(udg_Hash,GetHandleId(GetTriggerUnit()),StringHash("Xarcha"+I2S(GetHandleId(GetAttacker()))))==false and GetUnitAbilityLevel(GetAttacker(),'A0BC')>0
endfunction
function XarchaSet_Actions takes nothing returns nothing
local unit target=GetTriggerUnit()
local unit caster=GetAttacker()
call SaveBoolean(udg_Hash,GetHandleId(target),StringHash("Xarcha"+I2S(GetHandleId(caster))),true)
set target=null
set caster=null
endfunction
function InitTrig_XarchaSet takes nothing returns nothing
set gg_trg_XarchaSet=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_XarchaSet,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_XarchaSet,Condition(function XarchaSet_Conditions))
call TriggerAddAction(gg_trg_XarchaSet,function XarchaSet_Actions)
endfunction
function Eat_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0B9'
endfunction
function Eat_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0B9')
local real hitpoint=GetUnitState(caster,UNIT_STATE_MAX_LIFE)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=1
local effect eff
local string s
local real hp=(hitpoint*(0.02*lvl))
local real time=15.00
local real reload=3.00
if(GetUnitAbilityLevel(target,'A098')>0)then
call RemoveItem(UnitItemInSlot(target,0))
endif
call MagDamage(caster,target,999999)
call RemoveUnit(target)
set eff=AddSpecialEffect("Abilities\\Spells\\Orc\\Devour\\DevourEffectArt.mdl",x,y)
call DestroyEffect(eff)
loop
exitwhen i>R2I(time)
set s="+"+I2S(R2I(hp))+" hp"
call HP_RESTORE(caster,hp,s,10.00,0,255,0,0,96.00,0.75)
call TriggerSleepAction(reload)
set i=i+R2I(reload)
endloop
set eff=null
set caster=null
set target=null
endfunction
function InitTrig_Eat takes nothing returns nothing
set gg_trg_Eat=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Eat,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Eat,Condition(function Eat_Conditions))
call TriggerAddAction(gg_trg_Eat,function Eat_Actions)
endfunction
function HeroKiller_Conditions takes nothing returns boolean
return not IsUnitIllusion(GetKillingUnit())and GetUnitAbilityLevel(GetKillingUnit(),'A0CD')>0 and isUnitEnemy(GetTriggerUnit(),GetKillingUnit())and isUnitHero(GetTriggerUnit())and GetHeroStr(GetTriggerUnit(),false)>1 and GetHeroAgi(GetTriggerUnit(),false)>1 and GetHeroInt(GetTriggerUnit(),false)>1
endfunction
function HeroKiller_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local unit target=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0CD')
local real r=GetRandomReal(0.00,100.00)
local effect eff
local real chance=10.00+(15.00*lvl)
local integer steal=1
local integer take=2
if(r<=chance)then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\HowlOfTerror\\HowlCaster.mdl",caster,"origin")
call SetHeroStr(target,(GetHeroStr(target,false)-steal),true)
call SetHeroAgi(target,(GetHeroAgi(target,false)-steal),true)
call SetHeroInt(target,(GetHeroInt(target,false)-steal),true)
call SetHeroStr(caster,(GetHeroStr(caster,false)+take),true)
call SetHeroAgi(caster,(GetHeroAgi(caster,false)+take),true)
call SetHeroInt(caster,(GetHeroInt(caster,false)+take),true)
call DestroyEffect(eff)
endif
set eff=null
set target=null
set caster=null
endfunction
function InitTrig_HeroKiller takes nothing returns nothing
set gg_trg_HeroKiller=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_HeroKiller,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_HeroKiller,Condition(function HeroKiller_Conditions))
call TriggerAddAction(gg_trg_HeroKiller,function HeroKiller_Actions)
endfunction
function s__Parasites_projectile_st_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__Parasites_projectile_st_Timer[this])
set s__Parasites_projectile_st_lvl[this]=0
call DestroyEffect(s__Parasites_projectile_st_eff[this])
call DestroyTimer(s__Parasites_projectile_st_Timer[this])
call FlushChildHashtable(udg_Hash,id)
set s__Parasites_projectile_st_eff[this]=null
set s__Parasites_projectile_st_Timer[this]=null
set s__Parasites_projectile_st_caster[this]=null
set s__Parasites_projectile_st_target[this]=null
call s__Parasites_projectile_st_deallocate(this)
endfunction
function Parasites_projectileTimer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer ps=LoadInt(id,"ParasitesProjectile | Structure")
local real uX=GetUnitX(s__Parasites_projectile_st_target[ps])
local real uY=GetUnitY(s__Parasites_projectile_st_target[ps])
local real eX=GetEffectX(s__Parasites_projectile_st_eff[ps])
local real eY=GetEffectY(s__Parasites_projectile_st_eff[ps])
local real distance=PointsDistance(eX,eY,uX,uY)
local real angle=PointsAngle(eX,eY,uX,uY)
local real x
local real y
local real l__damage=15.00
local real periodic=1.00
local real time=6.00*s__Parasites_projectile_st_lvl[ps]
if distance>s__Parasites_projectile_st_speed[ps]then
set x=PolarPoints(eX,eY,s__Parasites_projectile_st_speed[ps],angle,"x")
set y=PolarPoints(eX,eY,s__Parasites_projectile_st_speed[ps],angle,"y")
call SetEffectFacing(s__Parasites_projectile_st_eff[ps],angle)
call SetEffectPosition(s__Parasites_projectile_st_eff[ps],x,y,GetEffectZ(s__Parasites_projectile_st_eff[ps]))
else
call Parasites_Start(s__Parasites_projectile_st_caster[ps],s__Parasites_projectile_st_target[ps],l__damage,periodic,time)
call s__Parasites_projectile_st_Destroy(ps)
endif
set t=null
endfunction
function Parasites_launchProjectile takes unit caster,unit target,integer lvl returns nothing
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer ps=s__Parasites_projectile_st__allocate()
set s__Parasites_projectile_st_eff[ps]=AddSpecialEffect("Abilities\\Weapons\\ChimaeraAcidMissile\\ChimaeraAcidMissile.mdl",GetUnitX(caster),GetUnitY(caster))
set s__Parasites_projectile_st_caster[ps]=caster
set s__Parasites_projectile_st_target[ps]=target
set s__Parasites_projectile_st_speed[ps]=25.00
set s__Parasites_projectile_st_lvl[ps]=lvl
set s__Parasites_projectile_st_Timer[ps]=t
call SaveInt(id,"ParasitesProjectile | Structure",ps)
call TimerStart(t,0.04,true,function Parasites_projectileTimer)
set t=null
endfunction
function Parasites_filter takes nothing returns boolean
return not isUnitParasited(GetFilterUnit())and isUnitStruct(GetFilterUnit())and isUnitEnemy(bj_caster,GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0.00
endfunction
function Parasites_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local group g=CreateGroup()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local boolexpr filter
local unit target
local effect eff
local real range=500.00
set bj_caster=caster
set filter=Condition(function Parasites_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call Parasites_launchProjectile(caster,target,lvl)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set target=null
set caster=null
set filter=null
endfunction
function Parasites_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A08P'
endfunction
function InitTrig_Parasites takes nothing returns nothing
set gg_trg_Parasites=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Parasites,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Parasites,Condition(function Parasites_Conditions))
call TriggerAddAction(gg_trg_Parasites,function Parasites_Actions)
endfunction
function Mogilnik_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A08U'
endfunction
function Mogilnik_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local integer lvl=GetUnitAbilityLevel(caster,'A08U')
local real x=GetLocationX(GetSpellTargetLoc())
local real y=GetLocationY(GetSpellTargetLoc())
local unit dami
local real time=120.00
set dami=CreateUnit(p,'u018',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(dami,'BTLF',time)
call SetUnitAbilityLevel(dami,'A08V',lvl)
if(GetPlayerTechCount(GetOwningPlayer(caster),'R02A',true)==1)then
call UnitAddAbility(dami,'A0E5')
call SetUnitAbilityLevel(dami,'A0E5',lvl)
endif
set p=null
set dami=null
set caster=null
endfunction
function InitTrig_Mogilnik takes nothing returns nothing
set gg_trg_Mogilnik=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Mogilnik,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Mogilnik,Condition(function Mogilnik_Conditions))
call TriggerAddAction(gg_trg_Mogilnik,function Mogilnik_Actions)
endfunction
function PancirWithSpikes_Conditions takes nothing returns boolean
return not isUnitStruct(GetEventDamageSource())and GetUnitAbilityLevel(GetTriggerUnit(),'A0JE')>0 and GetEventDamage()>0.00 and isUnitEnemy(GetTriggerUnit(),GetEventDamageSource())
endfunction
function PancirWithSpikes_Actions takes nothing returns nothing
local boolean isHand=isDamageFromHand()
local unit caster=GetTriggerUnit()
local real returnedDamage=LoadRealn(GetHandleId(caster),"PancirWithSpikes | ReturnedDamage")
local integer lvl=GetUnitAbilityLevel(caster,'A0JE')
local unit target=GetEventDamageSource()
local real l__damage=GetEventDamage()
local real returnCoef=0.10*lvl
local real needToBuff=150.00
local real totalDamage=returnCoef*l__damage
local real buffPower=5.00
if isHand then
call ClearDamage(caster,target,totalDamage)
if GetUnitHealth(target)<=0.00 and isPlayerHasSoloHero(Owner(caster))then
call CreateUnit(Owner(caster),'u019',GetUnitX(target),GetUnitY(target),bj_UNIT_FACING)
endif
set returnedDamage=returnedDamage+totalDamage
if returnedDamage>=needToBuff then
set returnedDamage=returnedDamage-needToBuff
call AddUnitMaxLife(caster,buffPower)
call UnitRestoreHealth(caster,buffPower)
endif
call SaveRealn(GetHandleId(caster),"PancirWithSpikes | ReturnedDamage",returnedDamage)
endif
set target=null
set caster=null
endfunction
function InitTrig_PancirWithSpikes takes nothing returns nothing
set gg_trg_PancirWithSpikes=CreateTrigger()
call TriggerAddCondition(gg_trg_PancirWithSpikes,Condition(function PancirWithSpikes_Conditions))
call TriggerAddAction(gg_trg_PancirWithSpikes,function PancirWithSpikes_Actions)
endfunction
function s__Impale_Destroy takes integer this returns nothing
local integer id=GetHandleId(s__Impale_Timer[this])
call DestroyTimer(s__Impale_Timer[this])
call DestroyGroup(s__Impale_targetGroup[this])
call FlushChildHashtable(udg_Hash,id)
set s__Impale_Timer[this]=null
set s__Impale_caster[this]=null
set s__Impale_targetGroup[this]=null
call s__Impale_deallocate(this)
endfunction
function Impale_filter takes nothing returns boolean
return not isUnitStruct(GetFilterUnit())and isUnitEnemy(bj_caster,GetFilterUnit())and isUnitAlive(GetFilterUnit())and not IsUnitInvulnerable(GetFilterUnit())
endfunction
function Impale_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer impale=LoadInteger(udg_Hash,id,StringHash("Impale | Struct"))
local group g=CreateGroup()
local boolexpr filter
local unit target
local effect eff
local real x
local real y
local real flyTime=0.
local real stunTime=0.
if s__Impale_count[impale]>0 then
set s__Impale_count[impale]=s__Impale_count[impale]-1
set x=PolarPoints(s__Impale_x[impale],s__Impale_y[impale],s__Impale_step[impale],s__Impale_angle[impale],"x")
set y=PolarPoints(s__Impale_x[impale],s__Impale_y[impale],s__Impale_step[impale],s__Impale_angle[impale],"y")
set s__Impale_x[impale]=x
set s__Impale_y[impale]=y
set eff=AddSpecialEffect("Abilities\\Spells\\Undead\\Impale\\ImpaleMissTarget.mdl",x,y)
call DestroyEffect(eff)
set bj_caster=s__Impale_caster[impale]
set filter=Condition(function Impale_filter)
call GroupEnumUnitsInRange(g,x,y,s__Impale_damageRange[impale],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set stunTime=s__Impale_stunTime[impale]
if not IsUnitInGroup(target,s__Impale_targetGroup[impale])then
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\Impale\\ImpaleHitTarget.mdl",target,"origin")
call DestroyEffect(eff)
call MagDamage(s__Impale_caster[impale],target,s__Impale_damage[impale])
if not isUnitAlive(target)and isPlayerHasSoloHero(Owner(s__Impale_caster[impale]))then
call CreateUnit(Owner(s__Impale_caster[impale]),'u019',GetUnitX(target),GetUnitY(target),bj_UNIT_FACING)
endif
if isUnitHero(target)then
set stunTime=stunTime*0.5
endif
set flyTime=Move_Jump_start(target,250,20,true,stunTime)
call TimedInvul(target,flyTime)
call GroupAddUnit(s__Impale_targetGroup[impale],target)
endif
call GroupRemoveUnit(g,target)
endloop
else
call s__Impale_Destroy(impale)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set t=null
set g=null
set eff=null
set filter=null
set target=null
endfunction
function Impale_Start takes unit caster,real range,real l__damage,real stunTime,real spellX,real spellY returns nothing
local real casterX=GetUnitX(caster)
local real casterY=GetUnitY(caster)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real angle=Angle(casterX,casterY,spellX,spellY)
local real totalX=PolarPoints(casterX,casterY,50,angle,"x")
local real totalY=PolarPoints(casterX,casterY,50,angle,"y")
local integer impale=s__Impale__allocate()
set s__Impale_targetGroup[impale]=CreateGroup()
set s__Impale_Timer[impale]=t
set s__Impale_caster[impale]=caster
set s__Impale_periodic[impale]=0.20
set s__Impale_x[impale]=totalX
set s__Impale_y[impale]=totalY
set s__Impale_angle[impale]=angle
set s__Impale_damage[impale]=l__damage
set s__Impale_stunTime[impale]=stunTime
set s__Impale_range[impale]=range
set s__Impale_damageRange[impale]=125.00
set s__Impale_step[impale]=125.00
set s__Impale_count[impale]=R2I(s__Impale_range[impale]/ s__Impale_step[impale])
call SaveInt(id,"Impale | Struct",impale)
call TimerStart(t,s__Impale_periodic[impale],true,function Impale_timer)
set t=null
endfunction
function Impale_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real casterX=GetUnitX(caster)
local real casterY=GetUnitY(caster)
local integer index=1
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local integer count=3
local real angle=30.00
local real distFromUnit=25.00
local real l__damage=35.00*lvl
local real range=500.00
local real stunTime=2.00
local real abp=PointsAngle(casterX,casterY,x,y)-angle*2
loop
exitwhen index>count
set x=PolarPoints(casterX,casterY,distFromUnit,abp+angle*index,"x")
set y=PolarPoints(casterX,casterY,distFromUnit,abp+angle*index,"y")
call Impale_Start(caster,range,l__damage,stunTime,x,y)
set index=index+1
endloop
set caster=null
endfunction
function Impale_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A07A'
endfunction
function InitTrig_Impale takes nothing returns nothing
set gg_trg_Impale=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Impale,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Impale,Condition(function Impale_Conditions))
call TriggerAddAction(gg_trg_Impale,function Impale_Actions)
endfunction
function s__DarkArmy_st_Destroy takes integer this returns nothing
call DestroyEffect(s__DarkArmy_st_eff[this])
set s__DarkArmy_st_eff[this]=null
set s__DarkArmy_st_caster[this]=null
call s__DarkArmy_st_deallocate(this)
endfunction
function DarkArm_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer da=LoadInt(id,"DarkArmy | Struct")
local real casterX=GetUnitX(s__DarkArmy_st_caster[da])
local real casterY=GetUnitY(s__DarkArmy_st_caster[da])
local integer total_unit=0
local string total_effect
local effect eff
local unit dummy
local real x
local real y
if s__DarkArmy_st_time[da]>0 and GetUnitCurrentOrder(s__DarkArmy_st_caster[da])==OrderId("revenge")then
set s__DarkArmy_st_time[da]=s__DarkArmy_st_time[da]-s__DarkArmy_st_periodic[da]
set x=GetRandomPointInRange(casterX,casterY,s__DarkArmy_st_range[da],"x")
set y=GetRandomPointInRange(casterX,casterY,s__DarkArmy_st_range[da],"y")
if Chance(s__DarkArmy_st_caster[da],s__DarkArmy_st_pudgeChance[da])then
set total_unit='u01M'
set total_effect="Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl"
elseif Chance(s__DarkArmy_st_caster[da],s__DarkArmy_st_zombieChance[da])then
set total_unit='n022'
set total_effect="Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl"
else
set total_unit='u01L'
set total_effect="Abilities\\Spells\\Undead\\RaiseSkeletonWarrior\\RaiseSkeleton.mdl"
endif
set eff=AddSpecialEffect(total_effect,x,y)
call DestroyEffect(eff)
set dummy=CreateUnit(Owner(s__DarkArmy_st_caster[da]),total_unit,x,y,GetRandomReal(0.00,360.00))
call UnitApplyTimedLife(dummy,'BTLF',60)
call SetUnitAnimation(dummy,"birth")
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__DarkArmy_st_Destroy(da)
endif
set t=null
set eff=null
endfunction
function DarkArm_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0FS')
local integer power=GetUnitUserData(caster)/ 10
local integer da=s__DarkArmy_st__allocate()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real lvl_coef=5.00
set s__DarkArmy_st_caster[da]=caster
set s__DarkArmy_st_range[da]=750.00
set s__DarkArmy_st_periodic[da]=(1.00-(0.25*(lvl-1)))-(power*0.01)
set s__DarkArmy_st_time[da]=30.00
set s__DarkArmy_st_zombieChance[da]=25.00+(lvl_coef*(lvl-1))
set s__DarkArmy_st_pudgeChance[da]=15.00+(lvl_coef*(lvl-1))
set s__DarkArmy_st_eff[da]=AddSpecialEffectTarget("Fountain of Souls_opt.mdx",s__DarkArmy_st_caster[da],"origin")
if(s__DarkArmy_st_periodic[da]<0.2)then
set s__DarkArmy_st_periodic[da]=0.2
endif
call SetUnitAnimation(caster,"death")
call SaveInt(id,"DarkArmy | Struct",da)
call TimerStart(t,s__DarkArmy_st_periodic[da],true,function DarkArm_timer)
set t=null
set caster=null
endfunction
function DarkArm_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0FS'
endfunction
function InitTrig_DarkArm takes nothing returns nothing
set gg_trg_DarkArm=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DarkArm,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(gg_trg_DarkArm,Condition(function DarkArm_Conditions))
call TriggerAddAction(gg_trg_DarkArm,function DarkArm_Actions)
endfunction
function YarostPleti_Conditions takes nothing returns boolean
if(not(GetUnitAbilityLevelSwapped('A089',GetKillingUnit())>0))then
return false
endif
if(not(IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetKillingUnit()))==true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)!=true))then
return false
endif
return true
endfunction
function YarostPleti_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local integer q=GetUnitUserData(caster)/ 10
local integer i=(GetUnitAbilityLevel(caster,'A089')*1)+q
local effect eff
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Doom\\DoomTarget.mdl",caster,"origin")
call SetHeroStr(caster,(GetHeroStr(caster,false)+i),true)
call SetHeroAgi(caster,(GetHeroAgi(caster,false)+i),true)
call SetHeroInt(caster,(GetHeroInt(caster,false)+i),true)
call TriggerSleepAction(10.00)
call SetHeroStr(caster,(GetHeroStr(caster,false)-i),true)
call SetHeroAgi(caster,(GetHeroAgi(caster,false)-i),true)
call SetHeroInt(caster,(GetHeroInt(caster,false)-i),true)
call DestroyEffect(eff)
set caster=null
set eff=null
endfunction
function InitTrig_YarostPleti takes nothing returns nothing
set gg_trg_YarostPleti=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_YarostPleti,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_YarostPleti,Condition(function YarostPleti_Conditions))
call TriggerAddAction(gg_trg_YarostPleti,function YarostPleti_Actions)
endfunction
function DarkMagic_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A08A'
endfunction
function DarkMagic_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer Buff=1
local integer i=GetUnitUserData(caster)
local string s
if(GetPlayerTechCount(GetOwningPlayer(caster),'R02A',true)>0)then
set Buff=Buff+1
endif
set i=i+Buff
if(GetLocalPlayer()==GetOwningPlayer(caster))then
set s=(I2S(i-Buff)+" > "+I2S(i))
call TextUp(s,caster,10,0,255,0,0,96.00,2.00)
endif
call SetUnitUserData(caster,i)
set caster=null
endfunction
function InitTrig_DarkMagic takes nothing returns nothing
set gg_trg_DarkMagic=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DarkMagic,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_DarkMagic,Condition(function DarkMagic_Conditions))
call TriggerAddAction(gg_trg_DarkMagic,function DarkMagic_Actions)
endfunction
function s__Exgumation_st_Destroy takes integer this returns nothing
set s__Exgumation_st_count[this]=0
set s__Exgumation_st_caster[this]=null
call s__Exgumation_st_deallocate(this)
endfunction
function Exgumation_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer ex=LoadInt(id,"Exgumation | Structure")
local effect eff=null
local unit dummy=null
local real x=GetRandomPointInRange(GetUnitX(s__Exgumation_st_caster[ex]),GetUnitY(s__Exgumation_st_caster[ex]),s__Exgumation_st_range[ex],"x")
local real y=GetRandomPointInRange(GetUnitX(s__Exgumation_st_caster[ex]),GetUnitY(s__Exgumation_st_caster[ex]),s__Exgumation_st_range[ex],"y")
if s__Exgumation_st_count[ex]>0 then
set s__Exgumation_st_count[ex]=s__Exgumation_st_count[ex]-1
set eff=AddSpecialEffect("Abilities\\Spells\\Undead\\RaiseSkeletonWarrior\\RaiseSkeleton.mdl",x,y)
call DestroyEffect(eff)
set dummy=CreateUnit(Owner(s__Exgumation_st_caster[ex]),'u003',x,y,GetRandomReal(0.00,360.00))
call UnitApplyTimedLife(dummy,'BTLF',30)
call SetUnitAnimation(dummy,"birth")
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__Exgumation_st_Destroy(ex)
endif
set t=null
set eff=null
set dummy=null
endfunction
function Exgumation takes unit caster returns nothing
local integer ex=s__Exgumation_st__allocate()
local integer power=GetUnitUserData(caster)
local timer t=CreateTimer()
local integer id=GetHandleId(t)
set s__Exgumation_st_range[ex]=400.00
set s__Exgumation_st_count[ex]=5+R2I(power/ 10)
set s__Exgumation_st_periodic[ex]=0.40
set s__Exgumation_st_caster[ex]=caster
call SaveInt(id,"Exgumation | Structure",ex)
call TimerStart(t,s__Exgumation_st_periodic[ex],true,function Exgumation_timer)
set t=null
endfunction
function DarkStrike_filter takes nothing returns boolean
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))and not IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)
endfunction
function DarkStrike_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A08B')
local integer buffCount=GetUnitUserData(caster)
local group g=CreateGroup()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer totalUnit=0
local string totalEff=""
local boolexpr filter
local unit target
local effect eff
local unit dami
local real range=250.00+buffCount
local real l__damage=35.00*lvl+buffCount
local real pudgeChance=10.00
local real zombieChance=25.00
set eff=AddSpecialEffect("Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl",x,y)
call DestroyEffect(eff)
call RangeEffect_start(caster,x,y,range,0.5)
set bj_caster=caster
set filter=Condition(function DarkStrike_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call MagDamage(caster,target,l__damage)
call GroupRemoveUnit(g,target)
if not(GetUnitState(target,UNIT_STATE_LIFE)>0)and not isUnitSummon(target)and not isUnitHero(target)then
set eff=AddSpecialEffect("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",x,y)
call DestroyEffect(eff)
if Chance(caster,pudgeChance)then
set totalUnit='u01M'
set totalEff="Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl"
elseif Chance(caster,zombieChance)then
set totalUnit='n022'
set totalEff="Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl"
else
set totalUnit='u01L'
set totalEff="Abilities\\Spells\\Undead\\RaiseSkeletonWarrior\\RaiseSkeleton.mdl"
endif
set eff=AddSpecialEffect(totalEff,GetUnitX(target),GetUnitY(target))
set dami=CreateUnit(GetOwningPlayer(caster),totalUnit,GetUnitX(target),GetUnitY(target),GetUnitFacing(target))
call RemoveUnit(target)
call UnitApplyTimedLife(dami,'BTLF',60)
call SetUnitAnimation(dami,"birth")
call DestroyEffect(eff)
endif
endloop
if isPlayerHasSoloHero(Owner(caster))then
call Exgumation(caster)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set dami=null
set target=null
set caster=null
set filter=null
endfunction
function DarkStrike_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A08B'
endfunction
function InitTrig_DarkStrike takes nothing returns nothing
set gg_trg_DarkStrike=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DarkStrike,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_DarkStrike,Condition(function DarkStrike_Conditions))
call TriggerAddAction(gg_trg_DarkStrike,function DarkStrike_Actions)
endfunction
function s__HellWrathCast_st_Destroy takes integer this returns nothing
set s__HellWrathCast_st_caster[this]=null
call s__HellWrathCast_st_deallocate(this)
endfunction
function s__HellWrath_st_Destroy takes integer this returns nothing
call KillUnit(s__HellWrath_st_dummy[this])
set s__HellWrath_st_dummy[this]=null
set s__HellWrath_st_caster[this]=null
call s__HellWrath_st_deallocate(this)
endfunction
function FrostArmor_filter takes nothing returns boolean
return GetUnitHealth(GetFilterUnit())>0 and not isUnitEnemy(GetFilterUnit(),bj_caster)and not isUnitStruct(GetFilterUnit())
endfunction
function HellWrath_filter takes nothing returns boolean
return GetUnitHealth(GetFilterUnit())>0 and isUnitEnemy(GetFilterUnit(),bj_caster)
endfunction
function HellWrath_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer sf=LoadInt(id,"HellWrath | Structure")
local group g=CreateGroup()
local boolexpr filter
local unit spirit
local unit target
if s__HellWrath_st_time[sf]>=s__HellWrath_st_periodic[sf]then
set s__HellWrath_st_time[sf]=s__HellWrath_st_time[sf]-s__HellWrath_st_periodic[sf]
set bj_caster=s__HellWrath_st_caster[sf]
set filter=Condition(function HellWrath_filter)
call GroupEnumUnitsInRange(g,s__HellWrath_st_x[sf],s__HellWrath_st_y[sf],s__HellWrath_st_range[sf],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call TimedEffectTarget("Abilities\\Spells\\Other\\Drain\\ManaDrainCaster.mdl",target,"overhead",0.25)
if isUnitStruct(target)then
call MagDamage(s__HellWrath_st_caster[sf],target,s__HellWrath_st_structDamage[sf]*GetUnitMaxHealth(target))
call UnitRestoreMana(target,(s__HellWrath_st_structDamage[sf]*GetUnitMaxMana(target))*-1)
elseif isUnitSummon(target)then
call MagDamage(s__HellWrath_st_caster[sf],target,s__HellWrath_st_summonDamage[sf]*GetUnitMaxHealth(target))
call UnitRestoreMana(target,(s__HellWrath_st_summonDamage[sf]*GetUnitMaxMana(target))*-1)
else
call MagDamage(s__HellWrath_st_caster[sf],target,s__HellWrath_st_damage[sf]*GetUnitMaxHealth(target))
call UnitRestoreMana(target,(s__HellWrath_st_damage[sf]*GetUnitMaxMana(target))*-1)
endif
call GroupRemoveUnit(g,target)
endloop
if isPlayerHasSoloHero(Owner(s__HellWrath_st_caster[sf]))then
call GroupClear(g)
set bj_caster=s__HellWrath_st_caster[sf]
set filter=Condition(function FrostArmor_filter)
call GroupEnumUnitsInRange(g,s__HellWrath_st_x[sf],s__HellWrath_st_y[sf],s__HellWrath_st_range[sf],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call TimedAbility(target,'A0IX',5.00)
call GroupRemoveUnit(g,target)
endloop
endif
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__HellWrath_st_Destroy(sf)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set t=null
set g=null
set spirit=null
set filter=null
set target=null
endfunction
function HellWrath_spawn takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer hwc=LoadInt(id,"HellWrathCast | Structure")
local integer casterID=GetHandleId(s__HellWrathCast_st_caster[hwc])
local integer lvl=GetUnitAbilityLevel(s__HellWrathCast_st_caster[hwc],'A07B')
local integer count=LoadInt(casterID,"FireShow | Count")
local integer sf=0
local integer tid=0
local timer tt
local real fireshowRangeBuff=1.50
local real fireshowDamageBuff=2.00
local integer fireshowNeedCount=5
if s__HellWrathCast_st_count[hwc]>0 and GetUnitCurrentOrder(s__HellWrathCast_st_caster[hwc])==OrderId("chemicalrage")then
set s__HellWrathCast_st_count[hwc]=s__HellWrathCast_st_count[hwc]-1
set sf=s__HellWrath_st__allocate()
set tt=CreateTimer()
set tid=GetHandleId(tt)
set s__HellWrath_st_caster[sf]=s__HellWrathCast_st_caster[hwc]
set s__HellWrath_st_x[sf]=GetRandomPointInRange(s__HellWrathCast_st_x[hwc],s__HellWrathCast_st_y[hwc],s__HellWrathCast_st_range[hwc],"x")
set s__HellWrath_st_y[sf]=GetRandomPointInRange(s__HellWrathCast_st_x[hwc],s__HellWrathCast_st_y[hwc],s__HellWrathCast_st_range[hwc],"y")
set s__HellWrath_st_damage[sf]=0.01*lvl
set s__HellWrath_st_range[sf]=200.00
set s__HellWrath_st_time[sf]=10.00
set s__HellWrath_st_periodic[sf]=0.25
set s__HellWrath_st_structDamage[sf]=s__HellWrath_st_damage[sf]*0.10
set s__HellWrath_st_summonDamage[sf]=s__HellWrath_st_damage[sf]*1.50
if isPlayerHasSoloHero(Owner(s__HellWrath_st_caster[sf]))then
set count=count+1
if count==fireshowNeedCount then
set count=0
set s__HellWrath_st_range[sf]=s__HellWrath_st_range[sf]*fireshowRangeBuff
set s__HellWrath_st_damage[sf]=s__HellWrath_st_damage[sf]*fireshowDamageBuff
set s__HellWrath_st_structDamage[sf]=s__HellWrath_st_structDamage[sf]*fireshowDamageBuff
set s__HellWrath_st_summonDamage[sf]=s__HellWrath_st_summonDamage[sf]*fireshowDamageBuff
set s__HellWrath_st_dummy[sf]=CreateUnit(Owner(s__HellWrath_st_caster[sf]),'h03T',s__HellWrath_st_x[sf],s__HellWrath_st_y[sf],0)
call SetUnitAnimation(s__HellWrath_st_dummy[sf],"birth")
call SetUnitScale(s__HellWrath_st_dummy[sf],fireshowRangeBuff,fireshowRangeBuff,fireshowRangeBuff)
endif
call SaveInt(casterID,"FireShow | Count",count)
endif
if s__HellWrath_st_dummy[sf]==null then
call TimedEffect("Mana Storm.mdx",s__HellWrath_st_x[sf],s__HellWrath_st_y[sf],s__HellWrath_st_time[sf])
endif
call SaveInt(tid,"HellWrath | Structure",sf)
call TimerStart(tt,s__HellWrath_st_periodic[sf],true,function HellWrath_timer)
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__HellWrathCast_st_Destroy(hwc)
endif
set t=null
set tt=null
endfunction
function HellWrath_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer level=GetUnitAbilityLevel(caster,'A07B')
local integer hw=s__HellWrathCast_st__allocate()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real periodic=0.45
set s__HellWrathCast_st_caster[hw]=caster
set s__HellWrathCast_st_count[hw]=2*level
set s__HellWrathCast_st_x[hw]=GetSpellTargetX()
set s__HellWrathCast_st_y[hw]=GetSpellTargetY()
set s__HellWrathCast_st_range[hw]=750.00
call SaveInt(id,"HellWrathCast | Structure",hw)
call TimerStart(t,periodic,true,function HellWrath_spawn)
set t=null
set caster=null
endfunction
function HellWrath_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A07B'
endfunction
function InitTrig_HellWrath takes nothing returns nothing
set gg_trg_HellWrath=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_HellWrath,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_HellWrath,Condition(function HellWrath_Conditions))
call TriggerAddAction(gg_trg_HellWrath,function HellWrath_Actions)
endfunction
function s__DarkFire_st_Destroy takes integer this returns nothing
call KillUnit(s__DarkFire_st_dummy[this])
set s__DarkFire_st_dummy[this]=null
set s__DarkFire_st_target[this]=null
set s__DarkFire_st_caster[this]=null
call s__DarkFire_st_deallocate(this)
endfunction
function DarkFire_filter takes nothing returns boolean
return GetUnitHealth(GetFilterUnit())>0 and isUnitEnemy(GetFilterUnit(),bj_caster)
endfunction
function DarkFire_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer sf=LoadInt(id,"DarkFire | Structure")
local group g=CreateGroup()
local boolexpr filter
local unit spirit
local unit target
if s__DarkFire_st_time[sf]>=s__DarkFire_st_periodic[sf]then
set s__DarkFire_st_time[sf]=s__DarkFire_st_time[sf]-s__DarkFire_st_periodic[sf]
set bj_caster=s__DarkFire_st_caster[sf]
set filter=Condition(function DarkFire_filter)
call GroupEnumUnitsInRange(g,s__DarkFire_st_x[sf],s__DarkFire_st_y[sf],s__DarkFire_st_range[sf],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call TimedEffectTarget("Abilities\\Spells\\Other\\Drain\\ManaDrainCaster.mdl",target,"overhead",0.25)
if isUnitStruct(target)then
call MagDamage(s__DarkFire_st_caster[sf],target,s__DarkFire_st_structDamage[sf]*GetUnitMaxHealth(target))
call UnitRestoreMana(target,(s__DarkFire_st_structDamage[sf]*GetUnitMaxMana(target))*-1)
elseif target==s__DarkFire_st_target[sf]then
call MagDamage(s__DarkFire_st_caster[sf],target,s__DarkFire_st_targetDamage[sf]*GetUnitMaxHealth(target))
call UnitRestoreMana(target,(s__DarkFire_st_targetDamage[sf]*GetUnitMaxMana(target))*-1)
elseif isUnitSummon(s__DarkFire_st_target[sf])then
call MagDamage(s__DarkFire_st_caster[sf],target,s__DarkFire_st_summonDamage[sf]*GetUnitMaxHealth(target))
call UnitRestoreMana(target,(s__DarkFire_st_summonDamage[sf]*GetUnitMaxMana(target))*-1)
else
call MagDamage(s__DarkFire_st_caster[sf],target,s__DarkFire_st_damage[sf]*GetUnitMaxHealth(target))
call UnitRestoreMana(target,(s__DarkFire_st_damage[sf]*GetUnitMaxMana(target))*-1)
endif
call GroupRemoveUnit(g,target)
endloop
if isPlayerHasSoloHero(Owner(s__DarkFire_st_caster[sf]))then
call GroupClear(g)
set bj_caster=s__DarkFire_st_caster[sf]
set filter=Condition(function FrostArmor_filter)
call GroupEnumUnitsInRange(g,s__DarkFire_st_x[sf],s__DarkFire_st_y[sf],s__DarkFire_st_range[sf],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call TimedAbility(target,'A0IX',5.00)
call GroupRemoveUnit(g,target)
endloop
endif
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__DarkFire_st_Destroy(sf)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set t=null
set g=null
set spirit=null
set filter=null
set target=null
endfunction
function DarkFire_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer casterID=GetHandleId(caster)
local integer lvl=GetUnitAbilityLevel(caster,'A0IS')
local integer sf=s__DarkFire_st__allocate()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer count=LoadInt(casterID,"FireShow | Count")
local real fireshowRangeBuff=1.50
local real fireshowDamageBuff=2.00
local integer fireshowNeedCount=5
set s__DarkFire_st_caster[sf]=caster
set s__DarkFire_st_target[sf]=GetSpellTargetUnit()
set s__DarkFire_st_x[sf]=GetUnitX(s__DarkFire_st_target[sf])
set s__DarkFire_st_y[sf]=GetUnitY(s__DarkFire_st_target[sf])
set s__DarkFire_st_damage[sf]=0.0035*lvl
set s__DarkFire_st_range[sf]=200.00
set s__DarkFire_st_time[sf]=10.00
set s__DarkFire_st_periodic[sf]=0.15
set s__DarkFire_st_structDamage[sf]=s__DarkFire_st_damage[sf]*0.10
set s__DarkFire_st_targetDamage[sf]=s__DarkFire_st_damage[sf]*1.50
set s__DarkFire_st_summonDamage[sf]=s__DarkFire_st_damage[sf]*1.50
if isPlayerHasSoloHero(Owner(caster))then
set count=count+1
if count==fireshowNeedCount then
set count=0
set s__DarkFire_st_range[sf]=s__DarkFire_st_range[sf]*fireshowRangeBuff
set s__DarkFire_st_damage[sf]=s__DarkFire_st_damage[sf]*fireshowDamageBuff
set s__DarkFire_st_structDamage[sf]=s__DarkFire_st_structDamage[sf]*fireshowDamageBuff
set s__DarkFire_st_targetDamage[sf]=s__DarkFire_st_targetDamage[sf]*fireshowDamageBuff
set s__DarkFire_st_summonDamage[sf]=s__DarkFire_st_summonDamage[sf]*fireshowDamageBuff
set s__DarkFire_st_dummy[sf]=CreateUnit(Owner(caster),'h03T',s__DarkFire_st_x[sf],s__DarkFire_st_y[sf],0)
call SetUnitAnimation(s__DarkFire_st_dummy[sf],"birth")
endif
call SaveInt(casterID,"FireShow | Count",count)
endif
if s__DarkFire_st_dummy[sf]==null then
call TimedEffect("Mana Storm.mdx",s__DarkFire_st_x[sf],s__DarkFire_st_y[sf],s__DarkFire_st_time[sf])
endif
call SaveInt(id,"DarkFire | Structure",sf)
call TimerStart(t,s__DarkFire_st_periodic[sf],true,function DarkFire_timer)
set t=null
set caster=null
endfunction
function DarkFire_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0IS'
endfunction
function InitTrig_DarkFire takes nothing returns nothing
set gg_trg_DarkFire=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DarkFire,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_DarkFire,Condition(function DarkFire_Conditions))
call TriggerAddAction(gg_trg_DarkFire,function DarkFire_Actions)
endfunction
function TombleStone takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer h=GetHandleId(t)
local unit Dami=LoadUnitHandle(udg_Hash,h,1)
local integer counter=LoadInteger(udg_Hash,h,2)
local integer lvl=LoadInteger(udg_Hash,h,3)
local real range=LoadReal(udg_Hash,h,4)
local real SkeletonTime=LoadReal(udg_Hash,h,5)
local integer maxcounter=LoadInteger(udg_Hash,h,6)
local integer q=LoadInteger(udg_Hash,h,30)
local unit krest=LoadUnitHandle(udg_Hash,h,q)
local real x1=GetUnitX(Dami)
local real y1=GetUnitY(Dami)
local integer i=1
local real x
local real y
local integer skeletonID='u00G'
if isPlayerHasSoloHero(Owner(Dami))then
set skeletonID='u002'
endif
if counter>0 then
call SetUnitAnimation(Dami,"work")
loop
exitwhen i>lvl
if(GetUnitState(Dami,UNIT_STATE_LIFE)>0)then
set x=GetRandomReal(x1-(range/ 2),x1+(range/ 2))
set y=GetRandomReal(y1-(range/ 2),y1+(range/ 2))
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(Dami),skeletonID,x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',SkeletonTime)
if(GetPlayerTechCount(GetOwningPlayer(Dami),'R02A',true)>0)then
call UnitAddAbility(bj_lastCreatedUnit,'A074')
endif
set bj_lastCreatedEffect=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",bj_lastCreatedUnit,"origin")
call DestroyEffect(bj_lastCreatedEffect)
call ShowUnit(krest,true)
set x=GetUnitX(krest)
set y=GetUnitY(krest)
set bj_lastCreatedEffect=AddSpecialEffect("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",x,y)
call DestroyEffect(bj_lastCreatedEffect)
endif
set i=i+1
endloop
call SaveInteger(udg_Hash,h,30,q+1)
call SaveInteger(udg_Hash,h,2,counter-1)
else
call KillUnit(Dami)
set i=1
loop
exitwhen i>maxcounter
set krest=LoadUnitHandle(udg_Hash,h,i+6)
call KillUnit(krest)
set i=i+1
endloop
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,h)
endif
set krest=null
set t=null
set Dami=null
endfunction
function TombleStone_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local timer t=CreateTimer()
local integer h=GetHandleId(t)
local unit Dami
local integer lvl=GetUnitAbilityLevel(caster,'A06U')
local unit array krest
local integer i=1
local real x
local real y
local real x1=GetSpellTargetX()
local real y1=GetSpellTargetY()
local real SkeletonTime=40.00
local real range=700.00
local integer counter=15
local real periodic=2.00
loop
exitwhen i>counter
set x=x1+300.00*Cos((i*(360/ counter))*bj_DEGTORAD)
set y=y1+300.00*Sin((i*(360/ counter))*bj_DEGTORAD)
set krest[i]=CreateUnit(GetOwningPlayer(caster),'u00I',x,y,bj_UNIT_FACING)
call ShowUnit(krest[i],false)
set i=i+1
endloop
set Dami=CreateUnit(GetOwningPlayer(caster),'u00H',x1,y1,bj_UNIT_FACING)
call SetUnitAnimation(Dami,"work")
call SaveUnitHandle(udg_Hash,h,1,Dami)
call SaveInteger(udg_Hash,h,2,counter)
call SaveInteger(udg_Hash,h,3,lvl)
call SaveReal(udg_Hash,h,4,range)
call SaveReal(udg_Hash,h,5,SkeletonTime)
call SaveInteger(udg_Hash,h,6,counter)
set i=1
loop
exitwhen i>counter
call SaveUnitHandle(udg_Hash,h,6+i,krest[i])
set krest[i]=null
set i=i+1
endloop
call SaveInteger(udg_Hash,h,30,7)
call TimerStart(t,periodic,true,function TombleStone)
set Dami=null
set caster=null
set t=null
endfunction
function TombleStone_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A06U'
endfunction
function InitTrig_TombleStone takes nothing returns nothing
set gg_trg_TombleStone=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_TombleStone,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_TombleStone,Condition(function TombleStone_Conditions))
call TriggerAddAction(gg_trg_TombleStone,function TombleStone_Actions)
endfunction
function BlackArrows_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetKillingUnit(),'A071')>0 and not isUnitSilenced(GetKillingUnit())
endfunction
function BlackArrows_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local integer array skeleton
local unit target=GetTriggerUnit()
local integer i=GetUnitAbilityLevel(caster,'A071')
local real x=GetUnitX(target)
local real y=GetUnitY(target)
set skeleton[1]='u00J'
set skeleton[2]='u00K'
set skeleton[3]='u00L'
set skeleton[4]='u00M'
set skeleton[5]='u00N'
if isPlayerHasSoloHero(Owner(caster))then
set skeleton[5]='u002'
endif
if(IsUnitType(target,UNIT_TYPE_SUMMONED)!=true)then
set bj_lastCreatedEffect=AddSpecialEffect("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",x,y)
call DestroyEffect(bj_lastCreatedEffect)
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),skeleton[i],x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',45.00)
if(GetPlayerTechCount(GetOwningPlayer(caster),'R02A',true)>0)then
call UnitAddAbility(bj_lastCreatedUnit,'A074')
endif
endif
set caster=null
set target=null
endfunction
function InitTrig_BlackArrows takes nothing returns nothing
set gg_trg_BlackArrows=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BlackArrows,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_BlackArrows,Condition(function BlackArrows_Conditions))
call TriggerAddAction(gg_trg_BlackArrows,function BlackArrows_Actions)
endfunction
function Charm_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0GM'
endfunction
function Charm_filter takes nothing returns boolean
local boolean unitType=not isUnitStruct(GetFilterUnit())and not isUnitHero(GetFilterUnit())and not isUnitMechanical(GetFilterUnit())
return GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))and unitType
endfunction
function Charm_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0GM')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local boolexpr filter=null
local unit target=null
local real time=4.00*lvl
local real range=275.00
set bj_caster=caster
set filter=Condition(function Charm_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call ControlUnit(caster,target,time)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_Charm takes nothing returns nothing
set gg_trg_Charm=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Charm,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Charm,Condition(function Charm_Conditions))
call TriggerAddAction(gg_trg_Charm,function Charm_Actions)
endfunction
function SharpBlade_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(caster,GetSpellAbilityId())
local real x1=GetUnitX(caster)
local real y1=GetUnitY(caster)
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local effect eff
local real l__damage=30*lvl
local real backBuff=3.00
local real poisonTime=5.00
local real poisonDamage=10.00
local string Type="Poison"
local string dmgEffPath="Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl"
if isUnitBack(target,caster)then
set l__damage=l__damage*backBuff
set poisonDamage=poisonDamage*backBuff
endif
set eff=AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodLarge0.mdl",target,"chest")
call DestroyEffect(eff)
call MagDamage(caster,target,l__damage)
if isPlayerHasSoloHero(Owner(caster))then
call PeriodicDamage_Start(Type,dmgEffPath,caster,target,poisonDamage,poisonDamage,0)
endif
set eff=null
set target=null
set caster=null
endfunction
function SharpBlade_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0JC'
endfunction
function InitTrig_SharpBlade takes nothing returns nothing
set gg_trg_SharpBlade=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_SharpBlade,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_SharpBlade,Condition(function SharpBlade_Conditions))
call TriggerAddAction(gg_trg_SharpBlade,function SharpBlade_Actions)
endfunction
function AstralArmor_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0J2'
endfunction
function AstralArmor_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0J2')
local real hpRegen=lvl*0.50
local real mpRegen=lvl*0.25
local integer armor=lvl*1
local integer l__damage=lvl*4
local real time=8.00+(2.00*lvl)
local real range=75.00
local real height=75.00
if isPlayerHasSoloHero(Owner(caster))then
call TimedDamage(target,l__damage,time)
endif
call TimedArmor(target,armor,time)
call TimedHpRegen(target,hpRegen,time)
call TimedMpRegen(target,mpRegen,time)
call TimedRoundedEffectTarget("Effect_ShieldBuff_Blue.mdx",target,height,range,time)
set target=null
set caster=null
endfunction
function InitTrig_AstralArmor takes nothing returns nothing
set gg_trg_AstralArmor=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_AstralArmor,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_AstralArmor,Condition(function AstralArmor_Conditions))
call TriggerAddAction(gg_trg_AstralArmor,function AstralArmor_Actions)
endfunction
function NaturePower_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0AA'
endfunction
function NaturePower_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local destructable array tree
local real x1=GetSpellTargetX()
local real y1=GetSpellTargetY()
local integer lvl=GetUnitAbilityLevel(caster,'A0AA')
local integer i=1
local effect eff
local unit dami
local real x
local real y
local integer max=12*lvl
local real time=5.00
local real lifetime=60.00
local real range=300.00+(100.00*lvl)
loop
exitwhen i>max
set x=GetRandomPointInRange(x1,y1,range,"x")
set y=GetRandomPointInRange(x1,y1,range,"y")
set tree[i]=CreateDestructable('VTlt',x,y,0,1,0)
call SetDestructableAnimation(tree[i],"birth")
call TriggerSleepAction(0.01)
set i=i+1
endloop
call TriggerSleepAction(time)
set i=1
loop
exitwhen i>max
set x=GetDestructableX(tree[i])
set y=GetDestructableY(tree[i])
call KillDestructable(tree[i])
set dami=CreateUnit(GetOwningPlayer(caster),'h02H',x,y,270)
call UnitApplyTimedLife(dami,'BTLF',lifetime)
set eff=AddSpecialEffectTarget("Objects\\Spawnmodels\\NightElf\\EntBirthTarget\\EntBirthTarget.mdl",dami,"origin")
call DestroyEffect(eff)
set i=i+1
endloop
call TriggerSleepAction(2.00)
set i=1
loop
exitwhen i>max
call RemoveDestructable(tree[i])
set tree[i]=null
set i=i+1
endloop
set dami=null
set caster=null
endfunction
function InitTrig_NaturePower takes nothing returns nothing
set gg_trg_NaturePower=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_NaturePower,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_NaturePower,Condition(function NaturePower_Conditions))
call TriggerAddAction(gg_trg_NaturePower,function NaturePower_Actions)
endfunction
function MagicSnaryads_Conditions takes nothing returns boolean
return not isUnitSilenced(GetEventDamageSource())and GetUnitAbilityLevel(GetEventDamageSource(),'A0DP')>0 and GetUnitAbilityLevel(GetTriggerUnit(),'B01H')>0 and GetEventDamage()>0
endfunction
function MagicSnaryads_Act1 takes nothing returns nothing
local unit target=GetEnumUnit()
local unit caster=GetEventDamageSource()
local integer lvl=GetUnitAbilityLevel(caster,'A0DP')
local real hp=3.00*lvl
local string s
if(GetUnitState(target,UNIT_STATE_LIFE)>0 and IsUnitAlly(target,GetOwningPlayer(caster))==true and IsUnitType(target,UNIT_TYPE_STRUCTURE)!=true)then
set s=("+"+I2S(R2I(hp))+" hp")
set bj_lastCreatedEffect=AddSpecialEffectTarget("Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdl",target,"origin")
call HP_RESTORE(target,hp,s,10.00,0,255,0,0,96.00,0.75)
call DestroyEffect(bj_lastCreatedEffect)
endif
set caster=null
set target=null
endfunction
function MagicSnaryads_Actions takes nothing returns nothing
local unit caster=GetEventDamageSource()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group ug=CreateGroup()
local effect eff
local real range=600.00
if isPlayerHasSoloHero(Owner(caster))then
set range=range+300.00
endif
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\ReplenishHealth\\ReplenishHealthCasterOverhead.mdl",caster,"overhead")
call DestroyEffect(eff)
call RangeEffect_start(caster,x,y,range,0.5)
call GroupEnumUnitsInRange(ug,x,y,range,null)
call ForGroup(ug,function MagicSnaryads_Act1)
call DestroyGroup(ug)
set eff=null
set ug=null
set caster=null
endfunction
function InitTrig_MagicSnaryads takes nothing returns nothing
set gg_trg_MagicSnaryads=CreateTrigger()
call TriggerAddCondition(gg_trg_MagicSnaryads,Condition(function MagicSnaryads_Conditions))
call TriggerAddAction(gg_trg_MagicSnaryads,function MagicSnaryads_Actions)
endfunction
function Vozmezide_filter takes nothing returns boolean
return GetUnitAbilityLevel(GetFilterUnit(),'A02J')>0 and IsUnitAlly(bj_caster,GetOwningPlayer(GetFilterUnit()))==true
endfunction
function Vozmezide_Actions takes nothing returns nothing
local boolexpr filter=Condition(function Vozmezide_filter)
local unit caster=GetTriggerUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local integer lvl
local unit target
local effect eff
local real heal
local string s
local real range=600.00
local real heal_lvl=5
set bj_caster=caster
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call RangeEffect_start(target,GetUnitX(target),GetUnitY(target),range,0.5)
set lvl=GetUnitAbilityLevel(target,'A02J')
set heal=heal_lvl*lvl
if isPlayerHasSoloHero(Owner(target))then
set heal=heal*1.25
endif
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdl",target,"origin")
set s="+"+I2S(R2I(heal))+" hp"
call HP_RESTORE(target,heal,s,10.00,0,255,0,60,96.00,0.75)
set s="+"+I2S(R2I(heal))+" mp"
call MP_RESTORE(target,heal,s,10.00,0,51,255,0,96.00,0.75)
call DestroyEffect(eff)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_Vozmezide takes nothing returns nothing
set gg_trg_Vozmezide=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Vozmezide,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddAction(gg_trg_Vozmezide,function Vozmezide_Actions)
endfunction
function s__SpiritFire_st_Destroy takes integer this returns nothing
call KillUnit(s__SpiritFire_st_dummy[this])
set s__SpiritFire_st_spiritID[this]=0
set s__SpiritFire_st_dummy[this]=null
set s__SpiritFire_st_caster[this]=null
call s__SpiritFire_st_deallocate(this)
endfunction
function SpiritFire_filter takes nothing returns boolean
return GetUnitHealth(GetFilterUnit())>0 and isUnitEnemy(GetFilterUnit(),bj_caster)
endfunction
function SpiritFire_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer sf=LoadInt(id,"SpiritFire | Structure")
local group g=CreateGroup()
local boolexpr filter
local unit spirit
local unit target
if s__SpiritFire_st_time[sf]>=s__SpiritFire_st_periodic[sf]and GetUnitCurrentOrder(s__SpiritFire_st_caster[sf])==OrderId("charm")then
set s__SpiritFire_st_time[sf]=s__SpiritFire_st_time[sf]-s__SpiritFire_st_periodic[sf]
if isPlayerHasSoloHero(Owner(s__SpiritFire_st_caster[sf]))then
call HealAlliesAroundUnit(s__SpiritFire_st_caster[sf],s__SpiritFire_st_range[sf],5.00)
endif
set bj_caster=s__SpiritFire_st_caster[sf]
set filter=Condition(function SpiritFire_filter)
call GroupEnumUnitsInRange(g,s__SpiritFire_st_x[sf],s__SpiritFire_st_y[sf],s__SpiritFire_st_range[sf],filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call TimedEffectTarget("Abilities\\Spells\\Human\\slow\\slowtarget.mdl",target,"chest",0.25)
if GetUnitAbilityLevel(target,'A0IQ')>0 then
call MagDamage(s__SpiritFire_st_caster[sf],target,s__SpiritFire_st_damage[sf]*1.25)
elseif isUnitStruct(target)then
call MagDamage(s__SpiritFire_st_caster[sf],target,s__SpiritFire_st_structDamage[sf])
else
call MagDamage(s__SpiritFire_st_caster[sf],target,s__SpiritFire_st_damage[sf])
endif
if not isUnitAlive(target)and not isUnitHero(target)and not isUnitStruct(target)and not isUnitSummon(target)then
call TimedEffect("Abilities\\Spells\\Orc\\AncestralSpirit\\AncestralSpiritCaster.mdl",GetUnitX(target),GetUnitY(target),1.00)
set spirit=CreateUnit(GetOwningPlayer(s__SpiritFire_st_caster[sf]),s__SpiritFire_st_spiritID[sf],GetUnitX(target),GetUnitY(target),0)
call UnitApplyTimedLife(spirit,'BTLF',45.00)
call RemoveUnit(target)
endif
call GroupRemoveUnit(g,target)
endloop
else
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__SpiritFire_st_Destroy(sf)
endif
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set t=null
set g=null
set spirit=null
set filter=null
set target=null
endfunction
function SpiritFire_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0IR')
local integer sf=s__SpiritFire_st__allocate()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real scale=1.75
set s__SpiritFire_st_caster[sf]=caster
set s__SpiritFire_st_x[sf]=GetSpellTargetX()
set s__SpiritFire_st_y[sf]=GetSpellTargetY()
set s__SpiritFire_st_damage[sf]=5+(5*lvl)
set s__SpiritFire_st_range[sf]=350.00
set s__SpiritFire_st_time[sf]=10.00
set s__SpiritFire_st_periodic[sf]=0.25
set s__SpiritFire_st_spiritID[sf]='o000'
set s__SpiritFire_st_structDamage[sf]=s__SpiritFire_st_damage[sf]*0.50
if GetPlayerTechCount(GetOwningPlayer(s__SpiritFire_st_caster[sf]),'R02A',true)>0 then
set s__SpiritFire_st_spiritID[sf]='o00K'
endif
set s__SpiritFire_st_dummy[sf]=CreateUnit(Owner(s__SpiritFire_st_caster[sf]),'h03U',s__SpiritFire_st_x[sf],s__SpiritFire_st_y[sf],0)
call SetUnitAnimation(s__SpiritFire_st_dummy[sf],"birth")
call SetUnitScale(s__SpiritFire_st_dummy[sf],scale,scale,scale)
call SetUnitAnimation(caster,"channel")
call SaveInt(id,"SpiritFire | Structure",sf)
call TimerStart(t,s__SpiritFire_st_periodic[sf],true,function SpiritFire_timer)
set t=null
set caster=null
endfunction
function SpiritFire_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0IR'
endfunction
function InitTrig_SpiritFire takes nothing returns nothing
set gg_trg_SpiritFire=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_SpiritFire,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_SpiritFire,Condition(function SpiritFire_Conditions))
call TriggerAddAction(gg_trg_SpiritFire,function SpiritFire_Actions)
endfunction
function WrathOfNature_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A02K'
endfunction
function WrathOfNature_filter takes nothing returns boolean
return GetUnitHealth(GetFilterUnit())>0 and isUnitEnemy(bj_caster,GetFilterUnit())and not isUnitStruct(GetFilterUnit())
endfunction
function WrathOfNature_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A02K')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local group g=CreateGroup()
local boolexpr filter
local unit target
local real time=15.00
local real range=300.00
local integer abilID='A0IP'
local integer effectID='A0IQ'
set bj_caster=caster
set filter=Condition(function WrathOfNature_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
call TimedAbility(target,abilID,time)
call SetUnitAbilityLevel(target,effectID,lvl)
call GroupRemoveUnit(g,target)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set filter=null
set caster=null
set target=null
endfunction
function InitTrig_WrathOfNature takes nothing returns nothing
set gg_trg_WrathOfNature=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_WrathOfNature,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_WrathOfNature,Condition(function WrathOfNature_Conditions))
call TriggerAddAction(gg_trg_WrathOfNature,function WrathOfNature_Actions)
endfunction
function PowerOfNature_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A032')>0 and GetUnitAbilityLevel(GetTriggerUnit(),'Brej')==0
endfunction
function PowerOfNature_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer chance=4+(GetUnitAbilityLevel(caster,'A032'))
local integer rej_lvl=GetUnitAbilityLevel(caster,'A030')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer abil='A033'
if(rej_lvl>2)then
set abil='A0E8'
endif
if Chance(caster,chance)then
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'h018',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',3.00)
call UnitAddAbility(bj_lastCreatedUnit,abil)
call SetUnitAbilityLevel(bj_lastCreatedUnit,abil,GetUnitAbilityLevel(caster,'A032'))
call IssueTargetOrder(bj_lastCreatedUnit,"rejuvination",caster)
endif
set caster=null
endfunction
function InitTrig_PowerOfNature takes nothing returns nothing
set gg_trg_PowerOfNature=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_PowerOfNature,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_PowerOfNature,Condition(function PowerOfNature_Conditions))
call TriggerAddAction(gg_trg_PowerOfNature,function PowerOfNature_Actions)
endfunction
function TreeSilence_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0EC'
endfunction
function TreeSilence_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer rej_lvl=GetUnitAbilityLevel(caster,'A030')
local integer lvl=GetUnitAbilityLevel(caster,'A0EC')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local destructable array tree
local integer i=1
local real x1
local real y1
local real range=200+(50*(lvl-1))
local real time=4.00*lvl
local integer trees=8+(2*(lvl-1))
local real angle=360/ trees
set i=1
loop
exitwhen i>trees
set x1=PolarPoints(x,y,range,angle*i,"x")
set y1=PolarPoints(x,y,range,angle*i,"y")
set tree[i]=CreateDestructable('ATtr',x1,y1,0,1.00,5)
set i=i+1
endloop
call TriggerSleepAction(time)
if isPlayerHasSoloHero(Owner(caster))then
call HealUnit(caster,400.00,false)
endif
set i=1
loop
exitwhen i>trees
call KillDestructable(tree[i])
if(rej_lvl>1)then
set bj_lastCreatedUnit=CreateUnit(GetOwningPlayer(caster),'h01A',GetDestructableX(tree[i]),GetDestructableY(tree[i]),GetRandomReal(0.00,360.00))
call UnitApplyTimedLife(bj_lastCreatedUnit,'BTLF',60)
endif
set i=i+1
endloop
call TriggerSleepAction(5.00)
set i=1
loop
exitwhen i>trees
call RemoveDestructable(tree[i])
set tree[i]=null
set i=i+1
endloop
set caster=null
endfunction
function InitTrig_TreeSilence takes nothing returns nothing
set gg_trg_TreeSilence=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_TreeSilence,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_TreeSilence,Condition(function TreeSilence_Conditions))
call TriggerAddAction(gg_trg_TreeSilence,function TreeSilence_Actions)
endfunction
function KornSystema_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A031'
endfunction
function KornSystema takes nothing returns nothing
local unit caster=bj_caster
local unit target=GetEnumUnit()
local integer ultimateLevel=GetUnitAbilityLevel(caster,'A030')
local integer lvl=GetUnitAbilityLevel(caster,'A031')
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local real l__damage=7*lvl
local real periodic=1.00
local real time=5.00
if ultimateLevel>0 then
set l__damage=l__damage*1.75
endif
if isUnitHero(target)then
set time=3.00
endif
if isUnitEnemy(caster,target)and not isUnitRooted(target)and not isUnitStruct(target)then
call Roots_Start(caster,target,l__damage,periodic,time)
endif
set caster=null
set target=null
endfunction
function KornSystema_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x1=GetUnitX(caster)
local real y1=GetUnitY(caster)
local real x
local real y
local effect array eff
local integer i=1
local integer q=1
local integer w=1
local group ug
local integer qwe=24
local integer max=5
if isPlayerHasSoloHero(Owner(caster))then
set max=max+3
endif
loop
exitwhen q>max
set i=1
loop
exitwhen i>24
set x=x1+(75*q)*Cos((15*i)*bj_DEGTORAD)
set y=y1+(75*q)*Sin((15*i)*bj_DEGTORAD)
set eff[w]=AddSpecialEffect("Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl",x,y)
set w=w+1
set i=i+1
endloop
set bj_caster=caster
set ug=CreateGroup()
call GroupEnumUnitsInRange(ug,x1,y1,(75*q),null)
call ForGroup(ug,function KornSystema)
call DestroyGroup(ug)
call TriggerSleepAction(0.1)
set q=q+1
endloop
call TriggerSleepAction(1.00)
set q=1
set i=1
loop
exitwhen q>max
loop
exitwhen i>qwe
call DestroyEffect(eff[i])
set eff[i]=null
set i=i+1
endloop
call TriggerSleepAction(0.1)
set qwe=qwe+24
set i=qwe-24
set q=q+1
endloop
set ug=null
set caster=null
endfunction
function InitTrig_KornSystema takes nothing returns nothing
set gg_trg_KornSystema=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_KornSystema,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_KornSystema,Condition(function KornSystema_Conditions))
call TriggerAddAction(gg_trg_KornSystema,function KornSystema_Actions)
endfunction
function SeaHope_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A063'
endfunction
function s__SeaHope_st_Destroy takes integer this returns nothing
call DestroyEffect(s__SeaHope_st_eff[this])
call UnitRemoveAbility(s__SeaHope_st_caster[this],s__SeaHope_st_abil[this])
set s__SeaHope_st_abil[this]=0
set s__SeaHope_st_eff[this]=null
set s__SeaHope_st_caster[this]=null
call s__SeaHope_st_deallocate(this)
endfunction
function SeaHope_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer hope=LoadInt(id,"SeaHope | Structure")
if GetUnitCurrentOrder(s__SeaHope_st_caster[hope])!=OrderId("charm")then
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,id)
call s__SeaHope_st_Destroy(hope)
endif
set t=null
endfunction
function SeaHope_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local integer hope=s__SeaHope_st__allocate()
local real periodic=0.04
set s__SeaHope_st_caster[hope]=caster
set s__SeaHope_st_eff[hope]=AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIda\\AIdaTarget.mdl",caster,"overhead")
set s__SeaHope_st_abil[hope]='A064'
call UnitAddAbility(caster,s__SeaHope_st_abil[hope])
call SetUnitAbilityLevel(caster,s__SeaHope_st_abil[hope],GetUnitAbilityLevel(caster,'A063'))
call SaveInt(id,"SeaHope | Structure",hope)
call TimerStart(t,periodic,true,function SeaHope_timer)
set t=null
set caster=null
endfunction
function InitTrig_SeaHope takes nothing returns nothing
set gg_trg_SeaHope=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_SeaHope,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_SeaHope,Condition(function SeaHope_Conditions))
call TriggerAddAction(gg_trg_SeaHope,function SeaHope_Actions)
endfunction
function GromKleshnya_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A062'
endfunction
function GromKleshnya_Act2 takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetEnumUnit()
local real dmg=12.50*GetUnitAbilityLevel(caster,'A062')
if(IsUnitEnemy(target,GetOwningPlayer(caster))==true)then
call MagDamage(caster,target,dmg)
endif
set caster=null
set target=null
endfunction
function GromKleshnya_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local real x1=GetLocationX(GetSpellTargetLoc())
local real y1=GetLocationY(GetSpellTargetLoc())
local real x2=GetUnitX(caster)
local real y2=GetUnitY(caster)
local integer i=1
local group ugGrom
local real x
local real y
local real z
local real range=250.00
loop
exitwhen i>6
set z=bj_RADTODEG*Atan2(y1-y2,x1-x2)
set x=x2+(100.00*i)*Cos(z*bj_DEGTORAD)
set y=y2+(100.00*i)*Sin(z*bj_DEGTORAD)
set bj_lastCreatedEffect=AddSpecialEffect("Abilities\\Spells\\Human\\ThunderClap\\ThunderClapCaster.mdl",x,y)
call DestroyEffect(bj_lastCreatedEffect)
set ugGrom=CreateGroup()
call GroupEnumUnitsInRange(ugGrom,x,y,range,null)
call ForGroup(ugGrom,function GromKleshnya_Act2)
call DestroyGroup(ugGrom)
call TriggerSleepAction(0.1)
set i=i+1
endloop
set caster=null
set ugGrom=null
endfunction
function InitTrig_GromKleshnya takes nothing returns nothing
set gg_trg_GromKleshnya=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_GromKleshnya,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_GromKleshnya,Condition(function GromKleshnya_Conditions))
call TriggerAddAction(gg_trg_GromKleshnya,function GromKleshnya_Actions)
endfunction
function Fenix_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0AT'
endfunction
function Fenix takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer h=GetHandleId(t)
local unit caster=LoadUnitHandle(udg_Hash,h,1)
local unit Dami=LoadUnitHandle(udg_Hash,h,2)
local integer counter=LoadInteger(udg_Hash,h,3)
local integer grad=LoadInteger(udg_Hash,h,4)
local integer nap=LoadInteger(udg_Hash,h,5)
local integer face=LoadInteger(udg_Hash,h,6)
local real x=GetUnitX(caster)+350*Cos(grad*bj_DEGTORAD)
local real y=GetUnitY(caster)+350*Sin(grad*bj_DEGTORAD)
if counter>0 then
call SetUnitPosition(Dami,x,y)
call SetUnitFacing(Dami,face+grad)
call SaveInteger(udg_Hash,h,3,counter-1)
call SaveInteger(udg_Hash,h,4,grad+nap)
else
if(GetUnitAbilityLevel(Dami,'A098')>0)then
call RemoveItem(UnitItemInSlot(Dami,0))
endif
call KillUnit(Dami)
call DestroyTimer(t)
call FlushChildHashtable(udg_Hash,h)
endif
set Dami=null
set caster=null
set t=null
endfunction
function Fenix_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local timer t=CreateTimer()
local integer h=GetHandleId(t)
local integer lvl=GetUnitAbilityLevel(caster,'A0AT')
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local boolean two=false
local real r=GetRandomReal(0.00,100.00)
local unit Dami
local real time=5+(5*lvl)
local integer i=R2I(time/ 0.02)
if(GetPlayerTechCount(GetOwningPlayer(caster),'R02A',true)>0)then
if(r<=100.00)then
set two=true
endif
endif
set Dami=CreateUnit(GetOwningPlayer(caster),'h026',x,y,bj_UNIT_FACING)
call SetUnitAbilityLevel(Dami,'A0AU',lvl)
call SaveUnitHandle(udg_Hash,h,1,caster)
call SaveUnitHandle(udg_Hash,h,2,Dami)
call SaveInteger(udg_Hash,h,3,i)
call SaveInteger(udg_Hash,h,4,0)
call SaveInteger(udg_Hash,h,5,3)
call SaveInteger(udg_Hash,h,6,90)
call TimerStart(t,0.02,true,function Fenix)
if(two==true)then
set t=CreateTimer()
set h=GetHandleId(t)
set Dami=CreateUnit(GetOwningPlayer(caster),'h026',x,y,bj_UNIT_FACING)
call SetUnitAbilityLevel(Dami,'A0AU',lvl)
call SaveUnitHandle(udg_Hash,h,1,caster)
call SaveUnitHandle(udg_Hash,h,2,Dami)
call SaveInteger(udg_Hash,h,3,i)
call SaveInteger(udg_Hash,h,4,0)
call SaveInteger(udg_Hash,h,5,-3)
call SaveInteger(udg_Hash,h,6,-90)
call TimerStart(t,0.02,true,function Fenix)
endif
set Dami=null
set caster=null
set t=null
endfunction
function InitTrig_Fenix takes nothing returns nothing
set gg_trg_Fenix=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Fenix,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_Fenix,Condition(function Fenix_Conditions))
call TriggerAddAction(gg_trg_Fenix,function Fenix_Actions)
endfunction
function FenixFly_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0II'
endfunction
function s__FenixFly_st_Destroy takes integer this returns nothing
call KillUnit(s__FenixFly_st_dummy[this])
set s__FenixFly_st_dummy[this]=null
set s__FenixFly_st_caster[this]=null
call s__FenixFly_st_deallocate(this)
endfunction
function FenixFly_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=GetHandleId(t)
local integer fly=LoadInt(id,"FenixFly | Structure")
local real height=GetUnitFlyHeight(s__FenixFly_st_dummy[fly])
local real angle=GetUnitFacing(s__FenixFly_st_dummy[fly])
local real x=GetUnitX(s__FenixFly_st_dummy[fly])
local real y=GetUnitY(s__FenixFly_st_dummy[fly])
local real upSpeed=s__FenixFly_st_speed[fly]
local real rate=upSpeed/ s__FenixFly_st_periodic[fly]
local real x1
local real y1
if s__FenixFly_st_distance[fly]<s__FenixFly_st_maxDistance[fly]then
call SetUnitHeightByDistance(s__FenixFly_st_dummy[fly],s__FenixFly_st_distance[fly],s__FenixFly_st_maxDistance[fly],upSpeed,rate)
set x1=PolarPoints(x,y,s__FenixFly_st_speed[fly],angle,"x")
set y1=PolarPoints(x,y,s__FenixFly_st_speed[fly],angle,"y")
call SetUnitPosition(s__FenixFly_st_dummy[fly],x1,y1)
call SetUnitPosition(s__FenixFly_st_caster[fly],x1,y1)
set s__FenixFly_st_distance[fly]=s__FenixFly_st_distance[fly]+s__FenixFly_st_speed[fly]
else
call DestroyTimer(t)
call ShowUnit(s__FenixFly_st_caster[fly],true)
call SelectUnitAddForPlayer(s__FenixFly_st_caster[fly],GetOwningPlayer(s__FenixFly_st_caster[fly]))
call FlushChildHashtable(udg_Hash,id)
call s__FenixFly_st_Destroy(fly)
endif
set t=null
endfunction
function FenixFly_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0II')
local timer t=CreateTimer()
local integer id=GetHandleId(t)
local real x1=GetSpellTargetX()
local real y1=GetSpellTargetY()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer fly=s__FenixFly_st__allocate()
local real angle=Angle(x,y,x1,y1)
set s__FenixFly_st_speed[fly]=20.00
set s__FenixFly_st_distance[fly]=0.00
set s__FenixFly_st_periodic[fly]=0.03
set s__FenixFly_st_caster[fly]=caster
set s__FenixFly_st_maxDistance[fly]=900.00+(lvl*100.00)
set s__FenixFly_st_dummy[fly]=CreateUnit(GetOwningPlayer(caster),'h038',x,y,angle)
call SetUnitAbilityLevel(s__FenixFly_st_dummy[fly],'A0IJ',lvl)
call ShowUnit(caster,false)
call SaveInt(id,"FenixFly | Structure",fly)
call TimerStart(t,s__FenixFly_st_periodic[fly],true,function FenixFly_timer)
set t=null
set caster=null
endfunction
function InitTrig_FenixFly takes nothing returns nothing
set gg_trg_FenixFly=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_FenixFly,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_FenixFly,Condition(function FenixFly_Conditions))
call TriggerAddAction(gg_trg_FenixFly,function FenixFly_Actions)
endfunction
function KladbisheCreate_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0B7'
endfunction
function KladbisheCreate_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0B7')
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
local unit dami
local real Time=40.00
set dami=CreateUnit(GetOwningPlayer(caster),'u01B',x,y,bj_UNIT_FACING)
call UnitApplyTimedLife(dami,'BTLF',Time)
call SetUnitUserData(dami,lvl)
set caster=null
set dami=null
endfunction
function InitTrig_KladbisheCreate takes nothing returns nothing
set gg_trg_KladbisheCreate=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_KladbisheCreate,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_KladbisheCreate,Condition(function KladbisheCreate_Conditions))
call TriggerAddAction(gg_trg_KladbisheCreate,function KladbisheCreate_Actions)
endfunction
function Kladbishe_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())!='h031' and not isUnitSummon(GetTriggerUnit())and not isUnitHero(GetTriggerUnit())and not isUnitStruct(GetTriggerUnit())and IsUnitIllusion(GetTriggerUnit())==false
endfunction
function Kladbishe takes nothing returns boolean
return GetUnitTypeId(GetFilterUnit())=='u01B' and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0
endfunction
function Kladbishe_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetUnitTypeId(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real r=GetRandomReal(0.00,100.00)
local boolean LifeTime=true
local group g=CreateGroup()
local effect eff
local unit dami
local player p
local real Range=700.00
local real ResTime=7.50
local real Time=30.00
call GroupEnumUnitsInRange(g,x,y,Range,Condition(function Kladbishe))
set dami=FirstOfGroup(g)
call DestroyGroup(g)
set p=GetOwningPlayer(dami)
if(dami!=null)then
if(GetUnitAbilityLevel(caster,'A098')>0)then
call RemoveItem(UnitItemInSlot(caster,0))
call RemoveItem(UnitItemInSlot(caster,1))
endif
call RemoveUnit(caster)
set eff=AddSpecialEffect("Abilities\\Spells\\Orc\\Reincarnation\\ReincarnationTarget.mdl",x,y)
call TriggerSleepAction(ResTime)
call DestroyEffect(eff)
set caster=CreateUnit(p,id,x,y,bj_UNIT_FACING)
call SetUnitVertexColor(caster,100,100,100,175)
call UnitAddType(caster,UNIT_TYPE_SUMMONED)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",caster,"origin")
call DestroyEffect(eff)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\HowlOfTerror\\HowlCaster.mdl",dami,"origin")
call DestroyEffect(eff)
if(GetUnitUserData(dami)>1)then
call UnitAddAbility(caster,'A0B8')
endif
if(GetUnitUserData(dami)>2)then
set Time=Time*2
endif
if(LifeTime==true)then
call UnitApplyTimedLife(caster,'BTLF',Time)
endif
endif
set p=null
set eff=null
set dami=null
set g=null
set caster=null
endfunction
function InitTrig_Kladbishe takes nothing returns nothing
set gg_trg_Kladbishe=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Kladbishe,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Kladbishe,Condition(function Kladbishe_Conditions))
call TriggerAddAction(gg_trg_Kladbishe,function Kladbishe_Actions)
endfunction
function SaberOfSeas_filter takes nothing returns boolean
return isUnitEnemy(bj_caster,GetFilterUnit())and GetUnitHealth(GetFilterUnit())>0 and not isUnitStruct(GetFilterUnit())
endfunction
function SaberOfSeas_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A0IZ')
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local group g=CreateGroup()
local boolexpr filter
local unit dummy
local effect eff
local real range=200.00
local real nearDamage=50*lvl
local real farDamage=30*lvl
local real stunTime=1.75
local integer gold=1
if isPlayerHasSoloHero(Owner(caster))then
set gold=gold+5
endif
set bj_caster=caster
set filter=Condition(function SaberOfSeas_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set dummy=FirstOfGroup(g)
exitwhen dummy==null
if dummy!=target then
call MagDamage(caster,dummy,farDamage)
else
if isPlayerHasSoloHero(Owner(caster))then
call Stun_Start(target,stunTime)
endif
call MagDamage(caster,dummy,nearDamage)
endif
set eff=AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodLarge0.mdl",dummy,"chest")
call DestroyEffect(eff)
if GetPlayerGold(Owner(dummy))>0 then
set eff=AddSpecialEffectTarget("UI\\Feedback\\GoldCredit\\GoldCredit.mdl",dummy,"origin")
call DestroyEffect(eff)
call PlayerAddGold(Owner(dummy),-gold)
if GetLocalPlayer()==Owner(dummy)then
call TextUp("-"+I2S(gold),target,11,0,255,0,60,96.00,2.00)
endif
call PlayerAddGold(Owner(caster),gold)
if GetLocalPlayer()==Owner(caster)then
call TextUp("+"+I2S(gold),caster,11,0,255,0,60,96.00,2.00)
endif
endif
call GroupRemoveUnit(g,dummy)
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set eff=null
set dummy=null
set filter=null
set target=null
set caster=null
endfunction
function SaberOfSeas_Conditions takes nothing returns boolean
return GetSpellAbilityId()=='A0IZ'
endfunction
function InitTrig_SaberOfSeas takes nothing returns nothing
set gg_trg_SaberOfSeas=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_SaberOfSeas,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_SaberOfSeas,Condition(function SaberOfSeas_Conditions))
call TriggerAddAction(gg_trg_SaberOfSeas,function SaberOfSeas_Actions)
endfunction
function PirateNatureHero_Act takes unit caster,unit target returns nothing
local player pllcast=GetOwningPlayer(caster)
local player plltarg=GetOwningPlayer(target)
local integer lvl=GetUnitAbilityLevel(caster,'A08C')
local real chance=100.00
local string s
local integer gold=1*lvl
if isPlayerHasSoloHero(pllcast)then
set gold=gold+1
endif
if Chance(caster,chance)==true then
call PlayerAddGold(plltarg,-gold)
if GetLocalPlayer()==plltarg then
set s="-"+I2S(gold)
call TextUp(s,target,11,0,255,0,60,96.00,2.00)
endif
call PlayerAddGold(pllcast,gold)
if GetLocalPlayer()==pllcast then
set s="+"+I2S(gold)
call TextUp(s,caster,11,0,255,0,60,96.00,2.00)
endif
endif
set caster=null
set target=null
set pllcast=null
set plltarg=null
endfunction
function PirateNatureHero_Cond takes unit attacker,unit target returns boolean
return GetUnitAbilityLevel(attacker,'A08C')>0 and GetPlayerState(GetOwningPlayer(target),PLAYER_STATE_RESOURCE_GOLD)>0 and isUnitEnemy(attacker,target)
endfunction
function PirateNatureHero_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetAttacker(),'A08C')>0 and GetPlayerState(GetOwningPlayer(GetTriggerUnit()),PLAYER_STATE_RESOURCE_GOLD)>0
endfunction
function SheepKaptainDmg_Conditions takes nothing returns boolean
return GetUnitTypeId(GetEventDamageSource())=='h02M'
endfunction
function SheepKaptainDmg_Actions takes nothing returns nothing
local unit caster=GetEventDamageSource()
local integer lvl=LoadInteger(udg_Hash,GetHandleId(caster),StringHash("Praudmur|SheepCaptain|LVL"))
local real dmg=LoadReal(udg_Hash,GetHandleId(caster),StringHash("Praudmur|SheepCaptain|DMG"))
set dmg=dmg+GetEventDamage()
call SaveReal(udg_Hash,GetHandleId(caster),StringHash("Praudmur|SheepCaptain|DMG"),dmg)
set caster=null
endfunction
function InitTrig_SheepKaptainDmg takes nothing returns nothing
set gg_trg_SheepKaptainDmg=CreateTrigger()
call TriggerAddCondition(gg_trg_SheepKaptainDmg,Condition(function SheepKaptainDmg_Conditions))
call TriggerAddAction(gg_trg_SheepKaptainDmg,function SheepKaptainDmg_Actions)
endfunction
function SheepKaptainDye_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())=='h02M'
endfunction
function SheepKaptainDye_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=LoadInteger(udg_Hash,GetHandleId(caster),StringHash("Praudmur|SheepCaptain|LVL"))
local real dmg=LoadReal(udg_Hash,GetHandleId(caster),StringHash("Praudmur|SheepCaptain|DMG"))
local player p=GetOwningPlayer(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=1
local unit dummy
local string s
local real DmgCoef=300-(50*(lvl-1))
local integer max=5+R2I(dmg/ DmgCoef)
set s="Урон: "+I2S(R2I(dmg))+"
"+"Пиратов: "+I2S(max)
call TextUp(s,caster,10,0,255,0,0,60.00,2.00)
loop
exitwhen i>max
set dummy=CreateUnit(p,'h00M',x,y,270)
call SetUnitVertexColor(dummy,255,255,255,100)
call SetUnitState(dummy,UNIT_STATE_MANA,GetUnitState(dummy,UNIT_STATE_MAX_MANA))
set i=i+1
endloop
set p=null
set dummy=null
set caster=null
endfunction
function InitTrig_SheepKaptainDye takes nothing returns nothing
set gg_trg_SheepKaptainDye=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_SheepKaptainDye,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_SheepKaptainDye,Condition(function SheepKaptainDye_Conditions))
call TriggerAddAction(gg_trg_SheepKaptainDye,function SheepKaptainDye_Actions)
endfunction
function Altar_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())!='h031' and IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)!=true and IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)!=true and IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true and IsUnitIllusion(GetTriggerUnit())==false
endfunction
function Altar takes nothing returns boolean
return GetUnitTypeId(GetFilterUnit())=='u01D' and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0 and IsUnitAlly(GetTriggerUnit(),GetOwningPlayer(GetFilterUnit()))==true
endfunction
function Altar_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local integer id=GetUnitTypeId(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local effect eff
local unit dami
local real Range=600.00
local real ResTime=8.00
call GroupEnumUnitsInRange(g,x,y,Range,Condition(function Altar))
set dami=FirstOfGroup(g)
call DestroyGroup(g)
if(dami!=null)then
if(GetUnitAbilityLevel(caster,'A098')>0)then
call RemoveItem(UnitItemInSlot(caster,0))
endif
call RemoveUnit(caster)
set eff=AddSpecialEffect("Abilities\\Spells\\Orc\\Reincarnation\\ReincarnationTarget.mdl",x,y)
call TriggerSleepAction(ResTime)
call DestroyEffect(eff)
set caster=CreateUnit(p,id,x,y,bj_UNIT_FACING)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl",caster,"origin")
call DestroyEffect(eff)
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl",dami,"origin")
call DestroyEffect(eff)
endif
set p=null
set eff=null
set dami=null
set g=null
set caster=null
endfunction
function InitTrig_Altar takes nothing returns nothing
set gg_trg_Altar=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Altar,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Altar,Condition(function Altar_Conditions))
call TriggerAddAction(gg_trg_Altar,function Altar_Actions)
endfunction
function HolyArmor_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A009')>0 and not isUnitSilenced(GetTriggerUnit())
endfunction
function HolyArmor_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer lvl=GetUnitAbilityLevel(caster,'A009')
local real hp=(1.00*I2R(lvl))
local string s="+"+I2S(R2I(hp))+" hp"
local real gloryShieldBuff=0.50*lvl
set bj_lastCreatedEffect=AddSpecialEffectTarget("Abilities\\Spells\\Human\\HolyBolt\\HolyBoltSpecialArt.mdl",caster,"origin")
call DestroyEffect(bj_lastCreatedEffect)
call HP_RESTORE(caster,hp,s,10.00,0,255,0,0,96.00,0.75)
if isPlayerHasSoloHero(Owner(caster))then
set s="+"+R2S(gloryShieldBuff)+" mp"
call TextUpRand(s,caster,6.00,0,50,255,0,96.00,0.75)
call MP_RESTORE(caster,gloryShieldBuff,"",10.00,0,255,0,0,96.00,0.75)
endif
set caster=null
endfunction
function InitTrig_HolyArmor takes nothing returns nothing
set gg_trg_HolyArmor=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_HolyArmor,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(gg_trg_HolyArmor,Condition(function HolyArmor_Conditions))
call TriggerAddAction(gg_trg_HolyArmor,function HolyArmor_Actions)
endfunction
function CastEvent_Actions takes nothing returns nothing
local integer id=GetSpellAbilityId()
local unit caster=GetTriggerUnit()
local real x=GetSpellTargetX()
local real y=GetSpellTargetY()
if(id=='A007')then
call GodArmor_Actions(caster)
endif
if(id=='A08Y')then
call AltarCreate_Actions(caster,x,y)
endif
if(id=='A00L')then
call ManaExp_Actions(caster)
endif
if(id=='A00M')then
call GreatSummon_Actions(caster)
endif
if(id=='A00N')then
call MagicDospex_Actions(caster)
endif
if(id=='A00A')then
call DalaranPortal_Actions(caster)
endif
if(id=='A01H')then
call Korsars_Actions(caster)
endif
if(id=='A01L')then
call GnevMorey_Actions(caster)
endif
if(id=='A0DV')then
call SheepKaptain_Actions(caster)
endif
set caster=null
endfunction
function InitTrig_CastEvent takes nothing returns nothing
set gg_trg_CastEvent=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_CastEvent,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddAction(gg_trg_CastEvent,function CastEvent_Actions)
endfunction
function Holodomor_Conditions takes nothing returns boolean
return isPlayerHasHolodomor(Owner(GetKillingUnit()))and isUnitJustUnit(GetTriggerUnit())and isUnitJustUnit(GetKillingUnit())
endfunction
function Holodomor_Actions takes nothing returns nothing
local unit target=GetTriggerUnit()
local unit caster=GetKillingUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
call TimedEffect("Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl",x,y,1.00)
call HealUnit(caster,1.00,true)
call RemoveUnit(target)
set target=null
set caster=null
endfunction
function InitTrig_Holodomor takes nothing returns nothing
set gg_trg_Holodomor=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Holodomor,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Holodomor,Condition(function Holodomor_Conditions))
call TriggerAddAction(gg_trg_Holodomor,function Holodomor_Actions)
endfunction


function GetHeroItemById takes unit target,integer itemId returns item
        local integer index= 0
        local item slotItem= null
        
        loop
            exitwhen index > 5
            set slotItem=UnitItemInSlot(target, index)
            if slotItem != null and GetItemTypeId(slotItem) == itemId then
                return slotItem
            endif
            set index=index + 1
        endloop
        
        set slotItem=null
        return null
    endfunction
    
    function heroHasItemById takes unit target,integer itemId returns boolean
        return GetHeroItemById(target , itemId) != null
    endfunction
    
    function dropHeroItemById takes unit target,integer itemId returns item
        local item slotItem= GetHeroItemById(target , itemId)
        call UnitDropItemPoint(target, slotItem, GetUnitX(target), GetUnitY(target))
        return slotItem
    endfunction
    
    function removeHeroItemById takes unit target,integer itemId returns nothing
        local item slotItem= GetHeroItemById(target , itemId)
        call RemoveItem(slotItem)
        set slotItem=null
    endfunction


//library libHero ends
//library libBuy:


    function libBuy___setItemSpell takes integer itemId,integer spellId returns nothing
        call SaveInteger(Hash, itemId, StringHash("Spell"), spellId)
    endfunction
    
    function libBuy___getItemSpell takes item whichItem returns integer
        return LoadInteger(Hash, GetItemTypeId(whichItem), StringHash("Spell"))
    endfunction
    
    function libBuy___initSpell takes integer itemId,integer spellId returns nothing
        call libBuy___setItemSpell(itemId , spellId)
    endfunction
    
    function libBuy___buySpellConditions takes nothing returns boolean
        return libBuy___getItemSpell(GetManipulatedItem()) != 0
    endfunction

    function libBuy___buySpell takes nothing returns nothing
        local item buyingItem= GetManipulatedItem()
        local integer spellId= libBuy___getItemSpell(buyingItem)
        local unit caster= GetTriggerUnit()
        
        call RemoveItem(buyingItem)
        
        if GetUnitAbilityLevel(caster, spellId) == 0 then
            call UnitAddAbility(caster, spellId)
        else
            call AdjustPlayerStateBJ(1, GetOwningPlayer(caster), PLAYER_STATE_RESOURCE_LUMBER)
        endif
        
        set caster=null
        set buyingItem=null
    endfunction
    
    
    
    
    
    
    
    function libBuy___setHeroCrafting takes unit target,boolean value returns nothing
        call SaveBoolean(Hash, GetHandleId(target), StringHash("libBuy_isCrafting"), value)
    endfunction
    
    function libBuy___isHeroCrafting takes unit target returns boolean
        return LoadBoolean(Hash, GetHandleId(target), StringHash("libBuy_isCrafting"))
    endfunction
    
    function libBuy___setCraft takes integer craftId,integer ing1,integer ing2,integer ing3,integer ing4,integer ing5,integer ing6 returns nothing
        set libBuy___CRAFTS[libBuy___CRAFT_COUNTER]=craftId
        set libBuy___CRAFT_COUNTER=libBuy___CRAFT_COUNTER + 1
        call SaveInteger(Hash, craftId, StringHash("Craft_ing1"), ing1)
        call SaveInteger(Hash, craftId, StringHash("Craft_ing2"), ing2)
        call SaveInteger(Hash, craftId, StringHash("Craft_ing3"), ing3)
        call SaveInteger(Hash, craftId, StringHash("Craft_ing4"), ing4)
        call SaveInteger(Hash, craftId, StringHash("Craft_ing5"), ing5)
        call SaveInteger(Hash, craftId, StringHash("Craft_ing6"), ing6)
    endfunction
    
    function libBuy___getCraftIngredient takes integer craftId,integer index returns integer
        return LoadInteger(Hash, craftId, StringHash("Craft_ing" + I2S(index)))
    endfunction
    
    function libBuy___initCraft takes integer craftId,integer ing1,integer ing2,integer ing3,integer ing4,integer ing5,integer ing6 returns nothing
        call libBuy___setCraft(craftId , ing1 , ing2 , ing3 , ing4 , ing5 , ing6)
    endfunction
    
    

    
    function libBuy___craftItem takes unit target,integer craftIndex returns nothing
        call UnitAddItemById(target, libBuy___CRAFTS[craftIndex])
    endfunction
    
    function libBuy___clearCollectedItems takes nothing returns nothing
        local integer i= 1
        
        loop
            exitwhen i > 6
            set libBuy___ITEMS[i]=0
            set i=i + 1
        endloop
    endfunction
    
    function libBuy___returnHeroItems takes unit target returns nothing
        local integer index= 1
        
        loop
            exitwhen index > 6
            call UnitAddItemById(target, libBuy___ITEMS[index])
            set index=index + 1
        endloop
    endfunction
    
    function libBuy___hasCraftIngredients takes unit target,integer craftId returns boolean
        local integer index= 1
        local integer ingId= 0
        
        loop
            exitwhen index > 6
            set ingId=libBuy___getCraftIngredient(craftId , index)
            
            if ingId != 0 then
                if heroHasItemById(target , ingId) then
                    call removeHeroItemById(target , ingId)
                    set libBuy___ITEMS[index]=ingId
                else
                    set libBuy___ITEMS[index]=0
                    call libBuy___returnHeroItems(target)
                    call libBuy___clearCollectedItems()
                    return false
                endif
            endif
            
            set index=index + 1
        endloop
        
        call libBuy___clearCollectedItems()
        
        return true
    endfunction
    
    function libBuy___craftItemConditions takes nothing returns boolean
        return not libBuy___isHeroCrafting(GetTriggerUnit())
    endfunction
    
    function libBuy___craftItemActions takes nothing returns nothing
        local unit target= GetTriggerUnit()
        local integer craftIndex= 0
        
        call libBuy___setHeroCrafting(target , true)
        
        loop
            exitwhen craftIndex > libBuy___CRAFT_COUNTER
            
            if libBuy___hasCraftIngredients(target , libBuy___CRAFTS[craftIndex]) then
                call libBuy___craftItem(target , craftIndex)
                set craftIndex=libBuy___CRAFT_COUNTER * 2
            endif
            
            set craftIndex=craftIndex + 1
        endloop
        
        call libBuy___setHeroCrafting(target , false)
        
        set target=null
    endfunction
    
    function libBuy___initItems takes nothing returns nothing
        // крафт итема: 1 - скрафченный итем, 2,3,4,5,6,7 - ингредиенты
    endfunction
    
    function libBuy___initSpells takes nothing returns nothing

    endfunction
    
    function libBuy___init takes nothing returns nothing
        local trigger spellTrig= CreateTrigger()
        local trigger craftTrig= CreateTrigger()
            call TriggerRegisterAnyUnitEventBJ(spellTrig, EVENT_PLAYER_UNIT_PICKUP_ITEM)
            call TriggerAddCondition(spellTrig, Condition(function libBuy___buySpellConditions))
            call TriggerAddAction(spellTrig, function libBuy___buySpell)
            
            call TriggerRegisterAnyUnitEventBJ(craftTrig, EVENT_PLAYER_UNIT_PICKUP_ITEM)
            call TriggerAddCondition(craftTrig, Condition(function libBuy___craftItemConditions))
            call TriggerAddAction(craftTrig, function libBuy___craftItemActions)
            
            call libBuy___initSpells()
            call libBuy___initItems()
        set spellTrig=null
        set craftTrig=null
    endfunction


function Hat_Group takes nothing returns nothing
    local unit p = GetEnumUnit()
    call UnitRemoveAbility( p, 'A0HC' )
    call UnitRemoveBuffBJ( 'B01T', p )
    set p = null
endfunction

function Hat_Force takes nothing returns nothing
    local player p = GetEnumPlayer()
    call SetPlayerAbilityAvailable( p, 'A0HC', false )
    set p = null
endfunction

function Hat takes nothing returns nothing
    call ForForce( GetPlayersAll(), function Hat_Force )
    call ForGroup( GetUnitsInRectAll(GetPlayableMapRect()), function Hat_Group)
    call SetAbilityBaseRangeById( 'A0HC', 1, 1. )
    call SetAbilityBaseAoEById( 'A0HC', 1, 1. )
endfunction

function InitTrig_Hat takes nothing returns nothing
    set gg_trg_Hat = CreateTrigger(  )
    call TriggerRegisterTimerEventSingle( gg_trg_Hat, 0.15 )
    call TriggerAddAction( gg_trg_Hat, function Hat )
endfunction


function BurdenOfDarkness_Conditions takes nothing returns boolean
local integer lvl=GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R04U',true)
return lvl>0 and not isUnitSummon(GetTriggerUnit())and isUnitEnemy(GetTriggerUnit(),GetKillingUnit())
endfunction
function BurdenOfDarkness_filter takes nothing returns boolean
local integer id=GetUnitTypeId(GetFilterUnit())
local boolean ids=id!='h01O' and id!='n01L' and id!='n01M' and id!='u01P' and id!='u01Q'
return ids and GetUnitHealth(GetFilterUnit())>0 and not isUnitStruct(GetFilterUnit())and not isUnitHero(GetFilterUnit()) and not IsUnitIllusion(GetFilterUnit())
endfunction
function BurdenOfDarkness_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local unit killer=GetKillingUnit()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local boolexpr filter
local unit target
local integer monsterID='u01P'
local real range=400.00
local real time=1.00
if isUnitStruct(caster)then
set monsterID='u01Q'
endif
set bj_caster=caster
set filter=Condition(function BurdenOfDarkness_filter)
call GroupEnumUnitsInRange(g,x,y,range,filter)
set target=FirstOfGroup(g)
if target==null then
set target=killer
endif
if not isUnitStruct(target)and not isUnitHero(target)then
call SetUnitOwner(target,GetOwningPlayer(caster),true)
call TimedEffectTarget("Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl",target,"origin",time)
call TimedPause(target,time)
call TimedInvul(target,time)
call OwnerAfterTime(caster,target,time*0.9)
call ReplaceAfterTime(target,monsterID,time)
endif
set g=null
set filter=null
set killer=null
set caster=null
endfunction
function InitTrig_BurdenOfDarkness takes nothing returns nothing
set gg_trg_BurdenOfDarkness=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BurdenOfDarkness,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_BurdenOfDarkness,Condition(function BurdenOfDarkness_Conditions))
call TriggerAddAction(gg_trg_BurdenOfDarkness,function BurdenOfDarkness_Actions)
endfunction
function AttackOnTitan_Conditions takes nothing returns boolean
return GetUnitTypeId(GetTriggerUnit())=='h02N'
endfunction
function AttackOnTitan_Actions takes nothing returns nothing
local integer ID=GetSpellAbilityId()
local unit caster=GetTriggerUnit()
local integer playerID=GetPlayerId(GetOwningPlayer(caster))+1
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local boolean replace=false
local integer i=1
local integer array abilityID
local integer array titanID
local string array iconPATH
set abilityID[1]='A0E3'
set titanID[1]='H036'
set iconPATH[1]="ReplaceableTextures\\CommandButtons\\BTNRockGolem.blp"
set abilityID[2]='A0HE'
set titanID[2]='H03H'
set iconPATH[2]="ReplaceableTextures\\CommandButtons\\BTNCastle.blp"
loop
exitwhen i>2
if ID==abilityID[i]then
call MultiboardIconForAllies(Player(playerID-1),iconPATH[i],playerID,4)
call RemoveUnit(caster)
set udg_Hero[playerID]=CreateUnit(Player(playerID-1),titanID[i],x,y,0)
call SelectUnitForPlayerSingle(udg_Hero[playerID],Player(playerID-1))
call ShowUnit(udg_Visualisator[playerID],false)
if i==2 then
call UnitSpawner_start(udg_Hero[playerID],'h03J',10.00)
endif
set i=120
endif
set i=i+1
endloop
set caster=null
endfunction
function InitTrig_AttackOnTitan takes nothing returns nothing
set gg_trg_AttackOnTitan=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_AttackOnTitan,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gg_trg_AttackOnTitan,Condition(function AttackOnTitan_Conditions))
call TriggerAddAction(gg_trg_AttackOnTitan,function AttackOnTitan_Actions)
endfunction
function Opolchenie_Conditions takes nothing returns boolean
return IsUnitEnemy(GetTriggerUnit(),GetOwningPlayer(GetEventDamageSource()))and GetPlayerTechCount(GetOwningPlayer(GetTriggerUnit()),'R03S',true)>0
endfunction
function Opolchenie_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetHandleId(caster)
local real dmg=LoadReal(udg_Hash,id,StringHash("Opolchenie|Damage"))
local player p=GetOwningPlayer(caster)
local real Damage=GetEventDamage()
local real total_dmg=dmg+Damage
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer i=1
local integer max_foots=5
local real dmg_coef=500.00
if(total_dmg>=dmg_coef)then
set total_dmg=total_dmg-dmg_coef
call SetSoundPosition(gg_snd_HumanCallToArmsWhat1,x,y,0)
call SetSoundVolume(gg_snd_HumanCallToArmsWhat1,255)
call StartSound(gg_snd_HumanCallToArmsWhat1)
loop
exitwhen i>max_foots
call CreateUnit(p,'h02U',x,y,0)
set i=i+1
endloop
endif
call SaveReal(udg_Hash,id,StringHash("Opolchenie|Damage"),total_dmg)
set p=null
set caster=null
endfunction
function InitTrig_Opolchenie takes nothing returns nothing
set gg_trg_Opolchenie=CreateTrigger()
call TriggerAddCondition(gg_trg_Opolchenie,Condition(function Opolchenie_Conditions))
call TriggerAddAction(gg_trg_Opolchenie,function Opolchenie_Actions)
endfunction
function Marshal_Conditions takes nothing returns boolean
local boolean checkTypes=not IsUnitIllusion(GetKillingUnit())and not IsUnitIllusion(GetTriggerUnit())and not isUnitStruct(GetKillingUnit())and not isUnitHero(GetKillingUnit())and not isUnitSummon(GetKillingUnit())and not isUnitSummon(GetTriggerUnit())
local boolean checkLevels=GetUnitAbilityLevel(GetKillingUnit(),'A0BH')==0 and GetPlayerTechCount(GetOwningPlayer(GetKillingUnit()),'R037',true)>0
return isUnitEnemy(GetTriggerUnit(),GetKillingUnit())and checkTypes and checkLevels
endfunction
function Marshal_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local integer lvlDMG=GetUnitAbilityLevel(caster,'A0BF')
local integer lvlARM=GetUnitAbilityLevel(caster,'A0BG')
local integer lvlSPEED=GetUnitAbilityLevel(caster,'A0BH')
local boolean give=true
local effect eff
local effect e
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Levelup\\LevelupCaster.mdl",caster,"origin")
if(lvlDMG==0 and give==true)then
set give=false
set e=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",caster,"origin")
call SaveEffectHandle(udg_Hash,GetHandleId(caster),3,e)
call UnitAddAbility(caster,'A0BF')
call UnitMakeAbilityPermanent(caster,true,'A0BF')
endif
if(lvlARM==0 and give==true)then
set give=false
set e=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",caster,"chest")
call SaveEffectHandle(udg_Hash,GetHandleId(caster),4,e)
call UnitAddAbility(caster,'A0BG')
call UnitMakeAbilityPermanent(caster,true,'A0BG')
endif
if(lvlSPEED==0 and give==true)then
set give=false
set e=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",caster,"overhead")
call SaveEffectHandle(udg_Hash,GetHandleId(caster),5,e)
call UnitAddAbility(caster,'A0BH')
call UnitMakeAbilityPermanent(caster,true,'A0BH')
endif
call DestroyEffect(eff)
set e=null
set eff=null
set caster=null
endfunction
function InitTrig_Marshal takes nothing returns nothing
set gg_trg_Marshal=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Marshal,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Marshal,Condition(function Marshal_Conditions))
call TriggerAddAction(gg_trg_Marshal,function Marshal_Actions)
endfunction
function ITEM_BUG_conditions takes integer itemm returns boolean
local integer array items
local integer i=1
local integer max
set items[1]='I00V'
set items[2]='I00Y'
set items[3]='I00X'
set items[4]='I011'
set items[5]='I013'
set items[6]='I014'
set items[7]='I01Z'
set items[8]='I020'
set items[9]='I021'
set items[10]='I022'
set items[11]='I023'
set max=15
loop
exitwhen i>max
if(itemm==items[i])then
return true
endif
set i=i+1
endloop
return false
endfunction
function ITEM_BUG_delete takes nothing returns nothing
local item target=GetEnumItem()
local integer id=0
local real x=GetItemX(target)
local real y=GetItemY(target)
if(ITEM_BUG_conditions(GetItemTypeId(target)))then
call RemoveItem(target)
endif
set target=null
endfunction
function ITEM_BUG_Actions takes nothing returns nothing
call EnumItemsInRect(bj_mapInitialPlayableArea,null,function ITEM_BUG_delete)
endfunction
function InitTrig_ITEM_BUG takes nothing returns nothing
set gg_trg_ITEM_BUG=CreateTrigger()
call TriggerRegisterTimerEvent(gg_trg_ITEM_BUG,0.50,true)
call TriggerAddAction(gg_trg_ITEM_BUG,function ITEM_BUG_Actions)
endfunction
function ClondikeItemovv_Conditions takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R02O',GetOwningPlayer(GetTriggerUnit()))>0))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)!=true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)!=true))then
return false
endif
return true
endfunction
function GetRandomItemClondike takes nothing returns integer
local integer array items
local integer max
local integer i
set items[1]='I00V'
set items[2]='I00Y'
set items[3]='I00X'
set items[4]='I011'
set items[5]='I013'
set items[6]='I014'
set items[7]='I01Z'
set items[8]='I020'
set items[9]='I021'
set items[10]='I022'
set items[11]='I023'
set items[12]='I028'
set max=12
set i=GetRandomInt(1,max)
return items[i]
endfunction
function ClondikeItemovv_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer count=GetRandomInt(1,2)
call UnitAddAbility(caster,'A098')
call SetUnitAbilityLevel(caster,'A098',count)
loop
exitwhen count==0
call UnitAddItemById(caster,GetRandomItemClondike())
set count=count-1
endloop
set caster=null
endfunction
function InitTrig_ClondikeItemovv takes nothing returns nothing
set gg_trg_ClondikeItemovv=CreateTrigger()
call TriggerRegisterEnterRectSimple(gg_trg_ClondikeItemovv,bj_mapInitialPlayableArea)
call TriggerAddCondition(gg_trg_ClondikeItemovv,Condition(function ClondikeItemovv_Conditions))
call TriggerAddAction(gg_trg_ClondikeItemovv,function ClondikeItemovv_Actions)
endfunction
function GoldHordeIncome_Cond takes nothing returns boolean
return not isUnitStruct(GetFilterUnit())and isUnitAlive(GetFilterUnit())and not isUnitSummon(GetFilterUnit())
endfunction
function GoldHordeIncome_Actions takes nothing returns nothing
local boolexpr filter=Condition(function GoldHordeIncome_Cond)
local boolean hasCastle=false
local group g=CreateGroup()
local unit target=null
local integer count=0
local integer gd=0
local integer i=0
local string s=""
local integer gold=1
loop
exitwhen i>7
set count=0
set hasCastle=isPlayerHasCastle(Player(i))
if GetPlayerTechCount(Player(i),'R01R',true)==1 then
call GroupClear(g)
call GroupEnumUnitsOfPlayer(g,Player(i),filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set count=count+1
if not hasCastle then
if GetLocalPlayer()==Player(i)then
set s="+"+I2S(gold)+" gold"
call TextUp(s,target,11,0,255,0,60,96.00,2.00)
endif
endif
call GroupRemoveUnit(g,target)
endloop
set gd=count*gold
if hasCastle then
if GetLocalPlayer()==Player(i)then
set s="+"+I2S(gd)+" gold"
call TextUp(s,udg_Castle[i+1],11,0,255,0,60,96.00,2.00)
endif
endif
call SetPlayerState(Player(i),PLAYER_STATE_RESOURCE_GOLD,GetPlayerState(Player(i),PLAYER_STATE_RESOURCE_GOLD)+gd)
endif
set i=i+1
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set target=null
set filter=null
endfunction
function InitTrig_GoldHordeIncome takes nothing returns nothing
set gg_trg_GoldHordeIncome=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_GoldHordeIncome,45.00)
call TriggerAddAction(gg_trg_GoldHordeIncome,function GoldHordeIncome_Actions)
endfunction
function PussyLick_Actions takes nothing returns nothing
local integer i=0
local integer q=1
local real x
local real y
local real x1
local real y1
loop
exitwhen i>5
set x1=GetUnitX(udg_Castle[i+1])
set y1=GetUnitY(udg_Castle[i+1])
set x=x1+500*Cos(60*bj_DEGTORAD)
set y=y1+500*Sin(60*bj_DEGTORAD)
if(GetPlayerTechCount(Player(i),'R01P',true)==1 and udg_Castle[i+1]!=null)then
if(GetPlayerTechCount(Player(i),'R03V',true)==1)then
call CreateUnit(Player(i),'h02J',x,y,bj_UNIT_FACING)
else
call CreateUnit(Player(i),'h009',x,y,bj_UNIT_FACING)
endif
endif
set q=1
loop
exitwhen q>2
if(GetPlayerTechCount(Player(i),'R00F',true)==1 and udg_Castle[i+1]!=null)then
set x=GetRandomReal(x1-(1100/ 2),x1+(1100/ 2))
set y=GetRandomReal(y1-(1100/ 2),y1+(1100/ 2))
call CreateUnit(Player(i),'nglm',x,y,bj_UNIT_FACING)
endif
set q=q+1
endloop
set i=i+1
endloop
endfunction
function InitTrig_PussyLick takes nothing returns nothing
set gg_trg_PussyLick=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_PussyLick,60.00)
call TriggerAddAction(gg_trg_PussyLick,function PussyLick_Actions)
endfunction
function Illusia_Eblana_Conditions takes nothing returns boolean
return GetUnitAbilityLevel(GetTriggerUnit(),'A0GH')==0 and not isUnitHero(GetTriggerUnit())and not isUnitStruct(GetTriggerUnit())and not isUnitSummon(GetTriggerUnit())and GetPlayerTechCountSimple('R02J',GetOwningPlayer(GetKillingUnit()))>0 and not IsUnitIllusion(GetTriggerUnit())
endfunction
function Illusia_Eblana_Actions takes nothing returns nothing
local unit caster=GetKillingUnit()
local unit target=GetTriggerUnit()
local real x=GetUnitX(target)
local real y=GetUnitY(target)
local player p=GetOwningPlayer(caster)
local integer id=GetUnitTypeId(target)
local unit dami
local effect eff
local real time=15.00
set eff=AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl",target,"origin")
set dami=CreateUnit(p,id,x,y,bj_UNIT_FACING)
call SetUnitVertexColor(dami,150,150,255,150)
call UnitAddType(dami,UNIT_TYPE_SUMMONED)
call UnitApplyTimedLife(dami,'BLil',time)
call DestroyEffect(eff)
set eff=null
set p=null
set dami=null
set caster=null
set target=null
endfunction
function InitTrig_Illusia_Eblana takes nothing returns nothing
local trigger t=CreateTrigger()
local integer index
set index=0
loop
call TriggerRegisterPlayerUnitEvent(t,Player(index),EVENT_PLAYER_UNIT_DEATH,null)
set index=index+1
exitwhen index==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(t,Condition(function Illusia_Eblana_Conditions))
call TriggerAddAction(t,function Illusia_Eblana_Actions)
set t=null
endfunction
function Trig_Kapital_Func001Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R01S',GetEnumPlayer())==1))then
return false
endif
return true
endfunction
function Trig_Kapital_Func001A takes nothing returns nothing
if(Trig_Kapital_Func001Func001C())then
call AdjustPlayerStateBJ(2000,GetEnumPlayer(),PLAYER_STATE_RESOURCE_GOLD)
else
endif
endfunction
function Trig_Kapital_Actions takes nothing returns nothing
call ForForce(GetPlayersAll(),function Trig_Kapital_Func001A)
endfunction
function InitTrig_Kapital takes nothing returns nothing
set gg_trg_Kapital=CreateTrigger()
call TriggerRegisterTimerEventSingle(gg_trg_Kapital,1800.00)
call TriggerAddAction(gg_trg_Kapital,function Trig_Kapital_Actions)
endfunction
function BlockTalants_Conditions takes nothing returns boolean
return UnitTag(GetTriggerUnit())=="block_talants"
endfunction
function BlockTalants_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local integer grade=GetResearched()
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local integer unitID=0
local integer num=0
local integer i=0
local string text
if BANNED_RACES>0 then
set unitID='h03N'
else
set unitID='h001'
endif
call IssueImmediateOrderById(caster,0xD0008)
set BANNED_TALANTS=BANNED_TALANTS-1
if BANNED_TALANTS>=0 then
set text=SetTextColor("Подсказка:","hint")+" Забанен талант "+GetObjectName(grade)+" ["+I2S(BANNED_TALANTS)+"]"
set i=0
loop
exitwhen i>11
call SetPlayerTechMaxAllowed(Player(i),grade,0)
call DisplayTextToPlayer(Player(i),0,0,text)
set i=i+1
endloop
if CHOICE_REJIME=="rand" then
call RemoveTalantFromList(grade)
endif
endif
if BANNED_TALANTS==0 then
call RemoveUnit(caster)
set caster=CreateUnit(p,unitID,x,y,bj_UNIT_FACING)
call SelectUnitForPlayerSingle(caster,p)
set udg_TalantPicker[GetPlayerId(p)+1]=caster
if BANNED_RACES>0 then
call MessageToAll(SetTextColor("Подсказка:","hint")+" Теперь "+bj_ChoicePlayer+" должен забанить "+I2S(BANNED_RACES)+" рас.")
else
call MessageToAll(SetTextColor("Подсказка:","hint")+" Игра началась!")
call UnpauseAllUnits()
if CHOICE_REJIME=="rand" then
set i=0
loop
exitwhen i>5
if isPlayerActive(Player(i))then
set num=GetRandomTalant()
call SetPlayerTechResearched(Player(i),num,1)
call Talants_Give(udg_TalantPicker[i+1],num)
call TriggerSleepAction(0.00)
set num=GetRandomRace()
call Race_Give(udg_TalantPicker[i+1],num)
endif
set i=i+1
endloop
endif
endif
endif
set caster=null
endfunction
function InitTrig_BlockTalants takes nothing returns nothing
set gg_trg_BlockTalants=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_BlockTalants,EVENT_PLAYER_UNIT_RESEARCH_START)
call TriggerAddCondition(gg_trg_BlockTalants,Condition(function BlockTalants_Conditions))
call TriggerAddAction(gg_trg_BlockTalants,function BlockTalants_Actions)
endfunction
function ChangePages_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer casterID=GetUnitTypeId(caster)
local integer abilID=GetSpellAbilityId()
local integer index=0
local integer array replaceID
local integer array abilityID
local integer array pageID
set index=index+1
set abilityID[index]='A08D'
set replaceID[index]='h028'
set pageID[index]='h001'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h02B'
set pageID[index]='h028'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h001'
set pageID[index]='h02B'
set index=index+1
set abilityID[index]='A08E'
set replaceID[index]='h02A'
set pageID[index]='h001'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h001'
set pageID[index]='h02A'
set index=index+1
set abilityID[index]='A0BK'
set replaceID[index]='h029'
set pageID[index]='h001'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h001'
set pageID[index]='h029'
set index=index+1
set abilityID[index]='A055'
set replaceID[index]='h03W'
set pageID[index]='h001'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h001'
set pageID[index]='h03W'
set index=index+1
set abilityID[index]='A08D'
set replaceID[index]='h03O'
set pageID[index]='h01S'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h03P'
set pageID[index]='h03O'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h01S'
set pageID[index]='h03P'
set index=index+1
set abilityID[index]='A08E'
set replaceID[index]='h02C'
set pageID[index]='h01S'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h01S'
set pageID[index]='h02C'
set index=index+1
set abilityID[index]='A0BK'
set replaceID[index]='h027'
set pageID[index]='h01S'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h01S'
set pageID[index]='h027'
set index=index+1
set abilityID[index]='A055'
set replaceID[index]='h03V'
set pageID[index]='h01S'
set index=index+1
set abilityID[index]='A07S'
set replaceID[index]='h01S'
set pageID[index]='h03V'
loop
exitwhen index==0
if casterID==pageID[index]and abilID==abilityID[index]then
set caster=ReplaceUnitBJ(caster,replaceID[index],bj_UNIT_STATE_METHOD_RELATIVE)
call SelectUnitForPlayerSingle(caster,GetOwningPlayer(caster))
endif
set index=index-1
endloop
set caster=null
endfunction
function InitTrig_ChangePages takes nothing returns nothing
set gg_trg_ChangePages=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ChangePages,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddAction(gg_trg_ChangePages,function ChangePages_Actions)
endfunction
function Limit_Cond takes nothing returns boolean
return not isUnitStruct(GetFilterUnit())and isUnitAlive(GetFilterUnit())and not isUnitSummon(GetFilterUnit())and not isUnitHero(GetFilterUnit())and GetUnitTypeId(GetFilterUnit())!='nglm'
endfunction
function Rats_filter takes nothing returns boolean
return GetUnitTypeId(GetFilterUnit())=='h010' and GetUnitState(GetFilterUnit(),UNIT_STATE_LIFE)>0
endfunction
function Limit_Actions takes nothing returns nothing
local multiboarditem mbitem
local integer i=0
local integer units
local unit target
loop
exitwhen i>5
set units=0
call GroupClear(LimitGroup)
call GroupEnumUnitsOfPlayer(LimitGroup,Player(i),LimitFilter)
loop
set target=FirstOfGroup(LimitGroup)
exitwhen target==null
set units=units+1
call GroupRemoveUnit(LimitGroup,target)
endloop
set Units[i+1]=units
set mbitem=MultiboardGetItem(udg_MultiBoard,i+1,2)
call MultiboardSetItemValue(mbitem,I2S(Units[i+1]))
call MultiboardReleaseItem(mbitem)
set units=0
call GroupClear(LimitGroup)
call GroupEnumUnitsOfPlayer(LimitGroup,Player(i),RatsFilter)
loop
set target=FirstOfGroup(LimitGroup)
exitwhen target==null
set units=units+1
call GroupRemoveUnit(LimitGroup,target)
endloop
set Rats[i+1]=units
set i=i+1
endloop
set mbitem=null
set target=null
endfunction
function InitTrig_Limit takes nothing returns nothing
set gg_trg_Limit=CreateTrigger()
call TriggerRegisterTimerEvent(gg_trg_Limit,0.50,true)
call TriggerAddAction(gg_trg_Limit,function Limit_Actions)
set LimitFilter=Condition(function Limit_Cond)
set RatsFilter=Condition(function Rats_filter)
endfunction
function Trig_DalaranTowers_Func002C takes nothing returns boolean
if((GetUnitTypeId(GetTriggerUnit())=='n01K'))then
return true
endif
if((GetUnitTypeId(GetTriggerUnit())=='n01N'))then
return true
endif
if((GetUnitTypeId(GetTriggerUnit())=='n01O'))then
return true
endif
if((GetUnitTypeId(GetTriggerUnit())=='n01P'))then
return true
endif
if((GetUnitTypeId(GetTriggerUnit())=='n01Q'))then
return true
endif
return false
endfunction
function Trig_DalaranTowers_Conditions takes nothing returns boolean
if(not Trig_DalaranTowers_Func002C())then
return false
endif
return true
endfunction
function Trig_DalaranTowers_Func001Func001Func001001002 takes nothing returns boolean
return(GetUnitTypeId(GetFilterUnit())=='n01R')
endfunction
function Trig_DalaranTowers_Func001Func001Func001A takes nothing returns nothing
call KillUnit(GetEnumUnit())
endfunction
function Trig_DalaranTowers_Func001Func001Func006001002 takes nothing returns boolean
return(GetUnitTypeId(GetFilterUnit())=='n01R')
endfunction
function Trig_DalaranTowers_Func001Func001Func006A takes nothing returns nothing
call KillUnit(GetEnumUnit())
endfunction
function Trig_DalaranTowers_Func001Func001C takes nothing returns boolean
if(not(DistanceBetweenPoints(GetUnitLoc(GetTriggerUnit()),GetRectCenter(gg_rct_CreepsUp))<=100.00))then
return false
endif
return true
endfunction
function Trig_DalaranTowers_Func001C takes nothing returns boolean
if(not(GetPlayerTechCountSimple('R01O',GetOwningPlayer(GetKillingUnitBJ()))>0))then
return false
endif
return true
endfunction
function Trig_DalaranTowers_Actions takes nothing returns nothing
if(Trig_DalaranTowers_Func001C())then
if(Trig_DalaranTowers_Func001Func001C())then
call ForGroupBJ(GetUnitsInRectMatching(gg_rct_CreepsUp,Condition(function Trig_DalaranTowers_Func001Func001Func006001002)),function Trig_DalaranTowers_Func001Func001Func006A)
call CreateNUnitsAtLoc(1,'n01R',GetOwningPlayer(GetKillingUnitBJ()),GetRectCenter(gg_rct_UpMiniTower1),bj_UNIT_FACING)
call CreateNUnitsAtLoc(1,'n01R',GetOwningPlayer(GetKillingUnitBJ()),GetRectCenter(gg_rct_UpMiniTower2),bj_UNIT_FACING)
call CreateNUnitsAtLoc(1,'n01R',GetOwningPlayer(GetKillingUnitBJ()),GetRectCenter(gg_rct_UpMiniTower3),bj_UNIT_FACING)
call CreateNUnitsAtLoc(1,'n01R',GetOwningPlayer(GetKillingUnitBJ()),GetRectCenter(gg_rct_UpMiniTower4),bj_UNIT_FACING)
else
call ForGroupBJ(GetUnitsInRectMatching(gg_rct_CreepsDown,Condition(function Trig_DalaranTowers_Func001Func001Func001001002)),function Trig_DalaranTowers_Func001Func001Func001A)
call CreateNUnitsAtLoc(1,'n01R',GetOwningPlayer(GetKillingUnitBJ()),GetRectCenter(gg_rct_DownMiniTower1),bj_UNIT_FACING)
call CreateNUnitsAtLoc(1,'n01R',GetOwningPlayer(GetKillingUnitBJ()),GetRectCenter(gg_rct_DownMiniTower2),bj_UNIT_FACING)
call CreateNUnitsAtLoc(1,'n01R',GetOwningPlayer(GetKillingUnitBJ()),GetRectCenter(gg_rct_DownMiniTower3),bj_UNIT_FACING)
call CreateNUnitsAtLoc(1,'n01R',GetOwningPlayer(GetKillingUnitBJ()),GetRectCenter(gg_rct_DownMiniTower4),bj_UNIT_FACING)
endif
else
endif
endfunction
function InitTrig_DalaranTowers takes nothing returns nothing
set gg_trg_DalaranTowers=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_DalaranTowers,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_DalaranTowers,Condition(function Trig_DalaranTowers_Conditions))
call TriggerAddAction(gg_trg_DalaranTowers,function Trig_DalaranTowers_Actions)
endfunction
function Trig_MineInvul_Actions takes nothing returns nothing
call SetUnitInvulnerable(gg_unit_n01K_0013,true)
call SetUnitInvulnerable(gg_unit_n01K_0012,true)
call TriggerSleepAction(60.00)
call SetUnitInvulnerable(gg_unit_n01K_0013,false)
call SetUnitInvulnerable(gg_unit_n01K_0012,false)
endfunction
function InitTrig_MineInvul takes nothing returns nothing
set gg_trg_MineInvul=CreateTrigger()
call TriggerRegisterTimerEventSingle(gg_trg_MineInvul,0.00)
call TriggerAddAction(gg_trg_MineInvul,function Trig_MineInvul_Actions)
endfunction
function Mine_Conditions takes nothing returns boolean
local integer id=GetUnitTypeId(GetTriggerUnit())
return id=='n01K' or id=='n01N' or id=='n01O' or id=='n01P' or id=='n01Q' or id=='nfoh'
endfunction
function Mine_filter takes nothing returns boolean
return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(bj_caster))==true
endfunction
function Mine_Actions takes nothing returns nothing
local boolexpr filter=Condition(function Mine_filter)
local unit caster=GetTriggerUnit()
local unit killer=GetKillingUnit()
local player p=GetOwningPlayer(killer)
local player pp=GetOwningPlayer(caster)
local integer id=GetUnitTypeId(caster)
local integer curse_lvl_caster=GetPlayerTechCount(pp,'R03M',true)
local integer curse_lvl_killer=GetPlayerTechCount(p,'R03M',true)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local group g=CreateGroup()
local effect array eff
local integer i=1
local integer gold
local unit target
local real dmg
local real x1
local real y1
local real eff_count=24
local real range=700.00
local real angle=360/ eff_count
local real hp_percent=0.10*curse_lvl_caster
local real gold_percent=0.05+(0.05*curse_lvl_caster)
if(killer==null)then
set p=Player(15)
endif
if curse_lvl_caster>curse_lvl_killer then
set gold=R2I(gold_percent*GetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD))
call AddPlayerState(pp,PLAYER_STATE_RESOURCE_GOLD,PLAYER_STATE_RESOURCE_GOLD,gold)
call AddPlayerState(p,PLAYER_STATE_RESOURCE_GOLD,PLAYER_STATE_RESOURCE_GOLD,-gold)
loop
exitwhen i>eff_count
set x1=x+range*Cos((angle*i)*bj_DEGTORAD)
set y1=y+range*Sin((angle*i)*bj_DEGTORAD)
set eff[i]=AddSpecialEffect("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",x1,y1)
set i=i+1
endloop
set bj_caster=caster
call GroupEnumUnitsInRange(g,x,y,range,filter)
loop
set target=FirstOfGroup(g)
exitwhen target==null
set dmg=GetUnitState(target,UNIT_STATE_MAX_LIFE)*hp_percent
call MagDamage(caster,target,dmg)
call GroupRemoveUnit(g,target)
endloop
endif
call RemoveUnit(caster)
set caster=CreateUnit(p,id,x,y,270)
call TextUp(GetPlayerName(p),caster,13,0,255,0,0,96.00,2.00)
call SetUnitInvulnerable(caster,true)
call TriggerSleepAction(1.00)
call SetUnitInvulnerable(caster,false)
set i=1
loop
exitwhen i>eff_count
call DestroyEffect(eff[i])
set eff[i]=null
set i=i+1
endloop
call DestroyGroup(g)
call DestroyBoolExpr(filter)
set g=null
set p=null
set pp=null
set filter=null
set target=null
set caster=null
set killer=null
endfunction
function InitTrig_Mine takes nothing returns nothing
set gg_trg_Mine=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_Mine,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_Mine,Condition(function Mine_Conditions))
call TriggerAddAction(gg_trg_Mine,function Mine_Actions)
endfunction
function GradesScore_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer i=GetPlayerId(GetOwningPlayer(caster))+1
if(GetUnitTypeId(caster)!='h02V')then
set GradeScore[i]=GradeScore[i]+1
endif
endfunction
function InitTrig_GradesScore takes nothing returns nothing
set gg_trg_GradesScore=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_GradesScore,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddAction(gg_trg_GradesScore,function GradesScore_Actions)
endfunction
function PowerCounter_Actions takes nothing returns nothing
local multiboarditem mbitem
local integer score=0
local integer i=1
local integer UnitsScore=5
local integer HeroScore=250
local integer HeroLvlScore=100
local integer GradesScore=150
local integer CastleScore=1000
loop
exitwhen i>6
set score=0
set score=score+(Units[i]*UnitsScore)
if(udg_Hero[i]!=null)then
set score=score+HeroScore
set score=score+(GetHeroLevel(udg_Hero[i])*HeroLvlScore)
endif
if(udg_Castle[i]!=null)then
set score=score+CastleScore
endif
set score=score+((GradeScore[i]-1)*GradesScore)
if(score<0)then
set score=0
endif
set PlayerPower[i]=score
set mbitem=MultiboardGetItem(udg_MultiBoard,i,5)
call MultiboardSetItemValue(mbitem,I2S(score))
call MultiboardReleaseItem(mbitem)
set mbitem=MultiboardGetItem(udg_MultiBoard,i,6)
call MultiboardSetItemValue(mbitem,R2SW(damage[i],0,2))
call MultiboardReleaseItem(mbitem)
set i=i+1
endloop
set mbitem=null
endfunction
function InitTrig_PowerCounter takes nothing returns nothing
local integer i=0
set gg_trg_PowerCounter=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_PowerCounter,0.75)
call TriggerAddAction(gg_trg_PowerCounter,function PowerCounter_Actions)
loop
exitwhen i>5
set PlayerPower[i+1]=0
set i=i+1
endloop
endfunction
function Time_Actions takes nothing returns nothing
local string Sec
local string Min
local string Hour
if(udg_TimeSecond!=59)then
set udg_TimeSecond=(udg_TimeSecond+1)
else
set udg_TimeSecond=0
if(udg_TimeMinute!=59)then
set udg_TimeMinute=(udg_TimeMinute+1)
else
set udg_TimeMinute=0
set udg_TimeHours=(udg_TimeHours+1)
endif
endif
set Sec=I2S(udg_TimeSecond)
if(udg_TimeSecond<10)then
set Sec="0"+I2S(udg_TimeSecond)
endif
set Min=I2S(udg_TimeMinute)
if(udg_TimeMinute<10)then
set Min="0"+I2S(udg_TimeMinute)
endif
set Hour=I2S(udg_TimeHours)
if(udg_TimeHours<10)then
set Hour="0"+I2S(udg_TimeHours)
endif
call MultiboardSetTitleText(udg_MultiBoard,("Cursed War "+Version+"    ["+Hour+":"+Min+":"+Sec+"]"))
call MultiboardDisplay(udg_MultiBoard,true)
endfunction
function InitTrig_Time takes nothing returns nothing
local trigger t=CreateTrigger()
call TriggerRegisterTimerEvent(t,1.00,true)
call TriggerAddAction(t,function Time_Actions)
set t=null
endfunction
function Trig_TableCreate_Actions takes nothing returns nothing
call CreateMultiboardBJ(7,7,"CursedWar")
set udg_MultiBoard=GetLastCreatedMultiboard()
call MultiboardSetItemStyleBJ(GetLastCreatedMultiboard(),0,0,true,false)
call MultiboardSetItemStyleBJ(GetLastCreatedMultiboard(),4,0,false,true)
call MultiboardSetItemStyleBJ(GetLastCreatedMultiboard(),4,1,true,false)
call MultiboardSetItemStyleBJ(GetLastCreatedMultiboard(),5,0,false,true)
call MultiboardSetItemStyleBJ(GetLastCreatedMultiboard(),5,1,true,false)
call MultiboardSetItemWidthBJ(GetLastCreatedMultiboard(),1,0,7.50)
call MultiboardSetItemWidthBJ(GetLastCreatedMultiboard(),2,0,5.00)
call MultiboardSetItemWidthBJ(GetLastCreatedMultiboard(),3,0,5.00)
call MultiboardSetItemWidthBJ(GetLastCreatedMultiboard(),4,0,5.00)
call MultiboardSetItemWidthBJ(GetLastCreatedMultiboard(),5,0,5.00)
call MultiboardSetItemWidthBJ(GetLastCreatedMultiboard(),6,0,5.00)
call MultiboardSetItemWidthBJ(GetLastCreatedMultiboard(),7,0,5.00)
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),1,1,"Игроки:")
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),2,1,"Убито:")
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),3,1,"Войск:")
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),4,1,"Талант:")
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),5,1,"Раса:")
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),6,1,"Мощь:")
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),7,1,"Нанесено:")
set bj_forLoopAIndex=2
set bj_forLoopAIndexEnd=7
loop
exitwhen bj_forLoopAIndex>bj_forLoopAIndexEnd
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),1,GetForLoopIndexA(),GetPlayerName(ConvertedPlayer((GetForLoopIndexA()-1))))
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),2,GetForLoopIndexA(),I2S(R2I((udg_KillBonus[(GetForLoopIndexA()-1)]*1000.00))))
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),3,GetForLoopIndexA(),I2S(0))
call MultiboardSetItemIconBJ(GetLastCreatedMultiboard(),4,GetForLoopIndexA(),"ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp")
call MultiboardSetItemIconBJ(GetLastCreatedMultiboard(),5,GetForLoopIndexA(),"ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp")
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),6,GetForLoopIndexA(),I2S(0))
call MultiboardSetItemValueBJ(GetLastCreatedMultiboard(),7,GetForLoopIndexA(),I2S(0))
call MultiboardSetItemColorBJ(GetLastCreatedMultiboard(),1,GetForLoopIndexA(),0.00,100.00,0.00,0)
set bj_forLoopAIndex=bj_forLoopAIndex+1
endloop
endfunction
function InitTrig_TableCreate takes nothing returns nothing
set gg_trg_TableCreate=CreateTrigger()
call TriggerRegisterTimerEventSingle(gg_trg_TableCreate,0.00)
call TriggerAddAction(gg_trg_TableCreate,function Trig_TableCreate_Actions)
endfunction
function BlockAbilities_Actions takes nothing returns nothing
local integer array abil
local integer index=0
local integer ind=1
set abil[1]='A0IP'
set abil[2]='A0IX'
set abil[3]='A09S'
set abil[4]='A09L'
set abil[5]='A0JP'
set abil[6]='A0JU'
loop
exitwhen index>11
set ind=1
loop
exitwhen abil[ind]==0
call SetPlayerAbilityAvailable(Player(index),abil[ind],false)
set ind=ind+1
endloop
set index=index+1
endloop
call SetRandomSeed(GetRandomInt(-1000000,1000000))
endfunction
function InitTrig_BlockAbilities takes nothing returns nothing
set gg_trg_BlockAbilities=CreateTrigger()
call TriggerRegisterTimerEventSingle(gg_trg_BlockAbilities,0.01)
call TriggerAddAction(gg_trg_BlockAbilities,function BlockAbilities_Actions)
endfunction
function CastleUnlockUltimate_timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local integer id=0
loop
exitwhen id>11
call SetPlayerTechResearched(Player(id),'R04L',1)
set id=id+1
endloop
call DestroyTimer(t)
set t=null
endfunction
function CastleUnlockUltimate takes nothing returns nothing
call PingMinimap(GetRectCenterX(gg_rct_CreepsUp),GetRectCenterY(gg_rct_CreepsUp),60.00)
call PingMinimap(GetRectCenterX(gg_rct_CreepsDown),GetRectCenterY(gg_rct_CreepsDown),60.00)
call TimerStart(CreateTimer(),CastleUnlockUltimate_time,false,function CastleUnlockUltimate_timer)
endfunction
function InitTrig_CastleUltimateUnlock takes nothing returns nothing
set gg_trg_CastleUltimateUnlock=CreateTrigger()
call TriggerRegisterTimerEventSingle(gg_trg_CastleUltimateUnlock,0.01)
call TriggerAddAction(gg_trg_CastleUltimateUnlock,function CastleUnlockUltimate)
endfunction
function UnitPreload_Actions takes nothing returns nothing
local integer index=0
local unit preload
set preload=CreateUnit(Player(11),'h01Q',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02X',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02E',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h023',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00H',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01U',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'e000',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01B',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h005',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02I',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01R',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'e006',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00M',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00P',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01F',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01V',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h020',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h011',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'u011',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01T',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01P',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h022',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00N',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'n002',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'n01D',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'n01R',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h004',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h006',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02T',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'u01C',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h013',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00U',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02W',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'u00F',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02N',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01C',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'u01F',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00A',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h028',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02B',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'u015',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01E',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'u01A',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02A',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01G',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h000',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00Q',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h029',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h002',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02Z',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h003',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02F',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00V',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h02C',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h01S',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h027',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h001',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'u01E',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h024',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h007',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'u00U',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h03F',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'n026',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H00B',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'O001',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'O00C',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'E001',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H01Z',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H016',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H036',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H02Y',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'E002',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'U01H',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'U012',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'U00T',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H01L',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'U01N',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'O00D',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'O007',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H00O',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H008',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'U017',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H034',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H00R',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'E004',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H02R',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'U00E',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H025',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'H017',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00F',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00C',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00G',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00E',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h00D',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h03B',0,0,0)
call RemoveUnit(preload)
set preload=CreateUnit(Player(11),'h03C',0,0,0)
call RemoveUnit(preload)
loop
exitwhen index>11
call CreateUnit(Player(index),'h03G',0,0,0)
set index=index+1
endloop
set preload=null
endfunction
function InitTrig_UnitPreload takes nothing returns nothing
set gg_trg_UnitPreload=CreateTrigger()
call TriggerAddAction(gg_trg_UnitPreload,function UnitPreload_Actions)
endfunction
function DamageTaken_Conditions takes nothing returns boolean
return LoadBoolean(udg_Hash,GetHandleId(GetEventDamageSource()),StringHash("DamageTaken|Go"))==true
endfunction
function DemonPowerWave takes unit caster,real angle returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A0BN')
local real damageCoef=0.15*lvl
local real l__damage=I2R(GetHeroAgi(caster,true))*damageCoef
local real distance=500.00
local string path="BlueWave.mdx"
local real speed=30.00
local real range=75.00
call DamageWave(caster,l__damage,range,speed,distance,angle,path)
endfunction
function WindwalkWave takes unit caster,real angle returns nothing
local integer lvl=GetUnitAbilityLevel(caster,'A0BL')
local real l__damage=20.00*lvl
local real distance=500.00
local string path="BlueWave.mdx"
local real speed=30.00
local real range=75.00
call DamageWave(caster,l__damage,range,speed,distance,angle,path)
endfunction
function DamageEvents takes unit caster,unit target,real l__damage returns real
local boolean fromHand=isDamageFromHand()
local integer lvl=0
if isDamageFromWindwalk()and GetUnitAbilityLevel(caster,'A0BL')>0 then
call WindwalkWave(caster,GetUnitFacing(caster))
if isPlayerHasSoloHero(Owner(caster))then
call WindwalkWave(caster,GetUnitFacing(caster)-30.00)
call WindwalkWave(caster,GetUnitFacing(caster)+30.00)
endif
endif
if fromHand and GetUnitAbilityLevel(caster,'A0BN')>0 then
set lvl=GetUnitAbilityLevel(caster,'A0BN')
call DemonPowerWave(caster,GetUnitFacing(caster))
if isUnitHero(target)then
call MagDamage(caster,target,l__damage*(0.25*lvl))
set l__damage=l__damage*(1.00+(0.25*lvl))
endif
endif
if fromHand and GetUnitAbilityLevel(caster,'A0CD')>0 then
set lvl=GetUnitAbilityLevel(caster,'A0CD')
if isUnitHero(target)then
call MagDamage(caster,target,l__damage*(0.12*lvl))
set l__damage=l__damage*(1.00+(0.12*lvl))
endif
endif
if fromHand and PirateNatureHero_Cond(caster,target)then
call PirateNatureHero_Act(caster,target)
endif
return l__damage
endfunction
function DamageCounter takes unit caster,unit target,real dmg returns real
local integer caster_id=GetHandleId(caster)
local integer target_id=GetHandleId(target)
local string caster_tag=UnitTag(caster)
local string target_tag=UnitTag(target)
local real x1=GetUnitX(target)
local real y1=GetUnitY(target)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local real dist=PointsDistance(x,y,x1,y1)
local boolean Pricel_go=LoadBoolean(udg_Hash,target_id,StringHash("Pricel"+I2S(caster_id)))
local integer Pricel_lvl=GetUnitAbilityLevel(caster,'A0EE')
local real Pricel_dist_coef=100.00
local real Pricel_lvl_coef=0.02
local real Pricel_dmg=dmg*(R2I(dist/ Pricel_dist_coef)*(Pricel_lvl_coef*Pricel_lvl))
local boolean Xarcha_go=LoadBoolean(udg_Hash,target_id,StringHash("Xarcha"+I2S(caster_id)))
local integer Xarcha_lvl=GetUnitAbilityLevel(caster,'A0BC')
local real Xarcha_dmg=0.15*Xarcha_lvl
local integer MagickAmuletLvl=GetUnitAbilityLevel(caster,'B01W')
local real MagickAmuletBuff=1.00
if(Pricel_lvl>0 and Pricel_go==true)then
call SaveBoolean(udg_Hash,target_id,StringHash("Pricel"+I2S(caster_id)),false)
call MagDamage(caster,target,Pricel_dmg)
set dmg=dmg+Pricel_dmg
endif
if(Xarcha_lvl>0 and Xarcha_go==true)then
call SaveBoolean(udg_Hash,target_id,StringHash("Xarcha"+I2S(caster_id)),false)
call MagDamage(caster,target,dmg*Xarcha_dmg)
set dmg=dmg+(dmg*Xarcha_dmg)
endif
if MagickAmuletLvl>0 and target_tag=="summon" then
call MagDamage(caster,target,dmg*MagickAmuletBuff)
set dmg=dmg+(dmg*MagickAmuletBuff)
endif
return dmg
endfunction
function DamageTaken_Actions takes nothing returns nothing
local unit caster=GetEventDamageSource()
local unit target=GetTriggerUnit()
local player p=GetOwningPlayer(caster)
local integer i=GetPlayerId(p)+1
local real dmg=GetEventDamage()
local string s=I2S(R2I(dmg))
local real size=8
local real TimeLife=0.75
local string Color="|cff9db9eb"
local real dmg_coef=1.00
local real size_coef=0.015
local real total_size=size+(R2I(dmg/ dmg_coef)*size_coef)
if(GetPlayerTechCount(p,'R03T',true)==1)then
set Color="|c0000ff00"
endif
call SaveBoolean(udg_Hash,GetHandleId(caster),StringHash("DamageTaken|Go"),false)
set dmg=DamageEvents(caster,target,dmg)
set dmg=DamageCounter(caster,target,dmg)
set total_size=size+(R2I(dmg/ dmg_coef)*size_coef)
call SaveBoolean(udg_Hash,GetHandleId(caster),StringHash("DamageTaken|Go"),true)
set s=Color+I2S(R2I(dmg))+"|r"
if(dmg>1 and dmg<9999)then
call TextUpRand(s,target,total_size,255,255,255,-60,60.00,TimeLife)
set damage[i]=damage[i]+dmg
endif
set p=null
set target=null
set caster=null
endfunction
function InitTrig_DamageTaken takes nothing returns nothing
set gg_trg_DamageTaken=CreateTrigger()
call TriggerAddAction(gg_trg_DamageTaken,function DamageTaken_Actions)
call TriggerAddCondition(gg_trg_DamageTaken,Condition(function DamageTaken_Conditions))
endfunction
function UNITS_ON_MAP_holy_aura takes nothing returns boolean
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)!=true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)!=true))then
return false
endif
if(not(GetPlayerTechCountSimple('R02Q',GetOwningPlayer(GetTriggerUnit()))>0))then
return false
endif
return true
endfunction
function UNITS_ON_MAP takes nothing returns nothing
local unit caster=GetEnumUnit()
local integer id=GetHandleId(caster)
if(UNITS_ON_MAP_holy_aura())then
call TriggerRegisterUnitStateEvent(gg_trg_HEAVEN_AURA,caster,UNIT_STATE_LIFE,LESS_THAN,0.40)
endif
call TriggerRegisterUnitEvent(gg_trg_NIGHT_AURA,caster,EVENT_UNIT_DAMAGED)
call SaveBoolean(udg_Hash,GetHandleId(caster),1,true)
call TriggerRegisterUnitEvent(gg_trg_KRIT_AURA,caster,EVENT_UNIT_DAMAGED)
call SaveBoolean(udg_Hash,GetHandleId(caster),2,true)
call TriggerRegisterUnitEvent(gg_trg_MagicSnaryads,caster,EVENT_UNIT_DAMAGED)
call TriggerRegisterUnitEvent(gg_trg_MeshokDruida,caster,EVENT_UNIT_DAMAGED)
call SaveBoolean(udg_Hash,GetHandleId(caster),4,true)
call TriggerRegisterUnitEvent(gg_trg_DamageTaken,caster,EVENT_UNIT_DAMAGED)
call SaveBoolean(udg_Hash,GetHandleId(caster),StringHash("DamageTaken|Go"),true)
call TriggerRegisterUnitEvent(gg_trg_SheepKaptainDmg,caster,EVENT_UNIT_DAMAGED)
call TriggerRegisterUnitEvent(gg_trg_Opolchenie,caster,EVENT_UNIT_DAMAGED)
if(IsUnitType(caster,UNIT_TYPE_HERO)==true)then
call TriggerRegisterUnitEvent(gg_trg_AmuletElyni,caster,EVENT_UNIT_DAMAGED)
endif
set caster=null
endfunction
function UNITS_ON_MAP_Actions takes nothing returns nothing
call ForGroupBJ(GetUnitsInRectAll(GetPlayableMapRect()),function UNITS_ON_MAP)
endfunction
function InitTrig_UNITS_ON_MAP takes nothing returns nothing
set gg_trg_UNITS_ON_MAP=CreateTrigger()
call TriggerAddAction(gg_trg_UNITS_ON_MAP,function UNITS_ON_MAP_Actions)
endfunction
function UNITS_ENTER_MAP_holy_aura takes nothing returns boolean
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_SUMMONED)!=true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)!=true))then
return false
endif
if(not(IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)!=true))then
return false
endif
if(not(GetPlayerTechCountSimple('R02Q',GetOwningPlayer(GetTriggerUnit()))>0))then
return false
endif
return true
endfunction
function UNITS_ENTER_MAP_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetHandleId(caster)
if(UNITS_ENTER_MAP_holy_aura())then
call TriggerRegisterUnitStateEvent(gg_trg_HEAVEN_AURA,caster,UNIT_STATE_LIFE,LESS_THAN,0.40)
endif
call TriggerRegisterUnitEvent(gg_trg_NIGHT_AURA,caster,EVENT_UNIT_DAMAGED)
call SaveBoolean(udg_Hash,GetHandleId(caster),1,true)
call TriggerRegisterUnitEvent(gg_trg_KRIT_AURA,caster,EVENT_UNIT_DAMAGED)
call SaveBoolean(udg_Hash,GetHandleId(caster),2,true)
call TriggerRegisterUnitEvent(gg_trg_MagicSnaryads,caster,EVENT_UNIT_DAMAGED)
if(IsUnitType(caster,UNIT_TYPE_SUMMONED)==true)then
call TriggerRegisterUnitEvent(gg_trg_MeshokDruida,caster,EVENT_UNIT_DAMAGED)
call SaveBoolean(udg_Hash,GetHandleId(caster),4,true)
endif
call TriggerRegisterUnitEvent(gg_trg_DamageTaken,caster,EVENT_UNIT_DAMAGED)
call SaveBoolean(udg_Hash,GetHandleId(caster),StringHash("DamageTaken|Go"),true)
call TriggerRegisterUnitEvent(gg_trg_SheepKaptainDmg,caster,EVENT_UNIT_DAMAGED)
if(IsUnitType(caster,UNIT_TYPE_STRUCTURE)==true)then
call TriggerRegisterUnitEvent(gg_trg_Opolchenie,caster,EVENT_UNIT_DAMAGED)
endif
if(IsUnitType(caster,UNIT_TYPE_STRUCTURE)==true)then
call TriggerRegisterUnitEvent(gg_trg_BattleBrigade,caster,EVENT_UNIT_DAMAGED)
endif
if(IsUnitType(caster,UNIT_TYPE_HERO)==true)then
call TriggerRegisterUnitEvent(gg_trg_AmuletElyni,caster,EVENT_UNIT_DAMAGED)
endif
if not isUnitStruct(caster)then
call TriggerRegisterUnitEvent(gg_trg_PancirWithSpikes,caster,EVENT_UNIT_DAMAGED)
endif
set caster=null
endfunction
function InitTrig_UNITS_ENTER_MAP takes nothing returns nothing
set gg_trg_UNITS_ENTER_MAP=CreateTrigger()
call TriggerRegisterEnterRectSimple(gg_trg_UNITS_ENTER_MAP,bj_mapInitialPlayableArea)
call TriggerAddAction(gg_trg_UNITS_ENTER_MAP,function UNITS_ENTER_MAP_Actions)
endfunction
function Trig_Discord_Actions takes nothing returns nothing
call DisplayTextToForce(GetPlayersAll(),"|cffffcc90Заходите на наш discord сервер - |r|cffffcc00discord.gg/naGkzRN|r|cffffcc90, чтобы получать самые свежие новости об обновлениях!|r")
endfunction
function InitTrig_Discord takes nothing returns nothing
set gg_trg_Discord=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(gg_trg_Discord,60.00)
call TriggerAddAction(gg_trg_Discord,function Trig_Discord_Actions)
endfunction
function Trig_SS_Conditions takes nothing returns boolean
local integer id=GetSpellAbilityId()
return id=='A0EN' or id=='A0AJ' or id=='A000' or id=='A05W' or id=='A05V'
endfunction
function Trig_SS_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local player owner=GetOwningPlayer(caster)
local integer id=GetSpellAbilityId()
if GetPlayerTechCountSimple('R01T',owner)==0 then
call UnitRemoveAbility(caster,id)
endif
set caster=null
endfunction
function InitTrig_SS takes nothing returns nothing
set gg_trg_SS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_SS,EVENT_PLAYER_UNIT_SPELL_FINISH)
call TriggerAddCondition(gg_trg_SS,Condition(function Trig_SS_Conditions))
call TriggerAddAction(gg_trg_SS,function Trig_SS_Actions)
endfunction
function Trig_HeroGrade_Conditions takes nothing returns boolean
if(not(GetResearched()=='R00U'))then
return false
endif
return true
endfunction
function Trig_HeroGrade_Actions takes nothing returns nothing
set udg_HeroResTime[GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))]=(udg_HeroResTime[GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))]-20.00)
endfunction
function InitTrig_HeroGrade takes nothing returns nothing
set gg_trg_HeroGrade=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_HeroGrade,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_HeroGrade,Condition(function Trig_HeroGrade_Conditions))
call TriggerAddAction(gg_trg_HeroGrade,function Trig_HeroGrade_Actions)
endfunction
function Trig_TimeGrade_Func002C takes nothing returns boolean
if((GetResearched()=='R005'))then
return true
endif
if((GetResearched()=='R00K'))then
return true
endif
if((GetResearched()=='R01K'))then
return true
endif
if((GetResearched()=='R02V'))then
return true
endif
if((GetResearched()=='R041'))then
return true
endif
return false
endfunction
function Trig_TimeGrade_Conditions takes nothing returns boolean
if(not Trig_TimeGrade_Func002C())then
return false
endif
return true
endfunction
function Trig_TimeGrade_Actions takes nothing returns nothing
set udg_SpawnTime[GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))]=(udg_SpawnTime[GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))]-0.75)
endfunction
function InitTrig_TimeGrade takes nothing returns nothing
set gg_trg_TimeGrade=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_TimeGrade,EVENT_PLAYER_UNIT_RESEARCH_FINISH)
call TriggerAddCondition(gg_trg_TimeGrade,Condition(function Trig_TimeGrade_Conditions))
call TriggerAddAction(gg_trg_TimeGrade,function Trig_TimeGrade_Actions)
endfunction
function UnitDye_Conditions takes nothing returns boolean
return IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO)!=true
endfunction
function UnitDye_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local integer id=GetHandleId(caster)
local real x=GetUnitX(caster)
local real y=GetUnitY(caster)
local multiboarditem mbitem
local integer i=1
local string val
local effect eff
local real delete_time=65.00
set eff=LoadEffectHandle(udg_Hash,GetHandleId(caster),3)
call DestroyEffect(eff)
set eff=LoadEffectHandle(udg_Hash,GetHandleId(caster),4)
call DestroyEffect(eff)
set eff=LoadEffectHandle(udg_Hash,GetHandleId(caster),5)
call DestroyEffect(eff)
loop
exitwhen i>7
set val=I2S(R2I((udg_KillBonus[i]*1000.00)))
set mbitem=MultiboardGetItem(udg_MultiBoard,i,1)
call MultiboardSetItemValue(mbitem,val)
call MultiboardReleaseItem(mbitem)
set i=i+1
endloop
if isUnitSummon(caster)then
set delete_time=0.00
endif
if GetUnitAbilityLevel(caster,'A0DQ')>0 then
set delete_time=1.00
endif
if delete_time>0.00 then
call TriggerSleepAction(delete_time)
endif
if(IsUnitType(caster,UNIT_TYPE_STRUCTURE)!=true and GetUnitAbilityLevel(caster,'A0DQ')==0)then
if IsUnitIllusion(caster)then
set eff=AddSpecialEffect("Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl",x,y)
elseif isUnitSummon(caster)then
set eff=AddSpecialEffect("Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl",x,y)
endif
call DestroyEffect(eff)
endif
if(GetUnitState(caster,UNIT_STATE_LIFE)<=0)then
if(GetUnitAbilityLevel(caster,'A098')>0)then
call RemoveItem(UnitItemInSlot(caster,0))
endif
call RemoveUnit(caster)
endif
set eff=null
set mbitem=null
set caster=null
endfunction
function InitTrig_UnitDye takes nothing returns nothing
set gg_trg_UnitDye=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_UnitDye,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(gg_trg_UnitDye,Condition(function UnitDye_Conditions))
call TriggerAddAction(gg_trg_UnitDye,function UnitDye_Actions)
endfunction
function Trig_Cam_Actions takes nothing returns nothing
call SetCameraFieldForPlayer(GetTriggerPlayer(),CAMERA_FIELD_TARGET_DISTANCE,S2R(SubStringBJ(GetEventPlayerChatString(),7,10)),1.00)
endfunction
function InitTrig_Cam takes nothing returns nothing
set gg_trg_Cam=CreateTrigger()
call TriggerRegisterPlayerChatEvent(gg_trg_Cam,Player(0),"-zoom",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Cam,Player(1),"-zoom",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Cam,Player(2),"-zoom",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Cam,Player(3),"-zoom",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Cam,Player(4),"-zoom",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Cam,Player(5),"-zoom",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Cam,Player(6),"-zoom",false)
call TriggerRegisterPlayerChatEvent(gg_trg_Cam,Player(7),"-zoom",false)
call TriggerAddAction(gg_trg_Cam,function Trig_Cam_Actions)
endfunction
function ItemCollect_Actions takes nothing returns nothing
local unit caster=GetTriggerUnit()
local item Item=GetManipulatedItem()
local player p=GetOwningPlayer(caster)
local integer id=GetItemTypeId(Item)
local integer i=0
local item ITEM
call SetItemPlayer(Item,p,false)
set p=null
set ITEM=null
set Item=null
set caster=null
endfunction
function InitTrig_ItemCollect takes nothing returns nothing
set gg_trg_ItemCollect=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gg_trg_ItemCollect,EVENT_PLAYER_UNIT_PICKUP_ITEM)
call TriggerAddAction(gg_trg_ItemCollect,function ItemCollect_Actions)
endfunction
function Trig___________________________u_Func031A takes nothing returns nothing
call SetPlayerTechMaxAllowedSwap('e005',15,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('h01I',15,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('n00W',15,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('n017',15,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('n00M',12,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('n00O',12,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('n016',12,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('n00X',12,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('h01J',8,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('n00P',8,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('o008',8,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('u00Q',8,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('o009',5,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('u00P',5,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('h01K',5,GetEnumPlayer())
call SetPlayerTechMaxAllowedSwap('n00Q',5,GetEnumPlayer())
call AdjustPlayerStateBJ((stand_tree),GetEnumPlayer(),PLAYER_STATE_RESOURCE_LUMBER)
call SetPlayerAbilityAvailableBJ(false,'A00P',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A0HV',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A0DN',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A0H5',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A0DY',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A0HS',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A0I1',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A0IO',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A07J',GetEnumPlayer())
call SetPlayerAbilityAvailableBJ(false,'A022',GetEnumPlayer())
call CreateFogModifierRectBJ(true,GetEnumPlayer(),FOG_OF_WAR_VISIBLE,gg_rct_MID)
call SetCameraFieldForPlayer(GetEnumPlayer(),CAMERA_FIELD_TARGET_DISTANCE,2700.00,0)
endfunction
function Trig___________________________u_Actions takes nothing returns nothing
set udg_Hash=InitHashtable()
set udg_TalantPicker[1]=gg_unit_h001_0017
set udg_TalantPicker[2]=gg_unit_h001_0018
set udg_TalantPicker[3]=gg_unit_h001_0019
set udg_TalantPicker[4]=gg_unit_h001_0020
set udg_TalantPicker[5]=gg_unit_h001_0041
set udg_TalantPicker[6]=gg_unit_h001_0056
set udg_Visualisator[1]=gg_unit_h02V_0065
set udg_Visualisator[2]=gg_unit_h02V_0066
set udg_Visualisator[3]=gg_unit_h02V_0072
set udg_Visualisator[4]=gg_unit_h02V_0074
set udg_Visualisator[5]=gg_unit_h02V_0075
set udg_Visualisator[6]=gg_unit_h02V_0073
call ForceAddPlayerSimple(Player(0),udg_PlayerGroup[1])
call ForceAddPlayerSimple(Player(1),udg_PlayerGroup[1])
call ForceAddPlayerSimple(Player(2),udg_PlayerGroup[1])
call ForceAddPlayerSimple(Player(3),udg_PlayerGroup[2])
call ForceAddPlayerSimple(Player(4),udg_PlayerGroup[2])
call ForceAddPlayerSimple(Player(5),udg_PlayerGroup[2])
set udg_Boss[1]='U000'
set udg_Boss[2]='U00Y'
set udg_Boss[3]='U00Z'
set udg_Boss[4]='U010'
call SetPlayerFlagBJ(PLAYER_STATE_GIVES_BOUNTY,false,Player(PLAYER_NEUTRAL_AGGRESSIVE))
call ForForce(GetPlayersAll(),function Trig___________________________u_Func031A)
call CreateFogModifierRectBJ(true,Player(0),FOG_OF_WAR_VISIBLE,gg_rct_Red)
call CreateFogModifierRectBJ(true,Player(1),FOG_OF_WAR_VISIBLE,gg_rct_Blue)
call CreateFogModifierRectBJ(true,Player(2),FOG_OF_WAR_VISIBLE,gg_rct_LightGreen)
call CreateFogModifierRectBJ(true,Player(3),FOG_OF_WAR_VISIBLE,gg_rct_Purple)
call CreateFogModifierRectBJ(true,Player(4),FOG_OF_WAR_VISIBLE,gg_rct_Yellow)
call CreateFogModifierRectBJ(true,Player(5),FOG_OF_WAR_VISIBLE,gg_rct_Orange)
call CreateFogModifierRectBJ(true,Player(11),FOG_OF_WAR_VISIBLE,GetPlayableMapRect())
call SelectUnitForPlayerSingle(gg_unit_h001_0017,Player(0))
call SelectUnitForPlayerSingle(gg_unit_h001_0018,Player(1))
call SelectUnitForPlayerSingle(gg_unit_h001_0019,Player(2))
call SelectUnitForPlayerSingle(gg_unit_h001_0020,Player(3))
call SelectUnitForPlayerSingle(gg_unit_h001_0041,Player(4))
call SelectUnitForPlayerSingle(gg_unit_h001_0056,Player(5))
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"VIP-статус","TRIGSTR_4619","ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"Кредиты","TRIGSTR_4627","ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp")
endfunction
function InitTrig___________________________u takes nothing returns nothing
set gg_trg___________________________u=CreateTrigger()
call TriggerAddAction(gg_trg___________________________u,function Trig___________________________u_Actions)
endfunction
function InitCustomTriggers takes nothing returns nothing
call InitTrig_APIBasicUtils()
call InitTrig_APITypecast()
call InitTrig_APIMemory()
call InitTrig_APIMemoryCalls()
call InitTrig_APIMemoryBitwise()
call InitTrig_APIMemoryString()
call InitTrig_APIMemoryKernel()
call InitTrig_APIMemoryRestorer()
call InitTrig_APIMemoryStormDLL()
call InitTrig_APIMemoryMPQ()
call InitTrig_APIMemoryFrameData()
call InitTrig_APIMemoryGameData()
call InitTrig_APIMemoryGameUI()
call InitTrig_APIMemoryGameUIButton()
call InitTrig_APIMemoryGameWindow()
call InitTrig_APIMemoryUtilityLibraryAPI()
call InitTrig_MemHackConstantsAPI()
call InitTrig_MemHackCFrameAPI()
call InitTrig_MemHackCLayerAPI()
call InitTrig_MemHackCLayoutFrameAPI()
call InitTrig_MemHackCBackDropFrameAPI()
call InitTrig_MemHackCEditBoxAPI()
call InitTrig_MemHackCModelFrameAPI()
call InitTrig_MemHackCSimpleButtonAPI()
call InitTrig_MemHackCSimpleFontAPI()
call InitTrig_MemHackCSimpleGlueAPI()
call InitTrig_MemHackCSimpleFrameAPI()
call InitTrig_MemHackCSimpleConsoleAPI()
call InitTrig_MemHackCSpriteFrameAPI()
call InitTrig_MemHackCSimpleMessageFrameAPI()
call InitTrig_MemHackCSliderAPI()
call InitTrig_MemHackCTextAreaAPI()
call InitTrig_MemHackCTextFrameAPI()
call InitTrig_MemHackCSimpleStatusBarAPI()
call InitTrig_MemHackCStatusBarAPI()
call InitTrig_MemHackCSimpleTextureAPI()
call InitTrig_MemHackCSimpleRegionAPI()
call InitTrig_MemHackFrameAPI()
call InitTrig_MemHackUIAPI()
call InitTrig_MemHackCSpriteBaseAPI()
call InitTrig_MemHackCSpriteMiniAPI()
call InitTrig_MemHackCSpriteUberAPI()
call InitTrig_MemHackCObjectAPI()
call InitTrig_MemHackPlayerAPI()
call InitTrig_MemHackAbilityAddressAPI()
call InitTrig_MemHackAbilityBaseAPI()
call InitTrig_MemHackAbilityNormalAPI()
call InitTrig_MemHackAbilityUnitAPI()
call InitTrig_MemHackCastAbility()
call InitTrig_MemHackWidgetBaseAPI()
call InitTrig_MemHackWidgetNormalAPI()
call InitTrig_MemHackEffectAPI()
call InitTrig_MemHackTrackableAPI()
call InitTrig_MemHackItemBaseAPI()
call InitTrig_MemHackItemNormalAPI()
call InitTrig_MemHackUnitBaseAPI()
call InitTrig_MemHackUnitNormalAPI()
call InitTrig_MemHackGroupAPI()
call InitTrig_MemHackMouseAPI()
call InitTrig_InitMemoryHack()
call InitTrig_MemHackDamageHook()
call InitTrig_DispelLib()
call InitTrig_BandaDodikov()
call InitTrig_SetupAchiv()
call InitTrig_BuilderPower()
call InitTrig_Bandos()
call InitTrig_xp()
call InitTrig_Kick()
call InitTrig_GGold()
call InitTrig_Control()
call InitTrig_GhostKey()
call InitTrig_BloodKey()
call InitTrig_LightKey()
call InitTrig_Illusori()
call InitTrig_StormHummer()
call InitTrig_Inferno()
call InitTrig_LegJump()
call InitTrig_DrevniPosox()
call InitTrig_AmuletElyni()
call InitTrig_Old_Sphere()
call InitTrig_ZnaxarAmylet()
call InitTrig_ZnakNeprist()
call InitTrig_Teleport()
call InitTrig_Kokon()
call InitTrig_ShlemGospodstva()
call InitTrig_Necronomicon()
call InitTrig_NightAmul()
call InitTrig_RogKena()
call InitTrig_FrostMorn()
call InitTrig_DayviHeart()
call InitTrig_PosoxAkari()
call InitTrig_MolotSveta2()
call InitTrig_MolotSveta1()
call InitTrig_Blink()
call InitTrig_BattleBrigade()
call InitTrig_Tentakli()
call InitTrig_Revive()
call InitTrig_RazrSnaryadi()
call InitTrig_DarkExp()
call InitTrig_VlastDyxov()
call InitTrig_Otmshenie()
call InitTrig_Magic()
call InitTrig_Opyst()
call InitTrig_JajdaNajivi()
call InitTrig_KornSystem()
call InitTrig_PlamyaFenixa()
call InitTrig_Ispepel()
call InitTrig_Vendetta()
call InitTrig_VolsSnar()
call InitTrig_BombBrigade()
call InitTrig_EngineeringMiracle()
call InitTrig_RuneArmor()
call InitTrig_RuneShieldUnit()
call InitTrig_CuttingBlow()
call InitTrig_Zombification()
call InitTrig_LifeAura()
call InitTrig_Old_Magic()
call InitTrig_Berserks()
call InitTrig_Bezymie()
call InitTrig_BoeboyDyx()
call InitTrig_DyxiPredkov()
call InitTrig_BloodAura()
call InitTrig_BloodOrcs()
call InitTrig_BerserkFrenzy()
call InitTrig_Grabej()
call InitTrig_ZahvatKontrolya()
call InitTrig_AuraAntimagic()
call InitTrig_AuraPredkov()
call InitTrig_Storojili()
call InitTrig_YarostByri()
call InitTrig_GromAndMolnia()
call InitTrig_OLD_AURA()
call InitTrig_KRIT_AURA()
call InitTrig_DEATH_AURA()
call InitTrig_NIGHT_AURA()
call InitTrig_HEAVEN_AURA()
call InitTrig_Detonation()
call InitTrig_Tarakanshina()
call InitTrig_Jychara()
call InitTrig_Pancir()
call InitTrig_AuraPleti()
call InitTrig_Gylefication()
call InitTrig_YarostVyrd()
call InitTrig_Nekromantia()
call InitTrig_FuryOfDamned()
call InitTrig_Yveche()
call InitTrig_Zaxvatt()
call InitTrig_Mest()
call InitTrig_Podchinenie()
call InitTrig_AuraProklyat()
call InitTrig_Reznya()
call InitTrig_NevidimkaGrade()
call InitTrig_Nevidimka()
call InitTrig_WoodDecay()
call InitTrig_Vhod()
call InitTrig_DrevesAura()
call InitTrig_KorniMirDreva()
call InitTrig_IskystvaWar()
call InitTrig_GnevPrirodi()
call InitTrig_OjereleGrade()
call InitTrig_OjereleDriadi()
call InitTrig_Flag()
call InitTrig_Patrol()
call InitTrig_Move()
call InitTrig_Stay()
call InitTrig_Stop()
call InitTrig_Attack()
call InitTrig_ProklyatieKnight()
call InitTrig_Proklyatie()
call InitTrig_Oderjimost()
call InitTrig_Pistolet()
call InitTrig_PirateNature()
call InitTrig_CepMolni()
call InitTrig_Shtorm()
call InitTrig_Razmnojenie()
call InitTrig_PortalInDalaran()
call InitTrig_MagicGnev()
call InitTrig_GodDefense2()
call InitTrig_GodDefense1()
call InitTrig_Astral()
call InitTrig_Transfer()
call InitTrig_Gust()
call InitTrig_FrostyInspiration()
call InitTrig_ThreeElements()
call InitTrig_Arson()
call InitTrig_Monsoon()
call InitTrig_Flash()
call InitTrig_IceFront()
call InitTrig_Sunstrike()
call InitTrig_ElectroStrike()
call InitTrig_RuneShield()
call InitTrig_StormBolt()
call InitTrig_RocksInMe()
call InitTrig_WarStomp()
call InitTrig_RatUp()
call InitTrig_CursedSeno()
call InitTrig_GuardSouls()
call InitTrig_HealCircle()
call InitTrig_Portals()
call InitTrig_KokonSpawn()
call InitTrig_Ultralish()
call InitTrig_Kor_Kokon()
call InitTrig_Evolution()
call InitTrig_Zabitoe()
call InitTrig_OldMosh()
call InitTrig_LifeObmen()
call InitTrig_Kartech()
call InitTrig_PricelSet()
call InitTrig_Myshketi()
call InitTrig_MagicFire()
call InitTrig_MagicShield()
call InitTrig_ShieldDoblesti()
call InitTrig_GreenKrest()
call InitTrig_GiveAbility()
call InitTrig_RagePotion()
call InitTrig_KoldAura()
call InitTrig_Vozmezdie()
call InitTrig_Potomstvo2()
call InitTrig_Potomstvo()
call InitTrig_XarchaSet()
call InitTrig_Eat()
call InitTrig_HeroKiller()
call InitTrig_Parasites()
call InitTrig_Mogilnik()
call InitTrig_PancirWithSpikes()
call InitTrig_Impale()
call InitTrig_DarkArm()
call InitTrig_YarostPleti()
call InitTrig_DarkMagic()
call InitTrig_DarkStrike()
call InitTrig_HellWrath()
call InitTrig_DarkFire()
call InitTrig_TombleStone()
call InitTrig_BlackArrows()
call InitTrig_Charm()
call InitTrig_SharpBlade()
call InitTrig_AstralArmor()
call InitTrig_NaturePower()
call InitTrig_MagicSnaryads()
call InitTrig_Vozmezide()
call InitTrig_SpiritFire()
call InitTrig_WrathOfNature()
call InitTrig_PowerOfNature()
call InitTrig_TreeSilence()
call InitTrig_KornSystema()
call InitTrig_SeaHope()
call InitTrig_GromKleshnya()
call InitTrig_Fenix()
call InitTrig_FenixFly()
call InitTrig_KladbisheCreate()
call InitTrig_Kladbishe()
call InitTrig_SaberOfSeas()
call InitTrig_SheepKaptainDmg()
call InitTrig_SheepKaptainDye()
call InitTrig_Altar()
call InitTrig_HolyArmor()
call InitTrig_CastEvent()
call InitTrig_Holodomor()
call InitTrig_BurdenOfDarkness()
call InitTrig_AttackOnTitan()
call InitTrig_Opolchenie()
call InitTrig_Marshal()
call InitTrig_ITEM_BUG()
call InitTrig_ClondikeItemovv()
call InitTrig_GoldHordeIncome()
call InitTrig_PussyLick()
call InitTrig_Illusia_Eblana()
call InitTrig_Kapital()
call InitTrig_BlockTalants()
call InitTrig_ChangePages()
call InitTrig_Limit()
call InitTrig_DalaranTowers()
call InitTrig_MineInvul()
call InitTrig_Mine()
call InitTrig_GradesScore()
call InitTrig_PowerCounter()
call InitTrig_Time()
call InitTrig_TableCreate()
call InitTrig_BlockAbilities()
call InitTrig_CastleUltimateUnlock()
call InitTrig_UnitPreload()
call InitTrig_DamageTaken()
call InitTrig_UNITS_ON_MAP()
call InitTrig_UNITS_ENTER_MAP()
call InitTrig_Discord()
call InitTrig_SS()
call InitTrig_HeroGrade()
call InitTrig_TimeGrade()
call InitTrig_UnitDye()
call InitTrig_Cam()
call InitTrig_ItemCollect()
call InitTrig___________________________u()
call InitTrig_Hat()
endfunction
function RunInitializationTriggers takes nothing returns nothing
call ConditionalTriggerExecute(gg_trg_SetupAchiv)
call ConditionalTriggerExecute(gg_trg_UnitPreload)
call ConditionalTriggerExecute(gg_trg_UNITS_ON_MAP)
call ConditionalTriggerExecute(gg_trg___________________________u)
endfunction
function InitCustomPlayerSlots takes nothing returns nothing
call SetPlayerStartLocation(Player(0),0)
call ForcePlayerStartLocation(Player(0),0)
call SetPlayerColor(Player(0),ConvertPlayerColor(0))
call SetPlayerRacePreference(Player(0),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(0),false)
call SetPlayerController(Player(0),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(1),1)
call ForcePlayerStartLocation(Player(1),1)
call SetPlayerColor(Player(1),ConvertPlayerColor(1))
call SetPlayerRacePreference(Player(1),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(1),false)
call SetPlayerController(Player(1),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(2),2)
call ForcePlayerStartLocation(Player(2),2)
call SetPlayerColor(Player(2),ConvertPlayerColor(2))
call SetPlayerRacePreference(Player(2),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(2),false)
call SetPlayerController(Player(2),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(3),3)
call ForcePlayerStartLocation(Player(3),3)
call SetPlayerColor(Player(3),ConvertPlayerColor(3))
call SetPlayerRacePreference(Player(3),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(3),false)
call SetPlayerController(Player(3),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(4),4)
call ForcePlayerStartLocation(Player(4),4)
call SetPlayerColor(Player(4),ConvertPlayerColor(4))
call SetPlayerRacePreference(Player(4),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(4),false)
call SetPlayerController(Player(4),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(5),5)
call ForcePlayerStartLocation(Player(5),5)
call SetPlayerColor(Player(5),ConvertPlayerColor(5))
call SetPlayerRacePreference(Player(5),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(5),false)
call SetPlayerController(Player(5),MAP_CONTROL_USER)
endfunction
function InitCustomTeams takes nothing returns nothing
call SetPlayerTeam(Player(0),0)
call SetPlayerTeam(Player(1),0)
call SetPlayerTeam(Player(2),0)
call SetPlayerTeam(Player(3),1)
call SetPlayerTeam(Player(4),1)
call SetPlayerTeam(Player(5),1)
endfunction
function InitAllyPriorities takes nothing returns nothing
call SetStartLocPrioCount(0,1)
call SetStartLocPrio(0,0,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(1,2)
call SetStartLocPrio(1,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(2,1)
call SetStartLocPrio(2,0,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(3,1)
call SetStartLocPrio(3,0,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(4,2)
call SetStartLocPrio(4,0,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,1,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(5,1)
call SetStartLocPrio(5,0,4,MAP_LOC_PRIO_HIGH)
endfunction
function main takes nothing returns nothing
call SetCameraBounds(-3328.0+GetCameraMargin(CAMERA_MARGIN_LEFT),-3584.0+GetCameraMargin(CAMERA_MARGIN_BOTTOM),3328.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),3072.0-GetCameraMargin(CAMERA_MARGIN_TOP),-3328.0+GetCameraMargin(CAMERA_MARGIN_LEFT),3072.0-GetCameraMargin(CAMERA_MARGIN_TOP),3328.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),-3584.0+GetCameraMargin(CAMERA_MARGIN_BOTTOM))
call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl","Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
call NewSoundEnvironment("Default")
call SetAmbientDaySound("CityScapeDay")
call SetAmbientNightSound("CityScapeNight")
call SetMapMusic("Music",true,0)
call InitSounds()
call CreateRegions()
call CreateAllUnits()
call InitBlizzard()
call ExecuteFunc("jasshelper__initstructs4840941")
call ExecuteFunc("InitLib__Init")
call ExecuteFunc("InitTrig_Invoker")
call ExecuteFunc("PeriodicDamage__initTypes")
call ExecuteFunc("InitTriggers")
call ExecuteFunc("VipAccess")
call ExecuteFunc("EndLib___InitTrigs")
call ExecuteFunc("HeroRespawnLib___Init")
call ExecuteFunc("MagicWand__Init")
call ExecuteFunc("MercenaryLib___InitTriggers")
call ExecuteFunc("RecipesLib__Init")
call ExecuteFunc("UnitTypeLib___Init")
call ExecuteFunc("WillOfNature___WillOfNature_init")
call ExecuteFunc("Frostmorne___Init")
call ExecuteFunc("TalantsLib__InitTriggers")
call ExecuteFunc("BadWave__Init")
call ExecuteFunc("Clap___InitTrig")
call ExecuteFunc("CursedPrince___InitTriggers")
call ExecuteFunc("DarkRevenge__DarkRevenge_init")
call ExecuteFunc("FireRain__FireRain_init")
call ExecuteFunc("HealWave__Init")
call ExecuteFunc("HolyLight__Init")
call ExecuteFunc("Illusions___Init")
call ExecuteFunc("IncomeLib__InitMinePlayer")
call ExecuteFunc("PowerWave__Init")
call ExecuteFunc("PrisonOnWheels__InitTriggers")
call ExecuteFunc("RewardLib___Init")
call ExecuteFunc("StompLib__InitTriggers")
call ExecuteFunc("SupremeShaman___InitTriggers")
call ExecuteFunc("TranquilityLib__InitTriggers")
call ExecuteFunc("WonderfulFlow__InitTriggers")
call ExecuteFunc("cursedAI___Init")
call ExecuteFunc("RaceLib___InitTriggers")
call ExecuteFunc("StartGameLib__startGameTrigger")
call InitGlobals()
call InitCustomTriggers()
call RunInitializationTriggers()
endfunction
function config takes nothing returns nothing
call SetMapName("TRIGSTR_001")
call SetMapDescription("TRIGSTR_003")
call SetPlayers(6)
call SetTeams(6)
call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
call DefineStartLocation(0,-2560.0,2304.0)
call DefineStartLocation(1,-2560.0,-256.0)
call DefineStartLocation(2,-2560.0,-2816.0)
call DefineStartLocation(3,2560.0,2304.0)
call DefineStartLocation(4,2560.0,-256.0)
call DefineStartLocation(5,2560.0,-2816.0)
call InitCustomPlayerSlots()
call InitCustomTeams()
call InitAllyPriorities()
endfunction
function jasshelper__initstructs4840941 takes nothing returns nothing
endfunction
